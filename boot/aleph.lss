
aleph.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00011926  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80013a00  80013a00  00013e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001948  80013c00  80013c00  00014000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000056c  00000008  80015548  00015c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000574  80015ab4  00016174  2**0
                  ALLOC
  8 .bss          00007428  00000578  00000578  00000000  2**2
                  ALLOC
  9 .heap         00007660  000079a0  000079a0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00016174  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000016c0  00000000  00000000  000161a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000031d1  00000000  00000000  00017864  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0003564c  00000000  00000000  0001aa35  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000074ae  00000000  00000000  00050081  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00029cda  00000000  00000000  0005752f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003e64  00000000  00000000  0008120c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000a4f7  00000000  00000000  00085070  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000df31  00000000  00000000  0008f567  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 02d2fc1a  00000000  00000000  0009d498  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00007458  00000000  00000000  02dcd0b2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe ff 00 04 	ld.w	pc,pc[4]
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	de 2c       	*unknown*

Disassembly of section .text:

80002008 <smc_get_cs_size>:

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
}

unsigned char smc_get_cs_size(unsigned char cs)
{
80002008:	e0 68 05 78 	mov	r8,1400
  return smc_tab_cs_size[cs];
}
8000200c:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80002010:	5e fc       	retal	r12
80002012:	d7 03       	nop

80002014 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80002014:	eb cd 40 c0 	pushm	r6-r7,lr
  // Enable SM mode for CS1 if necessary.
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
80002018:	fe 68 10 00 	mov	r8,-126976
8000201c:	f0 f9 01 24 	ld.w	r9,r8[292]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002026:	30 09       	mov	r9,0
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80002028:	f0 f8 01 24 	ld.w	r8,r8[292]
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
8000202c:	fe 68 1c 00 	mov	r8,-123904
80002030:	91 49       	st.w	r8[0x10],r9
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002032:	ee 79 42 3f 	mov	r9,999999
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002036:	e0 6e 4d d3 	mov	lr,19923
8000203a:	ea 1e 10 62 	orh	lr,0x1062
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000203e:	f8 09 00 0b 	add	r11,r12,r9
80002042:	e0 69 de 83 	mov	r9,56963
80002046:	ea 19 43 1b 	orh	r9,0x431b
8000204a:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000204e:	b3 8b       	lsr	r11,0x12
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002050:	f6 07 10 52 	mul	r7,r11,82
80002054:	ee c7 fc 19 	sub	r7,r7,-999
80002058:	ee 0e 06 46 	mulu.d	r6,r7,lr
8000205c:	0e 99       	mov	r9,r7
8000205e:	e0 67 00 a4 	mov	r7,164
80002062:	a7 89       	lsr	r9,0x6
80002064:	f6 07 02 47 	mul	r7,r11,r7
80002068:	f2 0a 15 10 	lsl	r10,r9,0x10
8000206c:	ee c7 fc 19 	sub	r7,r7,-999
80002070:	f5 e9 10 8c 	or	r12,r10,r9<<0x8
80002074:	ee 0e 06 46 	mulu.d	r6,r7,lr
80002078:	12 4c       	or	r12,r9
8000207a:	0e 9b       	mov	r11,r7
8000207c:	f9 e9 11 8c 	or	r12,r12,r9<<0x18
80002080:	a7 8b       	lsr	r11,0x6
80002082:	91 5c       	st.w	r8[0x14],r12
80002084:	12 3b       	cp.w	r11,r9
80002086:	f6 09 17 20 	movhs	r9,r11
8000208a:	12 4a       	or	r10,r9
8000208c:	e0 69 10 03 	mov	r9,4099
80002090:	91 6a       	st.w	r8[0x18],r10
80002092:	91 79       	st.w	r8[0x1c],r9
80002094:	31 29       	mov	r9,18
80002096:	e0 68 05 78 	mov	r8,1400
8000209a:	32 9b       	mov	r11,41
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
8000209c:	b0 99       	st.b	r8[0x1],r9
8000209e:	48 3c       	lddpc	r12,800020a8 <smc_init+0x94>
800020a0:	c9 8c       	rcall	800021d0 <gpio_enable_module>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
800020a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800020a6:	d7 03       	nop
800020a8:	80 01       	ld.sh	r1,r0[0x0]
800020aa:	3c 00       	mov	r0,-64

800020ac <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020ac:	fe 68 14 00 	mov	r8,-125952
800020b0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020b2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020b6:	91 09       	st.w	r8[0x0],r9
}
800020b8:	5e fc       	retal	r12

800020ba <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
800020ba:	e0 68 8a 3f 	mov	r8,35391
800020be:	ea 18 01 f7 	orh	r8,0x1f7
800020c2:	10 3c       	cp.w	r12,r8
800020c4:	e0 8b 00 0a 	brhi	800020d8 <flashc_set_bus_freq+0x1e>
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020c8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020cc:	30 0a       	mov	r10,0
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020ce:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020d0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020d4:	91 09       	st.w	r8[0x0],r9
800020d6:	5e fc       	retal	r12
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020d8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020dc:	30 1a       	mov	r10,1
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020de:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020e0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020e4:	91 09       	st.w	r8[0x0],r9
800020e6:	5e fc       	retal	r12

800020e8 <gpio_enable_pin_pull_up>:
 */
void gpio_enable_pin_pull_up(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->puers = 1 << (pin & 0x1F);
800020e8:	30 18       	mov	r8,1
800020ea:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_pull_up(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800020ee:	a5 9c       	lsr	r12,0x5
800020f0:	a9 6c       	lsl	r12,0x8
800020f2:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->puers = 1 << (pin & 0x1F);
800020f6:	f9 48 00 74 	st.w	r12[116],r8
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	gpio_port->pderc = 1 << (pin & 0x1F);
#endif
}
800020fa:	5e fc       	retal	r12

800020fc <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800020fc:	f8 08 16 05 	lsr	r8,r12,0x5
80002100:	a9 68       	lsl	r8,0x8
80002102:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80002106:	71 88       	ld.w	r8,r8[0x60]
80002108:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000210c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002110:	5e fc       	retal	r12

80002112 <gpio_set_gpio_pin>:
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002112:	30 18       	mov	r8,1
80002114:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002118:	a5 9c       	lsr	r12,0x5
8000211a:	a9 6c       	lsl	r12,0x8
8000211c:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002120:	f9 48 00 54 	st.w	r12[84],r8
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80002124:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002128:	99 18       	st.w	r12[0x4],r8
}
8000212a:	5e fc       	retal	r12

8000212c <gpio_clr_gpio_pin>:
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000212c:	30 18       	mov	r8,1
8000212e:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002132:	a5 9c       	lsr	r12,0x5
80002134:	a9 6c       	lsl	r12,0x8
80002136:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000213a:	f9 48 00 58 	st.w	r12[88],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000213e:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002142:	99 18       	st.w	r12[0x4],r8
}
80002144:	5e fc       	retal	r12

80002146 <gpio_enable_pin_glitch_filter>:
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->gfers = 1 << (pin & 0x1F);
80002146:	30 18       	mov	r8,1
80002148:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000214c:	a5 9c       	lsr	r12,0x5
8000214e:	a9 6c       	lsl	r12,0x8
80002150:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->gfers = 1 << (pin & 0x1F);
80002154:	f9 48 00 c4 	st.w	r12[196],r8
}
80002158:	5e fc       	retal	r12

8000215a <gpio_enable_pin_interrupt>:
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8000215a:	30 1a       	mov	r10,1
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000215c:	f8 08 16 05 	lsr	r8,r12,0x5

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80002160:	f4 0c 09 49 	lsl	r9,r10,r12
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002164:	a9 68       	lsl	r8,0x8
80002166:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8000216a:	f1 49 00 c4 	st.w	r8[196],r9
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8000216e:	14 3b       	cp.w	r11,r10
80002170:	c0 c0       	breq	80002188 <gpio_enable_pin_interrupt+0x2e>
80002172:	c0 82       	brcc	80002182 <gpio_enable_pin_interrupt+0x28>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002174:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80002178:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
8000217c:	f1 49 00 94 	st.w	r8[148],r9
80002180:	5e fd       	retal	0
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80002182:	58 2b       	cp.w	r11,2
80002184:	c0 90       	breq	80002196 <gpio_enable_pin_interrupt+0x3c>
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1s = 1 << (pin & 0x1F);
80002186:	5e fa       	retal	r10
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80002188:	f1 49 00 a4 	st.w	r8[164],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000218c:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80002190:	f1 49 00 94 	st.w	r8[148],r9
80002194:	5e fd       	retal	0
		gpio_port->imr0s = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002196:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1s = 1 << (pin & 0x1F);
8000219a:	f1 49 00 b4 	st.w	r8[180],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
8000219e:	f1 49 00 94 	st.w	r8[148],r9
800021a2:	5e fd       	retal	0

800021a4 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800021a4:	f8 08 16 05 	lsr	r8,r12,0x5
800021a8:	a9 68       	lsl	r8,0x8
800021aa:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
800021ae:	f0 f8 00 d0 	ld.w	r8,r8[208]
800021b2:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800021b6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800021ba:	5e fc       	retal	r12

800021bc <gpio_clear_pin_interrupt_flag>:
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800021bc:	30 18       	mov	r8,1
800021be:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800021c2:	a5 9c       	lsr	r12,0x5
800021c4:	a9 6c       	lsl	r12,0x8
800021c6:	e0 2c f0 00 	sub	r12,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800021ca:	f9 48 00 d8 	st.w	r12[216],r8
#endif
}
800021ce:	5e fc       	retal	r12

800021d0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800021d0:	eb cd 40 c0 	pushm	r6-r7,lr
800021d4:	18 98       	mov	r8,r12
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800021d6:	58 0b       	cp.w	r11,0
800021d8:	c3 60       	breq	80002244 <gpio_enable_module+0x74>
800021da:	30 0e       	mov	lr,0
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800021dc:	30 16       	mov	r6,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800021de:	1c 9c       	mov	r12,lr
800021e0:	c0 d8       	rjmp	800021fa <gpio_enable_module+0x2a>
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800021e2:	ec 07 09 4a 	lsl	r10,r6,r7
800021e6:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800021e8:	93 aa       	st.w	r9[0x28],r10
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800021ea:	93 2a       	st.w	r9[0x8],r10
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800021ec:	2f fe       	sub	lr,-1
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800021ee:	30 09       	mov	r9,0
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800021f0:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800021f2:	1c 3b       	cp.w	r11,lr
800021f4:	e0 88 00 17 	brls	80002222 <gpio_enable_module+0x52>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
800021f8:	2f 88       	sub	r8,-8
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800021fa:	70 07       	ld.w	r7,r8[0x0]
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
800021fc:	70 1a       	ld.w	r10,r8[0x4]
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800021fe:	ee 09 16 05 	lsr	r9,r7,0x5
80002202:	a9 69       	lsl	r9,0x8
80002204:	e0 29 f0 00 	sub	r9,61440

	/* Enable the correct function. */
	switch (function) {
80002208:	58 1a       	cp.w	r10,1
8000220a:	c0 e0       	breq	80002226 <gpio_enable_module+0x56>
8000220c:	ce b3       	brcs	800021e2 <gpio_enable_module+0x12>
8000220e:	58 2a       	cp.w	r10,2
80002210:	c1 50       	breq	8000223a <gpio_enable_module+0x6a>
80002212:	58 3a       	cp.w	r10,3
80002214:	c0 e0       	breq	80002230 <gpio_enable_module+0x60>
80002216:	30 19       	mov	r9,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002218:	2f fe       	sub	lr,-1
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000221a:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000221c:	1c 3b       	cp.w	r11,lr
8000221e:	fe 9b ff ed 	brhi	800021f8 <gpio_enable_module+0x28>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80002222:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002226:	f4 07 09 4a 	lsl	r10,r10,r7
8000222a:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000222c:	93 aa       	st.w	r9[0x28],r10
8000222e:	cd eb       	rjmp	800021ea <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002230:	ec 07 09 4a 	lsl	r10,r6,r7
80002234:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002236:	93 9a       	st.w	r9[0x24],r10
80002238:	cd 9b       	rjmp	800021ea <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000223a:	ec 07 09 4a 	lsl	r10,r6,r7
8000223e:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002240:	93 9a       	st.w	r9[0x24],r10
80002242:	cd 4b       	rjmp	800021ea <gpio_enable_module+0x1a>
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
80002244:	16 9c       	mov	r12,r11
80002246:	ce eb       	rjmp	80002222 <gpio_enable_module+0x52>

80002248 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002248:	c0 08       	rjmp	80002248 <_unhandled_interrupt>
8000224a:	d7 03       	nop

8000224c <INTC_register_interrupt>:

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000224c:	f3 db c0 05 	bfextu	r9,r11,0x0,0x5
80002250:	49 b8       	lddpc	r8,800022bc <INTC_register_interrupt+0x70>
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002252:	a5 9b       	lsr	r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002254:	f0 0b 00 38 	add	r8,r8,r11<<0x3
80002258:	70 18       	ld.w	r8,r8[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000225a:	f0 09 09 2c 	st.w	r8[r9<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000225e:	58 0a       	cp.w	r10,0
80002260:	c1 00       	breq	80002280 <INTC_register_interrupt+0x34>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	} else if (int_level == AVR32_INTC_INT1) {
80002262:	58 1a       	cp.w	r10,1
80002264:	c1 70       	breq	80002292 <INTC_register_interrupt+0x46>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
	} else if (int_level == AVR32_INTC_INT2) {
80002266:	58 2a       	cp.w	r10,2
80002268:	c1 f0       	breq	800022a6 <INTC_register_interrupt+0x5a>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000226a:	49 69       	lddpc	r9,800022c0 <INTC_register_interrupt+0x74>
8000226c:	49 68       	lddpc	r8,800022c4 <INTC_register_interrupt+0x78>
8000226e:	f2 08 01 08 	sub	r8,r9,r8
80002272:	fe 79 08 00 	mov	r9,-63488
80002276:	ea 18 c0 00 	orh	r8,0xc000
8000227a:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
8000227e:	5e fc       	retal	r12
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002280:	fe 78 08 00 	mov	r8,-63488
80002284:	49 09       	lddpc	r9,800022c4 <INTC_register_interrupt+0x78>
80002286:	49 1a       	lddpc	r10,800022c8 <INTC_register_interrupt+0x7c>
80002288:	f4 09 01 09 	sub	r9,r10,r9
8000228c:	f0 0b 09 29 	st.w	r8[r11<<0x2],r9
80002290:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002292:	48 f9       	lddpc	r9,800022cc <INTC_register_interrupt+0x80>
80002294:	48 c8       	lddpc	r8,800022c4 <INTC_register_interrupt+0x78>
80002296:	f2 08 01 08 	sub	r8,r9,r8
8000229a:	fe 79 08 00 	mov	r9,-63488
8000229e:	bf a8       	sbr	r8,0x1e
800022a0:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800022a4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800022a6:	48 b9       	lddpc	r9,800022d0 <INTC_register_interrupt+0x84>
800022a8:	48 78       	lddpc	r8,800022c4 <INTC_register_interrupt+0x78>
800022aa:	f2 08 01 08 	sub	r8,r9,r8
800022ae:	fe 79 08 00 	mov	r9,-63488
800022b2:	bf b8       	sbr	r8,0x1f
800022b4:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800022b8:	5e fc       	retal	r12
800022ba:	d7 03       	nop
800022bc:	80 01       	ld.sh	r1,r0[0x0]
800022be:	3d 48       	mov	r8,-44
800022c0:	80 01       	ld.sh	r1,r0[0x0]
800022c2:	3b 2e       	mov	lr,-78
800022c4:	80 01       	ld.sh	r1,r0[0x0]
800022c6:	3a 00       	mov	r0,-96
800022c8:	80 01       	ld.sh	r1,r0[0x0]
800022ca:	3b 04       	mov	r4,-80
800022cc:	80 01       	ld.sh	r1,r0[0x0]
800022ce:	3b 12       	mov	r2,-79
800022d0:	80 01       	ld.sh	r1,r0[0x0]
800022d2:	3b 20       	mov	r0,-78

800022d4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800022d4:	eb cd 40 e0 	pushm	r5-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800022d8:	48 f8       	lddpc	r8,80002314 <INTC_init_interrupts+0x40>
800022da:	e3 b8 00 01 	mtsr	0x4,r8
800022de:	48 f5       	lddpc	r5,80002318 <INTC_init_interrupts+0x44>
800022e0:	48 f7       	lddpc	r7,8000231c <INTC_init_interrupts+0x48>
800022e2:	10 15       	sub	r5,r8
800022e4:	30 0e       	mov	lr,0
800022e6:	fe cc 00 9e 	sub	r12,pc,158

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800022ea:	fe 76 08 00 	mov	r6,-63488

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800022ee:	6e 0a       	ld.w	r10,r7[0x0]
800022f0:	58 0a       	cp.w	r10,0
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800022f2:	c0 90       	breq	80002304 <INTC_init_interrupts+0x30>
800022f4:	30 08       	mov	r8,0
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800022f6:	6e 1b       	ld.w	r11,r7[0x4]
800022f8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800022fc:	2f f8       	sub	r8,-1
800022fe:	10 3a       	cp.w	r10,r8
80002300:	fe 9b ff fc 	brhi	800022f8 <INTC_init_interrupts+0x24>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002304:	ec 0e 09 25 	st.w	r6[lr<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002308:	2f 87       	sub	r7,-8
8000230a:	2f fe       	sub	lr,-1
8000230c:	59 4e       	cp.w	lr,20
8000230e:	cf 01       	brne	800022ee <INTC_init_interrupts+0x1a>
80002310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002314:	80 01       	ld.sh	r1,r0[0x0]
80002316:	3a 00       	mov	r0,-96
80002318:	80 01       	ld.sh	r1,r0[0x0]
8000231a:	3b 04       	mov	r4,-80
8000231c:	80 01       	ld.sh	r1,r0[0x0]
8000231e:	3d 48       	mov	r8,-44

80002320 <_get_interrupt_handler>:
80002320:	e0 68 00 83 	mov	r8,131
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002324:	f0 0c 01 0c 	sub	r12,r8,r12
80002328:	fe 78 08 00 	mov	r8,-63488
8000232c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002330:	f2 ca ff c0 	sub	r10,r9,-64
80002334:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002338:	58 0c       	cp.w	r12,0
8000233a:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000233c:	48 68       	lddpc	r8,80002354 <_get_interrupt_handler+0x34>
8000233e:	f8 0c 12 00 	clz	r12,r12
80002342:	f0 09 00 39 	add	r9,r8,r9<<0x3
80002346:	f8 0c 11 1f 	rsub	r12,r12,31
8000234a:	72 18       	ld.w	r8,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000234c:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002350:	5e fc       	retal	r12
80002352:	d7 03       	nop
80002354:	80 01       	ld.sh	r1,r0[0x0]
80002356:	3d 48       	mov	r8,-44

80002358 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002358:	30 e8       	mov	r8,14
8000235a:	f0 0c 18 00 	cp.b	r12,r8
8000235e:	e0 8b 00 06 	brhi	8000236a <pdca_get_handler+0x12>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002362:	a7 6c       	lsl	r12,0x6
80002364:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80002368:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000236a:	5e fe       	retal	-1

8000236c <pdca_disable>:
8000236c:	30 e8       	mov	r8,14
8000236e:	f0 0c 18 00 	cp.b	r12,r8
80002372:	e0 8b 00 08 	brhi	80002382 <pdca_disable+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002376:	a7 6c       	lsl	r12,0x6
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80002378:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000237a:	e0 3c 00 00 	sub	r12,65536
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000237e:	99 58       	st.w	r12[0x14],r8
}
80002380:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002382:	3f fc       	mov	r12,-1
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80002384:	30 28       	mov	r8,2
80002386:	99 58       	st.w	r12[0x14],r8
}
80002388:	5e fc       	retal	r12

8000238a <pdca_enable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000238a:	30 e8       	mov	r8,14
8000238c:	f0 0c 18 00 	cp.b	r12,r8
80002390:	e0 8b 00 08 	brhi	800023a0 <pdca_enable_interrupt_transfer_complete+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002394:	a7 6c       	lsl	r12,0x6
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80002396:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002398:	e0 3c 00 00 	sub	r12,65536
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
8000239c:	99 88       	st.w	r12[0x20],r8
}
8000239e:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800023a0:	3f fc       	mov	r12,-1
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
800023a2:	30 28       	mov	r8,2
800023a4:	99 88       	st.w	r12[0x20],r8
}
800023a6:	5e fc       	retal	r12

800023a8 <pdca_disable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800023a8:	30 e8       	mov	r8,14
800023aa:	f0 0c 18 00 	cp.b	r12,r8
800023ae:	e0 88 00 0e 	brls	800023ca <pdca_disable_interrupt_transfer_complete+0x22>
800023b2:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800023b4:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800023b8:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800023ba:	30 29       	mov	r9,2
800023bc:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800023be:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800023c0:	ed b8 00 10 	bld	r8,0x10
800023c4:	c0 20       	breq	800023c8 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800023c6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800023c8:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800023ca:	a7 6c       	lsl	r12,0x6
800023cc:	e0 3c 00 00 	sub	r12,65536
800023d0:	cf 2b       	rjmp	800023b4 <pdca_disable_interrupt_transfer_complete+0xc>

800023d2 <pdca_load_channel>:

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800023d2:	30 e8       	mov	r8,14
800023d4:	f0 0c 18 00 	cp.b	r12,r8
800023d8:	e0 88 00 11 	brls	800023fa <pdca_load_channel+0x28>
800023dc:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800023de:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800023e2:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)addr;
800023e4:	99 0b       	st.w	r12[0x0],r11
	pdca_channel->tcr = size;
800023e6:	99 2a       	st.w	r12[0x8],r10
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800023e8:	e0 69 01 00 	mov	r9,256
800023ec:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
800023ee:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800023f0:	ed b8 00 10 	bld	r8,0x10
800023f4:	c0 20       	breq	800023f8 <pdca_load_channel+0x26>
      cpu_irq_enable();
800023f6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800023f8:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800023fa:	a7 6c       	lsl	r12,0x6
800023fc:	e0 3c 00 00 	sub	r12,65536
80002400:	ce fb       	rjmp	800023de <pdca_load_channel+0xc>

80002402 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80002402:	eb cd 40 80 	pushm	r7,lr
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002406:	30 e8       	mov	r8,14

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002408:	f8 09 15 06 	lsl	r9,r12,0x6
8000240c:	e0 39 00 00 	sub	r9,65536

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002410:	f0 0c 18 00 	cp.b	r12,r8
80002414:	f9 b8 0b ff 	movhi	r8,-1
80002418:	f0 0e 17 b0 	movhi	lr,r8
8000241c:	f2 08 17 80 	movls	r8,r9
80002420:	f2 0e 17 80 	movls	lr,r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002424:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002428:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
8000242a:	30 27       	mov	r7,2
8000242c:	9d 97       	st.w	lr[0x24],r7
	pdca_channel->isr;
8000242e:	7c be       	ld.w	lr,lr[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002430:	ed ba 00 10 	bld	r10,0x10
80002434:	c0 20       	breq	80002438 <pdca_init_channel+0x36>
      cpu_irq_enable();
80002436:	d5 03       	csrf	0x10
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002438:	30 ea       	mov	r10,14
8000243a:	f8 0a 18 00 	cp.b	r10,r12
8000243e:	f9 b9 03 ff 	movlo	r9,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002442:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002446:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
80002448:	30 1c       	mov	r12,1
8000244a:	93 9c       	st.w	r9[0x24],r12
	pdca_channel->isr;
8000244c:	72 b9       	ld.w	r9,r9[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000244e:	ed ba 00 10 	bld	r10,0x10
80002452:	c0 20       	breq	80002456 <pdca_init_channel+0x54>
      cpu_irq_enable();
80002454:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002456:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000245a:	d3 03       	ssrf	0x10
	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
8000245c:	76 0a       	ld.w	r10,r11[0x0]
8000245e:	91 0a       	st.w	r8[0x0],r10
	pdca_channel->tcr = opt->size;
80002460:	76 1a       	ld.w	r10,r11[0x4]
80002462:	91 2a       	st.w	r8[0x8],r10
	pdca_channel->psr = opt->pid;
80002464:	76 4a       	ld.w	r10,r11[0x10]
80002466:	91 1a       	st.w	r8[0x4],r10
	pdca_channel->marr = (uint32_t)opt->r_addr;
80002468:	76 2a       	ld.w	r10,r11[0x8]
8000246a:	91 3a       	st.w	r8[0xc],r10
	pdca_channel->tcrr = opt->r_size;
8000246c:	76 3a       	ld.w	r10,r11[0xc]
8000246e:	91 4a       	st.w	r8[0x10],r10
	pdca_channel->mr =
80002470:	76 5a       	ld.w	r10,r11[0x14]
80002472:	91 6a       	st.w	r8[0x18],r10
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80002474:	e0 6a 01 00 	mov	r10,256
80002478:	91 5a       	st.w	r8[0x14],r10
	pdca_channel->isr;
8000247a:	70 b8       	ld.w	r8,r8[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000247c:	ed b9 00 10 	bld	r9,0x10
80002480:	c0 20       	breq	80002484 <pdca_init_channel+0x82>
      cpu_irq_enable();
80002482:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80002484:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80002488 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002488:	f8 c8 00 01 	sub	r8,r12,1
8000248c:	f0 0b 00 0b 	add	r11,r8,r11
80002490:	f6 0c 0d 0a 	divu	r10,r11,r12
80002494:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002496:	f4 c8 00 01 	sub	r8,r10,1
8000249a:	e0 48 00 fe 	cp.w	r8,254
8000249e:	e0 8b 00 04 	brhi	800024a6 <getBaudDiv+0x1e>
		return -1;
	}

	return baudDiv;
800024a2:	5c 8c       	casts.h	r12
}
800024a4:	5e fc       	retal	r12

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);

	if (baudDiv <= 0 || baudDiv > 255) {
800024a6:	5e fe       	retal	-1

800024a8 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
800024a8:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800024aa:	30 18       	mov	r8,1
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
800024ac:	18 99       	mov	r9,r12
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800024ae:	f7 3a 00 0d 	ld.ub	r10,r11[13]
800024b2:	f0 0a 18 00 	cp.b	r10,r8
800024b6:	e0 88 00 04 	brls	800024be <spi_initMaster+0x16>
800024ba:	30 2c       	mov	r12,2
800024bc:	d8 02       	popm	pc

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
	u_avr32_spi_mr.MR.llb = 0;
800024be:	30 0a       	mov	r10,0
	if (options->modfdis > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800024c0:	e0 68 00 80 	mov	r8,128
800024c4:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
800024c6:	30 1e       	mov	lr,1

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800024c8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800024ca:	f7 3b 00 0d 	ld.ub	r11,r11[13]
	u_avr32_spi_mr.MR.llb = 0;
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
	spi->mr = u_avr32_spi_mr.mr;
800024ce:	14 9c       	mov	r12,r10
	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
800024d0:	f1 de d0 01 	bfins	r8,lr,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800024d4:	f1 db d0 81 	bfins	r8,r11,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800024d8:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800024dc:	30 fa       	mov	r10,15
800024de:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800024e2:	93 18       	st.w	r9[0x4],r8

	return SPI_OK;
}
800024e4:	d8 02       	popm	pc

800024e6 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800024e6:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800024e8:	30 18       	mov	r8,1
800024ea:	f0 0b 18 00 	cp.b	r11,r8
800024ee:	5f be       	srhi	lr
800024f0:	f0 0a 18 00 	cp.b	r10,r8
800024f4:	5f b8       	srhi	r8
800024f6:	1c 48       	or	r8,lr
800024f8:	c0 a1       	brne	8000250c <spi_selectionMode+0x26>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800024fa:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800024fc:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002500:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002504:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002508:	99 18       	st.w	r12[0x4],r8
8000250a:	d8 0a       	popm	pc,r12=0
		uint8_t pcs_decode,
		uint8_t delay)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000250c:	30 2c       	mov	r12,2
8000250e:	d8 02       	popm	pc

80002510 <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002510:	78 19       	ld.w	r9,r12[0x4]

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002512:	18 98       	mov	r8,r12
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002514:	ea 19 00 0f 	orh	r9,0xf
80002518:	99 19       	st.w	r12[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000251a:	78 1c       	ld.w	r12,r12[0x4]
8000251c:	e2 1c 00 04 	andl	r12,0x4,COH
80002520:	c0 80       	breq	80002530 <spi_selectChip+0x20>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002522:	30 e9       	mov	r9,14
80002524:	f2 0b 18 00 	cp.b	r11,r9
80002528:	e0 88 00 12 	brls	8000254c <spi_selectChip+0x3c>
	} else {
		if (chip > 3) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000252c:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000252e:	5e fc       	retal	r12
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002530:	30 39       	mov	r9,3
80002532:	f2 0b 18 00 	cp.b	r11,r9
80002536:	fe 9b ff fb 	brhi	8000252c <spi_selectChip+0x1c>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000253a:	70 19       	ld.w	r9,r8[0x4]
8000253c:	2f 0b       	sub	r11,-16
8000253e:	30 1a       	mov	r10,1
80002540:	f4 0b 09 4b 	lsl	r11,r10,r11
80002544:	5c db       	com	r11
80002546:	12 6b       	and	r11,r9
80002548:	91 1b       	st.w	r8[0x4],r11
8000254a:	5e fc       	retal	r12
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000254c:	70 19       	ld.w	r9,r8[0x4]
8000254e:	b1 6b       	lsl	r11,0x10
80002550:	30 0c       	mov	r12,0
80002552:	ea 1b ff f0 	orh	r11,0xfff0
80002556:	e8 1b ff ff 	orl	r11,0xffff
8000255a:	12 6b       	and	r11,r9
8000255c:	91 1b       	st.w	r8[0x4],r11
8000255e:	5e fc       	retal	r12

80002560 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002560:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002562:	c0 58       	rjmp	8000256c <spi_unselectChip+0xc>
80002564:	2f f9       	sub	r9,-1
		if (!timeout--) {
80002566:	e0 49 3a 99 	cp.w	r9,15001
8000256a:	c0 d0       	breq	80002584 <spi_unselectChip+0x24>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000256c:	78 48       	ld.w	r8,r12[0x10]
8000256e:	ed b8 00 09 	bld	r8,0x9
80002572:	cf 91       	brne	80002564 <spi_unselectChip+0x4>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002574:	78 18       	ld.w	r8,r12[0x4]
80002576:	ea 18 00 0f 	orh	r8,0xf
8000257a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000257c:	fc 18 01 00 	movh	r8,0x100
80002580:	99 08       	st.w	r12[0x0],r8
80002582:	5e fd       	retal	0
spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002584:	5e ff       	retal	1
80002586:	d7 03       	nop

80002588 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002588:	eb cd 40 fe 	pushm	r1-r7,lr
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000258c:	30 34       	mov	r4,3
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000258e:	16 97       	mov	r7,r11
80002590:	18 96       	mov	r6,r12
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002592:	f7 35 00 0c 	ld.ub	r5,r11[12]
80002596:	e8 05 18 00 	cp.b	r5,r4
8000259a:	e0 8b 00 09 	brhi	800025ac <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
8000259e:	f7 32 00 0b 	ld.ub	r2,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800025a2:	30 13       	mov	r3,1
800025a4:	e6 02 18 00 	cp.b	r2,r3
800025a8:	e0 88 00 05 	brls	800025b2 <spi_setupChipReg+0x2a>
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
		break;
800025ac:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
800025ae:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800025b2:	f7 31 00 08 	ld.ub	r1,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800025b6:	30 78       	mov	r8,7
800025b8:	f0 01 18 00 	cp.b	r1,r8
800025bc:	fe 98 ff f8 	brls	800025ac <spi_setupChipReg+0x24>
800025c0:	31 08       	mov	r8,16
800025c2:	f0 01 18 00 	cp.b	r1,r8
800025c6:	fe 9b ff f3 	brhi	800025ac <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800025ca:	14 9b       	mov	r11,r10
800025cc:	6e 1c       	ld.w	r12,r7[0x4]
800025ce:	c5 df       	rcall	80002488 <getBaudDiv>
800025d0:	ce e5       	brlt	800025ac <spi_setupChipReg+0x24>

	if (baudDiv < 0) {
800025d2:	0a 9a       	mov	r10,r5
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800025d4:	ec 1a 00 01 	eorl	r10,0x1
800025d8:	30 08       	mov	r8,0
	if (baudDiv < 0) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800025da:	a1 95       	lsr	r5,0x1
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800025dc:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
800025e0:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800025e4:	ef 3a 00 09 	ld.ub	r10,r7[9]
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800025e8:	20 81       	sub	r1,8
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800025ea:	f1 d2 d0 61 	bfins	r8,r2,0x3,0x1

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800025ee:	0f 89       	ld.ub	r9,r7[0x0]
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
800025f0:	f1 d1 d0 84 	bfins	r8,r1,0x4,0x4
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800025f4:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800025f8:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800025fc:	ef 3a 00 0a 	ld.ub	r10,r7[10]
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002600:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
80002604:	e6 09 18 00 	cp.b	r9,r3

	switch (options->reg) {
80002608:	c0 f0       	breq	80002626 <spi_setupChipReg+0x9e>
8000260a:	c0 b3       	brcs	80002620 <spi_setupChipReg+0x98>
8000260c:	30 2a       	mov	r10,2
8000260e:	f4 09 18 00 	cp.b	r9,r10
80002612:	c0 d0       	breq	8000262c <spi_setupChipReg+0xa4>
80002614:	e8 09 18 00 	cp.b	r9,r4
80002618:	cc a1       	brne	800025ac <spi_setupChipReg+0x24>
8000261a:	8d f8       	st.w	r6[0x3c],r8
	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000261c:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80002620:	8d c8       	st.w	r6[0x30],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002622:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80002626:	8d d8       	st.w	r6[0x34],r8
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002628:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000262c:	8d e8       	st.w	r6[0x38],r8
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000262e:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80002632:	d7 03       	nop

80002634 <spi_enable>:
80002634:	30 18       	mov	r8,1
80002636:	99 08       	st.w	r12[0x0],r8
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
}
80002638:	5e fc       	retal	r12

8000263a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000263a:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000263c:	c0 58       	rjmp	80002646 <spi_write+0xc>
8000263e:	2f f9       	sub	r9,-1
		if (!timeout--) {
80002640:	e0 49 3a 99 	cp.w	r9,15001
80002644:	c0 80       	breq	80002654 <spi_write+0x1a>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002646:	78 48       	ld.w	r8,r12[0x10]
80002648:	ed b8 00 01 	bld	r8,0x1
8000264c:	cf 91       	brne	8000263e <spi_write+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000264e:	5c 7b       	castu.h	r11
80002650:	99 3b       	st.w	r12[0xc],r11
80002652:	5e fd       	retal	0
spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
		if (!timeout--) {
80002654:	5e ff       	retal	1

80002656 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002656:	30 09       	mov	r9,0
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002658:	c0 58       	rjmp	80002662 <spi_read+0xc>
8000265a:	2f f9       	sub	r9,-1
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000265c:	e0 49 3a 99 	cp.w	r9,15001
80002660:	c0 b0       	breq	80002676 <spi_read+0x20>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002662:	78 48       	ld.w	r8,r12[0x10]
80002664:	e2 18 02 01 	andl	r8,0x201,COH
80002668:	e0 48 02 01 	cp.w	r8,513
8000266c:	cf 71       	brne	8000265a <spi_read+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000266e:	78 28       	ld.w	r8,r12[0x8]
80002670:	30 0c       	mov	r12,0
80002672:	b6 08       	st.h	r11[0x0],r8

	return SPI_OK;
}
80002674:	5e fc       	retal	r12
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002676:	5e ff       	retal	1

80002678 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80002678:	d4 01       	pushm	lr
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
8000267a:	76 09       	ld.w	r9,r11[0x0]
8000267c:	58 29       	cp.w	r9,2
8000267e:	e0 8b 00 4b 	brhi	80002714 <tc_init_waveform+0x9c>
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80002682:	76 18       	ld.w	r8,r11[0x4]
80002684:	10 9e       	mov	lr,r8
80002686:	e6 1e c0 00 	andh	lr,0xc000,COH
8000268a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000268e:	af ba       	sbr	r10,0xf
80002690:	1c 4a       	or	r10,lr
80002692:	10 9e       	mov	lr,r8
80002694:	e6 1e 30 00 	andh	lr,0x3000,COH
80002698:	1c 4a       	or	r10,lr
8000269a:	10 9e       	mov	lr,r8
8000269c:	e6 1e 0c 00 	andh	lr,0xc00,COH
800026a0:	1c 4a       	or	r10,lr
800026a2:	10 9e       	mov	lr,r8
800026a4:	e6 1e 03 00 	andh	lr,0x300,COH
800026a8:	1c 4a       	or	r10,lr
800026aa:	10 9e       	mov	lr,r8
800026ac:	e6 1e 00 c0 	andh	lr,0xc0,COH
800026b0:	1c 4a       	or	r10,lr
800026b2:	10 9e       	mov	lr,r8
800026b4:	e6 1e 00 30 	andh	lr,0x30,COH
800026b8:	1c 4a       	or	r10,lr
800026ba:	10 9e       	mov	lr,r8
800026bc:	e6 1e 00 0c 	andh	lr,0xc,COH
800026c0:	1c 4a       	or	r10,lr
800026c2:	10 9e       	mov	lr,r8
800026c4:	e6 1e 00 03 	andh	lr,0x3,COH
800026c8:	1c 4a       	or	r10,lr
800026ca:	10 9e       	mov	lr,r8
800026cc:	e2 1e 60 00 	andl	lr,0x6000,COH
800026d0:	1c 4a       	or	r10,lr
800026d2:	10 9e       	mov	lr,r8
800026d4:	e2 1e 10 00 	andl	lr,0x1000,COH
800026d8:	1c 4a       	or	r10,lr
800026da:	10 9e       	mov	lr,r8
800026dc:	e2 1e 0c 00 	andl	lr,0xc00,COH
800026e0:	1c 4a       	or	r10,lr
800026e2:	10 9e       	mov	lr,r8
800026e4:	e2 1e 03 00 	andl	lr,0x300,COH
800026e8:	1c 4a       	or	r10,lr
800026ea:	10 9e       	mov	lr,r8
800026ec:	e2 1e 00 80 	andl	lr,0x80,COH
800026f0:	10 9b       	mov	r11,r8
800026f2:	1c 4a       	or	r10,lr
800026f4:	e2 1b 00 08 	andl	r11,0x8,COH
800026f8:	10 9e       	mov	lr,r8
800026fa:	a5 69       	lsl	r9,0x4
800026fc:	e2 1e 00 40 	andl	lr,0x40,COH
80002700:	2f f9       	sub	r9,-1
80002702:	1c 4a       	or	r10,lr
80002704:	e2 18 00 30 	andl	r8,0x30,COH
80002708:	f5 e8 10 08 	or	r8,r10,r8
8000270c:	16 48       	or	r8,r11
8000270e:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80002712:	d8 0a       	popm	pc,r12=0


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80002714:	dc 0a       	popm	pc,r12=-1

80002716 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002716:	58 2b       	cp.w	r11,2
80002718:	e0 8b 00 07 	brhi	80002726 <tc_start+0x10>
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000271c:	a7 6b       	lsl	r11,0x6
8000271e:	16 0c       	add	r12,r11
80002720:	30 58       	mov	r8,5
80002722:	99 08       	st.w	r12[0x0],r8
80002724:	5e fd       	retal	0


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002726:	5e fe       	retal	-1

80002728 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002728:	58 2b       	cp.w	r11,2
8000272a:	e0 8b 00 07 	brhi	80002738 <tc_read_sr+0x10>
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
8000272e:	a7 6b       	lsl	r11,0x6
80002730:	2e 0b       	sub	r11,-32
80002732:	16 0c       	add	r12,r11
80002734:	78 0c       	ld.w	r12,r12[0x0]
}
80002736:	5e fc       	retal	r12


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002738:	5e fe       	retal	-1

8000273a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000273a:	58 2b       	cp.w	r11,2
8000273c:	e0 8b 00 1a 	brhi	80002770 <tc_write_rc+0x36>
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80002740:	f6 08 15 04 	lsl	r8,r11,0x4
80002744:	2f f8       	sub	r8,-1
80002746:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
8000274a:	ed b8 00 0f 	bld	r8,0xf
8000274e:	c0 e1       	brne	8000276a <tc_write_rc+0x30>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80002750:	a7 6b       	lsl	r11,0x6
80002752:	f8 0b 00 0b 	add	r11,r12,r11
80002756:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
8000275a:	2e 4b       	sub	r11,-28
8000275c:	76 08       	ld.w	r8,r11[0x0]
8000275e:	e0 18 00 00 	andl	r8,0x0
80002762:	f9 e8 10 08 	or	r8,r12,r8
80002766:	97 08       	st.w	r11[0x0],r8

  return value;
}
80002768:	5e fc       	retal	r12
8000276a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
8000276e:	5e fc       	retal	r12


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002770:	5e fe       	retal	-1

80002772 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80002772:	eb cd 40 80 	pushm	r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002776:	e1 be 00 00 	mfsr	lr,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000277a:	58 2b       	cp.w	r11,2
8000277c:	e0 8b 00 5f 	brhi	8000283a <tc_configure_interrupts+0xc8>
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80002780:	74 08       	ld.w	r8,r10[0x0]
80002782:	10 99       	mov	r9,r8
80002784:	e2 19 00 02 	andl	r9,0x2,COH
80002788:	e2 18 00 fd 	andl	r8,0xfd,COH
8000278c:	12 48       	or	r8,r9
8000278e:	f6 09 15 06 	lsl	r9,r11,0x6
80002792:	f8 09 00 07 	add	r7,r12,r9
80002796:	2d c7       	sub	r7,-36
80002798:	8f 08       	st.w	r7[0x0],r8
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
8000279a:	ee 1e 00 01 	eorh	lr,0x1
8000279e:	fd de c2 01 	bfextu	lr,lr,0x10,0x1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800027a2:	c4 e1       	brne	8000283e <tc_configure_interrupts+0xcc>
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800027a4:	a7 6b       	lsl	r11,0x6
800027a6:	2e 0b       	sub	r11,-32
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800027a8:	74 08       	ld.w	r8,r10[0x0]
800027aa:	f8 09 00 0a 	add	r10,r12,r9
800027ae:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800027b2:	16 0c       	add	r12,r11
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800027b4:	e0 6b 00 80 	mov	r11,128
800027b8:	58 07       	cp.w	r7,0
800027ba:	f9 bb 01 00 	movne	r11,0
800027be:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
800027c2:	ec 19 00 01 	eorl	r9,0x1
800027c6:	f7 e9 10 09 	or	r9,r11,r9
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800027ca:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800027ce:	f9 bb 00 40 	moveq	r11,64
800027d2:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800027d6:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800027d8:	f7 d8 c0 a1 	bfextu	r11,r8,0x5,0x1
800027dc:	f9 bb 00 20 	moveq	r11,32
800027e0:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800027e4:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800027e6:	f7 d8 c0 81 	bfextu	r11,r8,0x4,0x1
800027ea:	f9 bb 00 10 	moveq	r11,16
800027ee:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800027f2:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800027f4:	f7 d8 c0 61 	bfextu	r11,r8,0x3,0x1
800027f8:	f9 bb 00 08 	moveq	r11,8
800027fc:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002800:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002802:	f7 d8 c0 41 	bfextu	r11,r8,0x2,0x1
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002806:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
8000280a:	58 0b       	cp.w	r11,0
8000280c:	f9 bb 00 04 	moveq	r11,4
80002810:	f9 bb 01 00 	movne	r11,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002814:	58 08       	cp.w	r8,0
80002816:	f9 b8 00 02 	moveq	r8,2
8000281a:	f9 b8 01 00 	movne	r8,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000281e:	16 49       	or	r9,r11
80002820:	f3 e8 10 08 	or	r8,r9,r8
80002824:	2d 8a       	sub	r10,-40
80002826:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002828:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000282a:	58 0e       	cp.w	lr,0
8000282c:	c0 41       	brne	80002834 <tc_configure_interrupts+0xc2>
8000282e:	1c 9c       	mov	r12,lr
80002830:	e3 cd 80 80 	ldm	sp++,r7,pc
80002834:	d5 03       	csrf	0x10
80002836:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
  bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000283a:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000283e:	d3 03       	ssrf	0x10
80002840:	cb 2b       	rjmp	800027a4 <tc_configure_interrupts+0x32>

80002842 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002842:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002844:	f6 08 15 04 	lsl	r8,r11,0x4
80002848:	14 38       	cp.w	r8,r10
8000284a:	e0 8b 00 26 	brhi	80002896 <usart_set_async_baudrate+0x54>
8000284e:	31 0e       	mov	lr,16
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002850:	f0 09 16 01 	lsr	r9,r8,0x1
80002854:	f2 0a 00 39 	add	r9,r9,r10<<0x3
80002858:	f2 08 0d 08 	divu	r8,r9,r8
8000285c:	10 99       	mov	r9,r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000285e:	a3 98       	lsr	r8,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002860:	f0 cb 00 01 	sub	r11,r8,1
80002864:	e0 4b ff fe 	cp.w	r11,65534
80002868:	e0 8b 00 1b 	brhi	8000289e <usart_set_async_baudrate+0x5c>
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000286c:	78 1a       	ld.w	r10,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000286e:	e8 6b 00 00 	mov	r11,524288
80002872:	e4 1a ff f7 	andh	r10,0xfff7
80002876:	e0 1a fe cf 	andl	r10,0xfecf
8000287a:	59 0e       	cp.w	lr,16
8000287c:	f6 0e 17 10 	movne	lr,r11
80002880:	f9 be 00 00 	moveq	lr,0
80002884:	fd ea 10 0a 	or	r10,lr,r10
80002888:	99 1a       	st.w	r12[0x4],r10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000288a:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
8000288e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002892:	99 88       	st.w	r12[0x20],r8
80002894:	d8 0a       	popm	pc,r12=0
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002896:	f6 08 15 03 	lsl	r8,r11,0x3
8000289a:	30 8e       	mov	lr,8
8000289c:	cd ab       	rjmp	80002850 <usart_set_async_baudrate+0xe>
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000289e:	da 0a       	popm	pc,r12=1

800028a0 <usart_write_line>:
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800028a0:	17 8a       	ld.ub	r10,r11[0x0]
800028a2:	58 0a       	cp.w	r10,0
800028a4:	5e 0c       	reteq	r12
800028a6:	30 09       	mov	r9,0
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800028a8:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800028aa:	ed b8 00 01 	bld	r8,0x1
800028ae:	c0 91       	brne	800028c0 <usart_write_line+0x20>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800028b0:	f1 da c0 09 	bfextu	r8,r10,0x0,0x9


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
800028b4:	2f fb       	sub	r11,-1

int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800028b6:	99 78       	st.w	r12[0x1c],r8
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800028b8:	17 8a       	ld.ub	r10,r11[0x0]
800028ba:	58 0a       	cp.w	r10,0
800028bc:	cf 51       	brne	800028a6 <usart_write_line+0x6>
800028be:	5e fc       	retal	r12
800028c0:	2f f9       	sub	r9,-1
{
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800028c2:	e0 49 27 10 	cp.w	r9,10000
800028c6:	cf 11       	brne	800028a8 <usart_write_line+0x8>


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
800028c8:	2f fb       	sub	r11,-1
800028ca:	cf 7b       	rjmp	800028b8 <usart_write_line+0x18>

800028cc <usart_init_rs232>:
              AVR32_USART_CR_RTSDIS_MASK;
}


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800028cc:	eb cd 40 e0 	pushm	r5-r7,lr
800028d0:	18 97       	mov	r7,r12
800028d2:	16 96       	mov	r6,r11
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800028d4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800028d8:	ed b8 00 10 	bld	r8,0x10
800028dc:	c2 e1       	brne	80002938 <usart_init_rs232+0x6c>
  usart->idr = 0xFFFFFFFF;
800028de:	3f f8       	mov	r8,-1
800028e0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800028e2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800028e4:	30 08       	mov	r8,0
800028e6:	8f 18       	st.w	r7[0x4],r8
  usart->rtor = 0;
800028e8:	8f 98       	st.w	r7[0x24],r8
  usart->ttgr = 0;
800028ea:	8f a8       	st.w	r7[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800028ec:	ea 68 61 0c 	mov	r8,680204
800028f0:	8f 08       	st.w	r7[0x0],r8
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800028f2:	58 06       	cp.w	r6,0
800028f4:	c2 00       	breq	80002934 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
800028f6:	0d c8       	ld.ub	r8,r6[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800028f8:	30 49       	mov	r9,4
800028fa:	f2 08 18 00 	cp.b	r8,r9
800028fe:	e0 88 00 1b 	brls	80002934 <usart_init_rs232+0x68>
80002902:	30 95       	mov	r5,9
80002904:	ea 08 18 00 	cp.b	r8,r5
80002908:	e0 8b 00 16 	brhi	80002934 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000290c:	0d d9       	ld.ub	r9,r6[0x5]
8000290e:	30 78       	mov	r8,7
80002910:	f0 09 18 00 	cp.b	r9,r8
80002914:	e0 8b 00 10 	brhi	80002934 <usart_init_rs232+0x68>
      opt->stopbits > 2 + 255 ||
80002918:	8c 39       	ld.sh	r9,r6[0x6]
8000291a:	e0 68 01 01 	mov	r8,257
8000291e:	f0 09 19 00 	cp.h	r9,r8
80002922:	e0 8b 00 09 	brhi	80002934 <usart_init_rs232+0x68>
      opt->channelmode > 3 ||
80002926:	ed 39 00 08 	ld.ub	r9,r6[8]
8000292a:	30 38       	mov	r8,3
8000292c:	f0 09 18 00 	cp.b	r9,r8
80002930:	e0 88 00 0a 	brls	80002944 <usart_init_rs232+0x78>
  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002934:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002938:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000293a:	3f f8       	mov	r8,-1
8000293c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000293e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002940:	d5 03       	csrf	0x10
80002942:	cd 1b       	rjmp	800028e4 <usart_init_rs232+0x18>
  if (!opt || // Null pointer.
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002944:	6c 0b       	ld.w	r11,r6[0x0]
80002946:	0e 9c       	mov	r12,r7
80002948:	c7 df       	rcall	80002842 <usart_set_async_baudrate>
8000294a:	58 1c       	cp.w	r12,1
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000294c:	cf 40       	breq	80002934 <usart_init_rs232+0x68>
8000294e:	0d c8       	ld.ub	r8,r6[0x4]
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002950:	ea 08 18 00 	cp.b	r8,r5
80002954:	c2 a0       	breq	800029a8 <usart_init_rs232+0xdc>
80002956:	6e 19       	ld.w	r9,r7[0x4]
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002958:	20 58       	sub	r8,5
8000295a:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000295e:	8f 18       	st.w	r7[0x4],r8
80002960:	6e 19       	ld.w	r9,r7[0x4]
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002962:	ed 3a 00 08 	ld.ub	r10,r6[8]
80002966:	0d d8       	ld.ub	r8,r6[0x5]
80002968:	a9 78       	lsl	r8,0x9
8000296a:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000296e:	12 48       	or	r8,r9
80002970:	8f 18       	st.w	r7[0x4],r8
80002972:	30 29       	mov	r9,2
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002974:	8c 38       	ld.sh	r8,r6[0x6]
80002976:	f2 08 19 00 	cp.h	r8,r9
8000297a:	e0 88 00 11 	brls	8000299c <usart_init_rs232+0xd0>
8000297e:	6e 18       	ld.w	r8,r7[0x4]
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002980:	ad b8       	sbr	r8,0xd
80002982:	8f 18       	st.w	r7[0x4],r8
80002984:	8c b8       	ld.uh	r8,r6[0x6]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002986:	20 28       	sub	r8,2
80002988:	8f a8       	st.w	r7[0x28],r8
8000298a:	6e 18       	ld.w	r8,r7[0x4]
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000298c:	e0 18 ff f0 	andl	r8,0xfff0
80002990:	8f 18       	st.w	r7[0x4],r8
80002992:	30 0c       	mov	r12,0
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002994:	35 08       	mov	r8,80
80002996:	8f 08       	st.w	r7[0x0],r8
80002998:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000299c:	6e 19       	ld.w	r9,r7[0x4]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000299e:	5c 78       	castu.h	r8
800029a0:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800029a4:	8f 18       	st.w	r7[0x4],r8
800029a6:	cf 2b       	rjmp	8000298a <usart_init_rs232+0xbe>
800029a8:	6e 18       	ld.w	r8,r7[0x4]
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800029aa:	b1 b8       	sbr	r8,0x11
800029ac:	8f 18       	st.w	r7[0x4],r8
800029ae:	cd 9b       	rjmp	80002960 <usart_init_rs232+0x94>

800029b0 <print_dbg_hex>:
  print_short_hex(DBG_USART, n);
}


void print_dbg_hex(unsigned long n)
{
800029b0:	d4 01       	pushm	lr
800029b2:	20 3d       	sub	sp,12

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
  for (i = 7; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
800029b4:	49 98       	lddpc	r8,80002a18 <print_dbg_hex+0x68>
800029b6:	f8 09 16 1c 	lsr	r9,r12,0x1c
800029ba:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029be:	ba 89       	st.b	sp[0x0],r9
{
  char tmp[9];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
800029c0:	30 09       	mov	r9,0
800029c2:	fb 69 00 08 	st.b	sp[8],r9
  for (i = 7; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
800029c6:	f3 dc c0 04 	bfextu	r9,r12,0x0,0x4
800029ca:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029ce:	ba f9       	st.b	sp[0x7],r9
800029d0:	f3 dc c0 84 	bfextu	r9,r12,0x4,0x4
800029d4:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029d8:	ba e9       	st.b	sp[0x6],r9
800029da:	f3 dc c1 04 	bfextu	r9,r12,0x8,0x4
800029de:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029e2:	ba d9       	st.b	sp[0x5],r9
800029e4:	f3 dc c1 84 	bfextu	r9,r12,0xc,0x4
800029e8:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029ec:	ba c9       	st.b	sp[0x4],r9
800029ee:	f3 dc c2 04 	bfextu	r9,r12,0x10,0x4
800029f2:	f0 09 07 09 	ld.ub	r9,r8[r9]
800029f6:	ba b9       	st.b	sp[0x3],r9
800029f8:	f3 dc c2 84 	bfextu	r9,r12,0x14,0x4
800029fc:	f9 dc c3 04 	bfextu	r12,r12,0x18,0x4
80002a00:	f0 09 07 09 	ld.ub	r9,r8[r9]
80002a04:	f0 0c 07 08 	ld.ub	r8,r8[r12]
80002a08:	ba a9       	st.b	sp[0x2],r9
80002a0a:	ba 98       	st.b	sp[0x1],r8


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002a0c:	1a 9b       	mov	r11,sp
80002a0e:	fe 7c 14 00 	mov	r12,-60416
80002a12:	c4 7f       	rcall	800028a0 <usart_write_line>
80002a14:	2f dd       	sub	sp,-12

void print_dbg_hex(unsigned long n)
{
  // Redirection to the debug USART.
  print_hex(DBG_USART, n);
}
80002a16:	d8 02       	popm	pc
80002a18:	80 01       	ld.sh	r1,r0[0x0]
80002a1a:	3d e8       	mov	r8,-34

80002a1c <print_dbg_ulong>:
80002a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a20:	20 3d       	sub	sp,12
80002a22:	30 08       	mov	r8,0
{
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80002a24:	30 a9       	mov	r9,10
80002a26:	fb 68 00 0a 	st.b	sp[10],r8
80002a2a:	1a 9b       	mov	r11,sp
  do
  {
    tmp[--i] = '0' + n % 10;
80002a2c:	e0 6e cc cd 	mov	lr,52429
80002a30:	ea 1e cc cc 	orh	lr,0xcccc
80002a34:	f8 0e 06 46 	mulu.d	r6,r12,lr
80002a38:	20 19       	sub	r9,1
80002a3a:	0e 98       	mov	r8,r7
80002a3c:	a3 98       	lsr	r8,0x3
80002a3e:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80002a42:	f8 0a 01 1c 	sub	r12,r12,r10<<0x1
80002a46:	2d 0c       	sub	r12,-48
80002a48:	f6 09 0b 0c 	st.b	r11[r9],r12
    n /= 10;
80002a4c:	10 9c       	mov	r12,r8
  } while (n);
80002a4e:	58 08       	cp.w	r8,0
80002a50:	cf 21       	brne	80002a34 <print_dbg_ulong+0x18>


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002a52:	12 0b       	add	r11,r9
80002a54:	fe 7c 14 00 	mov	r12,-60416
80002a58:	c2 4f       	rcall	800028a0 <usart_write_line>
80002a5a:	2f dd       	sub	sp,-12

void print_dbg_ulong(unsigned long n)
{
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
}
80002a5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80002a60 <print_dbg>:
80002a60:	d4 01       	pushm	lr
80002a62:	18 9b       	mov	r11,r12
80002a64:	fe 7c 14 00 	mov	r12,-60416


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002a68:	c1 cf       	rcall	800028a0 <usart_write_line>
80002a6a:	d8 02       	popm	pc

80002a6c <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80002a6c:	eb cd 40 c0 	pushm	r6-r7,lr
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
80002a70:	e0 69 28 aa 	mov	r9,10410
80002a74:	e0 68 28 ac 	mov	r8,10412
80002a78:	13 8b       	ld.ub	r11,r9[0x0]
80002a7a:	11 dc       	ld.ub	r12,r8[0x5]
80002a7c:	30 39       	mov	r9,3
80002a7e:	f2 0b 18 00 	cp.b	r11,r9
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002a82:	c4 60       	breq	80002b0e <sd_mmc_spi_get_capacity+0xa2>
80002a84:	11 fe       	ld.ub	lr,r8[0x7]
80002a86:	f1 37 00 08 	ld.ub	r7,r8[8]
80002a8a:	a7 87       	lsr	r7,0x6
80002a8c:	ee 0e 00 27 	add	r7,r7,lr<<0x2
80002a90:	11 ee       	ld.ub	lr,r8[0x6]
80002a92:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
    capacity = (uint64_t)c_size << 19;
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002a96:	ab 6e       	lsl	lr,0xa
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002a98:	f1 39 00 0a 	ld.ub	r9,r8[10]
80002a9c:	1c 07       	add	r7,lr
80002a9e:	f2 06 16 07 	lsr	r6,r9,0x7
80002aa2:	2f f7       	sub	r7,-1
80002aa4:	f1 3e 00 09 	ld.ub	lr,r8[9]
80002aa8:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80002aac:	ec 0e 00 1e 	add	lr,r6,lr<<0x1
80002ab0:	2f ee       	sub	lr,-2
80002ab2:	ee 0e 09 4e 	lsl	lr,r7,lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80002ab6:	20 1e       	sub	lr,1
80002ab8:	e0 6a 28 a4 	mov	r10,10404
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002abc:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
80002ac0:	95 0e       	st.w	r10[0x0],lr
80002ac2:	74 0e       	ld.w	lr,r10[0x0]
80002ac4:	2f fe       	sub	lr,-1
80002ac6:	fc 0c 09 4e 	lsl	lr,lr,r12
80002aca:	1c 96       	mov	r6,lr
80002acc:	30 0e       	mov	lr,0
80002ace:	1c 97       	mov	r7,lr
    capacity_mult = 0;
80002ad0:	e0 6e 28 98 	mov	lr,10392
80002ad4:	fc e7 00 00 	st.d	lr[0],r6
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002ad8:	e0 67 28 a0 	mov	r7,10400
80002adc:	30 0e       	mov	lr,0
80002ade:	ae 0e       	st.h	r7[0x0],lr
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002ae0:	30 97       	mov	r7,9
80002ae2:	ee 0c 18 00 	cp.b	r12,r7
80002ae6:	e0 88 00 07 	brls	80002af4 <sd_mmc_spi_get_capacity+0x88>
    }
  }
  if (card_type == MMC_CARD)
80002aea:	74 0e       	ld.w	lr,r10[0x0]
80002aec:	20 9c       	sub	r12,9
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002aee:	fc 0c 09 4c 	lsl	r12,lr,r12
80002af2:	95 0c       	st.w	r10[0x0],r12
80002af4:	58 0b       	cp.w	r11,0
80002af6:	c3 51       	brne	80002b60 <sd_mmc_spi_get_capacity+0xf4>
80002af8:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80002afc:	f1 38 00 0b 	ld.ub	r8,r8[11]
80002b00:	f3 d9 c0 45 	bfextu	r9,r9,0x2,0x5
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002b04:	a5 98       	lsr	r8,0x5
80002b06:	f1 ea 10 38 	or	r8,r8,r10<<0x3
80002b0a:	2f f8       	sub	r8,-1
80002b0c:	c3 28       	rjmp	80002b70 <sd_mmc_spi_get_capacity+0x104>
80002b0e:	f1 3e 00 08 	ld.ub	lr,r8[8]
80002b12:	f1 39 00 09 	ld.ub	r9,r8[9]
80002b16:	f3 ee 10 89 	or	r9,r9,lr<<0x8
    ++c_size;
80002b1a:	11 fe       	ld.ub	lr,r8[0x7]
    capacity = (uint64_t)c_size << 19;
80002b1c:	fd de c0 06 	bfextu	lr,lr,0x0,0x6
80002b20:	f3 ee 11 0e 	or	lr,r9,lr<<0x10
80002b24:	2f fe       	sub	lr,-1
80002b26:	fc 09 16 0d 	lsr	r9,lr,0xd
80002b2a:	fc 0a 15 13 	lsl	r10,lr,0x13
    capacity_mult = (c_size >> 13) & 0x01FF;
80002b2e:	e0 6c 28 98 	mov	r12,10392
80002b32:	12 9b       	mov	r11,r9
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002b34:	f8 eb 00 00 	st.d	r12[0],r10
80002b38:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
80002b3c:	e0 69 28 a0 	mov	r9,10400
80002b40:	b2 0a       	st.h	r9[0x0],r10
80002b42:	f8 ea 00 00 	ld.d	r10,r12[0]
80002b46:	92 0c       	ld.sh	r12,r9[0x0]
80002b48:	f4 09 16 09 	lsr	r9,r10,0x9
80002b4c:	b7 7c       	lsl	r12,0x17
80002b4e:	f3 eb 11 79 	or	r9,r9,r11<<0x17
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002b52:	20 19       	sub	r9,1
80002b54:	18 09       	add	r9,r12
80002b56:	e0 6a 28 a4 	mov	r10,10404
80002b5a:	95 09       	st.w	r10[0x0],r9
80002b5c:	f1 39 00 0a 	ld.ub	r9,r8[10]
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002b60:	f1 38 00 0b 	ld.ub	r8,r8[11]
80002b64:	a7 98       	lsr	r8,0x7
80002b66:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
}
80002b6a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80002b6e:	30 18       	mov	r8,1
80002b70:	2f f9       	sub	r9,-1
80002b72:	b1 39       	mul	r9,r8
80002b74:	e0 68 28 a2 	mov	r8,10402
80002b78:	b0 09       	st.h	r8[0x0],r9
80002b7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b7e:	d7 03       	nop

80002b80 <sd_mmc_spi_write_close>:
80002b80:	5e fc       	retal	r12
80002b82:	d7 03       	nop

80002b84 <sd_mmc_spi_read_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA read transfer
//! page programming.
//!
void sd_mmc_spi_read_close_PDCA (void)
{
80002b84:	d4 01       	pushm	lr

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80002b86:	e0 6b 00 ff 	mov	r11,255
80002b8a:	fe 7c 28 00 	mov	r12,-55296
80002b8e:	fe b0 fd 56 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80002b92:	e0 6b 00 ff 	mov	r11,255
80002b96:	fe 7c 28 00 	mov	r12,-55296
80002b9a:	fe b0 fd 50 	rcall	8000263a <spi_write>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80002b9e:	e0 6b 00 ff 	mov	r11,255
80002ba2:	fe 7c 28 00 	mov	r12,-55296
80002ba6:	fe b0 fd 4a 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80002baa:	e0 6b 00 ff 	mov	r11,255
80002bae:	fe 7c 28 00 	mov	r12,-55296
80002bb2:	fe b0 fd 44 	rcall	8000263a <spi_write>

  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002bb6:	30 2b       	mov	r11,2
80002bb8:	fe 7c 28 00 	mov	r12,-55296
80002bbc:	fe b0 fc d2 	rcall	80002560 <spi_unselectChip>

}
80002bc0:	d8 02       	popm	pc
80002bc2:	d7 03       	nop

80002bc4 <sd_mmc_spi_wait_not_busy>:
80002bc4:	d4 21       	pushm	r4-r7,lr
80002bc6:	20 1d       	sub	sp,4
80002bc8:	30 2b       	mov	r11,2
80002bca:	fe 7c 28 00 	mov	r12,-55296
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002bce:	fa c6 ff fe 	sub	r6,sp,-2
80002bd2:	fe b0 fc 9f 	rcall	80002510 <spi_selectChip>
80002bd6:	e0 65 28 bc 	mov	r5,10428
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002bda:	30 07       	mov	r7,0
80002bdc:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
80002bde:	c0 98       	rjmp	80002bf0 <sd_mmc_spi_wait_not_busy+0x2c>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002be0:	1b b8       	ld.ub	r8,sp[0x3]
80002be2:	aa 88       	st.b	r5[0x0],r8
80002be4:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
80002be8:	c1 40       	breq	80002c10 <sd_mmc_spi_wait_not_busy+0x4c>
80002bea:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002bee:	c1 80       	breq	80002c1e <sd_mmc_spi_wait_not_busy+0x5a>
80002bf0:	e0 6b 00 ff 	mov	r11,255
80002bf4:	fe 7c 28 00 	mov	r12,-55296
80002bf8:	fe b0 fd 21 	rcall	8000263a <spi_write>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002bfc:	0c 9b       	mov	r11,r6
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002bfe:	2f f7       	sub	r7,-1
80002c00:	fe 7c 28 00 	mov	r12,-55296
80002c04:	fe b0 fd 29 	rcall	80002656 <spi_read>
80002c08:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002c0a:	ce b1       	brne	80002be0 <sd_mmc_spi_wait_not_busy+0x1c>
80002c0c:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002c0e:	aa 88       	st.b	r5[0x0],r8
80002c10:	30 2b       	mov	r11,2
80002c12:	fe 7c 28 00 	mov	r12,-55296
80002c16:	fe b0 fc a5 	rcall	80002560 <spi_unselectChip>
80002c1a:	2f fd       	sub	sp,-4
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002c1c:	da 2a       	popm	r4-r7,pc,r12=1
80002c1e:	30 2b       	mov	r11,2
80002c20:	fe 7c 28 00 	mov	r12,-55296
80002c24:	fe b0 fc 9e 	rcall	80002560 <spi_unselectChip>
80002c28:	2f fd       	sub	sp,-4
80002c2a:	d8 2a       	popm	r4-r7,pc,r12=0

80002c2c <sd_mmc_spi_write_open>:
80002c2c:	d4 01       	pushm	lr
80002c2e:	e0 68 06 6c 	mov	r8,1644
80002c32:	a9 7c       	lsl	r12,0x9
80002c34:	91 0c       	st.w	r8[0x0],r12
80002c36:	cc 7f       	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80002c38:	d8 02       	popm	pc
80002c3a:	d7 03       	nop

80002c3c <sd_mmc_spi_command>:
80002c3c:	eb cd 40 e0 	pushm	r5-r7,lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9; // gl_ptr_mem = pos * 512

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
}
80002c40:	20 1d       	sub	sp,4
80002c42:	16 97       	mov	r7,r11
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80002c44:	18 96       	mov	r6,r12
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002c46:	e0 6b 00 ff 	mov	r11,255
80002c4a:	fe 7c 28 00 	mov	r12,-55296
80002c4e:	fe b0 fc f6 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002c52:	fe 7c 28 00 	mov	r12,-55296
80002c56:	0c 9b       	mov	r11,r6
80002c58:	a7 ab       	sbr	r11,0x6
80002c5a:	5c 5b       	castu.b	r11
80002c5c:	fe b0 fc ef 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80002c60:	ee 0b 16 18 	lsr	r11,r7,0x18
80002c64:	fe 7c 28 00 	mov	r12,-55296
80002c68:	fe b0 fc e9 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI, arg>>16);
80002c6c:	ee 0b 16 10 	lsr	r11,r7,0x10
80002c70:	fe 7c 28 00 	mov	r12,-55296
80002c74:	fe b0 fc e3 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI, arg>>8 );
80002c78:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002c7c:	fe 7c 28 00 	mov	r12,-55296
80002c80:	fe b0 fc dd 	rcall	8000263a <spi_write>
  spi_write(SD_MMC_SPI, arg    );
80002c84:	0e 9b       	mov	r11,r7
80002c86:	fe 7c 28 00 	mov	r12,-55296
80002c8a:	5c 7b       	castu.h	r11
80002c8c:	fe b0 fc d7 	rcall	8000263a <spi_write>
  switch(command)
80002c90:	30 08       	mov	r8,0
80002c92:	f0 06 18 00 	cp.b	r6,r8
80002c96:	e0 80 00 ec 	breq	80002e6e <sd_mmc_spi_command+0x232>
80002c9a:	30 88       	mov	r8,8
80002c9c:	f0 06 18 00 	cp.b	r6,r8
80002ca0:	e0 80 00 ee 	breq	80002e7c <sd_mmc_spi_command+0x240>
         break;
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
         break;
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002ca4:	e0 6b 00 ff 	mov	r11,255
80002ca8:	fe 7c 28 00 	mov	r12,-55296
80002cac:	fe b0 fc c7 	rcall	8000263a <spi_write>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002cb0:	e0 6b 00 ff 	mov	r11,255

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002cb4:	e0 67 28 bc 	mov	r7,10428
80002cb8:	3f f5       	mov	r5,-1
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002cba:	fe 7c 28 00 	mov	r12,-55296

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002cbe:	ae 85       	st.b	r7[0x0],r5
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002cc0:	fe b0 fc bd 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002cc4:	fa c6 ff fe 	sub	r6,sp,-2
80002cc8:	fe 7c 28 00 	mov	r12,-55296
80002ccc:	0c 9b       	mov	r11,r6
80002cce:	fe b0 fc c4 	rcall	80002656 <spi_read>
80002cd2:	58 1c       	cp.w	r12,1
80002cd4:	e0 80 00 db 	breq	80002e8a <sd_mmc_spi_command+0x24e>
     return 0xFF;
   return data_read;
80002cd8:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002cda:	ae 8c       	st.b	r7[0x0],r12
80002cdc:	ea 0c 18 00 	cp.b	r12,r5
80002ce0:	e0 81 00 c4 	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002ce4:	e0 6b 00 ff 	mov	r11,255
80002ce8:	fe 7c 28 00 	mov	r12,-55296
80002cec:	fe b0 fc a7 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002cf0:	0c 9b       	mov	r11,r6
80002cf2:	fe 7c 28 00 	mov	r12,-55296
80002cf6:	fe b0 fc b0 	rcall	80002656 <spi_read>
80002cfa:	58 1c       	cp.w	r12,1
80002cfc:	e0 80 00 c9 	breq	80002e8e <sd_mmc_spi_command+0x252>
     return 0xFF;
   return data_read;
80002d00:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002d02:	ae 8c       	st.b	r7[0x0],r12
80002d04:	3f f8       	mov	r8,-1
80002d06:	f0 0c 18 00 	cp.b	r12,r8
80002d0a:	e0 81 00 af 	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002d0e:	e0 6b 00 ff 	mov	r11,255
80002d12:	fe 7c 28 00 	mov	r12,-55296
80002d16:	fe b0 fc 92 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002d1a:	0c 9b       	mov	r11,r6
80002d1c:	fe 7c 28 00 	mov	r12,-55296
80002d20:	fe b0 fc 9b 	rcall	80002656 <spi_read>
80002d24:	58 1c       	cp.w	r12,1
80002d26:	e0 80 00 b7 	breq	80002e94 <sd_mmc_spi_command+0x258>
     return 0xFF;
   return data_read;
80002d2a:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002d2c:	ae 8c       	st.b	r7[0x0],r12
80002d2e:	3f f8       	mov	r8,-1
80002d30:	f0 0c 18 00 	cp.b	r12,r8
80002d34:	e0 81 00 9a 	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002d38:	e0 6b 00 ff 	mov	r11,255
80002d3c:	fe 7c 28 00 	mov	r12,-55296
80002d40:	fe b0 fc 7d 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002d44:	0c 9b       	mov	r11,r6
80002d46:	fe 7c 28 00 	mov	r12,-55296
80002d4a:	fe b0 fc 86 	rcall	80002656 <spi_read>
80002d4e:	58 1c       	cp.w	r12,1
80002d50:	e0 80 00 a5 	breq	80002e9a <sd_mmc_spi_command+0x25e>
     return 0xFF;
   return data_read;
80002d54:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002d56:	ae 8c       	st.b	r7[0x0],r12
80002d58:	3f f8       	mov	r8,-1
80002d5a:	f0 0c 18 00 	cp.b	r12,r8
80002d5e:	e0 81 00 85 	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002d62:	e0 6b 00 ff 	mov	r11,255
80002d66:	fe 7c 28 00 	mov	r12,-55296
80002d6a:	fe b0 fc 68 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002d6e:	0c 9b       	mov	r11,r6
80002d70:	fe 7c 28 00 	mov	r12,-55296
80002d74:	fe b0 fc 71 	rcall	80002656 <spi_read>
80002d78:	58 1c       	cp.w	r12,1
80002d7a:	e0 80 00 93 	breq	80002ea0 <sd_mmc_spi_command+0x264>
     return 0xFF;
   return data_read;
80002d7e:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002d80:	ae 8c       	st.b	r7[0x0],r12
80002d82:	3f f8       	mov	r8,-1
80002d84:	f0 0c 18 00 	cp.b	r12,r8
80002d88:	c7 01       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002d8a:	e0 6b 00 ff 	mov	r11,255
80002d8e:	fe 7c 28 00 	mov	r12,-55296
80002d92:	fe b0 fc 54 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002d96:	0c 9b       	mov	r11,r6
80002d98:	fe 7c 28 00 	mov	r12,-55296
80002d9c:	fe b0 fc 5d 	rcall	80002656 <spi_read>
80002da0:	58 1c       	cp.w	r12,1
80002da2:	e0 80 00 82 	breq	80002ea6 <sd_mmc_spi_command+0x26a>
     return 0xFF;
   return data_read;
80002da6:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002da8:	ae 8c       	st.b	r7[0x0],r12
80002daa:	3f f8       	mov	r8,-1
80002dac:	f0 0c 18 00 	cp.b	r12,r8
80002db0:	c5 c1       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002db2:	e0 6b 00 ff 	mov	r11,255
80002db6:	fe 7c 28 00 	mov	r12,-55296
80002dba:	fe b0 fc 40 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002dbe:	0c 9b       	mov	r11,r6
80002dc0:	fe 7c 28 00 	mov	r12,-55296
80002dc4:	fe b0 fc 49 	rcall	80002656 <spi_read>
80002dc8:	58 1c       	cp.w	r12,1
80002dca:	c7 10       	breq	80002eac <sd_mmc_spi_command+0x270>
     return 0xFF;
   return data_read;
80002dcc:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002dce:	ae 8c       	st.b	r7[0x0],r12
80002dd0:	3f f8       	mov	r8,-1
80002dd2:	f0 0c 18 00 	cp.b	r12,r8
80002dd6:	c4 91       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002dd8:	e0 6b 00 ff 	mov	r11,255
80002ddc:	fe 7c 28 00 	mov	r12,-55296
80002de0:	fe b0 fc 2d 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002de4:	0c 9b       	mov	r11,r6
80002de6:	fe 7c 28 00 	mov	r12,-55296
80002dea:	fe b0 fc 36 	rcall	80002656 <spi_read>
80002dee:	58 1c       	cp.w	r12,1
80002df0:	c6 10       	breq	80002eb2 <sd_mmc_spi_command+0x276>
     return 0xFF;
   return data_read;
80002df2:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002df4:	ae 8c       	st.b	r7[0x0],r12
80002df6:	3f f8       	mov	r8,-1
80002df8:	f0 0c 18 00 	cp.b	r12,r8
80002dfc:	c3 61       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002dfe:	e0 6b 00 ff 	mov	r11,255
80002e02:	fe 7c 28 00 	mov	r12,-55296
80002e06:	fe b0 fc 1a 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002e0a:	0c 9b       	mov	r11,r6
80002e0c:	fe 7c 28 00 	mov	r12,-55296
80002e10:	fe b0 fc 23 	rcall	80002656 <spi_read>
80002e14:	58 1c       	cp.w	r12,1
80002e16:	c5 10       	breq	80002eb8 <sd_mmc_spi_command+0x27c>
     return 0xFF;
   return data_read;
80002e18:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002e1a:	ae 8c       	st.b	r7[0x0],r12
80002e1c:	3f f8       	mov	r8,-1
80002e1e:	f0 0c 18 00 	cp.b	r12,r8
80002e22:	c2 31       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002e24:	e0 6b 00 ff 	mov	r11,255
80002e28:	fe 7c 28 00 	mov	r12,-55296
80002e2c:	fe b0 fc 07 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002e30:	0c 9b       	mov	r11,r6
80002e32:	fe 7c 28 00 	mov	r12,-55296
80002e36:	fe b0 fc 10 	rcall	80002656 <spi_read>
80002e3a:	58 1c       	cp.w	r12,1
80002e3c:	c4 10       	breq	80002ebe <sd_mmc_spi_command+0x282>
     return 0xFF;
   return data_read;
80002e3e:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002e40:	ae 8c       	st.b	r7[0x0],r12
80002e42:	3f f8       	mov	r8,-1
80002e44:	f0 0c 18 00 	cp.b	r12,r8
80002e48:	c1 01       	brne	80002e68 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002e4a:	e0 6b 00 ff 	mov	r11,255
80002e4e:	fe 7c 28 00 	mov	r12,-55296
80002e52:	fe b0 fb f4 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002e56:	0c 9b       	mov	r11,r6
80002e58:	fe 7c 28 00 	mov	r12,-55296
80002e5c:	fe b0 fb fd 	rcall	80002656 <spi_read>
80002e60:	58 1c       	cp.w	r12,1
80002e62:	c3 10       	breq	80002ec4 <sd_mmc_spi_command+0x288>
     return 0xFF;
   return data_read;
80002e64:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002e66:	ae 8c       	st.b	r7[0x0],r12
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80002e68:	2f fd       	sub	sp,-4
80002e6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  spi_write(SD_MMC_SPI, arg>>8 );
  spi_write(SD_MMC_SPI, arg    );
  switch(command)
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002e6e:	e0 6b 00 95 	mov	r11,149
80002e72:	fe 7c 28 00 	mov	r12,-55296
80002e76:	fe b0 fb e2 	rcall	8000263a <spi_write>
         break;
80002e7a:	c1 bb       	rjmp	80002cb0 <sd_mmc_spi_command+0x74>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80002e7c:	e0 6b 00 87 	mov	r11,135
80002e80:	fe 7c 28 00 	mov	r12,-55296
80002e84:	fe b0 fb db 	rcall	8000263a <spi_write>
         break;
80002e88:	c1 4b       	rjmp	80002cb0 <sd_mmc_spi_command+0x74>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002e8a:	ae 85       	st.b	r7[0x0],r5
80002e8c:	c2 cb       	rjmp	80002ce4 <sd_mmc_spi_command+0xa8>
80002e8e:	3f f8       	mov	r8,-1
80002e90:	ae 88       	st.b	r7[0x0],r8
80002e92:	c3 eb       	rjmp	80002d0e <sd_mmc_spi_command+0xd2>
80002e94:	3f f8       	mov	r8,-1
80002e96:	ae 88       	st.b	r7[0x0],r8
80002e98:	c5 0b       	rjmp	80002d38 <sd_mmc_spi_command+0xfc>
80002e9a:	3f f8       	mov	r8,-1
80002e9c:	ae 88       	st.b	r7[0x0],r8
80002e9e:	c6 2b       	rjmp	80002d62 <sd_mmc_spi_command+0x126>
80002ea0:	3f f8       	mov	r8,-1
80002ea2:	ae 88       	st.b	r7[0x0],r8
80002ea4:	c7 3b       	rjmp	80002d8a <sd_mmc_spi_command+0x14e>
80002ea6:	3f f8       	mov	r8,-1
80002ea8:	ae 88       	st.b	r7[0x0],r8
80002eaa:	c8 4b       	rjmp	80002db2 <sd_mmc_spi_command+0x176>
80002eac:	3f f8       	mov	r8,-1
80002eae:	ae 88       	st.b	r7[0x0],r8
80002eb0:	c9 4b       	rjmp	80002dd8 <sd_mmc_spi_command+0x19c>
80002eb2:	3f f8       	mov	r8,-1
80002eb4:	ae 88       	st.b	r7[0x0],r8
80002eb6:	ca 4b       	rjmp	80002dfe <sd_mmc_spi_command+0x1c2>
80002eb8:	3f f8       	mov	r8,-1
80002eba:	ae 88       	st.b	r7[0x0],r8
80002ebc:	cb 4b       	rjmp	80002e24 <sd_mmc_spi_command+0x1e8>
80002ebe:	3f f8       	mov	r8,-1
80002ec0:	ae 88       	st.b	r7[0x0],r8
80002ec2:	cc 4b       	rjmp	80002e4a <sd_mmc_spi_command+0x20e>
80002ec4:	3f f8       	mov	r8,-1
80002ec6:	e0 6c 00 ff 	mov	r12,255
80002eca:	ae 88       	st.b	r7[0x0],r8
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80002ecc:	2f fd       	sub	sp,-4
80002ece:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ed2:	d7 03       	nop

80002ed4 <sd_mmc_spi_read_open_PDCA>:
80002ed4:	d4 21       	pushm	r4-r7,lr
80002ed6:	20 1d       	sub	sp,4
80002ed8:	a9 7c       	lsl	r12,0x9
80002eda:	e0 67 06 6c 	mov	r7,1644
80002ede:	8f 0c       	st.w	r7[0x0],r12

  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9;                    // gl_ptr_mem = pos * 512

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002ee0:	c7 2e       	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80002ee2:	c0 31       	brne	80002ee8 <sd_mmc_spi_read_open_PDCA+0x14>
    spi_write(SD_MMC_SPI,0xFF);
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }
  return true;   // Read done.
}
80002ee4:	2f fd       	sub	sp,-4
80002ee6:	d8 22       	popm	r4-r7,pc
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;


  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI
80002ee8:	30 2b       	mov	r11,2
80002eea:	fe 7c 28 00 	mov	r12,-55296
80002eee:	fe b0 fb 11 	rcall	80002510 <spi_selectChip>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002ef2:	e0 68 28 aa 	mov	r8,10410
80002ef6:	11 89       	ld.ub	r9,r8[0x0]
80002ef8:	30 38       	mov	r8,3
80002efa:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80002efe:	c3 90       	breq	80002f70 <sd_mmc_spi_read_open_PDCA+0x9c>
80002f00:	6e 0b       	ld.w	r11,r7[0x0]
80002f02:	31 1c       	mov	r12,17
80002f04:	e0 66 28 bc 	mov	r6,10428
80002f08:	c9 ae       	rcall	80002c3c <sd_mmc_spi_command>
  }

  // check for valid response
  if (r1 != 0x00)
80002f0a:	ac 8c       	st.b	r6[0x0],r12
80002f0c:	58 0c       	cp.w	r12,0
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
       return false;
80002f0e:	c2 81       	brne	80002f5e <sd_mmc_spi_read_open_PDCA+0x8a>
80002f10:	18 97       	mov	r7,r12
80002f12:	fa c5 ff fe 	sub	r5,sp,-2
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002f16:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
80002f18:	c0 a8       	rjmp	80002f2c <sd_mmc_spi_read_open_PDCA+0x58>
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002f1a:	1b b8       	ld.ub	r8,sp[0x3]
80002f1c:	ac 88       	st.b	r6[0x0],r8
80002f1e:	e8 08 18 00 	cp.b	r8,r4

  // check for valid response
  if (r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
80002f22:	c1 41       	brne	80002f4a <sd_mmc_spi_read_open_PDCA+0x76>
  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
80002f24:	2f f7       	sub	r7,-1
80002f26:	e0 47 75 30 	cp.w	r7,30000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002f2a:	c1 a0       	breq	80002f5e <sd_mmc_spi_read_open_PDCA+0x8a>
80002f2c:	e0 6b 00 ff 	mov	r11,255
80002f30:	fe 7c 28 00 	mov	r12,-55296
80002f34:	fe b0 fb 83 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002f38:	0a 9b       	mov	r11,r5
80002f3a:	fe 7c 28 00 	mov	r12,-55296
80002f3e:	fe b0 fb 8c 	rcall	80002656 <spi_read>
80002f42:	58 1c       	cp.w	r12,1
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002f44:	ce b1       	brne	80002f1a <sd_mmc_spi_read_open_PDCA+0x46>
80002f46:	ac 84       	st.b	r6[0x0],r4
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80002f48:	ce eb       	rjmp	80002f24 <sd_mmc_spi_read_open_PDCA+0x50>
80002f4a:	3f e9       	mov	r9,-2
80002f4c:	f2 08 18 00 	cp.b	r8,r9
  {
    spi_write(SD_MMC_SPI,0xFF);
80002f50:	c0 e0       	breq	80002f6c <sd_mmc_spi_read_open_PDCA+0x98>
80002f52:	e0 6b 00 ff 	mov	r11,255
80002f56:	fe 7c 28 00 	mov	r12,-55296
80002f5a:	fe b0 fb 70 	rcall	8000263a <spi_write>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f5e:	30 2b       	mov	r11,2
80002f60:	fe 7c 28 00 	mov	r12,-55296
80002f64:	fe b0 fa fe 	rcall	80002560 <spi_unselectChip>
80002f68:	2f fd       	sub	sp,-4
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80002f6a:	d8 2a       	popm	r4-r7,pc,r12=0
80002f6c:	30 1c       	mov	r12,1

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002f6e:	cb bb       	rjmp	80002ee4 <sd_mmc_spi_read_open_PDCA+0x10>
80002f70:	6e 0b       	ld.w	r11,r7[0x0]
80002f72:	31 1c       	mov	r12,17
80002f74:	a9 9b       	lsr	r11,0x9
80002f76:	e0 66 28 bc 	mov	r6,10428
80002f7a:	c6 1e       	rcall	80002c3c <sd_mmc_spi_command>
80002f7c:	ac 8c       	st.b	r6[0x0],r12
80002f7e:	cc 7b       	rjmp	80002f0c <sd_mmc_spi_read_open_PDCA+0x38>

80002f80 <sd_mmc_spi_check_hc>:
80002f80:	eb cd 40 e0 	pushm	r5-r7,lr
80002f84:	20 1d       	sub	sp,4
80002f86:	c1 fe       	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80002f88:	c0 61       	brne	80002f94 <sd_mmc_spi_check_hc+0x14>
80002f8a:	3f f7       	mov	r7,-1
80002f8c:	0e 9c       	mov	r12,r7
80002f8e:	2f fd       	sub	sp,-4
80002f90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f94:	30 2b       	mov	r11,2
80002f96:	fe 7c 28 00 	mov	r12,-55296
80002f9a:	fe b0 fa bb 	rcall	80002510 <spi_selectChip>
80002f9e:	30 0b       	mov	r11,0
80002fa0:	33 ac       	mov	r12,58
80002fa2:	e0 66 28 bc 	mov	r6,10428
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80002fa6:	c4 be       	rcall	80002c3c <sd_mmc_spi_command>
80002fa8:	ac 8c       	st.b	r6[0x0],r12
80002faa:	c5 41       	brne	80003052 <sd_mmc_spi_check_hc+0xd2>
  // check for valid response
  if(r1 != 0) {
80002fac:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002fb0:	fe 7c 28 00 	mov	r12,-55296
80002fb4:	fe b0 fb 43 	rcall	8000263a <spi_write>
80002fb8:	fa c5 ff fe 	sub	r5,sp,-2
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002fbc:	fe 7c 28 00 	mov	r12,-55296
80002fc0:	0a 9b       	mov	r11,r5
80002fc2:	fe b0 fb 4a 	rcall	80002656 <spi_read>
80002fc6:	58 1c       	cp.w	r12,1
80002fc8:	c3 a0       	breq	8000303c <sd_mmc_spi_check_hc+0xbc>
80002fca:	1b b7       	ld.ub	r7,sp[0x3]
80002fcc:	ef d7 c0 c1 	bfextu	r7,r7,0x6,0x1
80002fd0:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002fd4:	fe 7c 28 00 	mov	r12,-55296
80002fd8:	fe b0 fb 31 	rcall	8000263a <spi_write>
80002fdc:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002fde:	fe 7c 28 00 	mov	r12,-55296
80002fe2:	fe b0 fb 3a 	rcall	80002656 <spi_read>
80002fe6:	58 1c       	cp.w	r12,1
80002fe8:	c3 20       	breq	8000304c <sd_mmc_spi_check_hc+0xcc>
80002fea:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
80002fec:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002ff0:	ac 88       	st.b	r6[0x0],r8
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002ff2:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002ff6:	fe b0 fb 22 	rcall	8000263a <spi_write>
80002ffa:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002ffc:	fe 7c 28 00 	mov	r12,-55296
80003000:	fe b0 fb 2b 	rcall	80002656 <spi_read>
80003004:	58 1c       	cp.w	r12,1
80003006:	c2 00       	breq	80003046 <sd_mmc_spi_check_hc+0xc6>
80003008:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
8000300a:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000300e:	ac 88       	st.b	r6[0x0],r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003010:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003014:	fe b0 fb 13 	rcall	8000263a <spi_write>
80003018:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000301a:	fe 7c 28 00 	mov	r12,-55296
8000301e:	fe b0 fb 1c 	rcall	80002656 <spi_read>
80003022:	58 1c       	cp.w	r12,1
80003024:	c0 e0       	breq	80003040 <sd_mmc_spi_check_hc+0xc0>
80003026:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
80003028:	ac 88       	st.b	r6[0x0],r8
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000302a:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000302c:	fe 7c 28 00 	mov	r12,-55296
80003030:	fe b0 fa 98 	rcall	80002560 <spi_unselectChip>
80003034:	0e 9c       	mov	r12,r7
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80003036:	2f fd       	sub	sp,-4
80003038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000303c:	18 97       	mov	r7,r12
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000303e:	cc 9b       	rjmp	80002fd0 <sd_mmc_spi_check_hc+0x50>
80003040:	e0 68 00 ff 	mov	r8,255
80003044:	cf 2b       	rjmp	80003028 <sd_mmc_spi_check_hc+0xa8>
80003046:	e0 68 00 ff 	mov	r8,255
8000304a:	ce 0b       	rjmp	8000300a <sd_mmc_spi_check_hc+0x8a>
8000304c:	e0 68 00 ff 	mov	r8,255
80003050:	cc eb       	rjmp	80002fec <sd_mmc_spi_check_hc+0x6c>
80003052:	30 2b       	mov	r11,2

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
  // check for valid response
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003054:	fe 7c 28 00 	mov	r12,-55296
80003058:	fe b0 fa 84 	rcall	80002560 <spi_unselectChip>
8000305c:	c9 7b       	rjmp	80002f8a <sd_mmc_spi_check_hc+0xa>
8000305e:	d7 03       	nop

80003060 <sd_mmc_spi_write_sector_from_ram>:
80003060:	d4 21       	pushm	r4-r7,lr
80003062:	20 1d       	sub	sp,4
80003064:	18 97       	mov	r7,r12
80003066:	fe b0 fd af 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
8000306a:	c0 31       	brne	80003070 <sd_mmc_spi_write_sector_from_ram+0x10>
8000306c:	2f fd       	sub	sp,-4
8000306e:	d8 22       	popm	r4-r7,pc
80003070:	30 2b       	mov	r11,2
80003072:	fe 7c 28 00 	mov	r12,-55296
80003076:	fe b0 fa 4d 	rcall	80002510 <spi_selectChip>
8000307a:	e0 68 28 aa 	mov	r8,10410
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000307e:	11 89       	ld.ub	r9,r8[0x0]
80003080:	30 38       	mov	r8,3
80003082:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80003086:	c5 40       	breq	8000312e <sd_mmc_spi_write_sector_from_ram+0xce>
80003088:	e0 64 06 6c 	mov	r4,1644
8000308c:	31 8c       	mov	r12,24
8000308e:	68 0b       	ld.w	r11,r4[0x0]
80003090:	e0 65 28 bc 	mov	r5,10428
  }

  // check for valid response
  if(r1 != 0x00)
80003094:	fe b0 fd d4 	rcall	80002c3c <sd_mmc_spi_command>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80003098:	aa 8c       	st.b	r5[0x0],r12
8000309a:	58 0c       	cp.w	r12,0
8000309c:	c4 21       	brne	80003120 <sd_mmc_spi_write_sector_from_ram+0xc0>
8000309e:	e0 6b 00 ff 	mov	r11,255
800030a2:	fe 7c 28 00 	mov	r12,-55296

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800030a6:	fe b0 fa ca 	rcall	8000263a <spi_write>
800030aa:	e0 6b 00 fe 	mov	r11,254
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
800030ae:	fe 7c 28 00 	mov	r12,-55296
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800030b2:	ee c6 fe 00 	sub	r6,r7,-512
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800030b6:	fe b0 fa c2 	rcall	8000263a <spi_write>
800030ba:	0f 3b       	ld.ub	r11,r7++
800030bc:	fe 7c 28 00 	mov	r12,-55296
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800030c0:	fe b0 fa bd 	rcall	8000263a <spi_write>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
800030c4:	0c 37       	cp.w	r7,r6
800030c6:	cf a1       	brne	800030ba <sd_mmc_spi_write_sector_from_ram+0x5a>
800030c8:	e0 6b 00 ff 	mov	r11,255
800030cc:	fe 7c 28 00 	mov	r12,-55296
  spi_write(SD_MMC_SPI,0xFF);
800030d0:	fe b0 fa b5 	rcall	8000263a <spi_write>
800030d4:	e0 6b 00 ff 	mov	r11,255
800030d8:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800030dc:	fe b0 fa af 	rcall	8000263a <spi_write>
800030e0:	e0 6b 00 ff 	mov	r11,255
800030e4:	fe 7c 28 00 	mov	r12,-55296
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800030e8:	fe b0 fa a9 	rcall	8000263a <spi_write>
800030ec:	fa cb ff fe 	sub	r11,sp,-2
800030f0:	fe 7c 28 00 	mov	r12,-55296
800030f4:	fe b0 fa b1 	rcall	80002656 <spi_read>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
800030f8:	58 1c       	cp.w	r12,1
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
800030fa:	c5 80       	breq	800031aa <sd_mmc_spi_write_sector_from_ram+0x14a>
800030fc:	1b b8       	ld.ub	r8,sp[0x3]
800030fe:	aa 88       	st.b	r5[0x0],r8
80003100:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80003104:	58 58       	cp.w	r8,5
80003106:	c1 f0       	breq	80003144 <sd_mmc_spi_write_sector_from_ram+0xe4>
80003108:	e0 6b 00 ff 	mov	r11,255
8000310c:	fe 7c 28 00 	mov	r12,-55296
    spi_write(SD_MMC_SPI,0xFF);
80003110:	fe b0 fa 95 	rcall	8000263a <spi_write>
80003114:	e0 6b 00 ff 	mov	r11,255
80003118:	fe 7c 28 00 	mov	r12,-55296
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000311c:	fe b0 fa 8f 	rcall	8000263a <spi_write>
80003120:	30 2b       	mov	r11,2
80003122:	fe 7c 28 00 	mov	r12,-55296
80003126:	fe b0 fa 1d 	rcall	80002560 <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
8000312a:	2f fd       	sub	sp,-4
8000312c:	d8 2a       	popm	r4-r7,pc,r12=0
8000312e:	e0 64 06 6c 	mov	r4,1644
80003132:	31 8c       	mov	r12,24
80003134:	68 0b       	ld.w	r11,r4[0x0]
80003136:	e0 65 28 bc 	mov	r5,10428
    spi_write(SD_MMC_SPI,0xFF);
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000313a:	a9 9b       	lsr	r11,0x9
8000313c:	fe b0 fd 80 	rcall	80002c3c <sd_mmc_spi_command>
80003140:	aa 8c       	st.b	r5[0x0],r12
80003142:	ca cb       	rjmp	8000309a <sd_mmc_spi_write_sector_from_ram+0x3a>
80003144:	e0 6b 00 ff 	mov	r11,255
  spi_write(SD_MMC_SPI,0xFF);
80003148:	fe 7c 28 00 	mov	r12,-55296
8000314c:	fe b0 fa 77 	rcall	8000263a <spi_write>
80003150:	e0 6b 00 ff 	mov	r11,255

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003154:	fe 7c 28 00 	mov	r12,-55296
80003158:	fe b0 fa 71 	rcall	8000263a <spi_write>
  gl_ptr_mem += 512;        // Update the memory pointer.
8000315c:	30 2b       	mov	r11,2
8000315e:	fe 7c 28 00 	mov	r12,-55296
80003162:	fe b0 f9 ff 	rcall	80002560 <spi_unselectChip>

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80003166:	68 08       	ld.w	r8,r4[0x0]
80003168:	f0 c8 fe 00 	sub	r8,r8,-512
8000316c:	89 08       	st.w	r4[0x0],r8
8000316e:	fe b0 fd 2b 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80003172:	c1 f1       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
80003174:	fe b0 fd 28 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80003178:	c1 c1       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
8000317a:	fe b0 fd 25 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
8000317e:	c1 91       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
80003180:	fe b0 fd 22 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80003184:	c1 61       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
80003186:	fe b0 fd 1f 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
8000318a:	c1 31       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
8000318c:	fe b0 fd 1c 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80003190:	c1 01       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
80003192:	fe b0 fd 19 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
80003196:	c0 d1       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
80003198:	fe b0 fd 16 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
8000319c:	c0 a1       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
8000319e:	fe b0 fd 13 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
800031a2:	c0 71       	brne	800031b0 <sd_mmc_spi_write_sector_from_ram+0x150>
800031a4:	fe b0 fd 10 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800031a8:	c6 2b       	rjmp	8000306c <sd_mmc_spi_write_sector_from_ram+0xc>
800031aa:	3f f8       	mov	r8,-1
800031ac:	aa 88       	st.b	r5[0x0],r8
800031ae:	ca db       	rjmp	80003108 <sd_mmc_spi_write_sector_from_ram+0xa8>
800031b0:	30 1c       	mov	r12,1
800031b2:	c5 db       	rjmp	8000306c <sd_mmc_spi_write_sector_from_ram+0xc>

800031b4 <sd_mmc_spi_get_if>:
800031b4:	eb cd 40 e0 	pushm	r5-r7,lr
800031b8:	20 1d       	sub	sp,4
800031ba:	fe b0 fd 05 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
800031be:	c0 51       	brne	800031c8 <sd_mmc_spi_get_if+0x14>
800031c0:	3f fc       	mov	r12,-1
800031c2:	2f fd       	sub	sp,-4
800031c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800031c8:	30 2b       	mov	r11,2
800031ca:	fe 7c 28 00 	mov	r12,-55296
800031ce:	fe b0 f9 a1 	rcall	80002510 <spi_selectChip>
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
800031d2:	e0 6b 01 aa 	mov	r11,426
800031d6:	e0 67 28 bc 	mov	r7,10428
800031da:	30 8c       	mov	r12,8
800031dc:	fe b0 fd 30 	rcall	80002c3c <sd_mmc_spi_command>
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
800031e0:	ae 8c       	st.b	r7[0x0],r12
800031e2:	ed bc 00 02 	bld	r12,0x2
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800031e6:	c5 00       	breq	80003286 <sd_mmc_spi_get_if+0xd2>
800031e8:	e0 6b 00 ff 	mov	r11,255
800031ec:	fe 7c 28 00 	mov	r12,-55296
800031f0:	fe b0 fa 25 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800031f4:	fa c6 ff fe 	sub	r6,sp,-2
800031f8:	fe 7c 28 00 	mov	r12,-55296
800031fc:	0c 9b       	mov	r11,r6
800031fe:	fe b0 fa 2c 	rcall	80002656 <spi_read>
80003202:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
80003204:	c4 90       	breq	80003296 <sd_mmc_spi_get_if+0xe2>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003206:	1b b8       	ld.ub	r8,sp[0x3]
80003208:	e0 6b 00 ff 	mov	r11,255
8000320c:	ae 88       	st.b	r7[0x0],r8
8000320e:	fe 7c 28 00 	mov	r12,-55296
80003212:	fe b0 fa 14 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003216:	0c 9b       	mov	r11,r6
80003218:	fe 7c 28 00 	mov	r12,-55296
8000321c:	fe b0 fa 1d 	rcall	80002656 <spi_read>
80003220:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
80003222:	c4 00       	breq	800032a2 <sd_mmc_spi_get_if+0xee>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003224:	1b b8       	ld.ub	r8,sp[0x3]
80003226:	e0 6b 00 ff 	mov	r11,255
8000322a:	ae 88       	st.b	r7[0x0],r8
8000322c:	fe 7c 28 00 	mov	r12,-55296
80003230:	fe b0 fa 05 	rcall	8000263a <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003234:	0c 9b       	mov	r11,r6
80003236:	fe 7c 28 00 	mov	r12,-55296
8000323a:	e0 65 28 bc 	mov	r5,10428
8000323e:	fe b0 fa 0c 	rcall	80002656 <spi_read>
     return 0xFF;
   return data_read;
80003242:	58 1c       	cp.w	r12,1
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003244:	c2 c0       	breq	8000329c <sd_mmc_spi_get_if+0xe8>
  if((r1 & 0x01) == 0) {
80003246:	1b b8       	ld.ub	r8,sp[0x3]
80003248:	aa 88       	st.b	r5[0x0],r8
8000324a:	ed b8 00 00 	bld	r8,0x0
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000324e:	c3 61       	brne	800032ba <sd_mmc_spi_get_if+0x106>
80003250:	e0 6b 00 ff 	mov	r11,255
80003254:	fe 7c 28 00 	mov	r12,-55296
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003258:	fe b0 f9 f1 	rcall	8000263a <spi_write>
8000325c:	0c 9b       	mov	r11,r6
8000325e:	fe 7c 28 00 	mov	r12,-55296
80003262:	fe b0 f9 fa 	rcall	80002656 <spi_read>
     return 0xFF;
   return data_read;
80003266:	58 1c       	cp.w	r12,1
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003268:	c2 00       	breq	800032a8 <sd_mmc_spi_get_if+0xf4>
  if(r1 != 0xaa) {
8000326a:	1b b8       	ld.ub	r8,sp[0x3]
8000326c:	ae 88       	st.b	r7[0x0],r8
8000326e:	3a a9       	mov	r9,-86
80003270:	f2 08 18 00 	cp.b	r8,r9
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003274:	c1 c1       	brne	800032ac <sd_mmc_spi_get_if+0xf8>
80003276:	30 2b       	mov	r11,2
80003278:	fe 7c 28 00 	mov	r12,-55296
8000327c:	fe b0 f9 72 	rcall	80002560 <spi_unselectChip>
80003280:	2f fd       	sub	sp,-4

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003282:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003286:	30 2b       	mov	r11,2
80003288:	fe 7c 28 00 	mov	r12,-55296
8000328c:	fe b0 f9 6a 	rcall	80002560 <spi_unselectChip>
80003290:	2f fd       	sub	sp,-4
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003292:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003296:	e0 68 00 ff 	mov	r8,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000329a:	cb 7b       	rjmp	80003208 <sd_mmc_spi_get_if+0x54>
8000329c:	3f f8       	mov	r8,-1
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000329e:	aa 88       	st.b	r5[0x0],r8
800032a0:	cd 8b       	rjmp	80003250 <sd_mmc_spi_get_if+0x9c>
800032a2:	e0 68 00 ff 	mov	r8,255
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800032a6:	cc 0b       	rjmp	80003226 <sd_mmc_spi_get_if+0x72>
  if(r1 != 0xaa) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032a8:	3f f8       	mov	r8,-1
800032aa:	ae 88       	st.b	r7[0x0],r8
800032ac:	30 2b       	mov	r11,2
800032ae:	fe 7c 28 00 	mov	r12,-55296
800032b2:	fe b0 f9 57 	rcall	80002560 <spi_unselectChip>
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032b6:	3f fc       	mov	r12,-1
800032b8:	c8 5b       	rjmp	800031c2 <sd_mmc_spi_get_if+0xe>
800032ba:	30 2b       	mov	r11,2
800032bc:	fe 7c 28 00 	mov	r12,-55296
800032c0:	fe b0 f9 50 	rcall	80002560 <spi_unselectChip>
800032c4:	c7 eb       	rjmp	800031c0 <sd_mmc_spi_get_if+0xc>
800032c6:	d7 03       	nop

800032c8 <sd_mmc_spi_internal_init>:
800032c8:	d4 31       	pushm	r0-r7,lr
800032ca:	20 1d       	sub	sp,4
800032cc:	e6 68 1a 80 	mov	r8,400000
800032d0:	e0 69 06 80 	mov	r9,1664
800032d4:	e0 67 06 70 	mov	r7,1648
800032d8:	72 0a       	ld.w	r10,r9[0x0]
800032da:	8f 18       	st.w	r7[0x4],r8
800032dc:	0e 9b       	mov	r11,r7
800032de:	fe 7c 28 00 	mov	r12,-55296
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800032e2:	fe b0 f9 53 	rcall	80002588 <spi_setupChipReg>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800032e6:	30 2b       	mov	r11,2
800032e8:	fe 7c 28 00 	mov	r12,-55296
800032ec:	fe b0 f9 12 	rcall	80002510 <spi_selectChip>
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
800032f0:	e0 6b 00 ff 	mov	r11,255
800032f4:	fe 7c 28 00 	mov	r12,-55296
800032f8:	fe b0 f9 a1 	rcall	8000263a <spi_write>
800032fc:	e0 6b 00 ff 	mov	r11,255
80003300:	fe 7c 28 00 	mov	r12,-55296
80003304:	fe b0 f9 9b 	rcall	8000263a <spi_write>
80003308:	e0 6b 00 ff 	mov	r11,255
8000330c:	fe 7c 28 00 	mov	r12,-55296
80003310:	fe b0 f9 95 	rcall	8000263a <spi_write>
80003314:	e0 6b 00 ff 	mov	r11,255
80003318:	fe 7c 28 00 	mov	r12,-55296
8000331c:	fe b0 f9 8f 	rcall	8000263a <spi_write>
80003320:	e0 6b 00 ff 	mov	r11,255
80003324:	fe 7c 28 00 	mov	r12,-55296
80003328:	fe b0 f9 89 	rcall	8000263a <spi_write>
8000332c:	e0 6b 00 ff 	mov	r11,255
80003330:	fe 7c 28 00 	mov	r12,-55296
80003334:	fe b0 f9 83 	rcall	8000263a <spi_write>
80003338:	e0 6b 00 ff 	mov	r11,255
8000333c:	fe 7c 28 00 	mov	r12,-55296
80003340:	fe b0 f9 7d 	rcall	8000263a <spi_write>
80003344:	e0 6b 00 ff 	mov	r11,255
80003348:	fe 7c 28 00 	mov	r12,-55296
8000334c:	fe b0 f9 77 	rcall	8000263a <spi_write>
80003350:	e0 6b 00 ff 	mov	r11,255
80003354:	fe 7c 28 00 	mov	r12,-55296
80003358:	fe b0 f9 71 	rcall	8000263a <spi_write>
8000335c:	e0 6b 00 ff 	mov	r11,255
80003360:	fe 7c 28 00 	mov	r12,-55296
80003364:	fe b0 f9 6b 	rcall	8000263a <spi_write>
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003368:	30 2b       	mov	r11,2
8000336a:	fe 7c 28 00 	mov	r12,-55296
8000336e:	fe b0 f8 f9 	rcall	80002560 <spi_unselectChip>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80003372:	30 08       	mov	r8,0
80003374:	e0 69 06 84 	mov	r9,1668
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003378:	30 2b       	mov	r11,2
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000337a:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
8000337c:	e0 61 28 aa 	mov	r1,10410
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003380:	fe 7c 28 00 	mov	r12,-55296
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
  card_type = MMC_CARD;
80003384:	a2 88       	st.b	r1[0x0],r8
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003386:	fe b0 f8 c5 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8000338a:	30 0b       	mov	r11,0
8000338c:	16 9c       	mov	r12,r11
8000338e:	fe b0 fc 57 	rcall	80002c3c <sd_mmc_spi_command>
80003392:	e0 66 28 bc 	mov	r6,10428
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003396:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003398:	ac 8c       	st.b	r6[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000339a:	fe 7c 28 00 	mov	r12,-55296
8000339e:	fe b0 f8 e1 	rcall	80002560 <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033a2:	e0 6b 00 ff 	mov	r11,255
800033a6:	fe 7c 28 00 	mov	r12,-55296
800033aa:	30 05       	mov	r5,0
800033ac:	fe b0 f9 47 	rcall	8000263a <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800033b0:	0c 90       	mov	r0,r6
800033b2:	30 12       	mov	r2,1
800033b4:	c1 78       	rjmp	800033e2 <sd_mmc_spi_internal_init+0x11a>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800033b6:	fe b0 f8 ad 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800033ba:	30 0b       	mov	r11,0
800033bc:	16 9c       	mov	r12,r11
800033be:	fe b0 fc 3f 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033c2:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800033c4:	a0 8c       	st.b	r0[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033c6:	fe 7c 28 00 	mov	r12,-55296
800033ca:	fe b0 f8 cb 	rcall	80002560 <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033ce:	e0 6b 00 ff 	mov	r11,255
800033d2:	fe 7c 28 00 	mov	r12,-55296
800033d6:	fe b0 f9 32 	rcall	8000263a <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
800033da:	e0 45 00 64 	cp.w	r5,100
800033de:	e0 80 00 b4 	breq	80003546 <sd_mmc_spi_internal_init+0x27e>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800033e2:	30 2b       	mov	r11,2
800033e4:	fe 7c 28 00 	mov	r12,-55296
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800033e8:	2f f5       	sub	r5,-1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800033ea:	0d 84       	ld.ub	r4,r6[0x0]
800033ec:	e0 63 28 bc 	mov	r3,10428
800033f0:	e4 04 18 00 	cp.b	r4,r2
800033f4:	ce 11       	brne	800033b6 <sd_mmc_spi_internal_init+0xee>

  if_cond = sd_mmc_spi_get_if();
800033f6:	cd fe       	rcall	800031b4 <sd_mmc_spi_get_if>
800033f8:	5b fc       	cp.w	r12,-1
  if(if_cond == -1) {
800033fa:	e0 80 00 a6 	breq	80003546 <sd_mmc_spi_internal_init+0x27e>
800033fe:	58 1c       	cp.w	r12,1
      return false; // card is bad
  } else if (if_cond == 1) {
80003400:	e0 80 00 a6 	breq	8000354c <sd_mmc_spi_internal_init+0x284>
80003404:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003406:	fe 7c 28 00 	mov	r12,-55296
8000340a:	fe b0 f8 83 	rcall	80002510 <spi_selectChip>
8000340e:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80003410:	33 7c       	mov	r12,55
80003412:	fe b0 fc 15 	rcall	80002c3c <sd_mmc_spi_command>
80003416:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003418:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000341a:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000341e:	fe b0 f8 a1 	rcall	80002560 <spi_unselectChip>
80003422:	e0 6b 00 ff 	mov	r11,255
      card_type = SD_CARD_2;
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003426:	fe 7c 28 00 	mov	r12,-55296
8000342a:	fe b0 f9 08 	rcall	8000263a <spi_write>
8000342e:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003430:	fe 7c 28 00 	mov	r12,-55296
80003434:	fe b0 f8 6e 	rcall	80002510 <spi_selectChip>
80003438:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000343a:	32 9c       	mov	r12,41
8000343c:	fe b0 fc 00 	rcall	80002c3c <sd_mmc_spi_command>
80003440:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003442:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003444:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003448:	fe b0 f8 8c 	rcall	80002560 <spi_unselectChip>
8000344c:	e0 6b 00 ff 	mov	r11,255
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003450:	fe 7c 28 00 	mov	r12,-55296
80003454:	fe b0 f8 f3 	rcall	8000263a <spi_write>
80003458:	07 88       	ld.ub	r8,r3[0x0]

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
8000345a:	e2 18 00 fe 	andl	r8,0xfe,COH
8000345e:	e0 80 00 d3 	breq	80003604 <sd_mmc_spi_internal_init+0x33c>
80003462:	30 08       	mov	r8,0
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80003464:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003466:	a2 88       	st.b	r1[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80003468:	fe 7c 28 00 	mov	r12,-55296
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000346c:	fe b0 f8 52 	rcall	80002510 <spi_selectChip>
80003470:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80003472:	16 9c       	mov	r12,r11
80003474:	fe b0 fb e4 	rcall	80002c3c <sd_mmc_spi_command>
80003478:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000347a:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000347c:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003480:	fe b0 f8 70 	rcall	80002560 <spi_unselectChip>
80003484:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003488:	fe 7c 28 00 	mov	r12,-55296
8000348c:	30 05       	mov	r5,0
8000348e:	fe b0 f8 d6 	rcall	8000263a <spi_write>
80003492:	30 14       	mov	r4,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80003494:	c1 68       	rjmp	800034c0 <sd_mmc_spi_internal_init+0x1f8>
80003496:	fe b0 f8 3d 	rcall	80002510 <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000349a:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
8000349c:	16 9c       	mov	r12,r11
8000349e:	fe b0 fb cf 	rcall	80002c3c <sd_mmc_spi_command>
800034a2:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800034a4:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800034a6:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800034aa:	fe b0 f8 5b 	rcall	80002560 <spi_unselectChip>
800034ae:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034b2:	fe 7c 28 00 	mov	r12,-55296
800034b6:	fe b0 f8 c2 	rcall	8000263a <spi_write>
800034ba:	e0 45 00 64 	cp.w	r5,100
        // do retry counter
        retry++;
        if(retry > 100)
800034be:	c4 40       	breq	80003546 <sd_mmc_spi_internal_init+0x27e>
800034c0:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800034c2:	fe 7c 28 00 	mov	r12,-55296
800034c6:	2f f5       	sub	r5,-1
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034c8:	0d 88       	ld.ub	r8,r6[0x0]
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800034ca:	e8 08 18 00 	cp.b	r8,r4
800034ce:	ce 41       	brne	80003496 <sd_mmc_spi_internal_init+0x1ce>
800034d0:	03 88       	ld.ub	r8,r1[0x0]
800034d2:	c4 08       	rjmp	80003552 <sd_mmc_spi_internal_init+0x28a>
800034d4:	03 89       	ld.ub	r9,r1[0x0]
     if(retry == 50000)    // measured approx. 500 on several cards
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
800034d6:	30 28       	mov	r8,2
800034d8:	f0 09 18 00 	cp.b	r9,r8
800034dc:	e0 80 01 77 	breq	800037ca <sd_mmc_spi_internal_init+0x502>
800034e0:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800034e2:	fe 7c 28 00 	mov	r12,-55296
800034e6:	fe b0 f8 15 	rcall	80002510 <spi_selectChip>
800034ea:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
800034ec:	33 bc       	mov	r12,59
800034ee:	fe b0 fb a7 	rcall	80002c3c <sd_mmc_spi_command>
800034f2:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800034f4:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800034f6:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800034fa:	fe b0 f8 33 	rcall	80002560 <spi_unselectChip>
800034fe:	e0 6b 00 ff 	mov	r11,255
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003502:	fe 7c 28 00 	mov	r12,-55296
80003506:	fe b0 f8 9a 	rcall	8000263a <spi_write>
8000350a:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000350c:	fe 7c 28 00 	mov	r12,-55296
80003510:	fe b0 f8 00 	rcall	80002510 <spi_selectChip>
80003514:	e0 6b 02 00 	mov	r11,512
  r1 = sd_mmc_spi_command(command, arg);
80003518:	31 0c       	mov	r12,16
8000351a:	fe b0 fb 91 	rcall	80002c3c <sd_mmc_spi_command>
8000351e:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003520:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003522:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003526:	fe b0 f8 1d 	rcall	80002560 <spi_unselectChip>
8000352a:	e0 6b 00 ff 	mov	r11,255
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000352e:	fe 7c 28 00 	mov	r12,-55296
80003532:	e0 64 28 bc 	mov	r4,10428
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003536:	fe b0 f8 82 	rcall	8000263a <spi_write>
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000353a:	0d 85       	ld.ub	r5,r6[0x0]
  if (r1 != 0x00)
8000353c:	58 05       	cp.w	r5,0
8000353e:	c0 41       	brne	80003546 <sd_mmc_spi_internal_init+0x27e>
80003540:	fe b0 fb 42 	rcall	80002bc4 <sd_mmc_spi_wait_not_busy>
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80003544:	c6 31       	brne	8000360a <sd_mmc_spi_internal_init+0x342>
80003546:	30 0c       	mov	r12,0
  sd_mmc_spi_init_done = true;

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
  return true;
80003548:	2f fd       	sub	sp,-4
}
8000354a:	d8 32       	popm	r0-r7,pc
8000354c:	30 28       	mov	r8,2

  if_cond = sd_mmc_spi_get_if();
  if(if_cond == -1) {
      return false; // card is bad
  } else if (if_cond == 1) {
      card_type = SD_CARD_2;
8000354e:	a2 88       	st.b	r1[0x0],r8
80003550:	30 28       	mov	r8,2
80003552:	30 05       	mov	r5,0
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80003554:	30 14       	mov	r4,1

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003556:	30 23       	mov	r3,2
80003558:	c1 d8       	rjmp	80003592 <sd_mmc_spi_internal_init+0x2ca>
8000355a:	fe b0 f7 db 	rcall	80002510 <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000355e:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80003560:	30 1c       	mov	r12,1
80003562:	fe b0 fb 6d 	rcall	80002c3c <sd_mmc_spi_command>
80003566:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003568:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8000356a:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000356e:	fe b0 f7 f9 	rcall	80002560 <spi_unselectChip>
80003572:	e0 6b 00 ff 	mov	r11,255
      break;
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003576:	fe 7c 28 00 	mov	r12,-55296
8000357a:	fe b0 f8 60 	rcall	8000263a <spi_write>
8000357e:	e0 45 c3 4f 	cp.w	r5,49999
      break;
    }
     // do retry counter
     retry++;
     if(retry == 50000)    // measured approx. 500 on several cards
80003582:	ce 20       	breq	80003546 <sd_mmc_spi_internal_init+0x27e>
80003584:	2f f5       	sub	r5,-1
80003586:	0d 89       	ld.ub	r9,r6[0x0]
        return false;
  } while (r1);
80003588:	30 08       	mov	r8,0
8000358a:	f0 09 18 00 	cp.b	r9,r8
8000358e:	ca 30       	breq	800034d4 <sd_mmc_spi_internal_init+0x20c>
80003590:	03 88       	ld.ub	r8,r1[0x0]
80003592:	e8 08 18 00 	cp.b	r8,r4

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80003596:	c2 00       	breq	800035d6 <sd_mmc_spi_internal_init+0x30e>
80003598:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000359a:	fe 7c 28 00 	mov	r12,-55296
8000359e:	cd e3       	brcs	8000355a <sd_mmc_spi_internal_init+0x292>

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800035a0:	e6 08 18 00 	cp.b	r8,r3
800035a4:	ce d1       	brne	8000357e <sd_mmc_spi_internal_init+0x2b6>
800035a6:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800035a8:	fe 7c 28 00 	mov	r12,-55296
800035ac:	fe b0 f7 b2 	rcall	80002510 <spi_selectChip>
800035b0:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
800035b2:	33 7c       	mov	r12,55
800035b4:	fe b0 fb 44 	rcall	80002c3c <sd_mmc_spi_command>
800035b8:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035ba:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800035bc:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035c0:	fe b0 f7 d0 	rcall	80002560 <spi_unselectChip>
800035c4:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800035c6:	fe 7c 28 00 	mov	r12,-55296
800035ca:	fe b0 f7 a3 	rcall	80002510 <spi_selectChip>
800035ce:	fc 1b 40 00 	movh	r11,0x4000
  r1 = sd_mmc_spi_command(command, arg);
800035d2:	32 9c       	mov	r12,41
800035d4:	cc 7b       	rjmp	80003562 <sd_mmc_spi_internal_init+0x29a>
800035d6:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800035d8:	fe 7c 28 00 	mov	r12,-55296
800035dc:	fe b0 f7 9a 	rcall	80002510 <spi_selectChip>
800035e0:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
800035e2:	33 7c       	mov	r12,55
800035e4:	fe b0 fb 2c 	rcall	80002c3c <sd_mmc_spi_command>
800035e8:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035ea:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800035ec:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800035f0:	fe b0 f7 b8 	rcall	80002560 <spi_unselectChip>
800035f4:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800035f6:	fe 7c 28 00 	mov	r12,-55296
800035fa:	fe b0 f7 8b 	rcall	80002510 <spi_selectChip>
800035fe:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80003600:	32 9c       	mov	r12,41
80003602:	cb 0b       	rjmp	80003562 <sd_mmc_spi_internal_init+0x29a>
80003604:	a2 84       	st.b	r1[0x0],r4

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
80003606:	30 18       	mov	r8,1
80003608:	ca 5b       	rjmp	80003552 <sd_mmc_spi_internal_init+0x28a>
8000360a:	30 2b       	mov	r11,2
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000360c:	fe 7c 28 00 	mov	r12,-55296
80003610:	fe b0 f7 80 	rcall	80002510 <spi_selectChip>
80003614:	30 0b       	mov	r11,0
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80003616:	30 9c       	mov	r12,9
80003618:	fe b0 fb 12 	rcall	80002c3c <sd_mmc_spi_command>
8000361c:	a8 8c       	st.b	r4[0x0],r12
8000361e:	e0 81 01 f1 	brne	80003a00 <sd_mmc_spi_internal_init+0x738>
  // check for valid response
  if(r1 != 0x00)
80003622:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003626:	fe 7c 28 00 	mov	r12,-55296
8000362a:	fe b0 f8 08 	rcall	8000263a <spi_write>
8000362e:	1a 95       	mov	r5,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003630:	fe 7c 28 00 	mov	r12,-55296
80003634:	1a 9b       	mov	r11,sp
80003636:	fe b0 f8 10 	rcall	80002656 <spi_read>
8000363a:	58 1c       	cp.w	r12,1
8000363c:	e0 80 01 ed 	breq	80003a16 <sd_mmc_spi_internal_init+0x74e>
80003640:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80003642:	a8 88       	st.b	r4[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003644:	3f e9       	mov	r9,-2
80003646:	f2 08 18 00 	cp.b	r8,r9
8000364a:	e0 80 00 d1 	breq	800037ec <sd_mmc_spi_internal_init+0x524>
8000364e:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003652:	fe 7c 28 00 	mov	r12,-55296
80003656:	fe b0 f7 f2 	rcall	8000263a <spi_write>
8000365a:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000365c:	fe 7c 28 00 	mov	r12,-55296
80003660:	fe b0 f7 fb 	rcall	80002656 <spi_read>
80003664:	58 1c       	cp.w	r12,1
80003666:	e0 80 00 c0 	breq	800037e6 <sd_mmc_spi_internal_init+0x51e>
8000366a:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000366c:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000366e:	3f e9       	mov	r9,-2
80003670:	f2 08 18 00 	cp.b	r8,r9
80003674:	e0 80 00 bc 	breq	800037ec <sd_mmc_spi_internal_init+0x524>
80003678:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000367c:	fe 7c 28 00 	mov	r12,-55296
80003680:	fe b0 f7 dd 	rcall	8000263a <spi_write>
80003684:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003686:	fe 7c 28 00 	mov	r12,-55296
8000368a:	fe b0 f7 e6 	rcall	80002656 <spi_read>
8000368e:	58 1c       	cp.w	r12,1
80003690:	e0 80 01 cb 	breq	80003a26 <sd_mmc_spi_internal_init+0x75e>
80003694:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80003696:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003698:	3f e9       	mov	r9,-2
8000369a:	f2 08 18 00 	cp.b	r8,r9
8000369e:	e0 80 00 a7 	breq	800037ec <sd_mmc_spi_internal_init+0x524>
800036a2:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800036a6:	fe 7c 28 00 	mov	r12,-55296
800036aa:	fe b0 f7 c8 	rcall	8000263a <spi_write>
800036ae:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800036b0:	fe 7c 28 00 	mov	r12,-55296
800036b4:	fe b0 f7 d1 	rcall	80002656 <spi_read>
800036b8:	58 1c       	cp.w	r12,1
800036ba:	e0 80 01 b2 	breq	80003a1e <sd_mmc_spi_internal_init+0x756>
800036be:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
800036c0:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800036c2:	3f e9       	mov	r9,-2
800036c4:	f2 08 18 00 	cp.b	r8,r9
800036c8:	e0 80 00 92 	breq	800037ec <sd_mmc_spi_internal_init+0x524>
800036cc:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800036d0:	fe 7c 28 00 	mov	r12,-55296
800036d4:	fe b0 f7 b3 	rcall	8000263a <spi_write>
800036d8:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800036da:	fe 7c 28 00 	mov	r12,-55296
800036de:	fe b0 f7 bc 	rcall	80002656 <spi_read>
800036e2:	58 1c       	cp.w	r12,1
800036e4:	e0 80 01 a9 	breq	80003a36 <sd_mmc_spi_internal_init+0x76e>
800036e8:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
800036ea:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800036ec:	3f e9       	mov	r9,-2
800036ee:	f2 08 18 00 	cp.b	r8,r9
800036f2:	c7 d0       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
800036f4:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800036f8:	fe 7c 28 00 	mov	r12,-55296
800036fc:	fe b0 f7 9f 	rcall	8000263a <spi_write>
80003700:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003702:	fe 7c 28 00 	mov	r12,-55296
80003706:	fe b0 f7 a8 	rcall	80002656 <spi_read>
8000370a:	58 1c       	cp.w	r12,1
8000370c:	e0 80 01 91 	breq	80003a2e <sd_mmc_spi_internal_init+0x766>
80003710:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80003712:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003714:	3f e9       	mov	r9,-2
80003716:	f2 08 18 00 	cp.b	r8,r9
8000371a:	c6 90       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
8000371c:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003720:	fe 7c 28 00 	mov	r12,-55296
80003724:	fe b0 f7 8b 	rcall	8000263a <spi_write>
80003728:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000372a:	fe 7c 28 00 	mov	r12,-55296
8000372e:	fe b0 f7 94 	rcall	80002656 <spi_read>
80003732:	58 1c       	cp.w	r12,1
80003734:	e0 80 01 85 	breq	80003a3e <sd_mmc_spi_internal_init+0x776>
80003738:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000373a:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000373c:	3f e9       	mov	r9,-2
8000373e:	f2 08 18 00 	cp.b	r8,r9
80003742:	c5 50       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
80003744:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003748:	fe 7c 28 00 	mov	r12,-55296
8000374c:	fe b0 f7 77 	rcall	8000263a <spi_write>
80003750:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80003752:	fe 7c 28 00 	mov	r12,-55296
80003756:	fe b0 f7 80 	rcall	80002656 <spi_read>
8000375a:	58 1c       	cp.w	r12,1
8000375c:	e0 80 01 75 	breq	80003a46 <sd_mmc_spi_internal_init+0x77e>
80003760:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80003762:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003764:	3f e9       	mov	r9,-2
80003766:	f2 08 18 00 	cp.b	r8,r9
8000376a:	c4 10       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
8000376c:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003770:	fe 7c 28 00 	mov	r12,-55296
80003774:	fe b0 f7 63 	rcall	8000263a <spi_write>
80003778:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8000377a:	fe 7c 28 00 	mov	r12,-55296
8000377e:	fe b0 f7 6c 	rcall	80002656 <spi_read>
80003782:	58 1c       	cp.w	r12,1
80003784:	e0 80 01 68 	breq	80003a54 <sd_mmc_spi_internal_init+0x78c>
80003788:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
8000378a:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000378c:	3f e9       	mov	r9,-2
8000378e:	f2 08 18 00 	cp.b	r8,r9
80003792:	c2 d0       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
80003794:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80003798:	fe 7c 28 00 	mov	r12,-55296
8000379c:	fe b0 f7 4f 	rcall	8000263a <spi_write>
800037a0:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800037a2:	fe 7c 28 00 	mov	r12,-55296
800037a6:	fe b0 f7 58 	rcall	80002656 <spi_read>
800037aa:	58 1c       	cp.w	r12,1
800037ac:	e0 80 01 51 	breq	80003a4e <sd_mmc_spi_internal_init+0x786>
800037b0:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
800037b2:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800037b4:	3f e9       	mov	r9,-2
800037b6:	f2 08 18 00 	cp.b	r8,r9
800037ba:	c1 90       	breq	800037ec <sd_mmc_spi_internal_init+0x524>
800037bc:	30 2b       	mov	r11,2
  {
    if (retry > 8)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800037be:	fe 7c 28 00 	mov	r12,-55296
800037c2:	fe b0 f6 cf 	rcall	80002560 <spi_unselectChip>
800037c6:	30 0c       	mov	r12,0
800037c8:	cc 0a       	rjmp	80003548 <sd_mmc_spi_internal_init+0x280>
800037ca:	fe b0 fb db 	rcall	80002f80 <sd_mmc_spi_check_hc>
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
    if_cond = sd_mmc_spi_check_hc();
800037ce:	5b fc       	cp.w	r12,-1
    if (if_cond == -1) {
800037d0:	fe 90 fe bb 	breq	80003546 <sd_mmc_spi_internal_init+0x27e>
800037d4:	58 1c       	cp.w	r12,1
      return false;
    } else if (if_cond == 1){
800037d6:	fe 91 fe 85 	brne	800034e0 <sd_mmc_spi_internal_init+0x218>
800037da:	30 39       	mov	r9,3
          card_type = SD_CARD_2_SDHC;
800037dc:	e0 68 28 aa 	mov	r8,10410
800037e0:	b0 89       	st.b	r8[0x0],r9
800037e2:	fe 9f fe 7f 	bral	800034e0 <sd_mmc_spi_internal_init+0x218>
800037e6:	3f f8       	mov	r8,-1
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800037e8:	ac 88       	st.b	r6[0x0],r8
800037ea:	c4 7b       	rjmp	80003678 <sd_mmc_spi_internal_init+0x3b0>
800037ec:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800037f0:	fe 7c 28 00 	mov	r12,-55296
800037f4:	fe b0 f7 23 	rcall	8000263a <spi_write>
800037f8:	fa c5 ff fe 	sub	r5,sp,-2
   spi_read(SD_MMC_SPI,&data_read);
800037fc:	fe 7c 28 00 	mov	r12,-55296
80003800:	0a 9b       	mov	r11,r5
80003802:	fe b0 f7 2a 	rcall	80002656 <spi_read>
80003806:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003808:	e0 66 28 ac 	mov	r6,10412
8000380c:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003810:	ac 88       	st.b	r6[0x0],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003812:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003816:	fe b0 f7 12 	rcall	8000263a <spi_write>
8000381a:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000381c:	fe 7c 28 00 	mov	r12,-55296
80003820:	fe b0 f7 1b 	rcall	80002656 <spi_read>
80003824:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003826:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000382a:	ac 98       	st.b	r6[0x1],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000382c:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003830:	fe b0 f7 05 	rcall	8000263a <spi_write>
80003834:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003836:	fe 7c 28 00 	mov	r12,-55296
8000383a:	fe b0 f7 0e 	rcall	80002656 <spi_read>
8000383e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003840:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003844:	ac a8       	st.b	r6[0x2],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003846:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000384a:	fe b0 f6 f8 	rcall	8000263a <spi_write>
8000384e:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003850:	fe 7c 28 00 	mov	r12,-55296
80003854:	fe b0 f7 01 	rcall	80002656 <spi_read>
80003858:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000385a:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000385e:	ac b8       	st.b	r6[0x3],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003860:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003864:	fe b0 f6 eb 	rcall	8000263a <spi_write>
80003868:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000386a:	fe 7c 28 00 	mov	r12,-55296
8000386e:	fe b0 f6 f4 	rcall	80002656 <spi_read>
80003872:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003874:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003878:	ac c8       	st.b	r6[0x4],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000387a:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000387e:	fe b0 f6 de 	rcall	8000263a <spi_write>
80003882:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003884:	fe 7c 28 00 	mov	r12,-55296
80003888:	fe b0 f6 e7 	rcall	80002656 <spi_read>
8000388c:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000388e:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003892:	ac d8       	st.b	r6[0x5],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003894:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003898:	fe b0 f6 d1 	rcall	8000263a <spi_write>
8000389c:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000389e:	fe 7c 28 00 	mov	r12,-55296
800038a2:	fe b0 f6 da 	rcall	80002656 <spi_read>
800038a6:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
800038a8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038ac:	ac e8       	st.b	r6[0x6],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
800038ae:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038b2:	fe b0 f6 c4 	rcall	8000263a <spi_write>
800038b6:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
800038b8:	fe 7c 28 00 	mov	r12,-55296
800038bc:	fe b0 f6 cd 	rcall	80002656 <spi_read>
800038c0:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
800038c2:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038c6:	ac f8       	st.b	r6[0x7],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
800038c8:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038cc:	fe b0 f6 b7 	rcall	8000263a <spi_write>
800038d0:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
800038d2:	fe 7c 28 00 	mov	r12,-55296
800038d6:	fe b0 f6 c0 	rcall	80002656 <spi_read>
800038da:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
800038dc:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038e0:	ed 68 00 08 	st.b	r6[8],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
800038e4:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038e8:	fe b0 f6 a9 	rcall	8000263a <spi_write>
800038ec:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
800038ee:	fe 7c 28 00 	mov	r12,-55296
800038f2:	fe b0 f6 b2 	rcall	80002656 <spi_read>
800038f6:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
800038f8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800038fc:	ed 68 00 09 	st.b	r6[9],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003900:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003904:	fe b0 f6 9b 	rcall	8000263a <spi_write>
80003908:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000390a:	fe 7c 28 00 	mov	r12,-55296
8000390e:	fe b0 f6 a4 	rcall	80002656 <spi_read>
80003912:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003914:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003918:	ed 68 00 0a 	st.b	r6[10],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000391c:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003920:	fe b0 f6 8d 	rcall	8000263a <spi_write>
80003924:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003926:	fe 7c 28 00 	mov	r12,-55296
8000392a:	fe b0 f6 96 	rcall	80002656 <spi_read>
8000392e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003930:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003934:	ed 68 00 0b 	st.b	r6[11],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003938:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000393c:	fe b0 f6 7f 	rcall	8000263a <spi_write>
80003940:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003942:	fe 7c 28 00 	mov	r12,-55296
80003946:	fe b0 f6 88 	rcall	80002656 <spi_read>
8000394a:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
8000394c:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003950:	ed 68 00 0c 	st.b	r6[12],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003954:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003958:	fe b0 f6 71 	rcall	8000263a <spi_write>
8000395c:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000395e:	fe 7c 28 00 	mov	r12,-55296
80003962:	fe b0 f6 7a 	rcall	80002656 <spi_read>
80003966:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003968:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
8000396c:	ed 68 00 0d 	st.b	r6[13],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80003970:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003974:	fe b0 f6 63 	rcall	8000263a <spi_write>
80003978:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
8000397a:	fe 7c 28 00 	mov	r12,-55296
8000397e:	fe b0 f6 6c 	rcall	80002656 <spi_read>
80003982:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80003984:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003988:	ed 68 00 0e 	st.b	r6[14],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
8000398c:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80003990:	fe b0 f6 55 	rcall	8000263a <spi_write>
80003994:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80003996:	fe 7c 28 00 	mov	r12,-55296
8000399a:	fe b0 f6 5e 	rcall	80002656 <spi_read>
8000399e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
800039a0:	e0 6b 00 ff 	mov	r11,255
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
800039a4:	ed 68 00 0f 	st.b	r6[15],r8
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
800039a8:	fe 7c 28 00 	mov	r12,-55296
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
800039ac:	fe b0 f6 47 	rcall	8000263a <spi_write>
800039b0:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);
800039b4:	fe 7c 28 00 	mov	r12,-55296
800039b8:	fe b0 f6 41 	rcall	8000263a <spi_write>
800039bc:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800039c0:	fe 7c 28 00 	mov	r12,-55296
800039c4:	fe b0 f6 3b 	rcall	8000263a <spi_write>
800039c8:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800039ca:	fe 7c 28 00 	mov	r12,-55296
800039ce:	fe b0 f5 c9 	rcall	80002560 <spi_unselectChip>
800039d2:	fe b0 f8 4d 	rcall	80002a6c <sd_mmc_spi_get_capacity>
  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
800039d6:	e0 69 06 80 	mov	r9,1664
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
800039da:	30 18       	mov	r8,1

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800039dc:	72 0a       	ld.w	r10,r9[0x0]
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
800039de:	e0 69 06 84 	mov	r9,1668

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
800039e2:	b2 88       	st.b	r9[0x0],r8
800039e4:	e0 68 1b 00 	mov	r8,6912
800039e8:	ea 18 00 b7 	orh	r8,0xb7
800039ec:	e0 6b 06 70 	mov	r11,1648
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800039f0:	8f 18       	st.w	r7[0x4],r8
800039f2:	fe 7c 28 00 	mov	r12,-55296
800039f6:	fe b0 f5 c9 	rcall	80002588 <spi_setupChipReg>
  return true;
800039fa:	30 1c       	mov	r12,1
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800039fc:	fe 9f fd a6 	bral	80003548 <sd_mmc_spi_internal_init+0x280>
80003a00:	30 2b       	mov	r11,2
80003a02:	fe 7c 28 00 	mov	r12,-55296
    sd_mmc_spi_init_done = false;
80003a06:	fe b0 f5 ad 	rcall	80002560 <spi_unselectChip>
80003a0a:	e0 68 06 84 	mov	r8,1668
80003a0e:	30 0c       	mov	r12,0
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80003a10:	b0 85       	st.b	r8[0x0],r5
80003a12:	fe 9f fd 9b 	bral	80003548 <sd_mmc_spi_internal_init+0x280>
80003a16:	3f f8       	mov	r8,-1
80003a18:	a8 88       	st.b	r4[0x0],r8
80003a1a:	fe 9f fe 1a 	bral	8000364e <sd_mmc_spi_internal_init+0x386>
80003a1e:	3f f8       	mov	r8,-1
80003a20:	ac 88       	st.b	r6[0x0],r8
80003a22:	fe 9f fe 55 	bral	800036cc <sd_mmc_spi_internal_init+0x404>
80003a26:	3f f8       	mov	r8,-1
80003a28:	ac 88       	st.b	r6[0x0],r8
80003a2a:	fe 9f fe 3c 	bral	800036a2 <sd_mmc_spi_internal_init+0x3da>
80003a2e:	3f f8       	mov	r8,-1
80003a30:	ac 88       	st.b	r6[0x0],r8
80003a32:	fe 9f fe 75 	bral	8000371c <sd_mmc_spi_internal_init+0x454>
80003a36:	3f f8       	mov	r8,-1
80003a38:	ac 88       	st.b	r6[0x0],r8
80003a3a:	fe 9f fe 5d 	bral	800036f4 <sd_mmc_spi_internal_init+0x42c>
80003a3e:	3f f8       	mov	r8,-1
80003a40:	ac 88       	st.b	r6[0x0],r8
80003a42:	fe 9f fe 81 	bral	80003744 <sd_mmc_spi_internal_init+0x47c>
80003a46:	3f f8       	mov	r8,-1
80003a48:	ac 88       	st.b	r6[0x0],r8
80003a4a:	fe 9f fe 91 	bral	8000376c <sd_mmc_spi_internal_init+0x4a4>
80003a4e:	3f f8       	mov	r8,-1
80003a50:	ac 88       	st.b	r6[0x0],r8
80003a52:	cb 5a       	rjmp	800037bc <sd_mmc_spi_internal_init+0x4f4>
80003a54:	3f f8       	mov	r8,-1
80003a56:	ac 88       	st.b	r6[0x0],r8
80003a58:	fe 9f fe 9e 	bral	80003794 <sd_mmc_spi_internal_init+0x4cc>

80003a5c <sd_mmc_spi_init>:
80003a5c:	eb cd 40 10 	pushm	r4,lr
80003a60:	e0 68 06 70 	mov	r8,1648
80003a64:	fa c4 ff f8 	sub	r4,sp,-8
80003a68:	e8 ea 00 08 	ld.d	r10,r4[8]
80003a6c:	f0 eb 00 08 	st.d	r8[8],r10
80003a70:	e0 69 06 80 	mov	r9,1664
80003a74:	93 0c       	st.w	r9[0x0],r12
80003a76:	e8 ea 00 00 	ld.d	r10,r4[0]
80003a7a:	f0 eb 00 00 	st.d	r8[0],r10
80003a7e:	fe b0 fc 25 	rcall	800032c8 <sd_mmc_spi_internal_init>
80003a82:	e3 cd 80 10 	ldm	sp++,r4,pc
80003a86:	d7 03       	nop

80003a88 <sd_mmc_spi_mem_check>:
80003a88:	eb cd 40 e0 	pushm	r5-r7,lr
80003a8c:	e0 65 06 84 	mov	r5,1668
80003a90:	30 07       	mov	r7,0
80003a92:	0b 88       	ld.ub	r8,r5[0x0]
80003a94:	ee 08 18 00 	cp.b	r8,r7
bool sd_mmc_spi_check_presence(void)
{
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80003a98:	e0 81 01 2c 	brne	80003cf0 <sd_mmc_spi_mem_check+0x268>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003a9c:	30 2b       	mov	r11,2
80003a9e:	fe 7c 28 00 	mov	r12,-55296
80003aa2:	fe b0 f5 37 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003aa6:	30 0b       	mov	r11,0
80003aa8:	16 9c       	mov	r12,r11
80003aaa:	fe b0 f8 c9 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003aae:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003ab0:	e0 67 28 bc 	mov	r7,10428
80003ab4:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003ab6:	fe 7c 28 00 	mov	r12,-55296
80003aba:	fe b0 f5 53 	rcall	80002560 <spi_unselectChip>
  return r1;
80003abe:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003ac0:	ae 88       	st.b	r7[0x0],r8
80003ac2:	30 16       	mov	r6,1
80003ac4:	ec 08 18 00 	cp.b	r8,r6
80003ac8:	e0 80 01 29 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003acc:	e0 6b 00 ff 	mov	r11,255
80003ad0:	fe 7c 28 00 	mov	r12,-55296
80003ad4:	fe b0 f5 b3 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003ad8:	30 2b       	mov	r11,2
80003ada:	fe 7c 28 00 	mov	r12,-55296
80003ade:	fe b0 f5 19 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003ae2:	30 0b       	mov	r11,0
80003ae4:	16 9c       	mov	r12,r11
80003ae6:	fe b0 f8 ab 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003aea:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003aec:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003aee:	fe 7c 28 00 	mov	r12,-55296
80003af2:	fe b0 f5 37 	rcall	80002560 <spi_unselectChip>
  return r1;
80003af6:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003af8:	ae 88       	st.b	r7[0x0],r8
80003afa:	ec 08 18 00 	cp.b	r8,r6
80003afe:	e0 80 01 0e 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003b02:	e0 6b 00 ff 	mov	r11,255
80003b06:	fe 7c 28 00 	mov	r12,-55296
80003b0a:	fe b0 f5 98 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003b0e:	30 2b       	mov	r11,2
80003b10:	fe 7c 28 00 	mov	r12,-55296
80003b14:	fe b0 f4 fe 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003b18:	30 0b       	mov	r11,0
80003b1a:	16 9c       	mov	r12,r11
80003b1c:	fe b0 f8 90 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b20:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003b22:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b24:	fe 7c 28 00 	mov	r12,-55296
80003b28:	fe b0 f5 1c 	rcall	80002560 <spi_unselectChip>
  return r1;
80003b2c:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003b2e:	ae 88       	st.b	r7[0x0],r8
80003b30:	ec 08 18 00 	cp.b	r8,r6
80003b34:	e0 80 00 f3 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003b38:	e0 6b 00 ff 	mov	r11,255
80003b3c:	fe 7c 28 00 	mov	r12,-55296
80003b40:	fe b0 f5 7d 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003b44:	30 2b       	mov	r11,2
80003b46:	fe 7c 28 00 	mov	r12,-55296
80003b4a:	fe b0 f4 e3 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003b4e:	30 0b       	mov	r11,0
80003b50:	16 9c       	mov	r12,r11
80003b52:	fe b0 f8 75 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b56:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003b58:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b5a:	fe 7c 28 00 	mov	r12,-55296
80003b5e:	fe b0 f5 01 	rcall	80002560 <spi_unselectChip>
  return r1;
80003b62:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003b64:	ae 88       	st.b	r7[0x0],r8
80003b66:	ec 08 18 00 	cp.b	r8,r6
80003b6a:	e0 80 00 d8 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003b6e:	e0 6b 00 ff 	mov	r11,255
80003b72:	fe 7c 28 00 	mov	r12,-55296
80003b76:	fe b0 f5 62 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003b7a:	30 2b       	mov	r11,2
80003b7c:	fe 7c 28 00 	mov	r12,-55296
80003b80:	fe b0 f4 c8 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003b84:	30 0b       	mov	r11,0
80003b86:	16 9c       	mov	r12,r11
80003b88:	fe b0 f8 5a 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b8c:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003b8e:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003b90:	fe 7c 28 00 	mov	r12,-55296
80003b94:	fe b0 f4 e6 	rcall	80002560 <spi_unselectChip>
  return r1;
80003b98:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003b9a:	ae 88       	st.b	r7[0x0],r8
80003b9c:	ec 08 18 00 	cp.b	r8,r6
80003ba0:	e0 80 00 bd 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003ba4:	e0 6b 00 ff 	mov	r11,255
80003ba8:	fe 7c 28 00 	mov	r12,-55296
80003bac:	fe b0 f5 47 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003bb0:	30 2b       	mov	r11,2
80003bb2:	fe 7c 28 00 	mov	r12,-55296
80003bb6:	fe b0 f4 ad 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003bba:	30 0b       	mov	r11,0
80003bbc:	16 9c       	mov	r12,r11
80003bbe:	fe b0 f8 3f 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003bc2:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003bc4:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003bc6:	fe 7c 28 00 	mov	r12,-55296
80003bca:	fe b0 f4 cb 	rcall	80002560 <spi_unselectChip>
  return r1;
80003bce:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003bd0:	ae 88       	st.b	r7[0x0],r8
80003bd2:	ec 08 18 00 	cp.b	r8,r6
80003bd6:	e0 80 00 a2 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003bda:	e0 6b 00 ff 	mov	r11,255
80003bde:	fe 7c 28 00 	mov	r12,-55296
80003be2:	fe b0 f5 2c 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003be6:	30 2b       	mov	r11,2
80003be8:	fe 7c 28 00 	mov	r12,-55296
80003bec:	fe b0 f4 92 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003bf0:	30 0b       	mov	r11,0
80003bf2:	16 9c       	mov	r12,r11
80003bf4:	fe b0 f8 24 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003bf8:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003bfa:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003bfc:	fe 7c 28 00 	mov	r12,-55296
80003c00:	fe b0 f4 b0 	rcall	80002560 <spi_unselectChip>
  return r1;
80003c04:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003c06:	ae 88       	st.b	r7[0x0],r8
80003c08:	ec 08 18 00 	cp.b	r8,r6
80003c0c:	e0 80 00 87 	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003c10:	e0 6b 00 ff 	mov	r11,255
80003c14:	fe 7c 28 00 	mov	r12,-55296
80003c18:	fe b0 f5 11 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003c1c:	30 2b       	mov	r11,2
80003c1e:	fe 7c 28 00 	mov	r12,-55296
80003c22:	fe b0 f4 77 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003c26:	30 0b       	mov	r11,0
80003c28:	16 9c       	mov	r12,r11
80003c2a:	fe b0 f8 09 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c2e:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003c30:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c32:	fe 7c 28 00 	mov	r12,-55296
80003c36:	fe b0 f4 95 	rcall	80002560 <spi_unselectChip>
  return r1;
80003c3a:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003c3c:	ae 88       	st.b	r7[0x0],r8
80003c3e:	ec 08 18 00 	cp.b	r8,r6
80003c42:	c6 c0       	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003c44:	e0 6b 00 ff 	mov	r11,255
80003c48:	fe 7c 28 00 	mov	r12,-55296
80003c4c:	fe b0 f4 f7 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003c50:	30 2b       	mov	r11,2
80003c52:	fe 7c 28 00 	mov	r12,-55296
80003c56:	fe b0 f4 5d 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003c5a:	30 0b       	mov	r11,0
80003c5c:	16 9c       	mov	r12,r11
80003c5e:	fe b0 f7 ef 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c62:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003c64:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c66:	fe 7c 28 00 	mov	r12,-55296
80003c6a:	fe b0 f4 7b 	rcall	80002560 <spi_unselectChip>
  return r1;
80003c6e:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003c70:	ae 88       	st.b	r7[0x0],r8
80003c72:	ec 08 18 00 	cp.b	r8,r6
80003c76:	c5 20       	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003c78:	e0 6b 00 ff 	mov	r11,255
80003c7c:	fe 7c 28 00 	mov	r12,-55296
80003c80:	fe b0 f4 dd 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003c84:	30 2b       	mov	r11,2
80003c86:	fe 7c 28 00 	mov	r12,-55296
80003c8a:	fe b0 f4 43 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003c8e:	30 0b       	mov	r11,0
80003c90:	16 9c       	mov	r12,r11
80003c92:	fe b0 f7 d5 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c96:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003c98:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003c9a:	fe 7c 28 00 	mov	r12,-55296
80003c9e:	fe b0 f4 61 	rcall	80002560 <spi_unselectChip>
  return r1;
80003ca2:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003ca4:	ae 88       	st.b	r7[0x0],r8
80003ca6:	ec 08 18 00 	cp.b	r8,r6
80003caa:	c3 80       	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003cac:	e0 6b 00 ff 	mov	r11,255
80003cb0:	fe 7c 28 00 	mov	r12,-55296
80003cb4:	fe b0 f4 c3 	rcall	8000263a <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003cb8:	30 2b       	mov	r11,2
80003cba:	fe 7c 28 00 	mov	r12,-55296
80003cbe:	fe b0 f4 29 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003cc2:	30 0b       	mov	r11,0
80003cc4:	16 9c       	mov	r12,r11
80003cc6:	fe b0 f7 bb 	rcall	80002c3c <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003cca:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003ccc:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003cce:	fe 7c 28 00 	mov	r12,-55296
80003cd2:	fe b0 f4 47 	rcall	80002560 <spi_unselectChip>
  return r1;
80003cd6:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003cd8:	ae 88       	st.b	r7[0x0],r8
80003cda:	ec 08 18 00 	cp.b	r8,r6
80003cde:	c1 e0       	breq	80003d1a <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003ce0:	e0 6b 00 ff 	mov	r11,255
80003ce4:	fe 7c 28 00 	mov	r12,-55296
80003ce8:	fe b0 f4 a9 	rcall	8000263a <spi_write>
80003cec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003cf0:	30 2b       	mov	r11,2
80003cf2:	fe 7c 28 00 	mov	r12,-55296
80003cf6:	fe b0 f4 0d 	rcall	80002510 <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003cfa:	30 0b       	mov	r11,0
80003cfc:	33 bc       	mov	r12,59
80003cfe:	fe b0 f7 9f 	rcall	80002c3c <sd_mmc_spi_command>
80003d02:	e0 66 28 bc 	mov	r6,10428
80003d06:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003d08:	ac 8c       	st.b	r6[0x0],r12
80003d0a:	fe 7c 28 00 	mov	r12,-55296
80003d0e:	fe b0 f4 29 	rcall	80002560 <spi_unselectChip>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80003d12:	0d 88       	ld.ub	r8,r6[0x0]
80003d14:	ac 88       	st.b	r6[0x0],r8
80003d16:	58 08       	cp.w	r8,0
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
  if (sd_mmc_spi_check_presence())
  {
    if (sd_mmc_spi_init_done == false)
80003d18:	c0 c1       	brne	80003d30 <sd_mmc_spi_mem_check+0x2a8>
80003d1a:	0b 89       	ld.ub	r9,r5[0x0]
80003d1c:	30 08       	mov	r8,0
80003d1e:	f0 09 18 00 	cp.b	r9,r8
80003d22:	c0 30       	breq	80003d28 <sd_mmc_spi_mem_check+0x2a0>
80003d24:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80003d28:	fe b0 fa d0 	rcall	800032c8 <sd_mmc_spi_internal_init>
    }
    else
      return true;
  }
  return false;
}
80003d2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
80003d30:	aa 87       	st.b	r5[0x0],r7
80003d32:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003d36:	d7 03       	nop

80003d38 <uhd_get_speed>:
	cpu_irq_restore(flags);
}

uhd_speed_t uhd_get_speed(void)
{
	switch (uhd_get_speed_mode()) {
80003d38:	fe 68 08 04 	mov	r8,-129020
80003d3c:	70 08       	ld.w	r8,r8[0x0]
80003d3e:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80003d42:	58 38       	cp.w	r8,3
80003d44:	c0 50       	breq	80003d4e <uhd_get_speed+0x16>
80003d46:	48 39       	lddpc	r9,80003d50 <uhd_get_speed+0x18>
80003d48:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]

	default:
		Assert(false);
		return UHD_SPEED_LOW;
	}
}
80003d4c:	5e fc       	retal	r12
	cpu_irq_restore(flags);
}

uhd_speed_t uhd_get_speed(void)
{
	switch (uhd_get_speed_mode()) {
80003d4e:	5e fd       	retal	0
80003d50:	80 01       	ld.sh	r1,r0[0x0]
80003d52:	3d f8       	mov	r8,-33

80003d54 <uhd_send_reset>:
	return uhd_get_microsof_number();
}

void uhd_send_reset(uhd_callback_reset_t callback)
{
	uhd_reset_callback = callback;
80003d54:	e0 69 06 88 	mov	r9,1672
	uhd_start_reset();
80003d58:	93 0c       	st.w	r9[0x0],r12
80003d5a:	fe 68 04 00 	mov	r8,-130048
80003d5e:	70 09       	ld.w	r9,r8[0x0]
80003d60:	a9 b9       	sbr	r9,0x9
}
80003d62:	91 09       	st.w	r8[0x0],r9
80003d64:	5e fc       	retal	r12
80003d66:	d7 03       	nop

80003d68 <uhd_suspend>:

void uhd_suspend(void)
{
80003d68:	eb cd 40 80 	pushm	r7,lr
	if (uhd_ctrl_request_timeout) {
80003d6c:	e0 68 28 d0 	mov	r8,10448
80003d70:	90 08       	ld.sh	r8,r8[0x0]
80003d72:	58 08       	cp.w	r8,0
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003d74:	c4 d1       	brne	80003e0e <uhd_suspend+0xa6>
80003d76:	fe 69 05 c4 	mov	r9,-129596
		uhd_freeze_pipe(pipe);
80003d7a:	72 0e       	ld.w	lr,r9[0x0]
80003d7c:	fe 69 05 f4 	mov	r9,-129548
80003d80:	e2 68 00 00 	mov	r8,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003d84:	93 08       	st.w	r9[0x0],r8
80003d86:	fe 69 05 c8 	mov	r9,-129592
		uhd_freeze_pipe(pipe);
80003d8a:	72 0c       	ld.w	r12,r9[0x0]
80003d8c:	fe 69 05 f8 	mov	r9,-129544
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003d90:	93 08       	st.w	r9[0x0],r8
80003d92:	fe 69 05 cc 	mov	r9,-129588
		uhd_freeze_pipe(pipe);
80003d96:	72 0b       	ld.w	r11,r9[0x0]
80003d98:	fe 69 05 fc 	mov	r9,-129540
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003d9c:	93 08       	st.w	r9[0x0],r8
80003d9e:	fe 69 05 d0 	mov	r9,-129584
		uhd_freeze_pipe(pipe);
80003da2:	72 0a       	ld.w	r10,r9[0x0]
80003da4:	fe 69 06 00 	mov	r9,-129536
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003da8:	93 08       	st.w	r9[0x0],r8
80003daa:	10 5e       	eor	lr,r8
80003dac:	10 5c       	eor	r12,r8
80003dae:	10 5b       	eor	r11,r8
80003db0:	10 5a       	eor	r10,r8
80003db2:	fe 69 05 d4 	mov	r9,-129580
		uhd_freeze_pipe(pipe);
80003db6:	fe 67 06 04 	mov	r7,-129532
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80003dba:	72 09       	ld.w	r9,r9[0x0]
80003dbc:	fd de c2 21 	bfextu	lr,lr,0x11,0x1
80003dc0:	8f 08       	st.w	r7[0x0],r8
80003dc2:	10 59       	eor	r9,r8
80003dc4:	f9 dc c2 21 	bfextu	r12,r12,0x11,0x1
80003dc8:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
80003dcc:	a3 6c       	lsl	r12,0x2
80003dce:	f7 db c2 21 	bfextu	r11,r11,0x11,0x1
80003dd2:	f9 ee 10 1e 	or	lr,r12,lr<<0x1
80003dd6:	f5 da c2 21 	bfextu	r10,r10,0x11,0x1
80003dda:	fd eb 10 3b 	or	r11,lr,r11<<0x3
80003dde:	f7 ea 10 4a 	or	r10,r11,r10<<0x4
80003de2:	f5 e9 10 5a 	or	r10,r10,r9<<0x5
80003de6:	fe 69 05 d8 	mov	r9,-129576
80003dea:	72 09       	ld.w	r9,r9[0x0]
80003dec:	10 59       	eor	r9,r8
80003dee:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
80003df2:	f5 e9 10 69 	or	r9,r10,r9<<0x6
		uhd_freeze_pipe(pipe);
80003df6:	fe 6a 06 08 	mov	r10,-129528
80003dfa:	95 08       	st.w	r10[0x0],r8
80003dfc:	e0 68 07 05 	mov	r8,1797
	}
	// Wait three SOFs before entering in suspend state
	uhd_suspend_start = 3;
80003e00:	b0 89       	st.b	r8[0x0],r9
80003e02:	30 39       	mov	r9,3
80003e04:	e0 68 07 04 	mov	r8,1796

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
80003e08:	b0 89       	st.b	r8[0x0],r9
80003e0a:	e3 cd 80 80 	ldm	sp++,r7,pc
		return;
80003e0e:	30 19       	mov	r9,1
80003e10:	e0 68 07 07 	mov	r8,1799
80003e14:	b0 89       	st.b	r8[0x0],r9
80003e16:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e1a:	d7 03       	nop

80003e1c <uhd_ep_alloc>:
80003e1c:	d4 21       	pushm	r4-r7,lr
80003e1e:	fe 69 00 00 	mov	r9,-131072
80003e22:	f2 f8 04 1c 	ld.w	r8,r9[1052]
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003e26:	ed b8 00 01 	bld	r8,0x1
80003e2a:	c2 90       	breq	80003e7c <uhd_ep_alloc+0x60>
80003e2c:	30 2a       	mov	r10,2
80003e2e:	30 19       	mov	r9,1
			continue;
		}
		uhd_enable_pipe(pipe);
80003e30:	fe 68 00 00 	mov	r8,-131072
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80003e34:	e0 67 02 00 	mov	r7,512

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
80003e38:	f0 fe 04 1c 	ld.w	lr,r8[1052]
80003e3c:	f5 ee 10 0e 	or	lr,r10,lr
80003e40:	f1 4e 04 1c 	st.w	r8[1052],lr
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80003e44:	e0 68 01 00 	mov	r8,256
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
80003e48:	17 ae       	ld.ub	lr,r11[0x2]
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80003e4a:	30 06       	mov	r6,0
80003e4c:	fc 06 18 00 	cp.b	r6,lr
80003e50:	f0 06 17 90 	movgt	r6,r8
80003e54:	ee 06 17 a0 	movle	r6,r7
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80003e58:	17 b8       	ld.ub	r8,r11[0x3]
		// Bank choice
		switch(ep_type) {
80003e5a:	30 27       	mov	r7,2
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80003e5c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
		// Bank choice
		switch(ep_type) {
80003e60:	ee 08 18 00 	cp.b	r8,r7
80003e64:	e0 80 00 9b 	breq	80003f9a <uhd_ep_alloc+0x17e>
80003e68:	30 37       	mov	r7,3
80003e6a:	ee 08 18 00 	cp.b	r8,r7
80003e6e:	c1 d0       	breq	80003ea8 <uhd_ep_alloc+0x8c>
80003e70:	30 17       	mov	r7,1
80003e72:	ee 08 18 00 	cp.b	r8,r7
80003e76:	e0 80 00 8e 	breq	80003f92 <uhd_ep_alloc+0x176>
		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
		uhd_enable_stall_interrupt(pipe);
		uhd_enable_pipe_error_interrupt(pipe);
		uhd_enable_pipe_interrupt(pipe);
		return true;
80003e7a:	d8 2a       	popm	r4-r7,pc,r12=0
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003e7c:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003e80:	ed b8 00 02 	bld	r8,0x2
80003e84:	c0 f1       	brne	80003ea2 <uhd_ep_alloc+0x86>
80003e86:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003e8a:	ed b8 00 03 	bld	r8,0x3
80003e8e:	c4 c1       	brne	80003f26 <uhd_ep_alloc+0x10a>
80003e90:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003e94:	ed b8 00 04 	bld	r8,0x4
80003e98:	e0 80 00 84 	breq	80003fa0 <uhd_ep_alloc+0x184>
80003e9c:	31 0a       	mov	r10,16
80003e9e:	30 49       	mov	r9,4
80003ea0:	cc 8b       	rjmp	80003e30 <uhd_ep_alloc+0x14>
80003ea2:	30 4a       	mov	r10,4
80003ea4:	30 29       	mov	r9,2
80003ea6:	cc 5b       	rjmp	80003e30 <uhd_ep_alloc+0x14>
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80003ea8:	17 e5       	ld.ub	r5,r11[0x6]
80003eaa:	30 07       	mov	r7,0
80003eac:	b9 65       	lsl	r5,0x18
		default:
			Assert(false);
			return false;
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
80003eae:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80003eb2:	ad 68       	lsl	r8,0xc
80003eb4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80003eb8:	ab a8       	sbr	r8,0xa
80003eba:	0c 48       	or	r8,r6
80003ebc:	f1 e5 10 05 	or	r5,r8,r5
80003ec0:	eb e7 10 06 	or	r6,r5,r7
80003ec4:	fe 65 05 00 	mov	r5,-129792
80003ec8:	17 d4       	ld.ub	r4,r11[0x5]
80003eca:	f2 0e 15 02 	lsl	lr,r9,0x2
80003ece:	17 cb       	ld.ub	r11,r11[0x4]
80003ed0:	fc 05 00 08 	add	r8,lr,r5
80003ed4:	e9 eb 10 8b 	or	r11,r4,r11<<0x8
80003ed8:	30 87       	mov	r7,8
80003eda:	e0 65 04 00 	mov	r5,1024
80003ede:	5c cb       	swap.bh	r11
80003ee0:	5c 7b       	castu.h	r11
80003ee2:	f6 07 0c 4b 	max	r11,r11,r7
80003ee6:	f6 05 0d 45 	min	r5,r11,r5
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
80003eea:	fe 6b 05 30 	mov	r11,-129744
		default:
			Assert(false);
			return false;
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
80003eee:	a1 75       	lsl	r5,0x1
80003ef0:	20 15       	sub	r5,1
80003ef2:	ea 05 12 00 	clz	r5,r5
80003ef6:	ea 05 11 1c 	rsub	r5,r5,28
80003efa:	ed e5 10 45 	or	r5,r6,r5<<0x4
80003efe:	91 05       	st.w	r8[0x0],r5
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
80003f00:	fc 0b 00 06 	add	r6,lr,r11
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
80003f04:	70 0b       	ld.w	r11,r8[0x0]
80003f06:	a1 bb       	sbr	r11,0x1
80003f08:	91 0b       	st.w	r8[0x0],r11
		if (!Is_uhd_pipe_configured(pipe)) {
80003f0a:	6c 08       	ld.w	r8,r6[0x0]
80003f0c:	e6 18 00 04 	andh	r8,0x4,COH
80003f10:	c0 e1       	brne	80003f2c <uhd_ep_alloc+0x110>
			uhd_disable_pipe(pipe);
80003f12:	5c da       	com	r10
80003f14:	10 9c       	mov	r12,r8
80003f16:	fe 68 00 00 	mov	r8,-131072
80003f1a:	f0 f9 04 1c 	ld.w	r9,r8[1052]
80003f1e:	12 6a       	and	r10,r9
80003f20:	f1 4a 04 1c 	st.w	r8[1052],r10
			return false;
80003f24:	d8 22       	popm	r4-r7,pc
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003f26:	30 8a       	mov	r10,8
80003f28:	30 39       	mov	r9,3
80003f2a:	c8 3b       	rjmp	80003e30 <uhd_ep_alloc+0x14>
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
			uhd_disable_pipe(pipe);
			return false;
		}
		uhd_configure_address(pipe, add);
80003f2c:	37 f5       	mov	r5,127
80003f2e:	12 98       	mov	r8,r9
80003f30:	f7 d9 c0 02 	bfextu	r11,r9,0x0,0x2
80003f34:	e2 18 00 04 	andl	r8,0x4,COH
80003f38:	a3 7b       	lsl	r11,0x3
80003f3a:	e0 38 fb dc 	sub	r8,130012
80003f3e:	ea 0b 09 4b 	lsl	r11,r5,r11
80003f42:	70 06       	ld.w	r6,r8[0x0]
80003f44:	16 95       	mov	r5,r11
80003f46:	5c 95       	brev	r5
80003f48:	ea 05 12 00 	clz	r5,r5
80003f4c:	16 86       	andn	r6,r11
80003f4e:	f8 05 09 4c 	lsl	r12,r12,r5
80003f52:	f9 eb 00 0b 	and	r11,r12,r11
80003f56:	0c 4b       	or	r11,r6
80003f58:	91 0b       	st.w	r8[0x0],r11
		uhd_enable_pipe(pipe);
80003f5a:	fe 68 00 00 	mov	r8,-131072
80003f5e:	f0 fb 04 1c 	ld.w	r11,r8[1052]
80003f62:	16 4a       	or	r10,r11
80003f64:	f1 4a 04 1c 	st.w	r8[1052],r10

		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
80003f68:	fc 1b 02 00 	movh	r11,0x200
80003f6c:	f2 ca 00 01 	sub	r10,r9,1
80003f70:	f6 0a 09 4a 	lsl	r10,r11,r10
80003f74:	f1 4a 04 18 	st.w	r8[1048],r10
		uhd_enable_stall_interrupt(pipe);
80003f78:	e0 3e fa 10 	sub	lr,129552
80003f7c:	34 0a       	mov	r10,64
80003f7e:	9d 0a       	st.w	lr[0x0],r10
		uhd_enable_pipe_error_interrupt(pipe);
80003f80:	9d 07       	st.w	lr[0x0],r7
		uhd_enable_pipe_interrupt(pipe);
80003f82:	e0 6a 01 00 	mov	r10,256
80003f86:	30 1c       	mov	r12,1
80003f88:	f4 09 09 49 	lsl	r9,r10,r9
80003f8c:	f1 49 04 18 	st.w	r8[1048],r9
		return true;
80003f90:	d8 22       	popm	r4-r7,pc
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80003f92:	17 e5       	ld.ub	r5,r11[0x6]
80003f94:	30 47       	mov	r7,4
80003f96:	b9 65       	lsl	r5,0x18
		case 1:
			bank = AVR32_USBB_UECFG0_EPBK_SINGLE;
			break;
		case 2:
			bank = AVR32_USBB_UECFG0_EPBK_DOUBLE;
			break;
80003f98:	c8 bb       	rjmp	80003eae <uhd_ep_alloc+0x92>
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80003f9a:	30 05       	mov	r5,0
80003f9c:	30 47       	mov	r7,4
80003f9e:	c8 8b       	rjmp	80003eae <uhd_ep_alloc+0x92>
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003fa0:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003fa4:	ed b8 00 05 	bld	r8,0x5
80003fa8:	c0 a1       	brne	80003fbc <uhd_ep_alloc+0x1a0>
80003faa:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003fae:	ed b8 00 06 	bld	r8,0x6
80003fb2:	fe 90 ff 64 	breq	80003e7a <uhd_ep_alloc+0x5e>
80003fb6:	34 0a       	mov	r10,64
80003fb8:	30 69       	mov	r9,6
80003fba:	c3 bb       	rjmp	80003e30 <uhd_ep_alloc+0x14>
80003fbc:	32 0a       	mov	r10,32
80003fbe:	30 59       	mov	r9,5
80003fc0:	c3 8b       	rjmp	80003e30 <uhd_ep_alloc+0x14>

80003fc2 <uhd_ep0_alloc>:
	uhd_send_resume();
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
80003fc2:	d4 01       	pushm	lr
	if (ep_size < 8) {
80003fc4:	30 78       	mov	r8,7
80003fc6:	f0 0b 18 00 	cp.b	r11,r8
80003fca:	e0 88 00 3f 	brls	80004048 <uhd_ep0_alloc+0x86>
#error TODO Add USB address in a list
		return true;
	}
#endif

	uhd_enable_pipe(0);
80003fce:	fe 69 00 00 	mov	r9,-131072
80003fd2:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80003fd6:	a1 a8       	sbr	r8,0x0
80003fd8:	f3 48 04 1c 	st.w	r9[1052],r8
	uhd_configure_pipe(0, // Pipe 0
80003fdc:	30 8e       	mov	lr,8
80003fde:	fe 68 05 00 	mov	r8,-129792
80003fe2:	f6 0e 0c 4b 	max	r11,r11,lr
80003fe6:	e0 6a 04 00 	mov	r10,1024
80003fea:	f6 0a 0d 4a 	min	r10,r11,r10
80003fee:	a1 7a       	lsl	r10,0x1
80003ff0:	20 1a       	sub	r10,1
80003ff2:	f4 0a 12 00 	clz	r10,r10
80003ff6:	f4 0a 11 1c 	rsub	r10,r10,28
80003ffa:	a5 6a       	lsl	r10,0x4
80003ffc:	91 0a       	st.w	r8[0x0],r10
#else
			ep_size,
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
80003ffe:	70 0a       	ld.w	r10,r8[0x0]
80004000:	a1 ba       	sbr	r10,0x1
80004002:	91 0a       	st.w	r8[0x0],r10
	if (!Is_uhd_pipe_configured(0)) {
80004004:	fe 68 05 30 	mov	r8,-129744
80004008:	70 08       	ld.w	r8,r8[0x0]
8000400a:	e6 18 00 04 	andh	r8,0x4,COH
8000400e:	c1 60       	breq	8000403a <uhd_ep0_alloc+0x78>
		uhd_disable_pipe(0);
		return false;
	}
	uhd_configure_address(0, add);
80004010:	fe 6a 04 24 	mov	r10,-130012
80004014:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80004018:	74 08       	ld.w	r8,r10[0x0]
8000401a:	e0 18 ff 80 	andl	r8,0xff80
8000401e:	f9 e8 10 08 	or	r8,r12,r8
80004022:	95 08       	st.w	r10[0x0],r8

	// Always enable stall and error interrupts of control endpoint
	uhd_enable_stall_interrupt(0);
80004024:	fe 68 05 f0 	mov	r8,-129552
80004028:	34 0a       	mov	r10,64
8000402a:	91 0a       	st.w	r8[0x0],r10
	uhd_enable_pipe_error_interrupt(0);
8000402c:	91 0e       	st.w	r8[0x0],lr
	uhd_enable_pipe_interrupt(0);
8000402e:	30 1c       	mov	r12,1
80004030:	e0 68 01 00 	mov	r8,256
80004034:	f3 48 04 18 	st.w	r9[1048],r8
	return true;
}
80004038:	d8 02       	popm	pc
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
	if (!Is_uhd_pipe_configured(0)) {
		uhd_disable_pipe(0);
8000403a:	10 9c       	mov	r12,r8
8000403c:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80004040:	a1 c8       	cbr	r8,0x0
80004042:	f3 48 04 1c 	st.w	r9[1052],r8
		return false;
80004046:	d8 02       	popm	pc
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
	if (ep_size < 8) {
80004048:	d8 0a       	popm	pc,r12=0
8000404a:	d7 03       	nop

8000404c <otg_dual_enable>:
	}
	otg_data_memory_barrier();
}

bool otg_dual_enable(void)
{
8000404c:	eb cd 40 80 	pushm	r7,lr
	if (otg_initialized) {
80004050:	e0 68 06 85 	mov	r8,1669
80004054:	30 09       	mov	r9,0
80004056:	11 8a       	ld.ub	r10,r8[0x0]
80004058:	f2 0a 18 00 	cp.b	r10,r9
8000405c:	c0 30       	breq	80004062 <otg_dual_enable+0x16>
8000405e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false; // Dual role already initialized
	}
	otg_initialized = true;
80004062:	30 19       	mov	r9,1

	//* Enable USB hardware clock
	sysclk_enable_usb();
80004064:	b0 89       	st.b	r8[0x0],r9
80004066:	e0 a0 0b a5 	rcall	800057b0 <sysclk_enable_usb>

	//* Link USB interrupt on OTG interrupt in dual role
	irq_register_handler(otg_interrupt, AVR32_USBB_IRQ, UHD_USB_INT_LEVEL);
8000406a:	30 0a       	mov	r10,0
8000406c:	e0 6b 02 20 	mov	r11,544
80004070:	fe cc f5 48 	sub	r12,pc,-2744
	//pm_asyn_wake_up_enable(AVR32_PM_AWEN_USB_WAKEN_MASK);

# ifdef USB_ID
	// By default USBB is already configured with ID pin enable
	// The USBB must be enabled to provide interrupt
	otg_input_id_pin();
80004074:	fe b0 f0 ec 	rcall	8000224c <INTC_register_interrupt>
80004078:	fe 78 10 00 	mov	r8,-61440
8000407c:	fc 19 00 20 	movh	r9,0x20
80004080:	91 69       	st.w	r8[0x18],r9
80004082:	91 99       	st.w	r8[0x24],r9
80004084:	91 29       	st.w	r8[0x8],r9
	otg_unfreeze_clock();
80004086:	f1 49 00 74 	st.w	r8[116],r9
8000408a:	fe 68 08 00 	mov	r8,-129024
8000408e:	70 09       	ld.w	r9,r8[0x0]
	otg_enable();
80004090:	af c9       	cbr	r9,0xe
80004092:	91 09       	st.w	r8[0x0],r9
80004094:	70 09       	ld.w	r9,r8[0x0]
	otg_enable_id_interrupt();
80004096:	af b9       	sbr	r9,0xf
80004098:	91 09       	st.w	r8[0x0],r9
8000409a:	70 09       	ld.w	r9,r8[0x0]
	otg_ack_id_transition();
8000409c:	a1 a9       	sbr	r9,0x0
8000409e:	91 09       	st.w	r8[0x0],r9
800040a0:	30 17       	mov	r7,1
800040a2:	fe 69 08 08 	mov	r9,-129016
	otg_freeze_clock();
800040a6:	93 07       	st.w	r9[0x0],r7
800040a8:	70 09       	ld.w	r9,r8[0x0]
	if (Is_otg_id_device()) {
800040aa:	af a9       	sbr	r9,0xe
800040ac:	91 09       	st.w	r8[0x0],r9
800040ae:	fe 68 08 04 	mov	r8,-129020
800040b2:	70 08       	ld.w	r8,r8[0x0]
800040b4:	ed b8 00 0a 	bld	r8,0xa
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
		udc_start();
	} else {
		UHC_MODE_CHANGE(true);
800040b8:	c0 90       	breq	800040ca <otg_dual_enable+0x7e>
800040ba:	0e 9c       	mov	r12,r7
		uhc_start();
800040bc:	e0 a0 25 16 	rcall	80008ae8 <usb_mode_change>
800040c0:	e0 a0 0c 4c 	rcall	80005958 <uhc_start>
	return true;  // ID pin management has been enabled
# else
	uhd_sleep_mode(UHD_STATE_OFF);
	return false; // ID pin management has not been enabled
# endif
}
800040c4:	0e 9c       	mov	r12,r7
	otg_enable_id_interrupt();
	otg_ack_id_transition();
	otg_freeze_clock();
	if (Is_otg_id_device()) {
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
800040c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800040ca:	30 0c       	mov	r12,0
800040cc:	e0 a0 25 0e 	rcall	80008ae8 <usb_mode_change>
800040d0:	0e 9c       	mov	r12,r7
800040d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800040d6:	d7 03       	nop

800040d8 <uhd_enable>:
800040d8:	eb cd 40 80 	pushm	r7,lr
800040dc:	e1 b7 00 00 	mfsr	r7,0x0
800040e0:	d3 03       	ssrf	0x10
800040e2:	cb 5f       	rcall	8000404c <otg_dual_enable>
800040e4:	c0 71       	brne	800040f2 <uhd_enable+0x1a>
800040e6:	fe 6b 08 04 	mov	r11,-129020
800040ea:	76 08       	ld.w	r8,r11[0x0]
		return;
	}

#ifdef USB_ID
	// Check that the host mode is selected by ID pin
	if (!Is_otg_id_host()) {
800040ec:	e2 18 04 00 	andl	r8,0x400,COH
800040f0:	c0 70       	breq	800040fe <uhd_enable+0x26>
800040f2:	e6 17 00 01 	andh	r7,0x1,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800040f6:	c0 21       	brne	800040fa <uhd_enable+0x22>
800040f8:	d5 03       	csrf	0x10
      cpu_irq_enable();
800040fa:	e3 cd 80 80 	ldm	sp++,r7,pc
   }

	barrier();
800040fe:	fe 79 10 00 	mov	r9,-61440
	otg_force_host_mode();
#endif

	// Enable USB hardware
#ifdef USB_VBOF
	uhd_output_vbof_pin();
80004102:	fc 1a 00 40 	movh	r10,0x40
80004106:	93 6a       	st.w	r9[0x18],r10
80004108:	93 9a       	st.w	r9[0x24],r10
8000410a:	93 2a       	st.w	r9[0x8],r10
8000410c:	f3 4a 00 88 	st.w	r9[136],r10
80004110:	f3 4a 00 78 	st.w	r9[120],r10
80004114:	fe 69 08 00 	mov	r9,-129024
# if USB_VBOF_ACTIVE_LEVEL == HIGH
	uhd_set_vbof_active_high();
# else // USB_VBOF_ACTIVE_LEVEL == LOW
	uhd_set_vbof_active_low();
80004118:	72 0a       	ld.w	r10,r9[0x0]
8000411a:	ad ba       	sbr	r10,0xd
8000411c:	93 0a       	st.w	r9[0x0],r10
8000411e:	72 0a       	ld.w	r10,r9[0x0]
# endif
#endif
	otg_enable_pad();
80004120:	ad aa       	sbr	r10,0xc
80004122:	93 0a       	st.w	r9[0x0],r10
80004124:	72 0a       	ld.w	r10,r9[0x0]
	otg_enable();
80004126:	af ba       	sbr	r10,0xf
80004128:	93 0a       	st.w	r9[0x0],r10
8000412a:	e0 6a 28 d0 	mov	r10,10448

	uhd_ctrl_request_first = NULL;
	uhd_ctrl_request_last = NULL;
	uhd_ctrl_request_timeout = 0;
8000412e:	b4 08       	st.h	r10[0x0],r8
	uhd_suspend_start = 0;
	uhd_resume_start = 0;
	uhd_b_suspend_requested = false;

	otg_unfreeze_clock();
80004130:	72 0a       	ld.w	r10,r9[0x0]
80004132:	af ca       	cbr	r10,0xe
80004134:	93 0a       	st.w	r9[0x0],r10
	uhd_disable_high_speed_mode();
#  endif
#endif

	// Clear all interrupts that may have been set by a previous host mode
	AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_DCONNIC_MASK
80004136:	37 fa       	mov	r10,127
80004138:	fe 69 00 00 	mov	r9,-131072
8000413c:	f3 4a 04 08 	st.w	r9[1032],r10
			| AVR32_USBB_UHINTCLR_DDISCIC_MASK | AVR32_USBB_UHINTCLR_HSOFIC_MASK
			| AVR32_USBB_UHINTCLR_HWUPIC_MASK | AVR32_USBB_UHINTCLR_RSMEDIC_MASK
			| AVR32_USBB_UHINTCLR_RSTIC_MASK | AVR32_USBB_UHINTCLR_RXRSMIC_MASK;
	otg_ack_vbus_transition();
80004140:	fe 6a 08 08 	mov	r10,-129016
80004144:	30 2c       	mov	r12,2
80004146:	95 0c       	st.w	r10[0x0],r12

	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
80004148:	f2 fa 08 00 	ld.w	r10,r9[2048]
8000414c:	e8 1a 01 0a 	orl	r10,0x10a
80004150:	f3 4a 08 00 	st.w	r9[2048],r10
# endif
#endif
	otg_enable_pad();
	otg_enable();

	uhd_ctrl_request_first = NULL;
80004154:	e0 6a 28 c4 	mov	r10,10436
80004158:	10 99       	mov	r9,r8
	uhd_ctrl_request_last = NULL;
8000415a:	95 08       	st.w	r10[0x0],r8
8000415c:	e0 6a 28 cc 	mov	r10,10444
	uhd_ctrl_request_timeout = 0;
	uhd_suspend_start = 0;
80004160:	95 08       	st.w	r10[0x0],r8
	uhd_resume_start = 0;
80004162:	e0 68 07 04 	mov	r8,1796
	uhd_b_suspend_requested = false;
80004166:	b0 89       	st.b	r8[0x0],r9
80004168:	e0 68 07 06 	mov	r8,1798
	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
			|AVR32_USBB_USBCON_VBUSTE_MASK
			|AVR32_USBB_USBCON_VBERRE_MASK);
	uhd_enable_vbus();
8000416c:	b0 89       	st.b	r8[0x0],r9
8000416e:	e0 68 07 07 	mov	r8,1799
80004172:	b0 89       	st.b	r8[0x0],r9

	// Force Vbus interrupt when Vbus is always high
	// This is possible due to a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
80004174:	fe 69 08 0c 	mov	r9,-129012
		otg_raise_vbus_transition();
80004178:	e0 68 02 00 	mov	r8,512
8000417c:	93 08       	st.w	r9[0x0],r8
	}

	// Enable main control interrupt
	// Connection, SOF and reset
	AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_DCONNIES_MASK
8000417e:	76 08       	ld.w	r8,r11[0x0]
80004180:	ed b8 00 0b 	bld	r8,0xb
80004184:	f3 fc 0a 00 	st.weq	r9[0x0],r12
			| AVR32_USBB_UHINTESET_HSOFIES_MASK
			| AVR32_USBB_UHINTESET_RSTIES_MASK;

	otg_freeze_clock();
80004188:	32 59       	mov	r9,37
8000418a:	fe 68 00 00 	mov	r8,-131072
8000418e:	f1 49 04 18 	st.w	r8[1048],r9
80004192:	fe 69 08 00 	mov	r9,-129024
80004196:	72 08       	ld.w	r8,r9[0x0]
80004198:	af a8       	sbr	r8,0xe
8000419a:	93 08       	st.w	r9[0x0],r8
8000419c:	ca bb       	rjmp	800040f2 <uhd_enable+0x1a>
8000419e:	d7 03       	nop

800041a0 <uhd_disable>:
800041a0:	eb cd 40 c0 	pushm	r6-r7,lr
800041a4:	fe 69 08 04 	mov	r9,-129020
800041a8:	18 96       	mov	r6,r12
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	ed b8 00 0e 	bld	r8,0xe
void uhd_disable(bool b_id_stop)
{
	irqflags_t flags;

	// Check USB clock ready after a potential sleep mode < IDLE
	while (!Is_otg_clock_usable());
800041b0:	cf d1       	brne	800041aa <uhd_disable+0xa>
	otg_unfreeze_clock();
800041b2:	fe 67 08 00 	mov	r7,-129024
800041b6:	6e 08       	ld.w	r8,r7[0x0]
800041b8:	af c8       	cbr	r8,0xe
800041ba:	8f 08       	st.w	r7[0x0],r8

	// Disable Vbus change and error interrupts
	Clr_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSTE_MASK
800041bc:	fe 68 00 00 	mov	r8,-131072
800041c0:	f0 f9 08 00 	ld.w	r9,r8[2048]
800041c4:	e0 19 ff f5 	andl	r9,0xfff5
800041c8:	f1 49 08 00 	st.w	r8[2048],r9
			| AVR32_USBB_USBCON_VBERRE_MASK);

	// Disable main control interrupt
	// (Connection, disconnection, SOF and reset)
	AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_DCONNIEC_MASK
800041cc:	37 f9       	mov	r9,127
800041ce:	f1 49 04 14 	st.w	r8[1044],r9
			| AVR32_USBB_UHINTECLR_HSOFIEC_MASK
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
800041d2:	fe 69 04 00 	mov	r9,-130048
800041d6:	72 08       	ld.w	r8,r9[0x0]
800041d8:	a9 c8       	cbr	r8,0x8
800041da:	93 08       	st.w	r9[0x0],r8
	uhd_disable_vbus();
800041dc:	fe 68 08 08 	mov	r8,-129016
800041e0:	e0 69 02 00 	mov	r9,512
	uhc_notify_connection(false);
800041e4:	30 0c       	mov	r12,0
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
	uhd_disable_vbus();
800041e6:	91 09       	st.w	r8[0x0],r9
	uhc_notify_connection(false);
800041e8:	e0 a0 0f 04 	rcall	80005ff0 <uhc_notify_connection>
	otg_freeze_clock();
800041ec:	6e 08       	ld.w	r8,r7[0x0]
800041ee:	af a8       	sbr	r8,0xe
800041f0:	8f 08       	st.w	r7[0x0],r8

#ifdef USB_ID
	uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
	if (!b_id_stop) {
800041f2:	58 06       	cp.w	r6,0
800041f4:	c0 31       	brne	800041fa <uhd_disable+0x5a>
800041f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800041fa:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
800041fe:	d3 03       	ssrf	0x10
}


void otg_dual_disable(void)
{
	if (!otg_initialized) {
80004200:	e0 68 06 85 	mov	r8,1669
80004204:	30 09       	mov	r9,0
80004206:	11 8a       	ld.ub	r10,r8[0x0]
80004208:	f2 0a 18 00 	cp.b	r10,r9
		return; // Dual role not initialized
	}
	otg_initialized = false;

	// Do not authorize asynchronous USB interrupts
	AVR32_PM.AWEN.usb_waken = 0;
8000420c:	c1 90       	breq	8000423e <uhd_disable+0x9e>
8000420e:	fe 7a 0c 00 	mov	r10,-62464
80004212:	30 0c       	mov	r12,0
80004214:	f4 fb 01 44 	ld.w	r11,r10[324]
80004218:	f7 dc d0 01 	bfins	r11,r12,0x0,0x1
8000421c:	f5 4b 01 44 	st.w	r10[324],r11
	otg_unfreeze_clock();
80004220:	6e 0a       	ld.w	r10,r7[0x0]
80004222:	af ca       	cbr	r10,0xe
# ifdef USB_ID
	otg_disable_id_interrupt();
80004224:	8f 0a       	st.w	r7[0x0],r10
80004226:	6e 0a       	ld.w	r10,r7[0x0]
80004228:	a1 ca       	cbr	r10,0x0
# endif
	otg_disable();
8000422a:	8f 0a       	st.w	r7[0x0],r10
8000422c:	6e 0a       	ld.w	r10,r7[0x0]
8000422e:	af da       	cbr	r10,0xf
void otg_dual_disable(void)
{
	if (!otg_initialized) {
		return; // Dual role not initialized
	}
	otg_initialized = false;
80004230:	8f 0a       	st.w	r7[0x0],r10
	otg_unfreeze_clock();
# ifdef USB_ID
	otg_disable_id_interrupt();
# endif
	otg_disable();
	otg_disable_pad();
80004232:	b0 89       	st.b	r8[0x0],r9
80004234:	6e 08       	ld.w	r8,r7[0x0]
80004236:	ad c8       	cbr	r8,0xc
	sysclk_disable_usb();
80004238:	8f 08       	st.w	r7[0x0],r8
8000423a:	e0 a0 0a 41 	rcall	800056bc <sysclk_disable_usb>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000423e:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
   }

	barrier();
80004242:	c0 30       	breq	80004248 <uhd_disable+0xa8>
80004244:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004248:	d5 03       	csrf	0x10
8000424a:	cf db       	rjmp	80004244 <uhd_disable+0xa4>

8000424c <uhd_ctrl_request_end>:
8000424c:	eb cd 40 f8 	pushm	r3-r7,lr
80004250:	20 2d       	sub	sp,8
80004252:	30 08       	mov	r8,0
80004254:	18 93       	mov	r3,r12
80004256:	e0 64 28 d0 	mov	r4,10448
	irqflags_t flags;
	uhd_callback_setup_end_t callback_end;
	struct uhd_ctrl_request_t *request_to_free;
	bool b_new_request;

	uhd_ctrl_request_timeout = 0;
8000425a:	e0 67 28 c4 	mov	r7,10436

	// Remove request from the control request list
	callback_end = uhd_ctrl_request_first->callback_end;
8000425e:	a8 08       	st.h	r4[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004260:	6e 0c       	ld.w	r12,r7[0x0]
80004262:	78 65       	ld.w	r5,r12[0x18]
	cpu_irq_disable();
80004264:	e1 b8 00 00 	mfsr	r8,0x0
	request_to_free = uhd_ctrl_request_first;
	flags = cpu_irq_save();
	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;
80004268:	d3 03       	ssrf	0x10
8000426a:	6e 09       	ld.w	r9,r7[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000426c:	72 76       	ld.w	r6,r9[0x1c]
8000426e:	8f 06       	st.w	r7[0x0],r6
80004270:	ed b8 00 10 	bld	r8,0x10
	b_new_request = (uhd_ctrl_request_first != NULL);
	cpu_irq_restore(flags);
	free(request_to_free);
80004274:	e0 81 00 c2 	brne	800043f8 <uhd_ctrl_request_end+0x1ac>

	// Call callback
	if (callback_end != NULL) {
80004278:	e0 a0 52 7c 	rcall	8000e770 <free>
		callback_end(uhd_get_configured_address(0), status, uhd_ctrl_nb_trans);
8000427c:	58 05       	cp.w	r5,0
8000427e:	c0 b0       	breq	80004294 <uhd_ctrl_request_end+0x48>
80004280:	fe 68 04 24 	mov	r8,-130012
80004284:	70 0c       	ld.w	r12,r8[0x0]
80004286:	e0 68 28 c8 	mov	r8,10440
8000428a:	06 9b       	mov	r11,r3
8000428c:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
	}

	// If a setup request is pending and no started by previous callback
	if (b_new_request) {
80004290:	90 8a       	ld.uh	r10,r8[0x0]
		usb_setup_req_t req;
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
80004292:	5d 15       	icall	r5
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80004294:	58 06       	cp.w	r6,0
80004296:	c3 50       	breq	80004300 <uhd_ctrl_request_end+0xb4>
		usb_setup_req_t req;
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
80004298:	e0 68 28 c0 	mov	r8,10432
8000429c:	6e 0b       	ld.w	r11,r7[0x0]
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
8000429e:	30 8a       	mov	r10,8
800042a0:	30 07       	mov	r7,0
800042a2:	2f fb       	sub	r11,-1

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
	uhd_ctrl_nb_trans = 0;
800042a4:	91 07       	st.w	r8[0x0],r7
800042a6:	1a 9c       	mov	r12,sp
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800042a8:	e0 a0 54 8e 	rcall	8000ebc4 <memcpy>
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
800042ac:	e0 68 28 c8 	mov	r8,10440

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
800042b0:	b0 07       	st.h	r8[0x0],r7
800042b2:	fe 68 00 00 	mov	r8,-131072
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800042b6:	40 09       	lddsp	r9,sp[0x0]
800042b8:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
800042bc:	5c ca       	swap.bh	r10
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
800042be:	5c 8a       	casts.h	r10

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
800042c0:	f0 fb 04 1c 	ld.w	r11,r8[1052]
800042c4:	f3 da d0 10 	bfins	r9,r10,0x0,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800042c8:	40 18       	lddsp	r8,sp[0x4]
800042ca:	f0 0a 14 10 	asr	r10,r8,0x10
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
800042ce:	5c ca       	swap.bh	r10
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
800042d0:	5c 8a       	casts.h	r10
800042d2:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800042d6:	f1 da d2 10 	bfins	r8,r10,0x10,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800042da:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
800042de:	5c ca       	swap.bh	r10
800042e0:	5c 8a       	casts.h	r10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800042e2:	58 0b       	cp.w	r11,0
800042e4:	c0 c0       	breq	800042fc <uhd_ctrl_request_end+0xb0>
800042e6:	fe 6b 04 24 	mov	r11,-130012
800042ea:	76 0b       	ld.w	r11,r11[0x0]
800042ec:	e0 6c 28 c4 	mov	r12,10436
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
		uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
800042f0:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7

	// If a setup request is pending and no started by previous callback
	if (b_new_request) {
		uhd_ctrl_phase_setup();
	}
	if (uhd_b_suspend_requested) {
800042f4:	78 0c       	ld.w	r12,r12[0x0]
800042f6:	19 8c       	ld.ub	r12,r12[0x0]
800042f8:	16 3c       	cp.w	r12,r11
800042fa:	c0 d0       	breq	80004314 <uhd_ctrl_request_end+0xc8>
800042fc:	30 1c       	mov	r12,1
800042fe:	ca 7f       	rcall	8000424c <uhd_ctrl_request_end>
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
80004300:	e0 68 07 07 	mov	r8,1799
80004304:	30 09       	mov	r9,0
		return; // Endpoint not valid
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
80004306:	11 8a       	ld.ub	r10,r8[0x0]
80004308:	f2 0a 18 00 	cp.b	r10,r9
8000430c:	c2 51       	brne	80004356 <uhd_ctrl_request_end+0x10a>
8000430e:	2f ed       	sub	sp,-8
80004310:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80004314:	fe 6c 05 00 	mov	r12,-129792
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
	uhd_ack_setup_ready(0);
80004318:	78 0b       	ld.w	r11,r12[0x0]
8000431a:	e0 1b fc ff 	andl	r11,0xfcff
	Assert(sizeof(setup) == sizeof(uint64_t));
	ptr_ep_data = (volatile uint64_t *)&uhd_get_pipe_fifo_access(0, 64);
	*ptr_ep_data = setup.value64;
8000431e:	99 0b       	st.w	r12[0x0],r11
80004320:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
80004324:	30 4c       	mov	r12,4
80004326:	fe 6b 05 60 	mov	r11,-129696

	uhd_ctrl_request_timeout = 5000;
8000432a:	97 0c       	st.w	r11[0x0],r12
8000432c:	10 9a       	mov	r10,r8
8000432e:	12 9b       	mov	r11,r9
	uhd_enable_setup_ready_interrupt(0);
80004330:	fc 18 e0 00 	movh	r8,0xe000
80004334:	f0 eb 00 00 	st.d	r8[0],r10
	uhd_ack_fifocon(0);
80004338:	e0 68 13 88 	mov	r8,5000
8000433c:	a8 08       	st.h	r4[0x0],r8
8000433e:	fe 68 05 f0 	mov	r8,-129552
	uhd_unfreeze_pipe(0);
80004342:	91 0c       	st.w	r8[0x0],r12
80004344:	e0 69 40 00 	mov	r9,16384
	if (b_new_request) {
		uhd_ctrl_phase_setup();
	}
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
80004348:	fe 68 06 20 	mov	r8,-129504
	uhd_start_reset();
}

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
8000434c:	91 09       	st.w	r8[0x0],r9
8000434e:	e2 69 00 00 	mov	r9,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80004352:	91 09       	st.w	r8[0x0],r9
80004354:	cd 6b       	rjmp	80004300 <uhd_ctrl_request_end+0xb4>
		uhd_freeze_pipe(pipe);
80004356:	b0 89       	st.b	r8[0x0],r9
80004358:	88 09       	ld.sh	r9,r4[0x0]
8000435a:	58 09       	cp.w	r9,0
8000435c:	c5 01       	brne	800043fc <uhd_ctrl_request_end+0x1b0>
8000435e:	fe 69 05 c4 	mov	r9,-129596
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80004362:	72 07       	ld.w	r7,r9[0x0]
80004364:	fe 69 05 f4 	mov	r9,-129548
		uhd_freeze_pipe(pipe);
80004368:	e2 68 00 00 	mov	r8,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8000436c:	93 08       	st.w	r9[0x0],r8
8000436e:	fe 69 05 c8 	mov	r9,-129592
		uhd_freeze_pipe(pipe);
80004372:	72 0c       	ld.w	r12,r9[0x0]
80004374:	fe 69 05 f8 	mov	r9,-129544
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80004378:	93 08       	st.w	r9[0x0],r8
8000437a:	fe 69 05 cc 	mov	r9,-129588
		uhd_freeze_pipe(pipe);
8000437e:	72 0b       	ld.w	r11,r9[0x0]
80004380:	fe 69 05 fc 	mov	r9,-129540
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80004384:	93 08       	st.w	r9[0x0],r8
80004386:	fe 69 05 d0 	mov	r9,-129584
8000438a:	72 0a       	ld.w	r10,r9[0x0]
8000438c:	fe 69 06 00 	mov	r9,-129536
		uhd_freeze_pipe(pipe);
80004390:	93 08       	st.w	r9[0x0],r8
80004392:	10 57       	eor	r7,r8
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80004394:	10 5c       	eor	r12,r8
80004396:	10 5b       	eor	r11,r8
80004398:	10 5a       	eor	r10,r8
		uhd_freeze_pipe(pipe);
8000439a:	fe 69 05 d4 	mov	r9,-129580
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8000439e:	fe 66 06 04 	mov	r6,-129532
800043a2:	72 09       	ld.w	r9,r9[0x0]
800043a4:	ef d7 c2 21 	bfextu	r7,r7,0x11,0x1
800043a8:	8d 08       	st.w	r6[0x0],r8
800043aa:	10 59       	eor	r9,r8
800043ac:	f9 dc c2 21 	bfextu	r12,r12,0x11,0x1
800043b0:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
800043b4:	a3 6c       	lsl	r12,0x2
800043b6:	f7 db c2 21 	bfextu	r11,r11,0x11,0x1
800043ba:	f9 e7 10 17 	or	r7,r12,r7<<0x1
800043be:	f5 da c2 21 	bfextu	r10,r10,0x11,0x1
800043c2:	ef eb 10 3b 	or	r11,r7,r11<<0x3
800043c6:	f7 ea 10 4a 	or	r10,r11,r10<<0x4
800043ca:	f5 e9 10 5a 	or	r10,r10,r9<<0x5
800043ce:	fe 69 05 d8 	mov	r9,-129576
		uhd_freeze_pipe(pipe);
800043d2:	72 09       	ld.w	r9,r9[0x0]
800043d4:	10 59       	eor	r9,r8
800043d6:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
	}
	// Wait three SOFs before entering in suspend state
	uhd_suspend_start = 3;
800043da:	f5 e9 10 69 	or	r9,r10,r9<<0x6
800043de:	fe 6a 06 08 	mov	r10,-129528
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
800043e2:	95 08       	st.w	r10[0x0],r8
800043e4:	e0 68 07 05 	mov	r8,1797
      cpu_irq_enable();
800043e8:	b0 89       	st.b	r8[0x0],r9

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
800043ea:	30 39       	mov	r9,3
800043ec:	e0 68 07 04 	mov	r8,1796
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
800043f0:	b0 89       	st.b	r8[0x0],r9
800043f2:	2f ed       	sub	sp,-8
800043f4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800043f8:	d5 03       	csrf	0x10
800043fa:	c3 fb       	rjmp	80004278 <uhd_ctrl_request_end+0x2c>
800043fc:	30 19       	mov	r9,1
800043fe:	b0 89       	st.b	r8[0x0],r9
80004400:	2f ed       	sub	sp,-8
80004402:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004406:	d7 03       	nop

80004408 <uhd_setup_request>:
80004408:	eb cd 40 fc 	pushm	r2-r7,lr
8000440c:	20 3d       	sub	sp,12
8000440e:	18 97       	mov	r7,r12
80004410:	50 0b       	stdsp	sp[0x0],r11
80004412:	14 92       	mov	r2,r10
80004414:	12 96       	mov	r6,r9
80004416:	10 93       	mov	r3,r8
		usb_setup_req_t *req,
		uint8_t *payload,
		uint16_t payload_size,
		uhd_callback_setup_run_t callback_run,
		uhd_callback_setup_end_t callback_end)
{
80004418:	40 a4       	lddsp	r4,sp[0x28]
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
8000441a:	32 0c       	mov	r12,32
8000441c:	e0 a0 51 b2 	rcall	8000e780 <malloc>
	if (request == NULL) {
80004420:	40 0b       	lddsp	r11,sp[0x0]
{
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
80004422:	18 95       	mov	r5,r12
	if (request == NULL) {
80004424:	c5 c0       	breq	800044dc <uhd_setup_request+0xd4>
		Assert(false);
		return false;
	}

	// Fill structure
	request->add = (uint8_t) add;
80004426:	18 c7       	st.b	r12++,r7
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
80004428:	30 8a       	mov	r10,8
8000442a:	e0 a0 53 cd 	rcall	8000ebc4 <memcpy>
	request->payload = payload;
	request->payload_size = payload_size;
	request->callback_run = callback_run;
	request->callback_end = callback_end;
	request->next_request = NULL;
8000442e:	30 08       	mov	r8,0
	}

	// Fill structure
	request->add = (uint8_t) add;
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
	request->payload = payload;
80004430:	8b 32       	st.w	r5[0xc],r2
	request->payload_size = payload_size;
80004432:	eb 56 00 10 	st.h	r5[16],r6
	request->callback_run = callback_run;
80004436:	8b 53       	st.w	r5[0x14],r3
	request->callback_end = callback_end;
80004438:	8b 64       	st.w	r5[0x18],r4
	request->next_request = NULL;
8000443a:	8b 78       	st.w	r5[0x1c],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000443c:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
80004440:	d3 03       	ssrf	0x10

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
80004442:	e0 69 28 c4 	mov	r9,10436
80004446:	72 0a       	ld.w	r10,r9[0x0]
80004448:	58 0a       	cp.w	r10,0
		uhd_ctrl_request_first = request;
		b_start_request = true;
	} else {
		uhd_ctrl_request_last->next_request = request;
8000444a:	c6 f0       	breq	80004528 <uhd_setup_request+0x120>
8000444c:	10 9a       	mov	r10,r8
8000444e:	e0 68 28 cc 	mov	r8,10444
	}
	uhd_ctrl_request_last = request;
80004452:	70 0c       	ld.w	r12,r8[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004454:	99 75       	st.w	r12[0x1c],r5
80004456:	91 05       	st.w	r8[0x0],r5
80004458:	ed bb 00 10 	bld	r11,0x10
	cpu_irq_restore(flags);

	if (b_start_request) {
8000445c:	c3 e1       	brne	800044d8 <uhd_setup_request+0xd0>
	*ptr_ep_data = setup.value64;

	uhd_ctrl_request_timeout = 5000;
	uhd_enable_setup_ready_interrupt(0);
	uhd_ack_fifocon(0);
	uhd_unfreeze_pipe(0);
8000445e:	58 0a       	cp.w	r10,0
80004460:	c0 41       	brne	80004468 <uhd_setup_request+0x60>
80004462:	2f dd       	sub	sp,-12
		usb_setup_req_t req;
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
80004464:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80004468:	e0 68 28 c0 	mov	r8,10432
8000446c:	72 0b       	ld.w	r11,r9[0x0]
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
8000446e:	30 07       	mov	r7,0
80004470:	2f fb       	sub	r11,-1
80004472:	91 07       	st.w	r8[0x0],r7
80004474:	30 8a       	mov	r10,8
80004476:	fa cc ff fc 	sub	r12,sp,-4

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
	uhd_ctrl_nb_trans = 0;
8000447a:	e0 a0 53 a5 	rcall	8000ebc4 <memcpy>
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
8000447e:	e0 68 28 c8 	mov	r8,10440

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
80004482:	b0 07       	st.h	r8[0x0],r7
80004484:	fe 68 00 00 	mov	r8,-131072
80004488:	40 19       	lddsp	r9,sp[0x4]
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
8000448a:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
8000448e:	5c ca       	swap.bh	r10
80004490:	5c 8a       	casts.h	r10
		uint64_t value64;
	} setup;
	volatile uint64_t *ptr_ep_data;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80004492:	f0 fb 04 1c 	ld.w	r11,r8[1052]

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
80004496:	f3 da d0 10 	bfins	r9,r10,0x0,0x10
8000449a:	40 28       	lddsp	r8,sp[0x8]
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
8000449c:	f0 0a 14 10 	asr	r10,r8,0x10
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
800044a0:	5c ca       	swap.bh	r10
800044a2:	5c 8a       	casts.h	r10
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
800044a4:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800044a8:	f1 da d2 10 	bfins	r8,r10,0x10,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800044ac:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
800044b0:	5c ca       	swap.bh	r10
800044b2:	5c 8a       	casts.h	r10
800044b4:	58 0b       	cp.w	r11,0
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800044b6:	c0 c0       	breq	800044ce <uhd_setup_request+0xc6>
800044b8:	fe 6b 04 24 	mov	r11,-130012
800044bc:	76 0b       	ld.w	r11,r11[0x0]
800044be:	e0 6c 28 c4 	mov	r12,10436
800044c2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
		uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
800044c6:	78 0c       	ld.w	r12,r12[0x0]
800044c8:	19 8c       	ld.ub	r12,r12[0x0]
800044ca:	16 3c       	cp.w	r12,r11
800044cc:	c0 b0       	breq	800044e2 <uhd_setup_request+0xda>
800044ce:	30 1c       	mov	r12,1
      cpu_irq_enable();
800044d0:	cb ee       	rcall	8000424c <uhd_ctrl_request_end>
800044d2:	2f dd       	sub	sp,-12
	if (b_start_request) {
		// Start immediately request
		uhd_ctrl_phase_setup();
	}
	return true;
}
800044d4:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800044d8:	d5 03       	csrf	0x10
		return; // Endpoint not valid
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
800044da:	cc 2b       	rjmp	8000445e <uhd_setup_request+0x56>
800044dc:	2f dd       	sub	sp,-12
800044de:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800044e2:	fe 6c 05 00 	mov	r12,-129792
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
800044e6:	78 0b       	ld.w	r11,r12[0x0]
800044e8:	e0 1b fc ff 	andl	r11,0xfcff
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
	uhd_ack_setup_ready(0);
800044ec:	99 0b       	st.w	r12[0x0],r11
800044ee:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
	Assert(sizeof(setup) == sizeof(uint64_t));
	ptr_ep_data = (volatile uint64_t *)&uhd_get_pipe_fifo_access(0, 64);
	*ptr_ep_data = setup.value64;
800044f2:	30 4c       	mov	r12,4
800044f4:	fe 6b 05 60 	mov	r11,-129696
800044f8:	97 0c       	st.w	r11[0x0],r12
800044fa:	10 9a       	mov	r10,r8
800044fc:	12 9b       	mov	r11,r9

	uhd_ctrl_request_timeout = 5000;
800044fe:	fc 18 e0 00 	movh	r8,0xe000
80004502:	f0 eb 00 00 	st.d	r8[0],r10
	uhd_enable_setup_ready_interrupt(0);
80004506:	e0 69 13 88 	mov	r9,5000
8000450a:	e0 68 28 d0 	mov	r8,10448
	uhd_ack_fifocon(0);
8000450e:	b0 09       	st.h	r8[0x0],r9
80004510:	fe 68 05 f0 	mov	r8,-129552
80004514:	91 0c       	st.w	r8[0x0],r12
	uhd_unfreeze_pipe(0);
80004516:	e0 69 40 00 	mov	r9,16384
8000451a:	fe 68 06 20 	mov	r8,-129504
	request->next_request = NULL;

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
		uhd_ctrl_request_first = request;
8000451e:	91 09       	st.w	r8[0x0],r9
80004520:	e2 69 00 00 	mov	r9,131072
80004524:	91 09       	st.w	r8[0x0],r9
80004526:	c9 eb       	rjmp	80004462 <uhd_setup_request+0x5a>
80004528:	93 05       	st.w	r9[0x0],r5
8000452a:	30 1a       	mov	r10,1
8000452c:	e0 68 28 cc 	mov	r8,10444
80004530:	c9 3b       	rjmp	80004456 <uhd_setup_request+0x4e>
80004532:	d7 03       	nop

80004534 <uhd_ep_abort_pipe>:
80004534:	eb cd 40 c0 	pushm	r6-r7,lr
80004538:	fe 68 00 00 	mov	r8,-131072
8000453c:	e0 79 00 00 	mov	r9,65536
80004540:	f0 fa 04 1c 	ld.w	r10,r8[1052]
80004544:	f2 0c 09 49 	lsl	r9,r9,r12
 * \param status Reason of abort
 */
static void uhd_ep_abort_pipe(uint8_t pipe, uhd_trans_status_t status)
{
	// Stop transfer
	uhd_reset_pipe(pipe);
80004548:	f3 ea 10 0a 	or	r10,r9,r10
8000454c:	f1 4a 04 1c 	st.w	r8[1052],r10
80004550:	f0 fa 04 1c 	ld.w	r10,r8[1052]
80004554:	5c d9       	com	r9
80004556:	14 69       	and	r9,r10

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
80004558:	fe 6a 05 00 	mov	r10,-129792
 * \param status Reason of abort
 */
static void uhd_ep_abort_pipe(uint8_t pipe, uhd_trans_status_t status)
{
	// Stop transfer
	uhd_reset_pipe(pipe);
8000455c:	f1 49 04 1c 	st.w	r8[1052],r9

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
80004560:	f8 08 15 02 	lsl	r8,r12,0x2
80004564:	f0 0a 00 0e 	add	lr,r8,r10
	uhd_enable_stall_interrupt(pipe);
80004568:	fe 6a 05 f0 	mov	r10,-129552
{
	// Stop transfer
	uhd_reset_pipe(pipe);

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
8000456c:	7c 09       	ld.w	r9,lr[0x0]
8000456e:	ab a9       	sbr	r9,0xa
80004570:	9d 09       	st.w	lr[0x0],r9
	uhd_enable_stall_interrupt(pipe);
80004572:	f0 0a 00 09 	add	r9,r8,r10
80004576:	34 0a       	mov	r10,64
80004578:	93 0a       	st.w	r9[0x0],r10
	uhd_enable_pipe_error_interrupt(pipe);

	uhd_disable_out_ready_interrupt(pipe);
8000457a:	e0 38 f9 e0 	sub	r8,129504
	uhd_reset_pipe(pipe);

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
	uhd_enable_stall_interrupt(pipe);
	uhd_enable_pipe_error_interrupt(pipe);
8000457e:	30 8a       	mov	r10,8
80004580:	93 0a       	st.w	r9[0x0],r10

	uhd_disable_out_ready_interrupt(pipe);
80004582:	30 29       	mov	r9,2
80004584:	91 09       	st.w	r8[0x0],r9
	uhd_pipe_dma_set_control(pipe, 0);
80004586:	f8 08 15 04 	lsl	r8,r12,0x4
8000458a:	e0 38 f9 00 	sub	r8,129280
8000458e:	30 09       	mov	r9,0
80004590:	91 29       	st.w	r8[0x8],r9
static void uhd_pipe_finish_job(uint8_t pipe, uhd_trans_status_t status)
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
80004592:	e0 68 06 8c 	mov	r8,1676
80004596:	f8 ca 00 01 	sub	r10,r12,1
8000459a:	f4 0a 00 2a 	add	r10,r10,r10<<0x2
8000459e:	f0 0a 00 2a 	add	r10,r8,r10<<0x2
	if (ptr_job->busy == false) {
800045a2:	74 08       	ld.w	r8,r10[0x0]
800045a4:	58 08       	cp.w	r8,0
		return; // No job running
	}
	ptr_job->busy = false;
800045a6:	c2 b4       	brge	800045fc <uhd_ep_abort_pipe+0xc8>
800045a8:	f1 d9 d3 e1 	bfins	r8,r9,0x1f,0x1
	if (NULL == ptr_job->call_end) {
800045ac:	95 08       	st.w	r10[0x0],r8
800045ae:	74 48       	ld.w	r8,r10[0x10]
800045b0:	58 08       	cp.w	r8,0
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
800045b2:	c2 50       	breq	800045fc <uhd_ep_abort_pipe+0xc8>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800045b4:	7c 06       	ld.w	r6,lr[0x0]
800045b6:	74 39       	ld.w	r9,r10[0xc]
			uhd_get_pipe_endpoint_address(pipe),
800045b8:	16 9a       	mov	r10,r11
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800045ba:	7c 0b       	ld.w	r11,lr[0x0]
800045bc:	fd d6 c2 04 	bfextu	lr,r6,0x10,0x4
800045c0:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
800045c4:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
800045c8:	a3 77       	lsl	r7,0x3
800045ca:	e0 66 00 80 	mov	r6,128
800045ce:	e2 1c 03 fc 	andl	r12,0x3fc,COH
800045d2:	58 1b       	cp.w	r11,1
800045d4:	ec 0b 17 00 	moveq	r11,r6
800045d8:	f9 bb 01 00 	movne	r11,0
800045dc:	e0 3c fb dc 	sub	r12,130012
800045e0:	1c 4b       	or	r11,lr
800045e2:	78 0c       	ld.w	r12,r12[0x0]
800045e4:	37 fe       	mov	lr,127
800045e6:	fc 07 09 4e 	lsl	lr,lr,r7
800045ea:	fd ec 00 0c 	and	r12,lr,r12
800045ee:	5c 9e       	brev	lr
800045f0:	fc 0e 12 00 	clz	lr,lr
800045f4:	f8 0e 0a 4c 	lsr	r12,r12,lr
800045f8:	5c 5c       	castu.b	r12
800045fa:	5d 18       	icall	r8
800045fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80004600 <uhd_ep_free>:
80004600:	d4 31       	pushm	r0-r7,lr
80004602:	20 2d       	sub	sp,8
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80004604:	30 17       	mov	r7,1
80004606:	18 91       	mov	r1,r12
80004608:	16 90       	mov	r0,r11
8000460a:	30 06       	mov	r6,0
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
8000460c:	fe 65 00 00 	mov	r5,-131072
80004610:	0e 94       	mov	r4,r7
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80004612:	30 63       	mov	r3,6
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004614:	37 f2       	mov	r2,127
			continue;
		}
		if (endp != 0xFF) {
80004616:	3f f8       	mov	r8,-1
80004618:	c0 48       	rjmp	80004620 <uhd_ep_free+0x20>
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
8000461a:	2f f7       	sub	r7,-1
8000461c:	2f f6       	sub	r6,-1
8000461e:	5c 57       	castu.b	r7
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80004620:	ea fa 04 1c 	ld.w	r10,r5[1052]
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80004624:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80004628:	e8 0c 09 49 	lsl	r9,r4,r12
8000462c:	f3 ea 00 0a 	and	r10,r9,r10
80004630:	c1 50       	breq	8000465a <uhd_ep_free+0x5a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004632:	18 9a       	mov	r10,r12
80004634:	e2 1a 00 fc 	andl	r10,0xfc,COH
80004638:	e0 3a fb dc 	sub	r10,130012
8000463c:	74 0b       	ld.w	r11,r10[0x0]
8000463e:	f5 dc c0 02 	bfextu	r10,r12,0x0,0x2
80004642:	a3 7a       	lsl	r10,0x3
80004644:	e4 0a 09 4a 	lsl	r10,r2,r10
80004648:	f5 eb 00 0b 	and	r11,r10,r11
8000464c:	5c 9a       	brev	r10
8000464e:	f4 0a 12 00 	clz	r10,r10
80004652:	f6 0a 0a 4a 	lsr	r10,r11,r10
80004656:	14 31       	cp.w	r1,r10
80004658:	c0 70       	breq	80004666 <uhd_ep_free+0x66>
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
8000465a:	e6 07 18 00 	cp.b	r7,r3
8000465e:	fe 98 ff de 	brls	8000461a <uhd_ep_free+0x1a>
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
	}
}
80004662:	2f ed       	sub	sp,-8
80004664:	d8 32       	popm	r0-r7,pc
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
80004666:	f0 00 18 00 	cp.b	r0,r8
8000466a:	c2 d0       	breq	800046c4 <uhd_ep_free+0xc4>
			// Disable specific endpoint number
			if (endp != uhd_get_pipe_endpoint_address(pipe)) {
8000466c:	f8 0a 15 02 	lsl	r10,r12,0x2
80004670:	e0 3a fb 00 	sub	r10,129792
80004674:	74 0e       	ld.w	lr,r10[0x0]
80004676:	fd de c2 04 	bfextu	lr,lr,0x10,0x4
8000467a:	74 0b       	ld.w	r11,r10[0x0]
8000467c:	50 0e       	stdsp	sp[0x0],lr
8000467e:	e0 6e 00 80 	mov	lr,128
80004682:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80004686:	58 1b       	cp.w	r11,1
80004688:	fc 0b 17 00 	moveq	r11,lr
8000468c:	f9 bb 01 00 	movne	r11,0
80004690:	40 0e       	lddsp	lr,sp[0x0]
80004692:	1c 4b       	or	r11,lr
80004694:	16 30       	cp.w	r0,r11
80004696:	ce 21       	brne	8000465a <uhd_ep_free+0x5a>
				continue; // Mismatch
			}
		}
		// Unalloc pipe
		uhd_disable_pipe(pipe);
80004698:	ea fb 04 1c 	ld.w	r11,r5[1052]
8000469c:	5c d9       	com	r9
8000469e:	16 69       	and	r9,r11
800046a0:	eb 49 04 1c 	st.w	r5[1052],r9
		uhd_unallocate_memory(pipe);
800046a4:	74 09       	ld.w	r9,r10[0x0]
800046a6:	a1 d9       	cbr	r9,0x1
800046a8:	95 09       	st.w	r10[0x0],r9

		// Stop transfer on this pipe
#ifndef USB_HOST_HUB_SUPPORT
		if (pipe == 0) {
800046aa:	58 0c       	cp.w	r12,0
800046ac:	c1 11       	brne	800046ce <uhd_ep_free+0xce>
			// Endpoint control
			if (uhd_ctrl_request_timeout) {
800046ae:	e0 6a 28 d0 	mov	r10,10448
800046b2:	94 09       	ld.sh	r9,r10[0x0]
800046b4:	58 09       	cp.w	r9,0
				uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
800046b6:	cd 20       	breq	8000465a <uhd_ep_free+0x5a>
800046b8:	50 18       	stdsp	sp[0x4],r8
800046ba:	30 1c       	mov	r12,1
800046bc:	fe b0 fd c8 	rcall	8000424c <uhd_ctrl_request_end>
800046c0:	40 18       	lddsp	r8,sp[0x4]
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
800046c2:	ca cb       	rjmp	8000461a <uhd_ep_free+0x1a>
800046c4:	f8 0a 15 02 	lsl	r10,r12,0x2
800046c8:	e0 3a fb 00 	sub	r10,129792
			}
			continue;
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
800046cc:	ce 6b       	rjmp	80004698 <uhd_ep_free+0x98>
800046ce:	50 18       	stdsp	sp[0x4],r8
800046d0:	30 1b       	mov	r11,1
800046d2:	c3 1f       	rcall	80004534 <uhd_ep_abort_pipe>
800046d4:	40 18       	lddsp	r8,sp[0x4]
800046d6:	cc 2b       	rjmp	8000465a <uhd_ep_free+0x5a>

800046d8 <uhd_pipe_trans_complet>:
800046d8:	eb cd 40 f8 	pushm	r3-r7,lr
800046dc:	e0 69 06 8c 	mov	r9,1676
800046e0:	f8 c8 00 01 	sub	r8,r12,1
	iram_size_t max_trans;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
800046e4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800046e8:	f2 08 00 28 	add	r8,r9,r8<<0x2

	if (!ptr_job->busy) {
800046ec:	70 0a       	ld.w	r10,r8[0x0]
800046ee:	58 0a       	cp.w	r10,0
800046f0:	e0 84 00 8c 	brge	80004808 <uhd_pipe_trans_complet+0x130>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
800046f4:	70 39       	ld.w	r9,r8[0xc]
800046f6:	70 26       	ld.w	r6,r8[0x8]
800046f8:	0c 39       	cp.w	r9,r6
800046fa:	e0 80 00 89 	breq	8000480c <uhd_pipe_trans_complet+0x134>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
800046fe:	fe 67 05 00 	mov	r7,-129792
80004702:	f8 0e 15 02 	lsl	lr,r12,0x2
80004706:	fc 07 00 0b 	add	r11,lr,r7
8000470a:	76 07       	ld.w	r7,r11[0x0]
8000470c:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
80004710:	58 17       	cp.w	r7,1
80004712:	e0 80 00 d5 	breq	800048bc <uhd_pipe_trans_complet+0x1e4>
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
				 max_trans = 256L * uhd_get_pipe_size(pipe);
80004716:	e0 77 00 00 	mov	r7,65536
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
8000471a:	12 16       	sub	r6,r9
8000471c:	0c 37       	cp.w	r7,r6
8000471e:	ec 07 17 b0 	movhi	r7,r6
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
80004722:	e0 57 00 00 	cp.w	r7,65536
80004726:	e0 80 00 c9 	breq	800048b8 <uhd_pipe_trans_complet+0x1e0>
			// Set 0 to transfer the maximum
			uhd_dma_ctrl = (0 <<
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		} else {
			uhd_dma_ctrl = (next_trans <<
8000472a:	ee 06 15 10 	lsl	r6,r7,0x10
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
8000472e:	76 05       	ld.w	r5,r11[0x0]
80004730:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80004734:	58 25       	cp.w	r5,2
80004736:	e0 80 00 b0 	breq	80004896 <uhd_pipe_trans_complet+0x1be>
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
8000473a:	76 0a       	ld.w	r10,r11[0x0]
8000473c:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
80004740:	58 1a       	cp.w	r10,1
80004742:	e0 80 00 d0 	breq	800048e2 <uhd_pipe_trans_complet+0x20a>
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
				// Enable short packet reception
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOT_IRQ_EN_MASK
80004746:	e8 16 00 14 	orl	r6,0x14
						| AVR32_USBB_UHDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
8000474a:	70 1a       	ld.w	r10,r8[0x4]
8000474c:	f4 09 00 09 	add	r9,r10,r9
80004750:	f8 0a 15 04 	lsl	r10,r12,0x4
80004754:	e0 3a f9 00 	sub	r10,129280
80004758:	95 19       	st.w	r10[0x4],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000475a:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
8000475e:	d3 03       	ssrf	0x10
				AVR32_USBB_UHDMA1_CONTROL_CH_EN_MASK;

		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
80004760:	74 39       	ld.w	r9,r10[0xc]
80004762:	ed b9 00 04 	bld	r9,0x4
80004766:	c1 a0       	breq	8000479a <uhd_pipe_trans_complet+0xc2>
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
80004768:	76 09       	ld.w	r9,r11[0x0]
8000476a:	f3 d9 c1 02 	bfextu	r9,r9,0x8,0x2
8000476e:	58 19       	cp.w	r9,1
80004770:	c7 70       	breq	8000485e <uhd_pipe_trans_complet+0x186>
				uhd_in_request_number(pipe,
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
80004772:	e0 3e f9 e0 	sub	lr,129504
80004776:	e0 69 10 00 	mov	r9,4096
8000477a:	9d 09       	st.w	lr[0x0],r9
			uhd_unfreeze_pipe(pipe);
8000477c:	e2 69 00 00 	mov	r9,131072
80004780:	9d 09       	st.w	lr[0x0],r9
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
		uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80004782:	e8 16 00 21 	orl	r6,0x21
				uhd_in_request_number(pipe,
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
			uhd_unfreeze_pipe(pipe);
			uhd_pipe_dma_set_control(pipe, uhd_dma_ctrl);
80004786:	95 26       	st.w	r10[0x8],r6
			ptr_job->nb_trans += next_trans;
80004788:	70 39       	ld.w	r9,r8[0xc]
8000478a:	f2 07 00 07 	add	r7,r9,r7
8000478e:	91 37       	st.w	r8[0xc],r7
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004790:	e6 15 00 01 	andh	r5,0x1,COH
80004794:	c6 30       	breq	8000485a <uhd_pipe_trans_complet+0x182>
			cpu_irq_restore(flags);
			return;
80004796:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000479a:	e6 15 00 01 	andh	r5,0x1,COH
8000479e:	c0 21       	brne	800047a2 <uhd_pipe_trans_complet+0xca>
      cpu_irq_enable();
800047a0:	d5 03       	csrf	0x10
		}
		cpu_irq_restore(flags);
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
800047a2:	70 39       	ld.w	r9,r8[0xc]
800047a4:	91 29       	st.w	r8[0x8],r9
	}
	if (uhd_is_pipe_out(pipe)) {
800047a6:	76 07       	ld.w	r7,r11[0x0]
		}
		cpu_irq_restore(flags);
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
800047a8:	70 0a       	ld.w	r10,r8[0x0]
	}
	if (uhd_is_pipe_out(pipe)) {
800047aa:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
800047ae:	58 27       	cp.w	r7,2
800047b0:	c3 90       	breq	80004822 <uhd_pipe_trans_complet+0x14a>
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
	if (ptr_job->busy == false) {
800047b2:	58 0a       	cp.w	r10,0
800047b4:	c2 a4       	brge	80004808 <uhd_pipe_trans_complet+0x130>
		return; // No job running
	}
	ptr_job->busy = false;
800047b6:	14 9e       	mov	lr,r10
800047b8:	30 0a       	mov	r10,0
800047ba:	fd da d3 e1 	bfins	lr,r10,0x1f,0x1
800047be:	91 0e       	st.w	r8[0x0],lr
	if (NULL == ptr_job->call_end) {
800047c0:	70 48       	ld.w	r8,r8[0x10]
800047c2:	58 08       	cp.w	r8,0
800047c4:	c2 20       	breq	80004808 <uhd_pipe_trans_complet+0x130>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
800047c6:	76 0e       	ld.w	lr,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800047c8:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
			uhd_get_pipe_endpoint_address(pipe),
800047cc:	76 06       	ld.w	r6,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800047ce:	e2 1c 03 fc 	andl	r12,0x3fc,COH
800047d2:	f7 de c2 04 	bfextu	r11,lr,0x10,0x4
800047d6:	e0 3c fb dc 	sub	r12,130012
800047da:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
800047de:	e0 6e 00 80 	mov	lr,128
800047e2:	58 16       	cp.w	r6,1
800047e4:	f4 0e 17 10 	movne	lr,r10
800047e8:	a3 77       	lsl	r7,0x3
800047ea:	fd eb 10 0b 	or	r11,lr,r11
800047ee:	78 0e       	ld.w	lr,r12[0x0]
800047f0:	37 fc       	mov	r12,127
800047f2:	f8 07 09 4c 	lsl	r12,r12,r7
800047f6:	f9 ee 00 0e 	and	lr,r12,lr
800047fa:	5c 9c       	brev	r12
800047fc:	f8 0c 12 00 	clz	r12,r12
80004800:	fc 0c 0a 4c 	lsr	r12,lr,r12
80004804:	5c 5c       	castu.b	r12
80004806:	5d 18       	icall	r8
80004808:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
8000480c:	fe 67 05 00 	mov	r7,-129792
80004810:	f8 0e 15 02 	lsl	lr,r12,0x2
80004814:	fc 07 00 0b 	add	r11,lr,r7
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}
	if (uhd_is_pipe_out(pipe)) {
80004818:	76 07       	ld.w	r7,r11[0x0]
8000481a:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
8000481e:	58 27       	cp.w	r7,2
80004820:	cc 91       	brne	800047b2 <uhd_pipe_trans_complet+0xda>
		if (ptr_job->b_shortpacket) {
80004822:	14 96       	mov	r6,r10
80004824:	e6 16 40 00 	andh	r6,0x4000,COH
80004828:	cc 50       	breq	800047b2 <uhd_pipe_trans_complet+0xda>
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			uhd_ack_out_ready(pipe);
8000482a:	fe 69 05 60 	mov	r9,-129696
8000482e:	fc 09 00 08 	add	r8,lr,r9
80004832:	91 07       	st.w	r8[0x0],r7
			if (Is_uhd_write_enabled(pipe)) {
80004834:	fe 69 05 30 	mov	r9,-129744
80004838:	fc 09 00 08 	add	r8,lr,r9
8000483c:	70 08       	ld.w	r8,r8[0x0]
8000483e:	ed b8 00 10 	bld	r8,0x10
80004842:	c0 61       	brne	8000484e <uhd_pipe_trans_complet+0x176>
				// Force interrupt in case of pipe already free
				uhd_raise_out_ready(pipe);
80004844:	fe 69 05 90 	mov	r9,-129648
80004848:	fc 09 00 08 	add	r8,lr,r9
8000484c:	91 07       	st.w	r8[0x0],r7
			}
			uhd_enable_out_ready_interrupt(pipe);
8000484e:	e0 3e fa 10 	sub	lr,129552
80004852:	30 28       	mov	r8,2
80004854:	9d 08       	st.w	lr[0x0],r8
			return;
80004856:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000485a:	d5 03       	csrf	0x10
8000485c:	c9 db       	rjmp	80004796 <uhd_pipe_trans_complet+0xbe>
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
				uhd_in_request_number(pipe,
8000485e:	fe 69 06 50 	mov	r9,-129456
80004862:	fc 09 00 0c 	add	r12,lr,r9
80004866:	78 09       	ld.w	r9,r12[0x0]
80004868:	76 03       	ld.w	r3,r11[0x0]
8000486a:	e0 19 ff 00 	andl	r9,0xff00
8000486e:	76 04       	ld.w	r4,r11[0x0]
80004870:	f7 d3 c0 83 	bfextu	r11,r3,0x4,0x3
80004874:	e9 d4 c0 83 	bfextu	r4,r4,0x4,0x3
80004878:	30 83       	mov	r3,8
8000487a:	2f d4       	sub	r4,-3
8000487c:	e6 0b 09 4b 	lsl	r11,r3,r11
80004880:	20 1b       	sub	r11,1
80004882:	0e 0b       	add	r11,r7
80004884:	f6 04 0a 4b 	lsr	r11,r11,r4
80004888:	20 1b       	sub	r11,1
8000488a:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000488e:	f7 e9 10 09 	or	r9,r11,r9
80004892:	99 09       	st.w	r12[0x0],r9
80004894:	c6 fb       	rjmp	80004772 <uhd_pipe_trans_complet+0x9a>
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
80004896:	76 05       	ld.w	r5,r11[0x0]
80004898:	30 84       	mov	r4,8
8000489a:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
8000489e:	e8 05 09 45 	lsl	r5,r4,r5
800048a2:	20 15       	sub	r5,1
800048a4:	ef e5 00 05 	and	r5,r7,r5
800048a8:	fe 90 ff 51 	breq	8000474a <uhd_pipe_trans_complet+0x72>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
800048ac:	30 05       	mov	r5,0
		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
800048ae:	08 46       	or	r6,r4
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
800048b0:	f5 d5 d3 c1 	bfins	r10,r5,0x1e,0x1
800048b4:	91 0a       	st.w	r8[0x0],r10
800048b6:	c4 ab       	rjmp	8000474a <uhd_pipe_trans_complet+0x72>
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
800048b8:	30 06       	mov	r6,0
800048ba:	c3 ab       	rjmp	8000472e <uhd_pipe_trans_complet+0x56>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
800048bc:	76 05       	ld.w	r5,r11[0x0]
800048be:	30 87       	mov	r7,8
800048c0:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
800048c4:	ee 05 09 45 	lsl	r5,r7,r5
800048c8:	ea 07 09 45 	lsl	r5,r5,r7
800048cc:	e0 45 ff ff 	cp.w	r5,65535
800048d0:	fe 99 ff 23 	brgt	80004716 <uhd_pipe_trans_complet+0x3e>
				 max_trans = 256L * uhd_get_pipe_size(pipe);
800048d4:	76 05       	ld.w	r5,r11[0x0]
800048d6:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
800048da:	ee 05 09 47 	lsl	r7,r7,r5
800048de:	a9 67       	lsl	r7,0x8
800048e0:	c1 db       	rjmp	8000471a <uhd_pipe_trans_complet+0x42>
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
800048e2:	76 0a       	ld.w	r10,r11[0x0]
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
800048e4:	30 85       	mov	r5,8
800048e6:	f5 da c0 83 	bfextu	r10,r10,0x4,0x3
800048ea:	ea 0a 09 4a 	lsl	r10,r5,r10
800048ee:	0e 3a       	cp.w	r10,r7
800048f0:	fe 93 ff 2d 	brlo	8000474a <uhd_pipe_trans_complet+0x72>
800048f4:	c2 9b       	rjmp	80004746 <uhd_pipe_trans_complet+0x6e>
800048f6:	d7 03       	nop

800048f8 <uhd_ep_run>:
800048f8:	eb cd 40 f8 	pushm	r3-r7,lr
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800048fc:	fe 6e 00 00 	mov	lr,-131072
80004900:	fc fe 04 1c 	ld.w	lr,lr[1052]
		bool b_shortpacket,
		uint8_t *buf,
		iram_size_t buf_size,
		uint16_t timeout,
		uhd_callback_trans_t callback)
{
80004904:	fa c4 ff e8 	sub	r4,sp,-24
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80004908:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
		bool b_shortpacket,
		uint8_t *buf,
		iram_size_t buf_size,
		uint16_t timeout,
		uhd_callback_trans_t callback)
{
8000490c:	68 17       	ld.w	r7,r4[0x4]
8000490e:	68 04       	ld.w	r4,r4[0x0]
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80004910:	c0 90       	breq	80004922 <uhd_ep_run+0x2a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004912:	fe 6e 04 24 	mov	lr,-130012
80004916:	7c 0e       	ld.w	lr,lr[0x0]
80004918:	fd de c0 07 	bfextu	lr,lr,0x0,0x7
8000491c:	1c 3c       	cp.w	r12,lr
8000491e:	e0 80 00 b4 	breq	80004a86 <uhd_ep_run+0x18e>
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80004922:	fe 6e 00 00 	mov	lr,-131072
80004926:	fc fe 04 1c 	ld.w	lr,lr[1052]
8000492a:	ed be 00 01 	bld	lr,0x1
8000492e:	c2 e0       	breq	8000498a <uhd_ep_run+0x92>
80004930:	fe 6e 00 00 	mov	lr,-131072
80004934:	fc fe 04 1c 	ld.w	lr,lr[1052]
80004938:	ed be 00 02 	bld	lr,0x2
8000493c:	c4 00       	breq	800049bc <uhd_ep_run+0xc4>
8000493e:	fe 6e 00 00 	mov	lr,-131072
80004942:	fc fe 04 1c 	ld.w	lr,lr[1052]
80004946:	ed be 00 03 	bld	lr,0x3
8000494a:	c5 20       	breq	800049ee <uhd_ep_run+0xf6>
8000494c:	fe 6e 00 00 	mov	lr,-131072
80004950:	fc fe 04 1c 	ld.w	lr,lr[1052]
80004954:	ed be 00 04 	bld	lr,0x4
80004958:	c6 40       	breq	80004a20 <uhd_ep_run+0x128>
8000495a:	fe 6e 00 00 	mov	lr,-131072
8000495e:	fc fe 04 1c 	ld.w	lr,lr[1052]
80004962:	ed be 00 05 	bld	lr,0x5
80004966:	c7 60       	breq	80004a52 <uhd_ep_run+0x15a>
80004968:	fe 6e 00 00 	mov	lr,-131072
8000496c:	fc fe 04 1c 	ld.w	lr,lr[1052]
80004970:	e2 1e 00 40 	andl	lr,0x40,COH
80004974:	c0 90       	breq	80004986 <uhd_ep_run+0x8e>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004976:	fe 6e 04 28 	mov	lr,-130008
8000497a:	7c 0e       	ld.w	lr,lr[0x0]
8000497c:	fd de c2 07 	bfextu	lr,lr,0x10,0x7
80004980:	1c 3c       	cp.w	r12,lr
80004982:	e0 80 00 aa 	breq	80004ad6 <uhd_ep_run+0x1de>
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
	return true;
80004986:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
8000498a:	fe 6e 04 24 	mov	lr,-130012
8000498e:	7c 0e       	ld.w	lr,lr[0x0]
80004990:	fd de c1 07 	bfextu	lr,lr,0x8,0x7
80004994:	1c 3c       	cp.w	r12,lr
80004996:	cc d1       	brne	80004930 <uhd_ep_run+0x38>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80004998:	fe 6e 05 04 	mov	lr,-129788
8000499c:	7c 06       	ld.w	r6,lr[0x0]
8000499e:	7c 05       	ld.w	r5,lr[0x0]
800049a0:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
800049a4:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
800049a8:	e0 6e 00 80 	mov	lr,128
800049ac:	58 15       	cp.w	r5,1
800049ae:	f9 be 01 00 	movne	lr,0
800049b2:	0c 4e       	or	lr,r6
800049b4:	1c 3b       	cp.w	r11,lr
800049b6:	cb d1       	brne	80004930 <uhd_ep_run+0x38>
800049b8:	30 1c       	mov	r12,1
800049ba:	c7 88       	rjmp	80004aaa <uhd_ep_run+0x1b2>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800049bc:	fe 6e 04 24 	mov	lr,-130012
800049c0:	7c 0e       	ld.w	lr,lr[0x0]
800049c2:	fd de c2 07 	bfextu	lr,lr,0x10,0x7
800049c6:	1c 3c       	cp.w	r12,lr
800049c8:	cb b1       	brne	8000493e <uhd_ep_run+0x46>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
800049ca:	fe 6e 05 08 	mov	lr,-129784
800049ce:	7c 06       	ld.w	r6,lr[0x0]
800049d0:	7c 05       	ld.w	r5,lr[0x0]
800049d2:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
800049d6:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
800049da:	e0 6e 00 80 	mov	lr,128
800049de:	58 15       	cp.w	r5,1
800049e0:	f9 be 01 00 	movne	lr,0
800049e4:	0c 4e       	or	lr,r6
800049e6:	1c 3b       	cp.w	r11,lr
800049e8:	ca b1       	brne	8000493e <uhd_ep_run+0x46>
800049ea:	30 2c       	mov	r12,2
800049ec:	c5 f8       	rjmp	80004aaa <uhd_ep_run+0x1b2>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800049ee:	fe 6e 04 24 	mov	lr,-130012
800049f2:	7c 0e       	ld.w	lr,lr[0x0]
800049f4:	fd de c3 07 	bfextu	lr,lr,0x18,0x7
800049f8:	1c 3c       	cp.w	r12,lr
800049fa:	ca 91       	brne	8000494c <uhd_ep_run+0x54>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
800049fc:	fe 6e 05 0c 	mov	lr,-129780
80004a00:	7c 06       	ld.w	r6,lr[0x0]
80004a02:	7c 05       	ld.w	r5,lr[0x0]
80004a04:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80004a08:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80004a0c:	e0 6e 00 80 	mov	lr,128
80004a10:	58 15       	cp.w	r5,1
80004a12:	f9 be 01 00 	movne	lr,0
80004a16:	0c 4e       	or	lr,r6
80004a18:	1c 3b       	cp.w	r11,lr
80004a1a:	c9 91       	brne	8000494c <uhd_ep_run+0x54>
80004a1c:	30 3c       	mov	r12,3
80004a1e:	c4 68       	rjmp	80004aaa <uhd_ep_run+0x1b2>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004a20:	fe 6e 04 28 	mov	lr,-130008
80004a24:	7c 0e       	ld.w	lr,lr[0x0]
80004a26:	fd de c0 07 	bfextu	lr,lr,0x0,0x7
80004a2a:	1c 3c       	cp.w	r12,lr
80004a2c:	c9 71       	brne	8000495a <uhd_ep_run+0x62>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80004a2e:	fe 6e 05 10 	mov	lr,-129776
80004a32:	7c 06       	ld.w	r6,lr[0x0]
80004a34:	7c 05       	ld.w	r5,lr[0x0]
80004a36:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80004a3a:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80004a3e:	e0 6e 00 80 	mov	lr,128
80004a42:	58 15       	cp.w	r5,1
80004a44:	f9 be 01 00 	movne	lr,0
80004a48:	0c 4e       	or	lr,r6
80004a4a:	1c 3b       	cp.w	r11,lr
80004a4c:	c8 71       	brne	8000495a <uhd_ep_run+0x62>
80004a4e:	30 4c       	mov	r12,4
80004a50:	c2 d8       	rjmp	80004aaa <uhd_ep_run+0x1b2>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80004a52:	fe 6e 04 28 	mov	lr,-130008
80004a56:	7c 0e       	ld.w	lr,lr[0x0]
80004a58:	fd de c1 07 	bfextu	lr,lr,0x8,0x7
80004a5c:	1c 3c       	cp.w	r12,lr
80004a5e:	c8 51       	brne	80004968 <uhd_ep_run+0x70>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80004a60:	fe 6e 05 14 	mov	lr,-129772
80004a64:	7c 06       	ld.w	r6,lr[0x0]
80004a66:	7c 05       	ld.w	r5,lr[0x0]
80004a68:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80004a6c:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80004a70:	e0 6e 00 80 	mov	lr,128
80004a74:	58 15       	cp.w	r5,1
80004a76:	f9 be 01 00 	movne	lr,0
80004a7a:	0c 4e       	or	lr,r6
80004a7c:	1c 3b       	cp.w	r11,lr
80004a7e:	fe 91 ff 75 	brne	80004968 <uhd_ep_run+0x70>
80004a82:	30 5c       	mov	r12,5
80004a84:	c1 38       	rjmp	80004aaa <uhd_ep_run+0x1b2>
80004a86:	fe 6e 05 00 	mov	lr,-129792
80004a8a:	7c 06       	ld.w	r6,lr[0x0]
80004a8c:	7c 05       	ld.w	r5,lr[0x0]
80004a8e:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80004a92:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80004a96:	e0 6e 00 80 	mov	lr,128
80004a9a:	58 15       	cp.w	r5,1
80004a9c:	f9 be 01 00 	movne	lr,0
80004aa0:	0c 4e       	or	lr,r6
80004aa2:	1c 3b       	cp.w	r11,lr
80004aa4:	fe 91 ff 3f 	brne	80004922 <uhd_ep_run+0x2a>
80004aa8:	30 0c       	mov	r12,0
	if (pipe == AVR32_USBB_EPT_NUM) {
		return false; // pipe not found
	}

	// Get job about pipe
	ptr_job = &uhd_pipe_job[pipe-1];
80004aaa:	f8 cb 00 01 	sub	r11,r12,1
80004aae:	e0 6e 06 8c 	mov	lr,1676
80004ab2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80004ab6:	fc 0b 00 2b 	add	r11,lr,r11<<0x2

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004aba:	e1 b6 00 00 	mfsr	r6,0x0
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
80004abe:	d3 03       	ssrf	0x10
80004ac0:	76 0e       	ld.w	lr,r11[0x0]
80004ac2:	1c 95       	mov	r5,lr
80004ac4:	e6 15 80 00 	andh	r5,0x8000,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004ac8:	c1 a0       	breq	80004afc <uhd_ep_run+0x204>
80004aca:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
80004ace:	c0 21       	brne	80004ad2 <uhd_ep_run+0x1da>
   }

	barrier();
80004ad0:	d5 03       	csrf	0x10
80004ad2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80004ad6:	fe 6c 05 18 	mov	r12,-129768
80004ada:	78 0e       	ld.w	lr,r12[0x0]
80004adc:	78 06       	ld.w	r6,r12[0x0]
80004ade:	fd de c2 04 	bfextu	lr,lr,0x10,0x4
80004ae2:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
80004ae6:	e0 6c 00 80 	mov	r12,128
80004aea:	58 16       	cp.w	r6,1
80004aec:	f9 bc 01 00 	movne	r12,0
80004af0:	1c 4c       	or	r12,lr
80004af2:	18 3b       	cp.w	r11,r12
80004af4:	fe 91 ff 49 	brne	80004986 <uhd_ep_run+0x8e>
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
	return true;
80004af8:	30 6c       	mov	r12,6
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false; // Job already on going
	}
	ptr_job->busy = true;
80004afa:	cd 8b       	rjmp	80004aaa <uhd_ep_run+0x1b2>
80004afc:	30 13       	mov	r3,1
80004afe:	fd d3 d3 e1 	bfins	lr,r3,0x1f,0x1

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
80004b02:	97 0e       	st.w	r11[0x0],lr
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
80004b04:	b6 14       	st.h	r11[0x2],r4
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->call_end = callback;
80004b06:	97 28       	st.w	r11[0x8],r8
	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80004b08:	97 47       	st.w	r11[0x10],r7
		return false; // Job already on going
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
80004b0a:	76 08       	ld.w	r8,r11[0x0]
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80004b0c:	97 19       	st.w	r11[0x4],r9
80004b0e:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
80004b12:	97 35       	st.w	r11[0xc],r5
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004b14:	97 08       	st.w	r11[0x0],r8
80004b16:	e6 16 00 01 	andh	r6,0x1,COH
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
80004b1a:	c0 50       	breq	80004b24 <uhd_ep_run+0x22c>
80004b1c:	fe b0 fd de 	rcall	800046d8 <uhd_pipe_trans_complet>
80004b20:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
      cpu_irq_enable();
80004b24:	d5 03       	csrf	0x10
80004b26:	cf bb       	rjmp	80004b1c <uhd_ep_run+0x224>

80004b28 <otg_interrupt>:
80004b28:	d4 31       	pushm	r0-r7,lr
80004b2a:	20 1d       	sub	sp,4
80004b2c:	fe 69 08 04 	mov	r9,-129020
ISR(otg_interrupt, AVR32_USBB_IRQ_GROUP, UHD_USB_INT_LEVEL)
{
	bool b_mode_device;

#ifdef USB_ID
	if (Is_otg_id_transition()) {
80004b30:	72 08       	ld.w	r8,r9[0x0]
80004b32:	ed b8 00 00 	bld	r8,0x0
80004b36:	c0 c0       	breq	80004b4e <otg_interrupt+0x26>
			UHC_MODE_CHANGE(true);
			uhc_start();
		}
		return;
	}
	b_mode_device = Is_otg_id_device();
80004b38:	72 08       	ld.w	r8,r9[0x0]
#else
	b_mode_device = Is_otg_device_mode_forced();
#endif

	// Redirection to host or device interrupt
	if (b_mode_device) {
80004b3a:	ed b8 00 0a 	bld	r8,0xa
80004b3e:	c2 e1       	brne	80004b9a <otg_interrupt+0x72>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
80004b40:	fe 68 00 00 	mov	r8,-131072
80004b44:	f0 f8 08 18 	ld.w	r8,r8[2072]
}
80004b48:	2f fd       	sub	sp,-4
80004b4a:	d4 32       	popm	r0-r7,lr
80004b4c:	d6 03       	rete
{
	bool b_mode_device;

#ifdef USB_ID
	if (Is_otg_id_transition()) {
		while (!Is_otg_clock_usable());
80004b4e:	72 08       	ld.w	r8,r9[0x0]
80004b50:	ed b8 00 0e 	bld	r8,0xe
80004b54:	cf d1       	brne	80004b4e <otg_interrupt+0x26>
		otg_unfreeze_clock();
80004b56:	fe 68 08 00 	mov	r8,-129024
80004b5a:	70 09       	ld.w	r9,r8[0x0]
80004b5c:	af c9       	cbr	r9,0xe
80004b5e:	91 09       	st.w	r8[0x0],r9
		otg_ack_id_transition();
80004b60:	30 1c       	mov	r12,1
80004b62:	fe 69 08 08 	mov	r9,-129016
80004b66:	93 0c       	st.w	r9[0x0],r12
		otg_freeze_clock();
80004b68:	70 09       	ld.w	r9,r8[0x0]
80004b6a:	af a9       	sbr	r9,0xe
80004b6c:	91 09       	st.w	r8[0x0],r9
		if (Is_otg_id_device()) {
80004b6e:	fe 68 08 04 	mov	r8,-129020
80004b72:	70 08       	ld.w	r8,r8[0x0]
80004b74:	ed b8 00 0a 	bld	r8,0xa
80004b78:	c0 a1       	brne	80004b8c <otg_interrupt+0x64>
			uhc_stop(false);
80004b7a:	30 0c       	mov	r12,0
80004b7c:	e0 a0 06 ea 	rcall	80005950 <uhc_stop>
			UHC_MODE_CHANGE(false);
80004b80:	30 0c       	mov	r12,0
80004b82:	e0 a0 1f b3 	rcall	80008ae8 <usb_mode_change>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80004b86:	2f fd       	sub	sp,-4
80004b88:	d4 32       	popm	r0-r7,lr
80004b8a:	d6 03       	rete
			uhc_stop(false);
			UHC_MODE_CHANGE(false);
			udc_start();
		} else {
			udc_stop();
			UHC_MODE_CHANGE(true);
80004b8c:	e0 a0 1f ae 	rcall	80008ae8 <usb_mode_change>
			uhc_start();
80004b90:	e0 a0 06 e4 	rcall	80005958 <uhc_start>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80004b94:	2f fd       	sub	sp,-4
80004b96:	d4 32       	popm	r0-r7,lr
80004b98:	d6 03       	rete
static void uhd_interrupt(void)
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
80004b9a:	fe 6a 04 04 	mov	r10,-130044
80004b9e:	74 08       	ld.w	r8,r10[0x0]
80004ba0:	ed b8 00 05 	bld	r8,0x5
80004ba4:	e0 80 00 a5 	breq	80004cee <otg_interrupt+0x1c6>
		uhd_sof_interrupt();
		return;
	}

	// Manage pipe interrupts
	pipe_int = uhd_get_interrupt_pipe_number();
80004ba8:	fe 69 00 00 	mov	r9,-131072
80004bac:	f2 f8 04 04 	ld.w	r8,r9[1028]
80004bb0:	f2 fc 04 10 	ld.w	r12,r9[1040]
80004bb4:	a9 88       	lsr	r8,0x8
80004bb6:	f1 ec 02 8c 	and	r12,r8,r12>>0x8
80004bba:	a7 bc       	sbr	r12,0x7
80004bbc:	5c 9c       	brev	r12
80004bbe:	f8 0c 12 00 	clz	r12,r12
	if (pipe_int == 0) {
80004bc2:	e0 80 00 c3 	breq	80004d48 <otg_interrupt+0x220>
		// Interrupt acked by control endpoint managed
		uhd_ctrl_interrupt();
		return;
	}
	if (pipe_int != AVR32_USBB_EPT_NUM) {
80004bc6:	30 78       	mov	r8,7
80004bc8:	f0 0c 18 00 	cp.b	r12,r8
80004bcc:	c5 c1       	brne	80004c84 <otg_interrupt+0x15c>
		// Interrupt acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt(pipe_int);
		return;
	}
	pipe_int = uhd_get_pipe_dma_interrupt_number();
80004bce:	f2 fb 04 04 	ld.w	r11,r9[1028]
80004bd2:	f2 fc 04 10 	ld.w	r12,r9[1040]
80004bd6:	b9 9b       	lsr	r11,0x19
80004bd8:	f7 ec 03 9b 	and	r11,r11,r12>>0x19
80004bdc:	a7 ab       	sbr	r11,0x6
80004bde:	5c 9b       	brev	r11
80004be0:	f6 0b 12 00 	clz	r11,r11
80004be4:	f6 cc ff ff 	sub	r12,r11,-1
	if (pipe_int != AVR32_USBB_EPT_NUM) {
80004be8:	f0 0c 18 00 	cp.b	r12,r8
80004bec:	c3 b0       	breq	80004c62 <otg_interrupt+0x13a>
static void uhd_pipe_interrupt_dma(uint8_t pipe)
{
	uhd_pipe_job_t *ptr_job;
	uint32_t nb_remaining;

	if (uhd_pipe_dma_get_status(pipe)
80004bee:	f8 08 15 04 	lsl	r8,r12,0x4
80004bf2:	e0 38 f9 00 	sub	r8,129280
80004bf6:	70 39       	ld.w	r9,r8[0xc]
80004bf8:	ed b9 00 00 	bld	r9,0x0
80004bfc:	ca 20       	breq	80004b40 <otg_interrupt+0x18>
			& AVR32_USBB_UHDMA1_STATUS_CH_EN_MASK) {
		return; // Ignore EOT_STA interrupt
	}
	// Save number of data no transfered
	nb_remaining = (uhd_pipe_dma_get_status(pipe) &
80004bfe:	70 3b       	ld.w	r11,r8[0xc]
80004c00:	b1 8b       	lsr	r11,0x10
			AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_MASK)
			>> AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_OFFSET;
	if (nb_remaining) {
80004c02:	c0 d0       	breq	80004c1c <otg_interrupt+0xf4>
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];
80004c04:	e0 69 06 8c 	mov	r9,1676
80004c08:	f8 c8 00 01 	sub	r8,r12,1
80004c0c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004c10:	f2 08 00 28 	add	r8,r9,r8<<0x2

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
80004c14:	70 39       	ld.w	r9,r8[0xc]
80004c16:	16 19       	sub	r9,r11

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
80004c18:	91 29       	st.w	r8[0x8],r9
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
80004c1a:	91 39       	st.w	r8[0xc],r9

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}

	if (uhd_is_pipe_out(pipe)) {
80004c1c:	f8 0a 15 02 	lsl	r10,r12,0x2
80004c20:	fe 69 05 00 	mov	r9,-129792
80004c24:	f4 09 00 08 	add	r8,r10,r9
80004c28:	70 08       	ld.w	r8,r8[0x0]
80004c2a:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
80004c2e:	58 28       	cp.w	r8,2
80004c30:	e0 80 02 35 	breq	8000509a <otg_interrupt+0x572>
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
	} else {
		if (!Is_uhd_pipe_frozen(pipe)) {
80004c34:	fe 68 05 c0 	mov	r8,-129600
80004c38:	f4 08 00 09 	add	r9,r10,r8
80004c3c:	72 08       	ld.w	r8,r9[0x0]
80004c3e:	ed b8 00 11 	bld	r8,0x11
80004c42:	c0 80       	breq	80004c52 <otg_interrupt+0x12a>
			// Pipe is not freeze in case of :
			// - incomplete transfer when the request number INRQ is not complete.
			// - low USB speed and with a high CPU frequency,
			// a ACK from host can be always running on USB line.

			if (nb_remaining) {
80004c44:	58 0b       	cp.w	r11,0
80004c46:	c0 90       	breq	80004c58 <otg_interrupt+0x130>
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
80004c48:	e0 3a fa 10 	sub	r10,129552
80004c4c:	e2 68 00 00 	mov	r8,131072
80004c50:	95 08       	st.w	r10[0x0],r8
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
				}
			}
		}
		uhd_pipe_trans_complet(pipe);
80004c52:	fe b0 fd 43 	rcall	800046d8 <uhd_pipe_trans_complet>
80004c56:	c7 5b       	rjmp	80004b40 <otg_interrupt+0x18>
			if (nb_remaining) {
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
			} else {
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
80004c58:	72 08       	ld.w	r8,r9[0x0]
80004c5a:	ed b8 00 11 	bld	r8,0x11
80004c5e:	cf d1       	brne	80004c58 <otg_interrupt+0x130>
80004c60:	cf 9b       	rjmp	80004c52 <otg_interrupt+0x12a>
		// Interrupt DMA acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt_dma(pipe_int);
		return;
	}
	// USB bus reset detection
	if (Is_uhd_reset_sent()) {
80004c62:	74 08       	ld.w	r8,r10[0x0]
80004c64:	e2 18 00 04 	andl	r8,0x4,COH
80004c68:	e0 80 01 79 	breq	80004f5a <otg_interrupt+0x432>
		uhd_ack_reset_sent();
80004c6c:	fe 68 04 08 	mov	r8,-130040
80004c70:	30 49       	mov	r9,4
80004c72:	91 09       	st.w	r8[0x0],r9
		if (uhd_reset_callback != NULL) {
80004c74:	e0 68 06 88 	mov	r8,1672
80004c78:	70 08       	ld.w	r8,r8[0x0]
80004c7a:	58 08       	cp.w	r8,0
80004c7c:	fe 90 ff 62 	breq	80004b40 <otg_interrupt+0x18>
			uhd_reset_callback();
80004c80:	5d 18       	icall	r8
80004c82:	c5 fb       	rjmp	80004b40 <otg_interrupt+0x18>
 *
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
80004c84:	fe 68 05 c0 	mov	r8,-129600
80004c88:	f8 0b 15 02 	lsl	r11,r12,0x2
80004c8c:	f6 08 00 0e 	add	lr,r11,r8
80004c90:	7c 08       	ld.w	r8,lr[0x0]
80004c92:	ed b8 00 0c 	bld	r8,0xc
80004c96:	e0 81 00 95 	brne	80004dc0 <otg_interrupt+0x298>
80004c9a:	fe 68 05 30 	mov	r8,-129744
80004c9e:	f6 08 00 09 	add	r9,r11,r8
80004ca2:	72 0a       	ld.w	r10,r9[0x0]
80004ca4:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
80004ca8:	e0 80 02 00 	breq	800050a8 <otg_interrupt+0x580>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
80004cac:	7c 08       	ld.w	r8,lr[0x0]
80004cae:	ed b8 00 01 	bld	r8,0x1
80004cb2:	c0 61       	brne	80004cbe <otg_interrupt+0x196>
80004cb4:	72 08       	ld.w	r8,r9[0x0]
80004cb6:	ed b8 00 01 	bld	r8,0x1
80004cba:	e0 80 01 a5 	breq	80005004 <otg_interrupt+0x4dc>
		uhd_ack_fifocon(pipe);
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
80004cbe:	72 08       	ld.w	r8,r9[0x0]
80004cc0:	e2 18 00 40 	andl	r8,0x40,COH
80004cc4:	e0 81 01 d9 	brne	80005076 <otg_interrupt+0x54e>
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
80004cc8:	72 09       	ld.w	r9,r9[0x0]
80004cca:	ed b9 00 03 	bld	r9,0x3
80004cce:	fe 91 ff 39 	brne	80004b40 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
80004cd2:	e0 3b f9 80 	sub	r11,129408
80004cd6:	76 09       	ld.w	r9,r11[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
80004cd8:	97 08       	st.w	r11[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80004cda:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80004cde:	20 18       	sub	r8,1
80004ce0:	58 28       	cp.w	r8,2
80004ce2:	e0 88 01 a9 	brls	80005034 <otg_interrupt+0x50c>
80004ce6:	30 6b       	mov	r11,6
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
		// Get and ack error
		uhd_ep_abort_pipe(pipe, uhd_pipe_get_error(pipe));
80004ce8:	fe b0 fc 26 	rcall	80004534 <uhd_ep_abort_pipe>
80004cec:	c2 ab       	rjmp	80004b40 <otg_interrupt+0x18>
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
		uhd_ack_sof();
80004cee:	32 09       	mov	r9,32
80004cf0:	fe 68 04 08 	mov	r8,-130040
80004cf4:	91 09       	st.w	r8[0x0],r9
			return;
		}
	}

	// Manage a delay to enter in suspend
	if (uhd_suspend_start) {
80004cf6:	e0 68 07 04 	mov	r8,1796
80004cfa:	11 89       	ld.ub	r9,r8[0x0]
80004cfc:	58 09       	cp.w	r9,0
80004cfe:	c6 60       	breq	80004dca <otg_interrupt+0x2a2>
		if (--uhd_suspend_start == 0) {
80004d00:	20 19       	sub	r9,1
80004d02:	5c 59       	castu.b	r9
80004d04:	b0 89       	st.b	r8[0x0],r9
80004d06:	fe 91 ff 1d 	brne	80004b40 <otg_interrupt+0x18>
			// then wait end of SOF generation
			// to be sure that disable SOF has been accepted
#ifdef AVR32_USBB_USBSTA_SPEED_HIGH // If UTMI
			while (115<uhd_get_frame_position()) {
#else
			while (185<uhd_get_frame_position()) {
80004d0a:	fe 69 04 20 	mov	r9,-130016
80004d0e:	72 08       	ld.w	r8,r9[0x0]
80004d10:	f1 d8 c2 08 	bfextu	r8,r8,0x10,0x8
80004d14:	e0 48 00 b9 	cp.w	r8,185
80004d18:	e0 88 00 06 	brls	80004d24 <otg_interrupt+0x1fc>
#endif
				if (Is_uhd_disconnection()) {
80004d1c:	74 08       	ld.w	r8,r10[0x0]
80004d1e:	ed b8 00 01 	bld	r8,0x1
80004d22:	cf 61       	brne	80004d0e <otg_interrupt+0x1e6>
					break;
				}
			}
			uhd_disable_sof();
80004d24:	fe 69 04 00 	mov	r9,-130048
80004d28:	72 08       	ld.w	r8,r9[0x0]
80004d2a:	a9 c8       	cbr	r8,0x8
80004d2c:	93 08       	st.w	r9[0x0],r8

			// Ack previous wakeup and resumes interrupts
			AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_HWUPIC_MASK
80004d2e:	fe 68 00 00 	mov	r8,-131072
80004d32:	35 89       	mov	r9,88
80004d34:	f1 49 04 08 	st.w	r8[1032],r9
					|AVR32_USBB_UHINTCLR_RSMEDIC_MASK
					|AVR32_USBB_UHINTCLR_RXRSMIC_MASK;

			// Enable wakeup/resumes interrupts
			AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_HWUPIES_MASK
80004d38:	f1 49 04 18 	st.w	r8[1048],r9
					|AVR32_USBB_UHINTESET_RSMEDIES_MASK
					|AVR32_USBB_UHINTESET_RXRSMIES_MASK;

			otg_freeze_clock();
80004d3c:	fe 69 08 00 	mov	r9,-129024
80004d40:	72 08       	ld.w	r8,r9[0x0]
80004d42:	af a8       	sbr	r8,0xe
80004d44:	93 08       	st.w	r9[0x0],r8
80004d46:	cf da       	rjmp	80004b40 <otg_interrupt+0x18>
{
	// A setup request is on-going
	Assert(uhd_ctrl_request_timeout!=0);

	// Disable setup, IN and OUT interrupts of control endpoint
	AVR32_USBB.upcon0clr = AVR32_USBB_UPCON0CLR_TXSTPEC_MASK
80004d48:	30 78       	mov	r8,7
80004d4a:	f3 48 06 20 	st.w	r9[1568],r8
			| AVR32_USBB_UPCON0CLR_RXINEC_MASK
			| AVR32_USBB_UPCON0CLR_TXOUTEC_MASK;

	// Search event on control endpoint
	if (Is_uhd_setup_ready(0)) {
80004d4e:	fe 69 05 30 	mov	r9,-129744
80004d52:	72 08       	ld.w	r8,r9[0x0]
80004d54:	ed b8 00 02 	bld	r8,0x2
80004d58:	c7 91       	brne	80004e4a <otg_interrupt+0x322>
		// SETUP packet sent
		uhd_freeze_pipe(0);
80004d5a:	fe 6b 05 f0 	mov	r11,-129552
80004d5e:	e2 69 00 00 	mov	r9,131072
80004d62:	97 09       	st.w	r11[0x0],r9
		uhd_ack_setup_ready(0);
80004d64:	30 4a       	mov	r10,4
80004d66:	fe 68 05 60 	mov	r8,-129696
80004d6a:	91 0a       	st.w	r8[0x0],r10
		Assert(uhd_ctrl_request_phase == UHD_CTRL_REQ_PHASE_SETUP);

		// Start DATA phase
		if ((uhd_ctrl_request_first->req.bmRequestType & USB_REQ_DIR_MASK)
80004d6c:	e0 67 28 c4 	mov	r7,10436
80004d70:	18 9e       	mov	lr,r12
80004d72:	6e 0a       	ld.w	r10,r7[0x0]
80004d74:	15 96       	ld.ub	r6,r10[0x1]
80004d76:	f8 06 18 00 	cp.b	r6,r12
80004d7a:	e0 85 02 e5 	brlt	80005344 <otg_interrupt+0x81c>
				== USB_REQ_DIR_IN ) {
			uhd_ctrl_phase_data_in_start();
		} else {
			if (uhd_ctrl_request_first->req.wLength) {
80004d7e:	15 f6       	ld.ub	r6,r10[0x7]
80004d80:	f5 3e 00 08 	ld.ub	lr,r10[8]
80004d84:	fd e6 10 8e 	or	lr,lr,r6<<0x8
80004d88:	f8 0e 19 00 	cp.h	lr,r12
80004d8c:	e0 81 01 ce 	brne	80005128 <otg_interrupt+0x600>
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80004d90:	fe 6c 05 00 	mov	r12,-129792
80004d94:	78 0a       	ld.w	r10,r12[0x0]
80004d96:	e0 1a fc ff 	andl	r10,0xfcff
80004d9a:	a9 aa       	sbr	r10,0x8
80004d9c:	99 0a       	st.w	r12[0x0],r10
	uhd_ack_in_received(0);
80004d9e:	30 1a       	mov	r10,1
80004da0:	91 0a       	st.w	r8[0x0],r10
	uhd_ack_short_packet(0);
80004da2:	e0 6c 00 80 	mov	r12,128
80004da6:	91 0c       	st.w	r8[0x0],r12
	uhd_enable_in_received_interrupt(0);
80004da8:	97 0a       	st.w	r11[0x0],r10
	uhd_ack_fifocon(0);
80004daa:	fe 68 06 20 	mov	r8,-129504
80004dae:	e0 6a 40 00 	mov	r10,16384
80004db2:	91 0a       	st.w	r8[0x0],r10
	uhd_unfreeze_pipe(0);
80004db4:	91 09       	st.w	r8[0x0],r9
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80004db6:	30 39       	mov	r9,3
80004db8:	e0 68 28 c0 	mov	r8,10432
80004dbc:	91 09       	st.w	r8[0x0],r9
80004dbe:	cc 1a       	rjmp	80004b40 <otg_interrupt+0x18>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80004dc0:	fe 68 05 30 	mov	r8,-129744
80004dc4:	f6 08 00 09 	add	r9,r11,r8
80004dc8:	c7 2b       	rjmp	80004cac <otg_interrupt+0x184>
			uhd_sleep_mode(UHD_STATE_SUSPEND);
		}
		return; // Abort SOF events
	}
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
80004dca:	e0 68 07 06 	mov	r8,1798
80004dce:	11 89       	ld.ub	r9,r8[0x0]
80004dd0:	58 09       	cp.w	r9,0
80004dd2:	c5 90       	breq	80004e84 <otg_interrupt+0x35c>
		if (--uhd_resume_start == 0) {
80004dd4:	20 19       	sub	r9,1
80004dd6:	5c 59       	castu.b	r9
80004dd8:	b0 89       	st.b	r8[0x0],r9
80004dda:	fe 91 fe b3 	brne	80004b40 <otg_interrupt+0x18>
80004dde:	e0 68 07 05 	mov	r8,1797
80004de2:	11 88       	ld.ub	r8,r8[0x0]
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004de4:	ed b8 00 01 	bld	r8,0x1
80004de8:	c0 61       	brne	80004df4 <otg_interrupt+0x2cc>
					uhd_unfreeze_pipe(pipe);
80004dea:	e2 6a 00 00 	mov	r10,131072
80004dee:	fe 69 06 24 	mov	r9,-129500
80004df2:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004df4:	ed b8 00 02 	bld	r8,0x2
80004df8:	c0 61       	brne	80004e04 <otg_interrupt+0x2dc>
					uhd_unfreeze_pipe(pipe);
80004dfa:	e2 6a 00 00 	mov	r10,131072
80004dfe:	fe 69 06 28 	mov	r9,-129496
80004e02:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004e04:	ed b8 00 03 	bld	r8,0x3
80004e08:	c0 61       	brne	80004e14 <otg_interrupt+0x2ec>
					uhd_unfreeze_pipe(pipe);
80004e0a:	e2 6a 00 00 	mov	r10,131072
80004e0e:	fe 69 06 2c 	mov	r9,-129492
80004e12:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004e14:	ed b8 00 04 	bld	r8,0x4
80004e18:	c0 61       	brne	80004e24 <otg_interrupt+0x2fc>
					uhd_unfreeze_pipe(pipe);
80004e1a:	e2 6a 00 00 	mov	r10,131072
80004e1e:	fe 69 06 30 	mov	r9,-129488
80004e22:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004e24:	ed b8 00 05 	bld	r8,0x5
80004e28:	c0 61       	brne	80004e34 <otg_interrupt+0x30c>
					uhd_unfreeze_pipe(pipe);
80004e2a:	e2 6a 00 00 	mov	r10,131072
80004e2e:	fe 69 06 34 	mov	r9,-129484
80004e32:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004e34:	ed b8 00 06 	bld	r8,0x6
80004e38:	c0 61       	brne	80004e44 <otg_interrupt+0x31c>
					uhd_unfreeze_pipe(pipe);
80004e3a:	e2 69 00 00 	mov	r9,131072
80004e3e:	fe 68 06 38 	mov	r8,-129480
80004e42:	91 09       	st.w	r8[0x0],r9
				}
			}
			uhc_notify_resume();
80004e44:	e0 a0 09 12 	rcall	80006068 <uhc_notify_resume>
80004e48:	c7 ca       	rjmp	80004b40 <otg_interrupt+0x18>
				uhd_ctrl_phase_zlp_in();
			}
		}
		return;
	}
	if (Is_uhd_in_received(0)) {
80004e4a:	72 0c       	ld.w	r12,r9[0x0]
80004e4c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80004e50:	e0 80 00 f8 	breq	80005040 <otg_interrupt+0x518>
		// In case of low USB speed and with a high CPU frequency,
		// a ACK from host can be always running on USB line
		// then wait end of ACK on IN pipe.
		while(!Is_uhd_pipe_frozen(0));
80004e54:	fe 69 05 c0 	mov	r9,-129600
80004e58:	72 08       	ld.w	r8,r9[0x0]
80004e5a:	ed b8 00 11 	bld	r8,0x11
80004e5e:	cf d1       	brne	80004e58 <otg_interrupt+0x330>

		// IN packet received
		uhd_ack_in_received(0);
80004e60:	fe 68 05 60 	mov	r8,-129696
80004e64:	30 19       	mov	r9,1
80004e66:	91 09       	st.w	r8[0x0],r9
		switch(uhd_ctrl_request_phase) {
80004e68:	e0 60 28 c0 	mov	r0,10432
80004e6c:	60 08       	ld.w	r8,r0[0x0]
80004e6e:	58 28       	cp.w	r8,2
80004e70:	e0 80 02 14 	breq	80005298 <otg_interrupt+0x770>
80004e74:	58 38       	cp.w	r8,3
80004e76:	fe 91 fe 65 	brne	80004b40 <otg_interrupt+0x18>
		case UHD_CTRL_REQ_PHASE_DATA_IN:
			uhd_ctrl_phase_data_in();
			break;
		case UHD_CTRL_REQ_PHASE_ZLP_IN:
			uhd_ctrl_request_end(UHD_TRANS_NOERROR);
80004e7a:	30 0c       	mov	r12,0
80004e7c:	fe b0 f9 e8 	rcall	8000424c <uhd_ctrl_request_end>
80004e80:	fe 9f fe 60 	bral	80004b40 <otg_interrupt+0x18>
			uhc_notify_resume();
		}
		return; // Abort SOF events
	}
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
80004e84:	e0 68 28 d0 	mov	r8,10448
80004e88:	90 09       	ld.sh	r9,r8[0x0]
80004e8a:	58 09       	cp.w	r9,0
80004e8c:	c0 80       	breq	80004e9c <otg_interrupt+0x374>
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
80004e8e:	90 09       	ld.sh	r9,r8[0x0]
80004e90:	20 19       	sub	r9,1
80004e92:	b0 09       	st.h	r8[0x0],r9
80004e94:	90 08       	ld.sh	r8,r8[0x0]
80004e96:	58 08       	cp.w	r8,0
80004e98:	e0 80 03 07 	breq	800054a6 <otg_interrupt+0x97e>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004e9c:	e0 67 06 8c 	mov	r7,1676
80004ea0:	6e 08       	ld.w	r8,r7[0x0]
80004ea2:	58 08       	cp.w	r8,0
80004ea4:	c0 94       	brge	80004eb6 <otg_interrupt+0x38e>
			if (ptr_job->timeout) {
80004ea6:	8e 18       	ld.sh	r8,r7[0x2]
80004ea8:	58 08       	cp.w	r8,0
80004eaa:	c0 60       	breq	80004eb6 <otg_interrupt+0x38e>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004eac:	20 18       	sub	r8,1
80004eae:	5c 88       	casts.h	r8
80004eb0:	ae 18       	st.h	r7[0x2],r8
80004eb2:	e0 80 03 99 	breq	800055e4 <otg_interrupt+0xabc>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004eb6:	e0 68 06 8c 	mov	r8,1676
80004eba:	6e 59       	ld.w	r9,r7[0x14]
80004ebc:	58 09       	cp.w	r9,0
80004ebe:	c0 b4       	brge	80004ed4 <otg_interrupt+0x3ac>
			if (ptr_job->timeout) {
80004ec0:	f1 09 00 16 	ld.sh	r9,r8[22]
80004ec4:	58 09       	cp.w	r9,0
80004ec6:	c0 70       	breq	80004ed4 <otg_interrupt+0x3ac>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004ec8:	20 19       	sub	r9,1
80004eca:	5c 89       	casts.h	r9
80004ecc:	f1 59 00 16 	st.h	r8[22],r9
80004ed0:	e0 80 03 90 	breq	800055f0 <otg_interrupt+0xac8>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004ed4:	e0 68 06 8c 	mov	r8,1676
80004ed8:	6e a9       	ld.w	r9,r7[0x28]
80004eda:	58 09       	cp.w	r9,0
80004edc:	c0 b4       	brge	80004ef2 <otg_interrupt+0x3ca>
			if (ptr_job->timeout) {
80004ede:	f1 09 00 2a 	ld.sh	r9,r8[42]
80004ee2:	58 09       	cp.w	r9,0
80004ee4:	c0 70       	breq	80004ef2 <otg_interrupt+0x3ca>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004ee6:	20 19       	sub	r9,1
80004ee8:	5c 89       	casts.h	r9
80004eea:	f1 59 00 2a 	st.h	r8[42],r9
80004eee:	e0 80 03 87 	breq	800055fc <otg_interrupt+0xad4>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004ef2:	e0 68 06 8c 	mov	r8,1676
80004ef6:	6e f9       	ld.w	r9,r7[0x3c]
80004ef8:	58 09       	cp.w	r9,0
80004efa:	c0 b4       	brge	80004f10 <otg_interrupt+0x3e8>
			if (ptr_job->timeout) {
80004efc:	f1 09 00 3e 	ld.sh	r9,r8[62]
80004f00:	58 09       	cp.w	r9,0
80004f02:	c0 70       	breq	80004f10 <otg_interrupt+0x3e8>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004f04:	20 19       	sub	r9,1
80004f06:	5c 89       	casts.h	r9
80004f08:	f1 59 00 3e 	st.h	r8[62],r9
80004f0c:	e0 80 03 7e 	breq	80005608 <otg_interrupt+0xae0>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004f10:	e0 68 06 8c 	mov	r8,1676
80004f14:	6f 49       	ld.w	r9,r7[0x50]
80004f16:	58 09       	cp.w	r9,0
80004f18:	c0 b4       	brge	80004f2e <otg_interrupt+0x406>
			if (ptr_job->timeout) {
80004f1a:	f1 09 00 52 	ld.sh	r9,r8[82]
80004f1e:	58 09       	cp.w	r9,0
80004f20:	c0 70       	breq	80004f2e <otg_interrupt+0x406>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004f22:	20 19       	sub	r9,1
80004f24:	5c 89       	casts.h	r9
80004f26:	f1 59 00 52 	st.h	r8[82],r9
80004f2a:	e0 80 03 75 	breq	80005614 <otg_interrupt+0xaec>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004f2e:	6f 99       	ld.w	r9,r7[0x64]
80004f30:	e0 68 06 8c 	mov	r8,1676
80004f34:	58 09       	cp.w	r9,0
80004f36:	c0 b4       	brge	80004f4c <otg_interrupt+0x424>
			if (ptr_job->timeout) {
80004f38:	f1 09 00 66 	ld.sh	r9,r8[102]
80004f3c:	58 09       	cp.w	r9,0
80004f3e:	c0 70       	breq	80004f4c <otg_interrupt+0x424>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004f40:	20 19       	sub	r9,1
80004f42:	5c 89       	casts.h	r9
80004f44:	f1 59 00 66 	st.h	r8[102],r9
80004f48:	e0 80 03 32 	breq	800055ac <otg_interrupt+0xa84>
				}
			}
		}
	}
	// Notify the UHC
	uhc_notify_sof(false);
80004f4c:	30 0c       	mov	r12,0
80004f4e:	e0 a0 04 df 	rcall	8000590c <uhc_notify_sof>

	// Notify the user application
	UHC_SOF_EVENT();
80004f52:	e0 a0 1d d0 	rcall	80008af2 <usb_sof>
80004f56:	fe 9f fd f5 	bral	80004b40 <otg_interrupt+0x18>
		}
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
80004f5a:	74 0a       	ld.w	r10,r10[0x0]
80004f5c:	ed ba 00 01 	bld	r10,0x1
80004f60:	c0 81       	brne	80004f70 <otg_interrupt+0x448>
80004f62:	fe 6a 04 10 	mov	r10,-130032
80004f66:	74 0a       	ld.w	r10,r10[0x0]
80004f68:	ed ba 00 01 	bld	r10,0x1
80004f6c:	e0 80 02 a7 	breq	800054ba <otg_interrupt+0x992>
		uhd_suspend_start = 0;
		uhd_resume_start = 0;
		uhc_notify_connection(false);
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
80004f70:	fe 68 04 04 	mov	r8,-130044
80004f74:	70 08       	ld.w	r8,r8[0x0]
80004f76:	ed b8 00 00 	bld	r8,0x0
80004f7a:	c0 81       	brne	80004f8a <otg_interrupt+0x462>
80004f7c:	fe 68 04 10 	mov	r8,-130032
80004f80:	70 08       	ld.w	r8,r8[0x0]
80004f82:	ed b8 00 00 	bld	r8,0x0
80004f86:	e0 80 02 b8 	breq	800054f6 <otg_interrupt+0x9ce>
		uhc_notify_connection(true);
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
80004f8a:	fe 69 08 04 	mov	r9,-129020
80004f8e:	72 08       	ld.w	r8,r9[0x0]
80004f90:	ed b8 00 03 	bld	r8,0x3
80004f94:	e0 80 01 f1 	breq	80005376 <otg_interrupt+0x84e>
		UHC_VBUS_ERROR();
		return;
	}

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
80004f98:	72 08       	ld.w	r8,r9[0x0]
80004f9a:	ed b8 00 0e 	bld	r8,0xe
80004f9e:	cf d1       	brne	80004f98 <otg_interrupt+0x470>
	otg_unfreeze_clock();
80004fa0:	fe 69 08 00 	mov	r9,-129024
80004fa4:	72 08       	ld.w	r8,r9[0x0]
80004fa6:	af c8       	cbr	r8,0xe
80004fa8:	93 08       	st.w	r9[0x0],r8

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
80004faa:	fe 68 04 10 	mov	r8,-130032
80004fae:	70 08       	ld.w	r8,r8[0x0]
80004fb0:	ed b8 00 06 	bld	r8,0x6
80004fb4:	e0 81 01 43 	brne	8000523a <otg_interrupt+0x712>
80004fb8:	fe 68 04 04 	mov	r8,-130044
80004fbc:	70 09       	ld.w	r9,r8[0x0]
80004fbe:	ed b9 00 06 	bld	r9,0x6
80004fc2:	c0 a0       	breq	80004fd6 <otg_interrupt+0x4ae>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
80004fc4:	70 09       	ld.w	r9,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
80004fc6:	ed b9 00 03 	bld	r9,0x3
80004fca:	c0 60       	breq	80004fd6 <otg_interrupt+0x4ae>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
80004fcc:	70 08       	ld.w	r8,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
80004fce:	ed b8 00 04 	bld	r8,0x4
80004fd2:	e0 81 01 34 	brne	8000523a <otg_interrupt+0x712>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
80004fd6:	fe 68 00 00 	mov	r8,-131072
80004fda:	35 89       	mov	r9,88
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
80004fdc:	fe 6a 04 00 	mov	r10,-130048
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
80004fe0:	f1 49 04 14 	st.w	r8[1044],r9
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
80004fe4:	74 08       	ld.w	r8,r10[0x0]
80004fe6:	a9 a8       	sbr	r8,0x8
		if ((!Is_uhd_downstream_resume())
80004fe8:	fe 69 04 04 	mov	r9,-130044
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
80004fec:	95 08       	st.w	r10[0x0],r8
		if ((!Is_uhd_downstream_resume())
80004fee:	72 08       	ld.w	r8,r9[0x0]
				&&(!Is_uhd_disconnection())) {
80004ff0:	ed b8 00 03 	bld	r8,0x3
80004ff4:	f3 f8 10 00 	ld.wne	r8,r9[0x0]
			if (Is_uhd_high_speed_mode()) {
				uhd_send_resume();
			}
		}
		// Wait 50ms before restarting transfer
		uhd_resume_start = 50;
80004ff8:	e0 68 07 06 	mov	r8,1798
80004ffc:	33 29       	mov	r9,50
80004ffe:	b0 89       	st.b	r8[0x0],r9
80005000:	fe 9f fd a0 	bral	80004b40 <otg_interrupt+0x18>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
		uhd_disable_out_ready_interrupt(pipe);
80005004:	30 29       	mov	r9,2
80005006:	fe 6c 06 20 	mov	r12,-129504
8000500a:	f6 0c 00 08 	add	r8,r11,r12
8000500e:	91 09       	st.w	r8[0x0],r9
		// One bank is free then send a ZLP
		uhd_ack_out_ready(pipe);
80005010:	fe 6c 05 60 	mov	r12,-129696
80005014:	f6 0c 00 0a 	add	r10,r11,r12
80005018:	95 09       	st.w	r10[0x0],r9
		uhd_ack_fifocon(pipe);
8000501a:	e0 69 40 00 	mov	r9,16384
8000501e:	91 09       	st.w	r8[0x0],r9
		uhd_unfreeze_pipe(pipe);
80005020:	e2 69 00 00 	mov	r9,131072
80005024:	91 09       	st.w	r8[0x0],r9
		uhd_enable_bank_interrupt(pipe);
80005026:	e0 3b fa 10 	sub	r11,129552
8000502a:	e0 68 10 00 	mov	r8,4096
8000502e:	97 08       	st.w	r11[0x0],r8
80005030:	fe 9f fd 88 	bral	80004b40 <otg_interrupt+0x18>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80005034:	fe f9 05 ec 	ld.w	r9,pc[1516]
80005038:	f2 08 03 2b 	ld.w	r11,r9[r8<<0x2]
8000503c:	fe 9f fe 56 	bral	80004ce8 <otg_interrupt+0x1c0>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_out_ready(0)) {
80005040:	72 08       	ld.w	r8,r9[0x0]
80005042:	ed b8 00 01 	bld	r8,0x1
80005046:	e0 81 01 13 	brne	8000526c <otg_interrupt+0x744>
		// OUT packet sent
		uhd_freeze_pipe(0);
8000504a:	fe 64 05 f0 	mov	r4,-129552
8000504e:	e2 65 00 00 	mov	r5,131072
80005052:	89 05       	st.w	r4[0x0],r5
		uhd_ack_out_ready(0);
80005054:	30 28       	mov	r8,2
80005056:	fe 6e 05 60 	mov	lr,-129696
8000505a:	9d 08       	st.w	lr[0x0],r8
		switch(uhd_ctrl_request_phase) {
8000505c:	e0 60 28 c0 	mov	r0,10432
80005060:	60 08       	ld.w	r8,r0[0x0]
80005062:	58 18       	cp.w	r8,1
80005064:	e0 80 01 a5 	breq	800053ae <otg_interrupt+0x886>
80005068:	58 48       	cp.w	r8,4
8000506a:	fe 91 fd 6b 	brne	80004b40 <otg_interrupt+0x18>
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
		// Get and ack error
		uhd_ctrl_request_end(uhd_pipe_get_error(0));
8000506e:	fe b0 f8 ef 	rcall	8000424c <uhd_ctrl_request_end>
80005072:	fe 9f fd 67 	bral	80004b40 <otg_interrupt+0x18>
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
80005076:	fe 69 05 60 	mov	r9,-129696
8000507a:	f6 09 00 08 	add	r8,r11,r9
8000507e:	34 09       	mov	r9,64
80005080:	91 09       	st.w	r8[0x0],r9
		uhd_reset_data_toggle(pipe);
80005082:	fe 69 05 f0 	mov	r9,-129552
80005086:	f6 09 00 08 	add	r8,r11,r9
8000508a:	e4 69 00 00 	mov	r9,262144
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
8000508e:	30 4b       	mov	r11,4
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
80005090:	91 09       	st.w	r8[0x0],r9
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
80005092:	fe b0 fa 51 	rcall	80004534 <uhd_ep_abort_pipe>
80005096:	fe 9f fd 55 	bral	80004b40 <otg_interrupt+0x18>
	}

	if (uhd_is_pipe_out(pipe)) {
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
8000509a:	e0 3a fa 10 	sub	r10,129552
8000509e:	e0 68 10 00 	mov	r8,4096
800050a2:	95 08       	st.w	r10[0x0],r8
800050a4:	fe 9f fd 4e 	bral	80004b40 <otg_interrupt+0x18>
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
		uhd_disable_bank_interrupt(pipe);
800050a8:	fe 69 06 20 	mov	r9,-129504
800050ac:	f6 09 00 08 	add	r8,r11,r9
800050b0:	e0 69 10 00 	mov	r9,4096
800050b4:	91 09       	st.w	r8[0x0],r9
static void uhd_pipe_finish_job(uint8_t pipe, uhd_trans_status_t status)
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
800050b6:	e0 68 06 8c 	mov	r8,1676
800050ba:	f8 c9 00 01 	sub	r9,r12,1
800050be:	f2 09 00 29 	add	r9,r9,r9<<0x2
800050c2:	f0 09 00 29 	add	r9,r8,r9<<0x2
	if (ptr_job->busy == false) {
800050c6:	72 08       	ld.w	r8,r9[0x0]
800050c8:	58 08       	cp.w	r8,0
800050ca:	fe 94 fd 3b 	brge	80004b40 <otg_interrupt+0x18>
		return; // No job running
	}
	ptr_job->busy = false;
800050ce:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
800050d2:	93 08       	st.w	r9[0x0],r8
	if (NULL == ptr_job->call_end) {
800050d4:	72 48       	ld.w	r8,r9[0x10]
800050d6:	58 08       	cp.w	r8,0
800050d8:	fe 90 fd 34 	breq	80004b40 <otg_interrupt+0x18>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
800050dc:	e0 3b fb 00 	sub	r11,129792
800050e0:	76 0e       	ld.w	lr,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800050e2:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
			uhd_get_pipe_endpoint_address(pipe),
800050e6:	76 06       	ld.w	r6,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800050e8:	e2 1c 00 3c 	andl	r12,0x3c,COH
800050ec:	f7 de c2 04 	bfextu	r11,lr,0x10,0x4
800050f0:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
800050f4:	e0 3c fb dc 	sub	r12,130012
800050f8:	e0 6e 00 80 	mov	lr,128
800050fc:	58 16       	cp.w	r6,1
800050fe:	f9 be 01 00 	movne	lr,0
80005102:	a3 77       	lsl	r7,0x3
80005104:	fd eb 10 0b 	or	r11,lr,r11
80005108:	78 0e       	ld.w	lr,r12[0x0]
8000510a:	37 fc       	mov	r12,127
8000510c:	f8 07 09 4c 	lsl	r12,r12,r7
80005110:	f9 ee 00 0e 	and	lr,r12,lr
80005114:	72 39       	ld.w	r9,r9[0xc]
80005116:	5c 9c       	brev	r12
80005118:	f8 0c 12 00 	clz	r12,r12
8000511c:	fc 0c 0a 4c 	lsr	r12,lr,r12
80005120:	5c 5c       	castu.b	r12
80005122:	5d 18       	icall	r8
80005124:	fe 9f fd 0e 	bral	80004b40 <otg_interrupt+0x18>
static void uhd_ctrl_phase_data_out(void)
{
	uint8_t *ptr_ep_data;
	uint8_t ep_ctrl_size;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
80005128:	e0 60 28 c0 	mov	r0,10432
8000512c:	30 14       	mov	r4,1
8000512e:	81 04       	st.w	r0[0x0],r4

	if (uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength) {
80005130:	f5 3e 00 08 	ld.ub	lr,r10[8]
80005134:	e0 66 28 c8 	mov	r6,10440
80005138:	15 f5       	ld.ub	r5,r10[0x7]
8000513a:	fd e5 10 85 	or	r5,lr,r5<<0x8
8000513e:	8c 0e       	ld.sh	lr,r6[0x0]
80005140:	5c 85       	casts.h	r5
80005142:	fc 05 19 00 	cp.h	r5,lr
80005146:	e0 80 01 f3 	breq	8000552c <otg_interrupt+0xa04>
		// End of DATA phase
		uhd_ctrl_phase_zlp_in();
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
8000514a:	f5 08 00 10 	ld.sh	r8,r10[16]
8000514e:	f8 08 19 00 	cp.h	r8,r12
80005152:	c1 81       	brne	80005182 <otg_interrupt+0x65a>
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
				|| !uhd_ctrl_request_first->callback_run(
80005154:	74 58       	ld.w	r8,r10[0x14]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80005156:	58 08       	cp.w	r8,0
80005158:	e0 80 01 17 	breq	80005386 <otg_interrupt+0x85e>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
8000515c:	fe 69 04 24 	mov	r9,-130012
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80005160:	f4 cb ff f4 	sub	r11,r10,-12
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
80005164:	72 0c       	ld.w	r12,r9[0x0]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80005166:	2f 0a       	sub	r10,-16
80005168:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000516c:	5d 18       	icall	r8
8000516e:	e0 80 01 0c 	breq	80005386 <otg_interrupt+0x85e>
80005172:	6e 0a       	ld.w	r10,r7[0x0]
80005174:	8c 0e       	ld.sh	lr,r6[0x0]
80005176:	15 f5       	ld.ub	r5,r10[0x7]
80005178:	f5 38 00 08 	ld.ub	r8,r10[8]
8000517c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80005180:	5c 85       	casts.h	r5
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80005182:	fe 69 05 00 	mov	r9,-129792
80005186:	72 0c       	ld.w	r12,r9[0x0]
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80005188:	72 08       	ld.w	r8,r9[0x0]
8000518a:	e0 18 fc ff 	andl	r8,0xfcff
8000518e:	a9 b8       	sbr	r8,0x9
80005190:	93 08       	st.w	r9[0x0],r8
	uhd_ack_out_ready(0);
80005192:	fe 68 05 60 	mov	r8,-129696
80005196:	30 29       	mov	r9,2
80005198:	91 09       	st.w	r8[0x0],r9
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
8000519a:	f1 dc c0 83 	bfextu	r8,r12,0x4,0x3

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8000519e:	fc 05 19 00 	cp.h	r5,lr
800051a2:	5f bb       	srhi	r11
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
800051a4:	30 8e       	mov	lr,8
800051a6:	fc 08 09 4e 	lsl	lr,lr,r8

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800051aa:	30 08       	mov	r8,0
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
800051ac:	5c 5e       	castu.b	lr

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800051ae:	f0 0e 18 00 	cp.b	lr,r8
800051b2:	5f 19       	srne	r9
800051b4:	f7 e9 00 09 	and	r9,r11,r9
800051b8:	f0 09 18 00 	cp.b	r9,r8
800051bc:	c3 10       	breq	8000521e <otg_interrupt+0x6f6>
800051be:	f5 08 00 10 	ld.sh	r8,r10[16]
800051c2:	30 0b       	mov	r11,0
800051c4:	f6 08 19 00 	cp.h	r8,r11
800051c8:	c2 b0       	breq	8000521e <otg_interrupt+0x6f6>
800051ca:	16 95       	mov	r5,r11
800051cc:	fc 19 e0 00 	movh	r9,0xe000
800051d0:	c0 68       	rjmp	800051dc <otg_interrupt+0x6b4>
800051d2:	f5 08 00 10 	ld.sh	r8,r10[16]
800051d6:	ea 08 19 00 	cp.h	r8,r5
800051da:	c2 20       	breq	8000521e <otg_interrupt+0x6f6>
			&& ep_ctrl_size && uhd_ctrl_request_first->payload_size) {
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
800051dc:	74 38       	ld.w	r8,r10[0xc]
800051de:	11 3c       	ld.ub	r12,r8++
800051e0:	12 cc       	st.b	r9++,r12
800051e2:	95 38       	st.w	r10[0xc],r8
		uhd_ctrl_nb_trans++;
800051e4:	8c 08       	ld.sh	r8,r6[0x0]
800051e6:	2f f8       	sub	r8,-1
800051e8:	ac 08       	st.h	r6[0x0],r8
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
800051ea:	6e 08       	ld.w	r8,r7[0x0]
800051ec:	f1 0a 00 10 	ld.sh	r10,r8[16]
800051f0:	20 1a       	sub	r10,1
800051f2:	f1 5a 00 10 	st.h	r8[16],r10

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800051f6:	fc 09 01 08 	sub	r8,lr,r9
800051fa:	6e 0a       	ld.w	r10,r7[0x0]
800051fc:	f6 08 18 00 	cp.b	r8,r11
80005200:	5f 1c       	srne	r12
80005202:	8c 04       	ld.sh	r4,r6[0x0]
80005204:	15 f3       	ld.ub	r3,r10[0x7]
80005206:	f5 38 00 08 	ld.ub	r8,r10[8]
8000520a:	f1 e3 10 88 	or	r8,r8,r3<<0x8
8000520e:	f0 04 19 00 	cp.h	r4,r8
80005212:	5f 38       	srlo	r8
80005214:	f9 e8 00 08 	and	r8,r12,r8
80005218:	f6 08 18 00 	cp.b	r8,r11
8000521c:	cd b1       	brne	800051d2 <otg_interrupt+0x6aa>
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
		uhd_ctrl_nb_trans++;
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
	}
	uhd_enable_out_ready_interrupt(0);
8000521e:	30 29       	mov	r9,2
80005220:	fe 68 05 f0 	mov	r8,-129552
80005224:	91 09       	st.w	r8[0x0],r9
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	uhd_enable_out_ready_interrupt(0);
	uhd_ack_fifocon(0);
80005226:	fe 68 06 20 	mov	r8,-129504
8000522a:	e0 69 40 00 	mov	r9,16384
8000522e:	91 09       	st.w	r8[0x0],r9
	uhd_unfreeze_pipe(0);
80005230:	e2 69 00 00 	mov	r9,131072
80005234:	91 09       	st.w	r8[0x0],r9
80005236:	fe 9f fc 85 	bral	80004b40 <otg_interrupt+0x18>
		uhd_sleep_mode(UHD_STATE_IDLE);
		return;
	}

	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
8000523a:	fe 69 08 04 	mov	r9,-129020
8000523e:	72 08       	ld.w	r8,r9[0x0]
80005240:	ed b8 00 01 	bld	r8,0x1
80005244:	fe 91 fc 7e 	brne	80004b40 <otg_interrupt+0x18>
		otg_ack_vbus_transition();
80005248:	30 2a       	mov	r10,2
8000524a:	fe 68 08 08 	mov	r8,-129016
8000524e:	91 0a       	st.w	r8[0x0],r10
		if (Is_otg_vbus_high()) {
80005250:	72 0c       	ld.w	r12,r9[0x0]
80005252:	e2 1c 08 00 	andl	r12,0x800,COH
80005256:	e0 81 01 81 	brne	80005558 <otg_interrupt+0xa30>
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
		} else {
			uhd_sleep_mode(UHD_STATE_NO_VBUS);
			otg_freeze_clock();
8000525a:	fe 69 08 00 	mov	r9,-129024
8000525e:	72 08       	ld.w	r8,r9[0x0]
80005260:	af a8       	sbr	r8,0xe
80005262:	93 08       	st.w	r9[0x0],r8
			UHC_VBUS_CHANGE(false);
80005264:	e0 a0 1c 43 	rcall	80008aea <usb_vbus_change>
80005268:	fe 9f fc 6c 	bral	80004b40 <otg_interrupt+0x18>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_stall(0)) {
8000526c:	72 08       	ld.w	r8,r9[0x0]
8000526e:	e2 18 00 40 	andl	r8,0x40,COH
80005272:	e0 81 01 94 	brne	8000559a <otg_interrupt+0xa72>
		// Stall Handshake received
		uhd_ack_stall(0);
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
80005276:	72 09       	ld.w	r9,r9[0x0]
80005278:	ed b9 00 03 	bld	r9,0x3
8000527c:	fe 91 fc 62 	brne	80004b40 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
80005280:	fe 69 06 80 	mov	r9,-129408
80005284:	72 0a       	ld.w	r10,r9[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
80005286:	93 08       	st.w	r9[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80005288:	f1 da c0 04 	bfextu	r8,r10,0x0,0x4
8000528c:	20 18       	sub	r8,1
8000528e:	58 28       	cp.w	r8,2
80005290:	e0 88 01 80 	brls	80005590 <otg_interrupt+0xa68>
80005294:	30 6c       	mov	r12,6
80005296:	ce ca       	rjmp	8000506e <otg_interrupt+0x546>
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
80005298:	fe 68 05 30 	mov	r8,-129744
8000529c:	e0 67 28 c4 	mov	r7,10436
800052a0:	70 05       	ld.w	r5,r8[0x0]
	//! In HUB mode, the control pipe is always configured to 64B
	//! thus the short packet flag must be computed
	b_short_packet = (nb_byte_received != uhd_get_pipe_size(0));
	uhd_ack_short_packet(0);
#else
	b_short_packet = Is_uhd_short_packet(0);
800052a2:	fc 12 e0 00 	movh	r2,0xe000
800052a6:	70 08       	ld.w	r8,r8[0x0]
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
800052a8:	eb d5 c2 88 	bfextu	r5,r5,0x14,0x8
	//! In HUB mode, the control pipe is always configured to 64B
	//! thus the short packet flag must be computed
	b_short_packet = (nb_byte_received != uhd_get_pipe_size(0));
	uhd_ack_short_packet(0);
#else
	b_short_packet = Is_uhd_short_packet(0);
800052ac:	50 08       	stdsp	sp[0x0],r8
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800052ae:	0e 91       	mov	r1,r7
800052b0:	30 06       	mov	r6,0
800052b2:	30 04       	mov	r4,0
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
800052b4:	e0 63 28 c8 	mov	r3,10440
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800052b8:	6e 0a       	ld.w	r10,r7[0x0]
800052ba:	ec 05 18 00 	cp.b	r5,r6
800052be:	5f 18       	srne	r8
800052c0:	f5 09 00 10 	ld.sh	r9,r10[16]
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
800052c4:	ea ce 00 01 	sub	lr,r5,1
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800052c8:	e8 09 19 00 	cp.h	r9,r4
800052cc:	5f 1c       	srne	r12
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800052ce:	f4 cb ff f4 	sub	r11,r10,-12
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800052d2:	f1 ec 00 0c 	and	r12,r8,r12
800052d6:	ec 0c 18 00 	cp.b	r12,r6
800052da:	c2 51       	brne	80005324 <otg_interrupt+0x7fc>
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
800052dc:	e8 09 19 00 	cp.h	r9,r4
800052e0:	5f 09       	sreq	r9
800052e2:	12 68       	and	r8,r9
800052e4:	ec 08 18 00 	cp.b	r8,r6
800052e8:	e0 80 01 3d 	breq	80005562 <otg_interrupt+0xa3a>
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
				|| !uhd_ctrl_request_first->callback_run(
800052ec:	74 58       	ld.w	r8,r10[0x14]
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800052ee:	58 08       	cp.w	r8,0
800052f0:	c0 90       	breq	80005302 <otg_interrupt+0x7da>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800052f2:	fe 69 04 24 	mov	r9,-130012
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800052f6:	2f 0a       	sub	r10,-16
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800052f8:	72 0c       	ld.w	r12,r9[0x0]
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800052fa:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800052fe:	5d 18       	icall	r8
80005300:	cd c1       	brne	800052b8 <otg_interrupt+0x790>
 * \internal
 * \brief Starts the ZLP OUT phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_out(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
80005302:	30 48       	mov	r8,4
80005304:	81 08       	st.w	r0[0x0],r8
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80005306:	fe 69 05 00 	mov	r9,-129792
8000530a:	72 08       	ld.w	r8,r9[0x0]
8000530c:	e0 18 fc ff 	andl	r8,0xfcff
80005310:	a9 b8       	sbr	r8,0x9
80005312:	93 08       	st.w	r9[0x0],r8
	uhd_ack_out_ready(0);
80005314:	30 28       	mov	r8,2
80005316:	fe 69 05 60 	mov	r9,-129696
8000531a:	93 08       	st.w	r9[0x0],r8
	uhd_enable_out_ready_interrupt(0);
8000531c:	fe 69 05 f0 	mov	r9,-129552
80005320:	93 08       	st.w	r9[0x0],r8
80005322:	c8 2b       	rjmp	80005226 <otg_interrupt+0x6fe>

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
80005324:	05 39       	ld.ub	r9,r2++
80005326:	74 38       	ld.w	r8,r10[0xc]
80005328:	10 c9       	st.b	r8++,r9
8000532a:	95 38       	st.w	r10[0xc],r8
		uhd_ctrl_nb_trans++;
8000532c:	86 08       	ld.sh	r8,r3[0x0]
8000532e:	2f f8       	sub	r8,-1
80005330:	a6 08       	st.h	r3[0x0],r8
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
80005332:	eb de c0 08 	bfextu	r5,lr,0x0,0x8
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
80005336:	62 08       	ld.w	r8,r1[0x0]
80005338:	f1 09 00 10 	ld.sh	r9,r8[16]
8000533c:	20 19       	sub	r9,1
8000533e:	f1 59 00 10 	st.h	r8[16],r9
80005342:	cb bb       	rjmp	800052b8 <otg_interrupt+0x790>
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80005344:	fe 6c 05 00 	mov	r12,-129792
80005348:	78 0a       	ld.w	r10,r12[0x0]
8000534a:	e0 1a fc ff 	andl	r10,0xfcff
8000534e:	a9 aa       	sbr	r10,0x8
80005350:	99 0a       	st.w	r12[0x0],r10
	uhd_ack_in_received(0);
80005352:	30 1a       	mov	r10,1
80005354:	91 0a       	st.w	r8[0x0],r10
	uhd_ack_short_packet(0);
80005356:	e0 6c 00 80 	mov	r12,128
8000535a:	91 0c       	st.w	r8[0x0],r12
	uhd_enable_in_received_interrupt(0);
8000535c:	97 0a       	st.w	r11[0x0],r10
	uhd_ack_fifocon(0);
8000535e:	fe 68 06 20 	mov	r8,-129504
80005362:	e0 6a 40 00 	mov	r10,16384
80005366:	91 0a       	st.w	r8[0x0],r10
	uhd_unfreeze_pipe(0);
80005368:	91 09       	st.w	r8[0x0],r9
 * \internal
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
8000536a:	30 29       	mov	r9,2
8000536c:	e0 68 28 c0 	mov	r8,10432
80005370:	91 09       	st.w	r8[0x0],r9
80005372:	fe 9f fb e7 	bral	80004b40 <otg_interrupt+0x18>
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
		uhd_ack_vbus_error_interrupt();
80005376:	30 89       	mov	r9,8
80005378:	fe 68 08 08 	mov	r8,-129016
8000537c:	91 09       	st.w	r8[0x0],r9
		UHC_VBUS_ERROR();
8000537e:	e0 a0 1b b7 	rcall	80008aec <usb_vbus_error>
80005382:	fe 9f fb df 	bral	80004b40 <otg_interrupt+0x18>
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80005386:	30 38       	mov	r8,3
80005388:	81 08       	st.w	r0[0x0],r8
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
8000538a:	fe 69 05 00 	mov	r9,-129792
8000538e:	72 08       	ld.w	r8,r9[0x0]
80005390:	e0 18 fc ff 	andl	r8,0xfcff
80005394:	a9 a8       	sbr	r8,0x8
80005396:	93 08       	st.w	r9[0x0],r8
	uhd_ack_in_received(0);
80005398:	fe 69 05 60 	mov	r9,-129696
8000539c:	30 18       	mov	r8,1
8000539e:	93 08       	st.w	r9[0x0],r8
	uhd_ack_short_packet(0);
800053a0:	e0 6a 00 80 	mov	r10,128
800053a4:	93 0a       	st.w	r9[0x0],r10
	uhd_enable_in_received_interrupt(0);
800053a6:	fe 69 05 f0 	mov	r9,-129552
800053aa:	93 08       	st.w	r9[0x0],r8
800053ac:	c3 db       	rjmp	80005226 <otg_interrupt+0x6fe>
static void uhd_ctrl_phase_data_out(void)
{
	uint8_t *ptr_ep_data;
	uint8_t ep_ctrl_size;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
800053ae:	81 08       	st.w	r0[0x0],r8

	if (uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength) {
800053b0:	e0 67 28 c4 	mov	r7,10436
800053b4:	e0 66 28 c8 	mov	r6,10440
800053b8:	6e 0a       	ld.w	r10,r7[0x0]
800053ba:	8c 0b       	ld.sh	r11,r6[0x0]
800053bc:	15 f3       	ld.ub	r3,r10[0x7]
800053be:	f5 39 00 08 	ld.ub	r9,r10[8]
800053c2:	f3 e3 10 89 	or	r9,r9,r3<<0x8
800053c6:	5c 89       	casts.h	r9
800053c8:	f6 09 19 00 	cp.h	r9,r11
800053cc:	e0 80 00 f6 	breq	800055b8 <otg_interrupt+0xa90>
		// End of DATA phase
		uhd_ctrl_phase_zlp_in();
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
800053d0:	f5 08 00 10 	ld.sh	r8,r10[16]
800053d4:	f8 08 19 00 	cp.h	r8,r12
800053d8:	c1 51       	brne	80005402 <otg_interrupt+0x8da>
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
				|| !uhd_ctrl_request_first->callback_run(
800053da:	74 58       	ld.w	r8,r10[0x14]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800053dc:	58 08       	cp.w	r8,0
800053de:	cd 40       	breq	80005386 <otg_interrupt+0x85e>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800053e0:	fe 69 04 24 	mov	r9,-130012
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800053e4:	f4 cb ff f4 	sub	r11,r10,-12
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800053e8:	72 0c       	ld.w	r12,r9[0x0]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800053ea:	2f 0a       	sub	r10,-16
800053ec:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800053f0:	5d 18       	icall	r8
800053f2:	cc a0       	breq	80005386 <otg_interrupt+0x85e>
800053f4:	6e 0a       	ld.w	r10,r7[0x0]
800053f6:	8c 0b       	ld.sh	r11,r6[0x0]
800053f8:	15 f9       	ld.ub	r9,r10[0x7]
800053fa:	f5 38 00 08 	ld.ub	r8,r10[8]
800053fe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80005402:	fe 6c 05 00 	mov	r12,-129792
80005406:	78 0e       	ld.w	lr,r12[0x0]
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80005408:	78 08       	ld.w	r8,r12[0x0]
8000540a:	e0 18 fc ff 	andl	r8,0xfcff
8000540e:	a9 b8       	sbr	r8,0x9
80005410:	99 08       	st.w	r12[0x0],r8
	uhd_ack_out_ready(0);
80005412:	fe 68 05 60 	mov	r8,-129696
80005416:	30 2c       	mov	r12,2
80005418:	91 0c       	st.w	r8[0x0],r12
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
8000541a:	f1 de c0 83 	bfextu	r8,lr,0x4,0x3

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8000541e:	f2 0b 19 00 	cp.h	r11,r9
80005422:	5f 3b       	srlo	r11
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80005424:	30 8c       	mov	r12,8
80005426:	f8 08 09 4c 	lsl	r12,r12,r8

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8000542a:	30 08       	mov	r8,0
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
8000542c:	5c 5c       	castu.b	r12

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8000542e:	f0 0c 18 00 	cp.b	r12,r8
80005432:	5f 19       	srne	r9
80005434:	f7 e9 00 09 	and	r9,r11,r9
80005438:	f0 09 18 00 	cp.b	r9,r8
8000543c:	fe 90 fe f1 	breq	8000521e <otg_interrupt+0x6f6>
80005440:	f5 09 00 10 	ld.sh	r9,r10[16]
80005444:	30 08       	mov	r8,0
80005446:	f0 09 19 00 	cp.h	r9,r8
8000544a:	fe 90 fe ea 	breq	8000521e <otg_interrupt+0x6f6>
8000544e:	10 9e       	mov	lr,r8
80005450:	fc 19 e0 00 	movh	r9,0xe000
80005454:	c0 78       	rjmp	80005462 <otg_interrupt+0x93a>
80005456:	f5 0b 00 10 	ld.sh	r11,r10[16]
8000545a:	fc 0b 19 00 	cp.h	r11,lr
8000545e:	fe 90 fe e0 	breq	8000521e <otg_interrupt+0x6f6>
			&& ep_ctrl_size && uhd_ctrl_request_first->payload_size) {
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
80005462:	74 3b       	ld.w	r11,r10[0xc]
80005464:	17 35       	ld.ub	r5,r11++
80005466:	12 c5       	st.b	r9++,r5
80005468:	95 3b       	st.w	r10[0xc],r11
		uhd_ctrl_nb_trans++;
8000546a:	8c 0a       	ld.sh	r10,r6[0x0]
8000546c:	2f fa       	sub	r10,-1
8000546e:	ac 0a       	st.h	r6[0x0],r10
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
80005470:	6e 0a       	ld.w	r10,r7[0x0]
80005472:	f5 0b 00 10 	ld.sh	r11,r10[16]
80005476:	20 1b       	sub	r11,1
80005478:	f5 5b 00 10 	st.h	r10[16],r11

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8000547c:	f8 09 01 0a 	sub	r10,r12,r9
80005480:	8c 04       	ld.sh	r4,r6[0x0]
80005482:	f0 0a 18 00 	cp.b	r10,r8
80005486:	5f 15       	srne	r5
80005488:	6e 0a       	ld.w	r10,r7[0x0]
8000548a:	15 f3       	ld.ub	r3,r10[0x7]
8000548c:	f5 3b 00 08 	ld.ub	r11,r10[8]
80005490:	f7 e3 10 8b 	or	r11,r11,r3<<0x8
80005494:	f6 04 19 00 	cp.h	r4,r11
80005498:	5f 3b       	srlo	r11
8000549a:	eb eb 00 0b 	and	r11,r5,r11
8000549e:	f0 0b 18 00 	cp.b	r11,r8
800054a2:	cd a1       	brne	80005456 <otg_interrupt+0x92e>
800054a4:	cb da       	rjmp	8000521e <otg_interrupt+0x6f6>
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
			// Stop request
			uhd_freeze_pipe(0);
800054a6:	e2 69 00 00 	mov	r9,131072
800054aa:	fe 68 05 f0 	mov	r8,-129552
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
800054ae:	30 7c       	mov	r12,7
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
			// Stop request
			uhd_freeze_pipe(0);
800054b0:	91 09       	st.w	r8[0x0],r9
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
800054b2:	fe b0 f6 cd 	rcall	8000424c <uhd_ctrl_request_end>
800054b6:	fe 9f fc f3 	bral	80004e9c <otg_interrupt+0x374>
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
		uhd_ack_disconnection();
800054ba:	30 2a       	mov	r10,2
800054bc:	fe 6b 04 08 	mov	r11,-130040
800054c0:	97 0a       	st.w	r11[0x0],r10
		uhd_disable_disconnection_int();
800054c2:	fe 6b 04 14 	mov	r11,-130028
800054c6:	97 0a       	st.w	r11[0x0],r10
		// Stop reset signal, in case of disconnection during reset
		uhd_stop_reset();
800054c8:	fe 6b 04 00 	mov	r11,-130048
800054cc:	76 0a       	ld.w	r10,r11[0x0]
800054ce:	a9 da       	cbr	r10,0x9
800054d0:	97 0a       	st.w	r11[0x0],r10
		// Disable wakeup/resumes interrupts,
		// in case of disconnection during suspend mode
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
800054d2:	35 8a       	mov	r10,88
800054d4:	f3 4a 04 14 	st.w	r9[1044],r10
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_sleep_mode(UHD_STATE_DISCONNECT);
		uhd_enable_connection_int();
800054d8:	fe 69 04 18 	mov	r9,-130024
800054dc:	30 1a       	mov	r10,1
800054de:	93 0a       	st.w	r9[0x0],r10
		uhd_suspend_start = 0;
800054e0:	e0 69 07 04 	mov	r9,1796
		uhd_resume_start = 0;
800054e4:	b2 88       	st.b	r9[0x0],r8
		uhc_notify_connection(false);
800054e6:	e0 69 07 06 	mov	r9,1798
800054ea:	10 9c       	mov	r12,r8
800054ec:	b2 88       	st.b	r9[0x0],r8
800054ee:	e0 a0 05 81 	rcall	80005ff0 <uhc_notify_connection>
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
800054f2:	fe 9f fb 27 	bral	80004b40 <otg_interrupt+0x18>
800054f6:	fe 68 04 08 	mov	r8,-130040
		uhd_disable_connection_int();
800054fa:	30 1c       	mov	r12,1
800054fc:	91 0c       	st.w	r8[0x0],r12
800054fe:	fe 68 04 14 	mov	r8,-130028
		uhd_enable_disconnection_int();
80005502:	91 0c       	st.w	r8[0x0],r12
		uhd_enable_sof();
80005504:	fe 68 04 18 	mov	r8,-130024
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
		uhd_disable_connection_int();
		uhd_enable_disconnection_int();
80005508:	fe 6a 04 00 	mov	r10,-130048
		uhd_enable_sof();
8000550c:	30 29       	mov	r9,2
8000550e:	91 09       	st.w	r8[0x0],r9
80005510:	74 08       	ld.w	r8,r10[0x0]
		uhd_sleep_mode(UHD_STATE_IDLE);
		uhd_suspend_start = 0;
80005512:	a9 a8       	sbr	r8,0x8
80005514:	95 08       	st.w	r10[0x0],r8
80005516:	e0 68 07 04 	mov	r8,1796
		uhd_resume_start = 0;
8000551a:	30 09       	mov	r9,0
		uhc_notify_connection(true);
8000551c:	b0 89       	st.b	r8[0x0],r9
8000551e:	e0 68 07 06 	mov	r8,1798
80005522:	b0 89       	st.b	r8[0x0],r9
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80005524:	e0 a0 05 66 	rcall	80005ff0 <uhc_notify_connection>
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80005528:	fe 9f fb 0c 	bral	80004b40 <otg_interrupt+0x18>
8000552c:	30 3a       	mov	r10,3
8000552e:	81 0a       	st.w	r0[0x0],r10
80005530:	fe 6c 05 00 	mov	r12,-129792
80005534:	78 0a       	ld.w	r10,r12[0x0]
	uhd_ack_in_received(0);
80005536:	e0 1a fc ff 	andl	r10,0xfcff
	uhd_ack_short_packet(0);
8000553a:	a9 aa       	sbr	r10,0x8
8000553c:	99 0a       	st.w	r12[0x0],r10
	uhd_enable_in_received_interrupt(0);
8000553e:	91 04       	st.w	r8[0x0],r4
	uhd_ack_fifocon(0);
80005540:	e0 6a 00 80 	mov	r10,128
80005544:	91 0a       	st.w	r8[0x0],r10
80005546:	97 04       	st.w	r11[0x0],r4
80005548:	fe 68 06 20 	mov	r8,-129504
	uhd_unfreeze_pipe(0);
8000554c:	e0 6a 40 00 	mov	r10,16384
	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
		otg_ack_vbus_transition();
		if (Is_otg_vbus_high()) {
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
80005550:	91 0a       	st.w	r8[0x0],r10
80005552:	91 09       	st.w	r8[0x0],r9
80005554:	fe 9f fa f6 	bral	80004b40 <otg_interrupt+0x18>
80005558:	30 1c       	mov	r12,1
		// thus the data load can restart.
		goto uhd_ctrl_receiv_in_read_data;
	}

	// Test short packet
	if ((uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength)
8000555a:	e0 a0 1a c8 	rcall	80008aea <usb_vbus_change>
8000555e:	fe 9f fa f1 	bral	80004b40 <otg_interrupt+0x18>
80005562:	15 f9       	ld.ub	r9,r10[0x7]
80005564:	f5 38 00 08 	ld.ub	r8,r10[8]
80005568:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000556c:	e0 69 28 c8 	mov	r9,10440
80005570:	92 09       	ld.sh	r9,r9[0x0]
80005572:	f0 09 19 00 	cp.h	r9,r8
80005576:	fe 90 fe c6 	breq	80005302 <otg_interrupt+0x7da>
		uhd_ctrl_phase_zlp_out();
		return;
	}

	// Send a new IN packet request
	uhd_enable_in_received_interrupt(0);
8000557a:	40 08       	lddsp	r8,sp[0x0]
8000557c:	ed b8 00 07 	bld	r8,0x7
80005580:	fe 90 fe c1 	breq	80005302 <otg_interrupt+0x7da>
80005584:	30 19       	mov	r9,1
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80005586:	fe 68 05 f0 	mov	r8,-129552
8000558a:	91 09       	st.w	r8[0x0],r9
8000558c:	fe 9f fe 4d 	bral	80005226 <otg_interrupt+0x6fe>
		}
		return;
	}
	if (Is_uhd_stall(0)) {
		// Stall Handshake received
		uhd_ack_stall(0);
80005590:	4a 49       	lddpc	r9,80005620 <otg_interrupt+0xaf8>
80005592:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		uhd_ctrl_request_end(UHD_TRANS_STALL);
80005596:	fe 9f fd 6c 	bral	8000506e <otg_interrupt+0x546>
8000559a:	34 09       	mov	r9,64
8000559c:	fe 68 05 60 	mov	r8,-129696
800055a0:	30 4c       	mov	r12,4
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
800055a2:	91 09       	st.w	r8[0x0],r9
800055a4:	fe b0 f6 54 	rcall	8000424c <uhd_ctrl_request_end>
800055a8:	fe 9f fa cc 	bral	80004b40 <otg_interrupt+0x18>
800055ac:	30 7b       	mov	r11,7
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
800055ae:	30 6c       	mov	r12,6
800055b0:	fe b0 f7 c2 	rcall	80004534 <uhd_ep_abort_pipe>
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
800055b4:	fe 9f fc cc 	bral	80004f4c <otg_interrupt+0x424>
800055b8:	30 39       	mov	r9,3
800055ba:	81 09       	st.w	r0[0x0],r9
800055bc:	fe 6a 05 00 	mov	r10,-129792
	uhd_ack_in_received(0);
800055c0:	74 09       	ld.w	r9,r10[0x0]
	uhd_ack_short_packet(0);
800055c2:	e0 19 fc ff 	andl	r9,0xfcff
800055c6:	a9 a9       	sbr	r9,0x8
	uhd_enable_in_received_interrupt(0);
800055c8:	95 09       	st.w	r10[0x0],r9
	uhd_ack_fifocon(0);
800055ca:	9d 08       	st.w	lr[0x0],r8
800055cc:	e0 69 00 80 	mov	r9,128
800055d0:	9d 09       	st.w	lr[0x0],r9
800055d2:	89 08       	st.w	r4[0x0],r8
	uhd_unfreeze_pipe(0);
800055d4:	e0 69 40 00 	mov	r9,16384
800055d8:	fe 68 06 20 	mov	r8,-129504
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
800055dc:	91 09       	st.w	r8[0x0],r9
800055de:	91 05       	st.w	r8[0x0],r5
800055e0:	fe 9f fa b0 	bral	80004b40 <otg_interrupt+0x18>
800055e4:	30 7b       	mov	r11,7
800055e6:	30 1c       	mov	r12,1
800055e8:	fe b0 f7 a6 	rcall	80004534 <uhd_ep_abort_pipe>
800055ec:	fe 9f fc 65 	bral	80004eb6 <otg_interrupt+0x38e>
800055f0:	30 7b       	mov	r11,7
800055f2:	30 2c       	mov	r12,2
800055f4:	fe b0 f7 a0 	rcall	80004534 <uhd_ep_abort_pipe>
800055f8:	fe 9f fc 6e 	bral	80004ed4 <otg_interrupt+0x3ac>
800055fc:	30 7b       	mov	r11,7
800055fe:	30 3c       	mov	r12,3
80005600:	fe b0 f7 9a 	rcall	80004534 <uhd_ep_abort_pipe>
80005604:	fe 9f fc 77 	bral	80004ef2 <otg_interrupt+0x3ca>
80005608:	30 7b       	mov	r11,7
8000560a:	30 4c       	mov	r12,4
8000560c:	fe b0 f7 94 	rcall	80004534 <uhd_ep_abort_pipe>
80005610:	fe 9f fc 80 	bral	80004f10 <otg_interrupt+0x3e8>
80005614:	30 7b       	mov	r11,7
80005616:	30 5c       	mov	r12,5
80005618:	fe b0 f7 8e 	rcall	80004534 <uhd_ep_abort_pipe>
8000561c:	fe 9f fc 89 	bral	80004f2e <otg_interrupt+0x406>
80005620:	80 01       	ld.sh	r1,r0[0x0]
80005622:	3e 04       	mov	r4,-32

80005624 <osc_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005624:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80005628:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint32_t   oscctrl;

	flags = cpu_irq_save();

	switch (id) {
8000562a:	58 0c       	cp.w	r12,0
8000562c:	c0 f0       	breq	8000564a <osc_enable+0x26>
8000562e:	30 29       	mov	r9,2
80005630:	f2 0c 18 00 	cp.b	r12,r9
80005634:	c0 61       	brne	80005640 <osc_enable+0x1c>
	case OSC_ID_OSC32:
		oscctrl = OSC32_STARTUP_VALUE
				<< AVR32_PM_OSCCTRL32_STARTUP_OFFSET;
		oscctrl |= OSC32_MODE_VALUE << AVR32_PM_OSCCTRL32_MODE_OFFSET;
		oscctrl |= 1 << AVR32_PM_OSCCTRL32_OSC32EN_OFFSET;
		AVR32_PM.oscctrl32 = oscctrl;
80005636:	e2 6a 01 01 	mov	r10,131329
8000563a:	fe 79 0c 00 	mov	r9,-62464
8000563e:	93 ca       	st.w	r9[0x30],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005640:	ed b8 00 10 	bld	r8,0x10
80005644:	c0 20       	breq	80005648 <osc_enable+0x24>
      cpu_irq_enable();
80005646:	d5 03       	csrf	0x10
		/* unhandled_case(id); */
		break;
	}

	cpu_irq_restore(flags);
}
80005648:	5e fc       	retal	r12
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
8000564a:	fe 79 0c 00 	mov	r9,-62464
8000564e:	e0 6a 03 07 	mov	r10,775
80005652:	93 aa       	st.w	r9[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80005654:	72 0a       	ld.w	r10,r9[0x0]
80005656:	a3 aa       	sbr	r10,0x2
80005658:	93 0a       	st.w	r9[0x0],r10
		break;
8000565a:	cf 3b       	rjmp	80005640 <osc_enable+0x1c>

8000565c <sysclk_priv_disable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000565c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80005660:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80005662:	fe 79 0c 00 	mov	r9,-62464
80005666:	73 58       	ld.w	r8,r9[0x54]
80005668:	ed b8 00 06 	bld	r8,0x6
8000566c:	cf d1       	brne	80005666 <sysclk_priv_disable_module+0xa>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
8000566e:	a3 6c       	lsl	r12,0x2
	mask &= ~(1U << module_index);
80005670:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80005672:	e0 2c f3 f8 	sub	r12,62456
	mask &= ~(1U << module_index);
80005676:	f0 0b 09 48 	lsl	r8,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
8000567a:	78 09       	ld.w	r9,r12[0x0]
	mask &= ~(1U << module_index);
8000567c:	5c d8       	com	r8
8000567e:	12 68       	and	r8,r9
	*(&AVR32_PM.cpumask + bus_id) = mask;
80005680:	99 08       	st.w	r12[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005682:	ed ba 00 10 	bld	r10,0x10
80005686:	c0 20       	breq	8000568a <sysclk_priv_disable_module+0x2e>
      cpu_irq_enable();
80005688:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
8000568a:	5e fc       	retal	r12

8000568c <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000568c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80005690:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80005692:	fe 79 0c 00 	mov	r9,-62464
80005696:	73 58       	ld.w	r8,r9[0x54]
80005698:	ed b8 00 06 	bld	r8,0x6
8000569c:	cf d1       	brne	80005696 <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
8000569e:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800056a0:	a3 6c       	lsl	r12,0x2
	mask |= 1U << module_index;
800056a2:	f0 0b 09 4b 	lsl	r11,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800056a6:	e0 2c f3 f8 	sub	r12,62456
800056aa:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
800056ac:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
800056ae:	99 0b       	st.w	r12[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800056b0:	ed ba 00 10 	bld	r10,0x10
800056b4:	c0 20       	breq	800056b8 <sysclk_priv_enable_module+0x2c>
      cpu_irq_enable();
800056b6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800056b8:	5e fc       	retal	r12
800056ba:	d7 03       	nop

800056bc <sysclk_disable_usb>:

/**
 * \brief Disable the USB generic clock
 */
void sysclk_disable_usb(void)
{
800056bc:	eb cd 40 80 	pushm	r7,lr
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
}

static inline void genclk_disable(unsigned int id)
{
	AVR32_PM.gcctrl[id] = 0;
800056c0:	fe 79 0c 00 	mov	r9,-62464
800056c4:	30 08       	mov	r8,0
800056c6:	f3 48 00 70 	st.w	r9[112],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800056ca:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
800056ce:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
800056d0:	73 58       	ld.w	r8,r9[0x54]
800056d2:	ed b8 00 06 	bld	r8,0x6
800056d6:	cf d1       	brne	800056d0 <sysclk_disable_usb+0x14>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800056d8:	fe 79 0c 0c 	mov	r9,-62452
800056dc:	72 08       	ld.w	r8,r9[0x0]
	mask &= ~(1U << module_index);
800056de:	a3 d8       	cbr	r8,0x3
	*(&AVR32_PM.cpumask + bus_id) = mask;
800056e0:	93 08       	st.w	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800056e2:	ed ba 00 10 	bld	r10,0x10
800056e6:	c0 20       	breq	800056ea <sysclk_disable_usb+0x2e>
      cpu_irq_enable();
800056e8:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800056ea:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
800056ee:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
800056f0:	fe 79 0c 00 	mov	r9,-62464
800056f4:	73 58       	ld.w	r8,r9[0x54]
800056f6:	ed b8 00 06 	bld	r8,0x6
800056fa:	cf d1       	brne	800056f4 <sysclk_disable_usb+0x38>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800056fc:	fe 79 0c 14 	mov	r9,-62444
80005700:	72 08       	ld.w	r8,r9[0x0]
	mask &= ~(1U << module_index);
80005702:	a1 d8       	cbr	r8,0x1
	*(&AVR32_PM.cpumask + bus_id) = mask;
80005704:	93 08       	st.w	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005706:	ed ba 00 10 	bld	r10,0x10
8000570a:	c0 20       	breq	8000570e <sysclk_disable_usb+0x52>
      cpu_irq_enable();
8000570c:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000570e:	e1 b7 00 00 	mfsr	r7,0x0
	cpu_irq_disable();
80005712:	d3 03       	ssrf	0x10
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_PBB, index);

	/* Disable the bridge if possible */
	flags = cpu_irq_save();

	sysclk_pbb_refcount--;
80005714:	e0 69 07 08 	mov	r9,1800
80005718:	13 88       	ld.ub	r8,r9[0x0]
8000571a:	20 18       	sub	r8,1
8000571c:	5c 58       	castu.b	r8
	if (!sysclk_pbb_refcount)
8000571e:	b2 88       	st.b	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005720:	c0 70       	breq	8000572e <sysclk_disable_usb+0x72>
80005722:	e6 17 00 01 	andh	r7,0x1,COH
      cpu_irq_enable();
80005726:	c0 21       	brne	8000572a <sysclk_disable_usb+0x6e>
void sysclk_disable_usb(void)
{
	genclk_disable(AVR32_PM_GCLK_USBB);
	sysclk_disable_hsb_module(SYSCLK_USBB_DATA);
	sysclk_disable_pbb_module(SYSCLK_USBB_REGS);
}
80005728:	d5 03       	csrf	0x10
8000572a:	e3 cd 80 80 	ldm	sp++,r7,pc
 * \brief Disable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_disable_hsb_module(unsigned int index)
{
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_HSB, index);
8000572e:	30 2b       	mov	r11,2
80005730:	30 1c       	mov	r12,1
80005732:	c9 5f       	rcall	8000565c <sysclk_priv_disable_module>
80005734:	cf 7b       	rjmp	80005722 <sysclk_disable_usb+0x66>
80005736:	d7 03       	nop

80005738 <sysclk_enable_pbb_module>:
80005738:	d4 01       	pushm	lr
8000573a:	e1 bb 00 00 	mfsr	r11,0x0
8000573e:	d3 03       	ssrf	0x10
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_pbb_refcount)
80005740:	e0 69 07 08 	mov	r9,1800
80005744:	13 88       	ld.ub	r8,r9[0x0]
80005746:	58 08       	cp.w	r8,0
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);

	sysclk_pbb_refcount++;
80005748:	c1 d0       	breq	80005782 <sysclk_enable_pbb_module+0x4a>
8000574a:	2f f8       	sub	r8,-1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000574c:	b2 88       	st.b	r9[0x0],r8
8000574e:	ed bb 00 10 	bld	r11,0x10
      cpu_irq_enable();
80005752:	c0 20       	breq	80005756 <sysclk_enable_pbb_module+0x1e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005754:	d5 03       	csrf	0x10
80005756:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000575a:	d3 03       	ssrf	0x10
8000575c:	fe 79 0c 00 	mov	r9,-62464
80005760:	73 58       	ld.w	r8,r9[0x54]
80005762:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
80005766:	cf d1       	brne	80005760 <sysclk_enable_pbb_module+0x28>
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80005768:	30 19       	mov	r9,1
8000576a:	fe 78 0c 14 	mov	r8,-62444
	mask |= 1U << module_index;
8000576e:	f2 0c 09 4c 	lsl	r12,r9,r12
80005772:	70 09       	ld.w	r9,r8[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
80005774:	12 4c       	or	r12,r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005776:	91 0c       	st.w	r8[0x0],r12
80005778:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
8000577c:	c0 20       	breq	80005780 <sysclk_enable_pbb_module+0x48>

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
}
8000577e:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005780:	d8 02       	popm	pc
80005782:	e1 be 00 00 	mfsr	lr,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80005786:	d3 03       	ssrf	0x10
80005788:	fe 7a 0c 00 	mov	r10,-62464
8000578c:	75 58       	ld.w	r8,r10[0x54]
8000578e:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80005792:	cf d1       	brne	8000578c <sysclk_enable_pbb_module+0x54>
80005794:	fe 7a 0c 0c 	mov	r10,-62452
	mask |= 1U << module_index;
80005798:	74 08       	ld.w	r8,r10[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
8000579a:	a3 a8       	sbr	r8,0x2
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000579c:	95 08       	st.w	r10[0x0],r8
8000579e:	ed be 00 10 	bld	lr,0x10
      cpu_irq_enable();
   }

	barrier();
800057a2:	c0 31       	brne	800057a8 <sysclk_enable_pbb_module+0x70>
800057a4:	13 88       	ld.ub	r8,r9[0x0]
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
800057a6:	cd 2b       	rjmp	8000574a <sysclk_enable_pbb_module+0x12>
   }

	barrier();
800057a8:	d5 03       	csrf	0x10
800057aa:	13 88       	ld.ub	r8,r9[0x0]
800057ac:	cc fb       	rjmp	8000574a <sysclk_enable_pbb_module+0x12>
800057ae:	d7 03       	nop

800057b0 <sysclk_enable_usb>:
 * \pre The USB generic clock must be configured to 48MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
800057b0:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800057b4:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
800057b8:	d3 03       	ssrf	0x10
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_pbb_refcount)
800057ba:	e0 67 07 08 	mov	r7,1800
800057be:	0f 88       	ld.ub	r8,r7[0x0]
800057c0:	58 08       	cp.w	r8,0
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);

	sysclk_pbb_refcount++;
800057c2:	c4 e0       	breq	8000585e <sysclk_enable_usb+0xae>
800057c4:	2f f8       	sub	r8,-1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800057c6:	ae 88       	st.b	r7[0x0],r8
800057c8:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
800057cc:	c0 21       	brne	800057d0 <sysclk_enable_usb+0x20>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800057ce:	d5 03       	csrf	0x10
800057d0:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
800057d4:	d3 03       	ssrf	0x10
800057d6:	fe 79 0c 00 	mov	r9,-62464
800057da:	73 58       	ld.w	r8,r9[0x54]
800057dc:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800057e0:	cf d1       	brne	800057da <sysclk_enable_usb+0x2a>
800057e2:	fe 79 0c 14 	mov	r9,-62444
	mask |= 1U << module_index;
800057e6:	72 08       	ld.w	r8,r9[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
800057e8:	a1 b8       	sbr	r8,0x1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800057ea:	93 08       	st.w	r9[0x0],r8
800057ec:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
800057f0:	c0 20       	breq	800057f4 <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800057f2:	d5 03       	csrf	0x10
800057f4:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
800057f8:	d3 03       	ssrf	0x10
800057fa:	fe 79 0c 00 	mov	r9,-62464
800057fe:	73 58       	ld.w	r8,r9[0x54]
80005800:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80005804:	cf d1       	brne	800057fe <sysclk_enable_usb+0x4e>
80005806:	fe 79 0c 0c 	mov	r9,-62452
	mask |= 1U << module_index;
8000580a:	72 08       	ld.w	r8,r9[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
8000580c:	a3 b8       	sbr	r8,0x3
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000580e:	93 08       	st.w	r9[0x0],r8
80005810:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
80005814:	c0 20       	breq	80005818 <sysclk_enable_usb+0x68>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80005816:	d5 03       	csrf	0x10
80005818:	fe 77 0c 00 	mov	r7,-62464

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
8000581c:	6f 58       	ld.w	r8,r7[0x54]
8000581e:	ed b8 00 01 	bld	r8,0x1
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC0RDY));
80005822:	c1 10       	breq	80005844 <sysclk_enable_usb+0x94>

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80005824:	6f 5c       	ld.w	r12,r7[0x54]
80005826:	e2 1c 00 80 	andl	r12,0x80,COH
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
8000582a:	c1 40       	breq	80005852 <sysclk_enable_usb+0xa2>
8000582c:	fe 78 0c 00 	mov	r8,-62464
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80005830:	e0 6a 02 0d 	mov	r10,525
80005834:	ea 1a 3f 0f 	orh	r10,0x3f0f
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80005838:	10 99       	mov	r9,r8

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
8000583a:	91 9a       	st.w	r8[0x24],r10
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
8000583c:	73 58       	ld.w	r8,r9[0x54]
8000583e:	ed b8 00 01 	bld	r8,0x1
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80005842:	cf d1       	brne	8000583c <sysclk_enable_usb+0x8c>
80005844:	30 79       	mov	r9,7
80005846:	fe 78 0c 00 	mov	r8,-62464
8000584a:	f1 49 00 70 	st.w	r8[112],r9
void sysclk_enable_usb(void)
{
	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
	sysclk_enable_hsb_module(SYSCLK_USBB_DATA);
	genclk_enable_config(AVR32_PM_GCLK_USBB, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
}
8000584e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
80005852:	ce 9e       	rcall	80005624 <osc_enable>
80005854:	6f 58       	ld.w	r8,r7[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80005856:	ed b8 00 07 	bld	r8,0x7
8000585a:	cf d1       	brne	80005854 <sysclk_enable_usb+0xa4>
8000585c:	ce 8b       	rjmp	8000582c <sysclk_enable_usb+0x7c>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
8000585e:	30 2b       	mov	r11,2
80005860:	30 1c       	mov	r12,1
80005862:	c1 5f       	rcall	8000568c <sysclk_priv_enable_module>
80005864:	0f 88       	ld.ub	r8,r7[0x0]
80005866:	ca fb       	rjmp	800057c4 <sysclk_enable_usb+0x14>

80005868 <sysclk_init>:
80005868:	eb cd 40 80 	pushm	r7,lr
8000586c:	fe 77 0c 00 	mov	r7,-62464
80005870:	6f 58       	ld.w	r8,r7[0x54]
80005872:	ed b8 00 00 	bld	r8,0x0
80005876:	c1 10       	breq	80005898 <sysclk_init+0x30>
80005878:	6f 5c       	ld.w	r12,r7[0x54]

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
8000587a:	e2 1c 00 80 	andl	r12,0x80,COH
8000587e:	c2 c0       	breq	800058d6 <sysclk_init+0x6e>
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80005880:	fe 78 0c 00 	mov	r8,-62464
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80005884:	e0 6a 02 05 	mov	r10,517
80005888:	ea 1a 3f 0a 	orh	r10,0x3f0a

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
8000588c:	10 99       	mov	r9,r8
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
8000588e:	91 8a       	st.w	r8[0x20],r10

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80005890:	73 58       	ld.w	r8,r9[0x54]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80005892:	ed b8 00 00 	bld	r8,0x0
80005896:	cf d1       	brne	80005890 <sysclk_init+0x28>

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80005898:	e0 6c 14 80 	mov	r12,5248
8000589c:	ea 1c 03 ef 	orh	r12,0x3ef
800058a0:	fe b0 e4 0d 	rcall	800020ba <flashc_set_bus_freq>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800058a4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800058a8:	d3 03       	ssrf	0x10
	uint32_t   mcctrl;

	Assert(src <= SYSCLK_SRC_PLL0);

	flags = cpu_irq_save();
	mcctrl = AVR32_PM.mcctrl & ~AVR32_PM_MCCTRL_MCSEL_MASK;
800058aa:	fe 7a 0c 00 	mov	r10,-62464
800058ae:	74 08       	ld.w	r8,r10[0x0]
800058b0:	e0 18 ff fc 	andl	r8,0xfffc
	mcctrl |= src << AVR32_PM_MCCTRL_MCSEL;
800058b4:	a1 b8       	sbr	r8,0x1
	AVR32_PM.mcctrl = mcctrl;
800058b6:	95 08       	st.w	r10[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800058b8:	ed b9 00 10 	bld	r9,0x10
800058bc:	c0 20       	breq	800058c0 <sysclk_init+0x58>
      cpu_irq_enable();
800058be:	d5 03       	csrf	0x10
	/* If the user has specified clock masks, enable only requested clocks */
#if defined(CONFIG_SYSCLK_INIT_CPUMASK)
	AVR32_PM.cpumask = SYSCLK_INIT_MINIMAL_CPUMASK | CONFIG_SYSCLK_INIT_CPUMASK;
#endif
#if defined(CONFIG_SYSCLK_INIT_PBAMASK)
	AVR32_PM.pbamask = SYSCLK_INIT_MINIMAL_PBAMASK | CONFIG_SYSCLK_INIT_PBAMASK;
800058c0:	fe 78 0c 00 	mov	r8,-62464
800058c4:	e0 69 43 6f 	mov	r9,17263
800058c8:	91 49       	st.w	r8[0x10],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_PBBMASK)
	AVR32_PM.pbbmask = SYSCLK_INIT_MINIMAL_PBBMASK | CONFIG_SYSCLK_INIT_PBBMASK;
800058ca:	31 59       	mov	r9,21
800058cc:	91 59       	st.w	r8[0x14],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_HSBMASK)
	AVR32_PM.hsbmask = SYSCLK_INIT_MINIMAL_HSBMASK | CONFIG_SYSCLK_INIT_HSBMASK;
800058ce:	36 39       	mov	r9,99
800058d0:	91 39       	st.w	r8[0xc],r9

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
800058d2:	e3 cd 80 80 	ldm	sp++,r7,pc
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
800058d6:	ca 7e       	rcall	80005624 <osc_enable>
800058d8:	6f 58       	ld.w	r8,r7[0x54]
800058da:	ed b8 00 07 	bld	r8,0x7
800058de:	cf d1       	brne	800058d8 <sysclk_init+0x70>
800058e0:	cd 0b       	rjmp	80005880 <sysclk_init+0x18>
800058e2:	d7 03       	nop

800058e4 <uhc_enumeration_step2>:
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
		uhc_sof_timeout_callback_t callback)
{
	uhc_sof_timeout_callback = callback;
800058e4:	fe c9 ff 70 	sub	r9,pc,-144
800058e8:	e0 68 07 2c 	mov	r8,1836
	uhc_sof_timeout = timeout;
800058ec:	91 09       	st.w	r8[0x0],r9
800058ee:	31 49       	mov	r9,20
 * Lets USB line in IDLE state during 20ms.
 */
static void uhc_enumeration_step2(void)
{
	uhc_enable_timeout_callback(20, uhc_enumeration_step3);
}
800058f0:	e0 68 28 d2 	mov	r8,10450
800058f4:	b0 89       	st.b	r8[0x0],r9
800058f6:	5e fc       	retal	r12

800058f8 <uhc_enumeration_step8>:
800058f8:	fe c9 fe 44 	sub	r9,pc,-444
800058fc:	e0 68 07 2c 	mov	r8,1836
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
		uhc_sof_timeout_callback_t callback)
{
	uhc_sof_timeout_callback = callback;
	uhc_sof_timeout = timeout;
80005900:	91 09       	st.w	r8[0x0],r9
80005902:	36 49       	mov	r9,100
 */
static void uhc_enumeration_step8(void)
{
	// Wait 100ms
	uhc_enable_timeout_callback(100, uhc_enumeration_step9);
}
80005904:	e0 68 28 d2 	mov	r8,10450
80005908:	b0 89       	st.b	r8[0x0],r9
8000590a:	5e fc       	retal	r12

8000590c <uhc_notify_sof>:
8000590c:	eb cd 40 c0 	pushm	r6-r7,lr
80005910:	48 f7       	lddpc	r7,8000594c <uhc_notify_sof+0x40>
80005912:	18 96       	mov	r6,r12

void uhc_notify_sof(bool b_micro)
{
	// Call all UHIs
	for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
		if (uhc_uhis[i].sof_notify != NULL) {
80005914:	6e 38       	ld.w	r8,r7[0xc]
80005916:	58 08       	cp.w	r8,0
80005918:	c0 20       	breq	8000591c <uhc_notify_sof+0x10>
			uhc_uhis[i].sof_notify(b_micro);
8000591a:	5d 18       	icall	r8

void uhc_notify_sof(bool b_micro)
{
	// Call all UHIs
	for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
		if (uhc_uhis[i].sof_notify != NULL) {
8000591c:	6e 78       	ld.w	r8,r7[0x1c]
8000591e:	58 08       	cp.w	r8,0
80005920:	c0 30       	breq	80005926 <uhc_notify_sof+0x1a>
			uhc_uhis[i].sof_notify(b_micro);
80005922:	0c 9c       	mov	r12,r6
80005924:	5d 18       	icall	r8
		}
	}

	if (!b_micro) {
80005926:	58 06       	cp.w	r6,0
80005928:	c0 a1       	brne	8000593c <uhc_notify_sof+0x30>
		// Manage SOF timeout
		if (uhc_sof_timeout) {
8000592a:	e0 68 28 d2 	mov	r8,10450
8000592e:	11 89       	ld.ub	r9,r8[0x0]
80005930:	58 09       	cp.w	r9,0
			if (--uhc_sof_timeout == 0) {
80005932:	c0 50       	breq	8000593c <uhc_notify_sof+0x30>
80005934:	20 19       	sub	r9,1
80005936:	5c 59       	castu.b	r9
80005938:	b0 89       	st.b	r8[0x0],r9
8000593a:	c0 30       	breq	80005940 <uhc_notify_sof+0x34>
8000593c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
				uhc_sof_timeout_callback();
80005940:	e0 68 07 2c 	mov	r8,1836
80005944:	70 08       	ld.w	r8,r8[0x0]
80005946:	5d 18       	icall	r8
80005948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000594c:	80 01       	ld.sh	r1,r0[0x0]
8000594e:	41 24       	lddsp	r4,sp[0x48]

80005950 <uhc_stop>:
80005950:	d4 01       	pushm	lr
80005952:	fe b0 f4 27 	rcall	800041a0 <uhd_disable>

void uhc_stop(bool b_id_stop)
{
	// Stop UHD
	uhd_disable(b_id_stop);
}
80005956:	d8 02       	popm	pc

80005958 <uhc_start>:
80005958:	d4 01       	pushm	lr
8000595a:	3f f9       	mov	r9,-1
 *
 * @{
 */
void uhc_start(void)
{
	g_uhc_device_root.address = UHC_USB_ADD_NOT_VALID;
8000595c:	e0 68 07 0c 	mov	r8,1804
80005960:	f1 69 00 12 	st.b	r8[18],r9
	uhc_sof_timeout = 0; // No callback registered on a SOF timeout
80005964:	30 09       	mov	r9,0
80005966:	e0 68 28 d2 	mov	r8,10450
	uhd_enable();
8000596a:	b0 89       	st.b	r8[0x0],r9
}
8000596c:	fe b0 f3 b6 	rcall	800040d8 <uhd_enable>
80005970:	d8 02       	popm	pc
80005972:	d7 03       	nop

80005974 <uhc_enumeration_step3>:
80005974:	d4 01       	pushm	lr
80005976:	fe cc ff ea 	sub	r12,pc,-22
8000597a:	fe b0 f1 ed 	rcall	80003d54 <uhd_send_reset>
 * Reset USB line.
 */
static void uhc_enumeration_step3(void)
{
	uhc_enumeration_reset(uhc_enumeration_step4);
}
8000597e:	d8 02       	popm	pc

80005980 <uhc_enumeration_step7>:
80005980:	d4 01       	pushm	lr
80005982:	fe cc 00 8a 	sub	r12,pc,138
80005986:	fe b0 f1 e7 	rcall	80003d54 <uhd_send_reset>
 * Reset USB line.
 */
static void uhc_enumeration_step7(void)
{
	uhc_enumeration_reset(uhc_enumeration_step8);
}
8000598a:	d8 02       	popm	pc

8000598c <uhc_enumeration_step4>:
8000598c:	d4 01       	pushm	lr
8000598e:	fe b0 f1 d5 	rcall	80003d38 <uhd_get_speed>
80005992:	e0 68 07 0c 	mov	r8,1804
 * \brief Device enumeration step 4
 * Lets USB line in IDLE state during 100ms.
 */
static void uhc_enumeration_step4(void)
{
	uhc_dev_enum->speed = uhd_get_speed();
80005996:	fe c9 ff 82 	sub	r9,pc,-126
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
		uhc_sof_timeout_callback_t callback)
{
	uhc_sof_timeout_callback = callback;
8000599a:	91 5c       	st.w	r8[0x14],r12
	uhc_sof_timeout = timeout;
8000599c:	e0 68 07 2c 	mov	r8,1836
800059a0:	91 09       	st.w	r8[0x0],r9
 */
static void uhc_enumeration_step4(void)
{
	uhc_dev_enum->speed = uhd_get_speed();
	uhc_enable_timeout_callback(100, uhc_enumeration_step5);
}
800059a2:	36 49       	mov	r9,100
800059a4:	e0 68 28 d2 	mov	r8,10450
800059a8:	b0 89       	st.b	r8[0x0],r9
800059aa:	d8 02       	popm	pc

800059ac <uhc_enumeration_error>:
800059ac:	d4 21       	pushm	r4-r7,lr
800059ae:	18 96       	mov	r6,r12
800059b0:	58 7c       	cp.w	r12,7
800059b2:	c2 c0       	breq	80005a0a <uhc_enumeration_error+0x5e>
800059b4:	e0 67 07 0c 	mov	r7,1804
{
	if (status == UHC_ENUM_DISCONNECT) {
		uhc_enum_try = 0;
		return; // Abort enumeration process
	}
	uhd_ep_free(uhc_dev_enum->address, 0xFF);
800059b8:	e0 6b 00 ff 	mov	r11,255
800059bc:	ef 3c 00 12 	ld.ub	r12,r7[18]
800059c0:	fe b0 f6 20 	rcall	80004600 <uhd_ep_free>

	// Free USB configuration descriptor buffer
	if (uhc_dev_enum->conf_desc != NULL) {
800059c4:	6e 6c       	ld.w	r12,r7[0x18]
800059c6:	58 0c       	cp.w	r12,0
		free(uhc_dev_enum->conf_desc);
800059c8:	c0 50       	breq	800059d2 <uhc_enumeration_error+0x26>
800059ca:	e0 a0 46 d3 	rcall	8000e770 <free>
		uhc_dev_enum->conf_desc = NULL;
800059ce:	30 08       	mov	r8,0
	}
	uhc_dev_enum->address = 0;
	if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
800059d0:	8f 68       	st.w	r7[0x18],r8
	// Free USB configuration descriptor buffer
	if (uhc_dev_enum->conf_desc != NULL) {
		free(uhc_dev_enum->conf_desc);
		uhc_dev_enum->conf_desc = NULL;
	}
	uhc_dev_enum->address = 0;
800059d2:	e0 65 07 28 	mov	r5,1832
800059d6:	30 04       	mov	r4,0
800059d8:	0b 88       	ld.ub	r8,r5[0x0]
	if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
800059da:	ef 64 00 12 	st.b	r7[18],r4
800059de:	f0 c9 ff ff 	sub	r9,r8,-1
800059e2:	aa 89       	st.b	r5[0x0],r9
800059e4:	30 39       	mov	r9,3
800059e6:	f2 08 18 00 	cp.b	r8,r9
		uhi_hub_suspend(uhc_dev_enum);
	} else
#endif
	{
		// Suspend USB line
		uhd_suspend();
800059ea:	e0 88 00 0b 	brls	80005a00 <uhc_enumeration_error+0x54>
		uhc_enumeration_step1();
		return;
	}
	// Abort enumeration, set line in suspend mode
	uhc_enumeration_suspend();
	UHC_ENUM_EVENT(uhc_dev_enum, status);
800059ee:	fe b0 f1 bd 	rcall	80003d68 <uhd_suspend>
800059f2:	0c 9b       	mov	r11,r6
800059f4:	e0 6c 07 0c 	mov	r12,1804
	uhc_enum_try = 0;
800059f8:	e0 a0 18 7e 	rcall	80008af4 <usb_enum>
		// Device connected on USB hub
		uhi_hub_send_reset(uhc_dev_enum, callback);
	} else
#endif
	{
		uhd_send_reset(callback);
800059fc:	aa 84       	st.b	r5[0x0],r4
800059fe:	d8 22       	popm	r4-r7,pc
	}
	uhc_dev_enum->address = 0;
	if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
		// Restart enumeration at beginning
		uhc_enumeration_step1();
		return;
80005a00:	fe cc 01 1c 	sub	r12,pc,284
 * \param status        Enumeration error occurred
 */
static void uhc_enumeration_error(uhc_enum_status_t status)
{
	if (status == UHC_ENUM_DISCONNECT) {
		uhc_enum_try = 0;
80005a04:	fe b0 f1 a8 	rcall	80003d54 <uhd_send_reset>
		return; // Abort enumeration process
80005a08:	d8 22       	popm	r4-r7,pc
80005a0a:	30 09       	mov	r9,0
80005a0c:	e0 68 07 28 	mov	r8,1832
80005a10:	b0 89       	st.b	r8[0x0],r9
80005a12:	d8 22       	popm	r4-r7,pc

80005a14 <uhc_enumeration_step5>:
80005a14:	d4 01       	pushm	lr
80005a16:	20 2d       	sub	sp,8
80005a18:	38 08       	mov	r8,-128
80005a1a:	ba 88       	st.b	sp[0x0],r8
80005a1c:	30 68       	mov	r8,6
80005a1e:	ba 98       	st.b	sp[0x1],r8
80005a20:	e0 68 01 00 	mov	r8,256
80005a24:	ba 18       	st.h	sp[0x2],r8
80005a26:	30 08       	mov	r8,0
80005a28:	ba 28       	st.h	sp[0x4],r8
80005a2a:	30 88       	mov	r8,8
	req.wValue = (USB_DT_DEVICE << 8);
	req.wIndex = 0;
	req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
			+ sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

	if (!uhd_ep0_alloc(0, 64)) {
80005a2c:	34 0b       	mov	r11,64

	req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
	req.wValue = (USB_DT_DEVICE << 8);
	req.wIndex = 0;
	req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
80005a2e:	ba 38       	st.h	sp[0x6],r8
			+ sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

	if (!uhd_ep0_alloc(0, 64)) {
80005a30:	30 0c       	mov	r12,0
80005a32:	fe b0 f2 c8 	rcall	80003fc2 <uhd_ep0_alloc>
80005a36:	c1 60       	breq	80005a62 <uhc_enumeration_step5+0x4e>
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
		return;
	}
	if (!uhd_setup_request(0,
80005a38:	fe c9 ff cc 	sub	r9,pc,-52
80005a3c:	30 08       	mov	r8,0
80005a3e:	1a d9       	st.w	--sp,r9
80005a40:	e0 6a 07 0c 	mov	r10,1804
80005a44:	fa cb ff fc 	sub	r11,sp,-4
80005a48:	31 29       	mov	r9,18
80005a4a:	10 9c       	mov	r12,r8
80005a4c:	fe b0 f4 de 	rcall	80004408 <uhd_setup_request>
80005a50:	2f fd       	sub	sp,-4
			NULL,
			uhc_enumeration_step6)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005a52:	58 0c       	cp.w	r12,0
80005a54:	c0 30       	breq	80005a5a <uhc_enumeration_step5+0x46>
			&req,
			(uint8_t*)&uhc_dev_enum->dev_desc,
			sizeof(usb_dev_desc_t),
			NULL,
			uhc_enumeration_step6)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005a56:	2f ed       	sub	sp,-8
80005a58:	d8 02       	popm	pc
80005a5a:	30 6c       	mov	r12,6
		return;
	}
}
80005a5c:	ca 8f       	rcall	800059ac <uhc_enumeration_error>
80005a5e:	2f ed       	sub	sp,-8
	req.wIndex = 0;
	req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
			+ sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

	if (!uhd_ep0_alloc(0, 64)) {
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80005a60:	d8 02       	popm	pc
80005a62:	30 4c       	mov	r12,4
80005a64:	ca 4f       	rcall	800059ac <uhc_enumeration_error>
			NULL,
			uhc_enumeration_step6)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005a66:	2f ed       	sub	sp,-8
80005a68:	d8 02       	popm	pc
80005a6a:	d7 03       	nop

80005a6c <uhc_enumeration_step6>:
80005a6c:	d4 01       	pushm	lr
80005a6e:	30 79       	mov	r9,7
80005a70:	58 0b       	cp.w	r11,0
80005a72:	5f 18       	srne	r8
80005a74:	f2 0a 19 00 	cp.h	r10,r9
80005a78:	5f 89       	srls	r9
80005a7a:	f3 e8 10 08 	or	r8,r9,r8
80005a7e:	c0 b1       	brne	80005a94 <uhc_enumeration_step6+0x28>
		usb_add_t add,
		uhd_trans_status_t status,
		uint16_t payload_trans)
{
	UNUSED(add);
	if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
80005a80:	e0 68 07 0c 	mov	r8,1804
80005a84:	11 99       	ld.ub	r9,r8[0x1]
80005a86:	30 18       	mov	r8,1
80005a88:	f0 09 18 00 	cp.b	r9,r8
			|| (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
		uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80005a8c:	c0 90       	breq	80005a9e <uhc_enumeration_step6+0x32>
80005a8e:	30 3c       	mov	r12,3
80005a90:	c8 ef       	rcall	800059ac <uhc_enumeration_error>
				UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
		return;
80005a92:	d8 02       	popm	pc
		uint16_t payload_trans)
{
	UNUSED(add);
	if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
			|| (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
		uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80005a94:	58 1b       	cp.w	r11,1
80005a96:	cf c1       	brne	80005a8e <uhc_enumeration_step6+0x22>
80005a98:	30 7c       	mov	r12,7
80005a9a:	c8 9f       	rcall	800059ac <uhc_enumeration_error>
80005a9c:	d8 02       	popm	pc
				UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
		return;
80005a9e:	fe c9 01 1e 	sub	r9,pc,286
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
		uhc_sof_timeout_callback_t callback)
{
	uhc_sof_timeout_callback = callback;
80005aa2:	e0 68 07 2c 	mov	r8,1836
	uhc_sof_timeout = timeout;
80005aa6:	91 09       	st.w	r8[0x0],r9
80005aa8:	31 49       	mov	r9,20
80005aaa:	e0 68 28 d2 	mov	r8,10450
80005aae:	b0 89       	st.b	r8[0x0],r9
80005ab0:	d8 02       	popm	pc
80005ab2:	d7 03       	nop

80005ab4 <uhc_enumeration_step9>:
80005ab4:	eb cd 40 80 	pushm	r7,lr
80005ab8:	20 2d       	sub	sp,8
80005aba:	30 18       	mov	r8,1
80005abc:	e0 67 07 0c 	mov	r7,1804
80005ac0:	ba 18       	st.h	sp[0x2],r8
80005ac2:	ef 68 00 12 	st.b	r7[18],r8
#else
	req.wValue = UHC_DEVICE_ENUM_ADD;
	uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
	req.wIndex = 0;
	req.wLength = 0;
80005ac6:	30 08       	mov	r8,0
	uhc_dev_enum->address = usb_addr_free;
#else
	req.wValue = UHC_DEVICE_ENUM_ADD;
	uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
	req.wIndex = 0;
80005ac8:	ba 38       	st.h	sp[0x6],r8
 */
static void uhc_enumeration_step9(void)
{
	usb_setup_req_t req;

	req.bmRequestType = USB_REQ_RECIP_DEVICE
80005aca:	ba 28       	st.h	sp[0x4],r8
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_ADDRESS;
80005acc:	ba 88       	st.b	sp[0x0],r8
#endif
	req.wIndex = 0;
	req.wLength = 0;

	// After a USB reset, the reallocation is required
	uhd_ep_free(0, 0);
80005ace:	30 58       	mov	r8,5
{
	usb_setup_req_t req;

	req.bmRequestType = USB_REQ_RECIP_DEVICE
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_ADDRESS;
80005ad0:	30 0b       	mov	r11,0
#endif
	req.wIndex = 0;
	req.wLength = 0;

	// After a USB reset, the reallocation is required
	uhd_ep_free(0, 0);
80005ad2:	ba 98       	st.b	sp[0x1],r8
80005ad4:	16 9c       	mov	r12,r11
80005ad6:	fe b0 f5 95 	rcall	80004600 <uhd_ep_free>
	if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
80005ada:	0f fb       	ld.ub	r11,r7[0x7]
80005adc:	30 0c       	mov	r12,0
80005ade:	fe b0 f2 72 	rcall	80003fc2 <uhd_ep0_alloc>
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
		return;
	}

	if (!uhd_setup_request(0,
80005ae2:	c1 70       	breq	80005b10 <uhc_enumeration_step9+0x5c>
80005ae4:	fe c9 ff c8 	sub	r9,pc,-56
80005ae8:	30 08       	mov	r8,0
80005aea:	1a d9       	st.w	--sp,r9
80005aec:	0e 9a       	mov	r10,r7
80005aee:	fa cb ff fc 	sub	r11,sp,-4
80005af2:	31 29       	mov	r9,18
80005af4:	10 9c       	mov	r12,r8
80005af6:	fe b0 f4 89 	rcall	80004408 <uhd_setup_request>
80005afa:	2f fd       	sub	sp,-4
			NULL,
			uhc_enumeration_step10)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005afc:	58 0c       	cp.w	r12,0
80005afe:	c0 40       	breq	80005b06 <uhc_enumeration_step9+0x52>
80005b00:	2f ed       	sub	sp,-8
			&req,
			(uint8_t*)&uhc_dev_enum->dev_desc,
			sizeof(usb_dev_desc_t),
			NULL,
			uhc_enumeration_step10)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005b02:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b06:	30 6c       	mov	r12,6
		return;
	}
}
80005b08:	c5 2f       	rcall	800059ac <uhc_enumeration_error>
80005b0a:	2f ed       	sub	sp,-8
80005b0c:	e3 cd 80 80 	ldm	sp++,r7,pc
	req.wLength = 0;

	// After a USB reset, the reallocation is required
	uhd_ep_free(0, 0);
	if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80005b10:	30 4c       	mov	r12,4
80005b12:	c4 df       	rcall	800059ac <uhc_enumeration_error>
			NULL,
			uhc_enumeration_step10)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005b14:	2f ed       	sub	sp,-8
80005b16:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b1a:	d7 03       	nop

80005b1c <uhc_enumeration_step10>:
80005b1c:	d4 01       	pushm	lr
80005b1e:	58 0b       	cp.w	r11,0
80005b20:	c0 80       	breq	80005b30 <uhc_enumeration_step10+0x14>
80005b22:	58 1b       	cp.w	r11,1
80005b24:	f9 bc 00 07 	moveq	r12,7
80005b28:	f9 bc 01 03 	movne	r12,3
80005b2c:	c4 0f       	rcall	800059ac <uhc_enumeration_error>
80005b2e:	d8 02       	popm	pc
80005b30:	fe c9 ff ec 	sub	r9,pc,-20
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
		uhc_sof_timeout_callback_t callback)
{
	uhc_sof_timeout_callback = callback;
80005b34:	e0 68 07 2c 	mov	r8,1836
	uhc_sof_timeout = timeout;
80005b38:	91 09       	st.w	r8[0x0],r9
80005b3a:	31 49       	mov	r9,20
80005b3c:	e0 68 28 d2 	mov	r8,10450
80005b40:	b0 89       	st.b	r8[0x0],r9
80005b42:	d8 02       	popm	pc

80005b44 <uhc_enumeration_step11>:
80005b44:	eb cd 40 80 	pushm	r7,lr
80005b48:	20 2d       	sub	sp,8
80005b4a:	30 0b       	mov	r11,0
80005b4c:	16 9c       	mov	r12,r11
80005b4e:	fe b0 f5 59 	rcall	80004600 <uhd_ep_free>

	// Free address 0 used to start enumeration
	uhd_ep_free(0, 0);

	// Alloc control endpoint with the new USB address
	if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
80005b52:	30 1c       	mov	r12,1
80005b54:	e0 67 07 0c 	mov	r7,1804
80005b58:	0f fb       	ld.ub	r11,r7[0x7]
80005b5a:	fe b0 f2 34 	rcall	80003fc2 <uhd_ep0_alloc>
			uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
		return;
	}
	// Send USB device descriptor request
	req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80005b5e:	c2 20       	breq	80005ba2 <uhc_enumeration_step11+0x5e>
80005b60:	38 08       	mov	r8,-128
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
80005b62:	ba 88       	st.b	sp[0x0],r8
80005b64:	30 68       	mov	r8,6
	req.wValue = (USB_DT_DEVICE << 8);
80005b66:	ba 98       	st.b	sp[0x1],r8
80005b68:	e0 68 01 00 	mov	r8,256
	req.wIndex = 0;
80005b6c:	ba 18       	st.h	sp[0x2],r8
80005b6e:	30 08       	mov	r8,0
	req.wLength = sizeof(usb_dev_desc_t);
80005b70:	ba 28       	st.h	sp[0x4],r8
80005b72:	31 28       	mov	r8,18
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005b74:	ba 38       	st.h	sp[0x6],r8
80005b76:	fe c8 ff ca 	sub	r8,pc,-54
80005b7a:	0e 9a       	mov	r10,r7
80005b7c:	1a d8       	st.w	--sp,r8
80005b7e:	31 29       	mov	r9,18
80005b80:	fa cb ff fc 	sub	r11,sp,-4
80005b84:	30 08       	mov	r8,0
80005b86:	30 1c       	mov	r12,1
80005b88:	fe b0 f4 40 	rcall	80004408 <uhd_setup_request>
80005b8c:	2f fd       	sub	sp,-4
			sizeof(usb_dev_desc_t),
			NULL, uhc_enumeration_step12)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005b8e:	58 0c       	cp.w	r12,0
80005b90:	c0 40       	breq	80005b98 <uhc_enumeration_step11+0x54>
80005b92:	2f ed       	sub	sp,-8
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			&req,
			(uint8_t *) & uhc_dev_enum->dev_desc,
			sizeof(usb_dev_desc_t),
			NULL, uhc_enumeration_step12)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005b94:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b98:	30 6c       	mov	r12,6
		return;
	}
}
80005b9a:	c0 9f       	rcall	800059ac <uhc_enumeration_error>
80005b9c:	2f ed       	sub	sp,-8
80005b9e:	e3 cd 80 80 	ldm	sp++,r7,pc
	uhd_ep_free(0, 0);

	// Alloc control endpoint with the new USB address
	if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
			uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
		uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80005ba2:	30 4c       	mov	r12,4
80005ba4:	c0 4f       	rcall	800059ac <uhc_enumeration_error>
			sizeof(usb_dev_desc_t),
			NULL, uhc_enumeration_step12)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
}
80005ba6:	2f ed       	sub	sp,-8
80005ba8:	e3 cd 80 80 	ldm	sp++,r7,pc

80005bac <uhc_enumeration_step12>:
80005bac:	eb cd 40 80 	pushm	r7,lr
80005bb0:	20 2d       	sub	sp,8
80005bb2:	31 29       	mov	r9,18
80005bb4:	58 0b       	cp.w	r11,0
80005bb6:	5f 18       	srne	r8
80005bb8:	f2 0a 19 00 	cp.h	r10,r9
80005bbc:	5f 19       	srne	r9
80005bbe:	f3 e8 10 08 	or	r8,r9,r8
80005bc2:	c0 d1       	brne	80005bdc <uhc_enumeration_step12+0x30>
{
	usb_setup_req_t req;
	uint8_t conf_num;
	UNUSED(add);

	if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
80005bc4:	e0 67 07 0c 	mov	r7,1804
80005bc8:	30 18       	mov	r8,1
80005bca:	0f 99       	ld.ub	r9,r7[0x1]
80005bcc:	f0 09 18 00 	cp.b	r9,r8
			|| (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
		uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80005bd0:	c0 a0       	breq	80005be4 <uhc_enumeration_step12+0x38>
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			&req,
			(uint8_t *) uhc_dev_enum->conf_desc,
			sizeof(usb_conf_desc_t),
			NULL, uhc_enumeration_step13)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005bd2:	30 3c       	mov	r12,3
80005bd4:	ce ce       	rcall	800059ac <uhc_enumeration_error>
		return;
	}
}
80005bd6:	2f ed       	sub	sp,-8
80005bd8:	e3 cd 80 80 	ldm	sp++,r7,pc
	uint8_t conf_num;
	UNUSED(add);

	if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
			|| (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
		uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80005bdc:	58 1b       	cp.w	r11,1
80005bde:	cf a1       	brne	80005bd2 <uhc_enumeration_step12+0x26>
80005be0:	30 7c       	mov	r12,7
80005be2:	cf 9b       	rjmp	80005bd4 <uhc_enumeration_step12+0x28>
		conf_num = UHC_DEVICE_CONF(uhc_dev_enum);
	} else {
		conf_num = 1;
	}

	uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
80005be4:	30 9c       	mov	r12,9
80005be6:	e0 a0 45 cd 	rcall	8000e780 <malloc>
80005bea:	8f 6c       	st.w	r7[0x18],r12
	if (uhc_dev_enum->conf_desc == NULL) {
80005bec:	c1 c0       	breq	80005c24 <uhc_enumeration_step12+0x78>
		Assert(false);
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
	// Send USB device descriptor request
	req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80005bee:	38 08       	mov	r8,-128
80005bf0:	ba 88       	st.b	sp[0x0],r8
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
80005bf2:	30 68       	mov	r8,6
80005bf4:	ba 98       	st.b	sp[0x1],r8
	req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80005bf6:	e0 68 02 00 	mov	r8,512
80005bfa:	ba 18       	st.h	sp[0x2],r8
	req.wIndex = 0;
80005bfc:	30 08       	mov	r8,0
80005bfe:	ba 28       	st.h	sp[0x4],r8
	req.wLength = sizeof(usb_conf_desc_t);
80005c00:	30 98       	mov	r8,9
80005c02:	ba 38       	st.h	sp[0x6],r8
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005c04:	fe c8 ff d8 	sub	r8,pc,-40
80005c08:	18 9a       	mov	r10,r12
80005c0a:	1a d8       	st.w	--sp,r8
80005c0c:	30 99       	mov	r9,9
80005c0e:	fa cb ff fc 	sub	r11,sp,-4
80005c12:	30 08       	mov	r8,0
80005c14:	30 1c       	mov	r12,1
80005c16:	fe b0 f3 f9 	rcall	80004408 <uhd_setup_request>
80005c1a:	2f fd       	sub	sp,-4
80005c1c:	58 0c       	cp.w	r12,0
			&req,
			(uint8_t *) uhc_dev_enum->conf_desc,
			sizeof(usb_conf_desc_t),
			NULL, uhc_enumeration_step13)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005c1e:	cd c1       	brne	80005bd6 <uhc_enumeration_step12+0x2a>
80005c20:	30 6c       	mov	r12,6
	}

	uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
	if (uhc_dev_enum->conf_desc == NULL) {
		Assert(false);
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005c22:	cd 9b       	rjmp	80005bd4 <uhc_enumeration_step12+0x28>
80005c24:	30 6c       	mov	r12,6
80005c26:	cc 3e       	rcall	800059ac <uhc_enumeration_error>
		return;
80005c28:	cd 7b       	rjmp	80005bd6 <uhc_enumeration_step12+0x2a>
80005c2a:	d7 03       	nop

80005c2c <uhc_enumeration_step13>:
80005c2c:	eb cd 40 e0 	pushm	r5-r7,lr
80005c30:	20 2d       	sub	sp,8
80005c32:	30 99       	mov	r9,9
80005c34:	58 0b       	cp.w	r11,0
80005c36:	5f 18       	srne	r8
80005c38:	f2 0a 19 00 	cp.h	r10,r9
80005c3c:	5f 19       	srne	r9
80005c3e:	f3 e8 10 08 	or	r8,r9,r8
	uint8_t conf_num, conf_size;
	uint16_t bus_power = 0;
	usb_setup_req_t req;
	UNUSED(add);

	if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
80005c42:	c0 e1       	brne	80005c5e <uhc_enumeration_step13+0x32>
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
80005c44:	e0 67 07 0c 	mov	r7,1804
80005c48:	30 29       	mov	r9,2
	uint8_t conf_num, conf_size;
	uint16_t bus_power = 0;
	usb_setup_req_t req;
	UNUSED(add);

	if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
80005c4a:	6e 68       	ld.w	r8,r7[0x18]
80005c4c:	11 9a       	ld.ub	r10,r8[0x1]
80005c4e:	f2 0a 18 00 	cp.b	r10,r9
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
		uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80005c52:	c0 a0       	breq	80005c66 <uhc_enumeration_step13+0x3a>
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			&req,
			(uint8_t *) uhc_dev_enum->conf_desc,
			conf_size,
			NULL, uhc_enumeration_step14)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005c54:	30 3c       	mov	r12,3
80005c56:	ca be       	rcall	800059ac <uhc_enumeration_error>
		return;
	}
}
80005c58:	2f ed       	sub	sp,-8
80005c5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	usb_setup_req_t req;
	UNUSED(add);

	if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
		uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80005c5e:	58 1b       	cp.w	r11,1
80005c60:	cf a1       	brne	80005c54 <uhc_enumeration_step13+0x28>
80005c62:	30 7c       	mov	r12,7
80005c64:	cf 9b       	rjmp	80005c56 <uhc_enumeration_step13+0x2a>
		}
		// Go to USB HUB parent
		dev = dev->hub;
	}
#else
	if (!(uhc_dev_enum->conf_desc->bmAttributes
80005c66:	11 f9       	ld.ub	r9,r8[0x7]
80005c68:	ed b9 00 06 	bld	r9,0x6
80005c6c:	c1 10       	breq	80005c8e <uhc_enumeration_step13+0x62>
			&USB_CONFIG_ATTR_SELF_POWERED)) {
		bus_power = uhc_dev_enum->conf_desc->bMaxPower * 2;
80005c6e:	f1 3a 00 08 	ld.ub	r10,r8[8]
80005c72:	e0 69 01 f4 	mov	r9,500
80005c76:	a1 7a       	lsl	r10,0x1
80005c78:	f2 0a 19 00 	cp.h	r10,r9
80005c7c:	e0 88 00 09 	brls	80005c8e <uhc_enumeration_step13+0x62>
	}
#endif
	if ((bus_power + uhc_power_running) > USB_HOST_POWER_MAX) {
		// USB interfaces consumption too high
		UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_OVERCURRENT);
80005c80:	0e 9c       	mov	r12,r7
80005c82:	30 2b       	mov	r11,2
80005c84:	e0 a0 17 38 	rcall	80008af4 <usb_enum>
		uhi_hub_suspend(uhc_dev_enum);
	} else
#endif
	{
		// Suspend USB line
		uhd_suspend();
80005c88:	fe b0 f0 70 	rcall	80003d68 <uhd_suspend>
80005c8c:	ce 6b       	rjmp	80005c58 <uhc_enumeration_step13+0x2c>
	uhc_dev_enum->power = bus_power;
	uhc_power_running += bus_power;
#endif

	// Save information about USB configuration descriptor size
	conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
80005c8e:	11 a6       	ld.ub	r6,r8[0x2]
	conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
80005c90:	6e 68       	ld.w	r8,r7[0x18]
	Assert(conf_num);
	// Re alloc USB configuration descriptor
	free(uhc_dev_enum->conf_desc);
80005c92:	10 9c       	mov	r12,r8
	uhc_power_running += bus_power;
#endif

	// Save information about USB configuration descriptor size
	conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
	conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
80005c94:	11 d5       	ld.ub	r5,r8[0x5]
	Assert(conf_num);
	// Re alloc USB configuration descriptor
	free(uhc_dev_enum->conf_desc);
80005c96:	e0 a0 45 6d 	rcall	8000e770 <free>
	uhc_dev_enum->conf_desc = malloc(conf_size);
80005c9a:	0c 9c       	mov	r12,r6
80005c9c:	e0 a0 45 72 	rcall	8000e780 <malloc>
80005ca0:	8f 6c       	st.w	r7[0x18],r12
	if (uhc_dev_enum->conf_desc == NULL) {
80005ca2:	c1 b0       	breq	80005cd8 <uhc_enumeration_step13+0xac>
		Assert(false);
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
		return;
	}
	// Send USB device descriptor request
	req.bmRequestType =
80005ca4:	38 08       	mov	r8,-128
80005ca6:	ba 88       	st.b	sp[0x0],r8
			USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
			USB_REQ_DIR_IN;
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
80005ca8:	30 68       	mov	r8,6
80005caa:	ba 98       	st.b	sp[0x1],r8
	req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
	req.wIndex = 0;
80005cac:	30 08       	mov	r8,0
80005cae:	ba 28       	st.h	sp[0x4],r8
	req.wLength = conf_size;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005cb0:	fe c8 ff 60 	sub	r8,pc,-160
80005cb4:	ba 36       	st.h	sp[0x6],r6
	// Send USB device descriptor request
	req.bmRequestType =
			USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
			USB_REQ_DIR_IN;
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
	req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80005cb6:	18 9a       	mov	r10,r12
	req.wIndex = 0;
	req.wLength = conf_size;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005cb8:	20 15       	sub	r5,1
	// Send USB device descriptor request
	req.bmRequestType =
			USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
			USB_REQ_DIR_IN;
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
	req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80005cba:	0c 99       	mov	r9,r6
	req.wIndex = 0;
	req.wLength = conf_size;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005cbc:	a9 b5       	sbr	r5,0x9
	// Send USB device descriptor request
	req.bmRequestType =
			USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
			USB_REQ_DIR_IN;
	req.bRequest = USB_REQ_GET_DESCRIPTOR;
	req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80005cbe:	30 1c       	mov	r12,1
	req.wIndex = 0;
	req.wLength = conf_size;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005cc0:	ba 15       	st.h	sp[0x2],r5
80005cc2:	1a d8       	st.w	--sp,r8
80005cc4:	30 08       	mov	r8,0
80005cc6:	fa cb ff fc 	sub	r11,sp,-4
80005cca:	fe b0 f3 9f 	rcall	80004408 <uhd_setup_request>
80005cce:	2f fd       	sub	sp,-4
80005cd0:	58 0c       	cp.w	r12,0
			&req,
			(uint8_t *) uhc_dev_enum->conf_desc,
			conf_size,
			NULL, uhc_enumeration_step14)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005cd2:	cc 31       	brne	80005c58 <uhc_enumeration_step13+0x2c>
80005cd4:	30 6c       	mov	r12,6
	// Re alloc USB configuration descriptor
	free(uhc_dev_enum->conf_desc);
	uhc_dev_enum->conf_desc = malloc(conf_size);
	if (uhc_dev_enum->conf_desc == NULL) {
		Assert(false);
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005cd6:	cc 0b       	rjmp	80005c56 <uhc_enumeration_step13+0x2a>
80005cd8:	30 6c       	mov	r12,6
80005cda:	c6 9e       	rcall	800059ac <uhc_enumeration_error>
		return;
80005cdc:	cb eb       	rjmp	80005c58 <uhc_enumeration_step13+0x2c>
80005cde:	d7 03       	nop

80005ce0 <uhc_enumeration_step15>:
80005ce0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ce4:	20 1d       	sub	sp,4
80005ce6:	30 08       	mov	r8,0
80005ce8:	58 0b       	cp.w	r11,0
80005cea:	5f 19       	srne	r9
80005cec:	f0 0a 19 00 	cp.h	r10,r8
80005cf0:	5f 17       	srne	r7
80005cf2:	12 47       	or	r7,r9
80005cf4:	f0 07 18 00 	cp.b	r7,r8
80005cf8:	c1 50       	breq	80005d22 <uhc_enumeration_step15+0x42>
80005cfa:	49 57       	lddpc	r7,80005d4c <uhc_enumeration_step15+0x6c>
80005cfc:	50 0b       	stdsp	sp[0x0],r11
80005cfe:	6e 28       	ld.w	r8,r7[0x8]
		uint16_t payload_trans)
{
	UNUSED(add);
	if ((status!=UHD_TRANS_NOERROR) || (payload_trans!=0)) {
		for(uint8_t i = 0; i < UHC_NB_UHI; i++) {
			uhc_uhis[i].uninstall(uhc_dev_enum);
80005d00:	e0 6c 07 0c 	mov	r12,1804
80005d04:	5d 18       	icall	r8
80005d06:	6e 68       	ld.w	r8,r7[0x18]
80005d08:	e0 6c 07 0c 	mov	r12,1804
		}
		uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80005d0c:	5d 18       	icall	r8
80005d0e:	40 0b       	lddsp	r11,sp[0x0]
80005d10:	58 1b       	cp.w	r11,1
80005d12:	f9 bc 00 07 	moveq	r12,7
80005d16:	f9 bc 01 03 	movne	r12,3
		uhc_uhis[i].enable(uhc_dev_enum);
	}
	uhc_enum_try = 0;
	
	UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
}
80005d1a:	c4 9e       	rcall	800059ac <uhc_enumeration_error>
80005d1c:	2f fd       	sub	sp,-4
80005d1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		return;
	}

	// Enable all UHIs supported
	for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
		uhc_uhis[i].enable(uhc_dev_enum);
80005d22:	48 b6       	lddpc	r6,80005d4c <uhc_enumeration_step15+0x6c>
80005d24:	e0 6c 07 0c 	mov	r12,1804
80005d28:	6c 18       	ld.w	r8,r6[0x4]
80005d2a:	5d 18       	icall	r8
80005d2c:	6c 58       	ld.w	r8,r6[0x14]
	}
	uhc_enum_try = 0;
80005d2e:	e0 6c 07 0c 	mov	r12,1804
80005d32:	5d 18       	icall	r8
	
	UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
80005d34:	e0 68 07 28 	mov	r8,1832
80005d38:	30 0b       	mov	r11,0
}
80005d3a:	b0 87       	st.b	r8[0x0],r7
80005d3c:	e0 6c 07 0c 	mov	r12,1804
80005d40:	e0 a0 16 da 	rcall	80008af4 <usb_enum>
80005d44:	2f fd       	sub	sp,-4
80005d46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d4a:	d7 03       	nop
80005d4c:	80 01       	ld.sh	r1,r0[0x0]
80005d4e:	41 24       	lddsp	r4,sp[0x48]

80005d50 <uhc_enumeration_step14>:
80005d50:	eb cd 40 e0 	pushm	r5-r7,lr
 */
static void uhc_enumeration_step14(
		usb_add_t add,
		uhd_trans_status_t status,
		uint16_t payload_trans)
{
80005d54:	20 2d       	sub	sp,8
	bool b_conf_supported = false;
	UNUSED(add);

	/////////////////////////////////
	///// TESTING
	print_dbg("\r\n received device descriptor. ");
80005d56:	fe fc 02 2e 	ld.w	r12,pc[558]
 */
static void uhc_enumeration_step14(
		usb_add_t add,
		uhd_trans_status_t status,
		uint16_t payload_trans)
{
80005d5a:	16 97       	mov	r7,r11
80005d5c:	14 95       	mov	r5,r10
	bool b_conf_supported = false;
	UNUSED(add);

	/////////////////////////////////
	///// TESTING
	print_dbg("\r\n received device descriptor. ");
80005d5e:	fe b0 e6 81 	rcall	80002a60 <print_dbg>

	print_dbg("\r\n address: ");
80005d62:	fe fc 02 26 	ld.w	r12,pc[550]
80005d66:	fe b0 e6 7d 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum -> address);
80005d6a:	e0 66 07 0c 	mov	r6,1804
80005d6e:	ed 3c 00 12 	ld.ub	r12,r6[18]
80005d72:	fe b0 e6 1f 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n speed: ");
80005d76:	fe fc 02 16 	ld.w	r12,pc[534]
80005d7a:	fe b0 e6 73 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum -> speed);
80005d7e:	6c 5c       	ld.w	r12,r6[0x14]
80005d80:	fe b0 e6 18 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n\r\n");
80005d84:	fe fc 02 0c 	ld.w	r12,pc[524]
80005d88:	fe b0 e6 6c 	rcall	80002a60 <print_dbg>

	print_dbg("\r\n dev desc -> bLength : ");
80005d8c:	fe fc 02 08 	ld.w	r12,pc[520]
80005d90:	fe b0 e6 68 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bLength);
80005d94:	0d 8c       	ld.ub	r12,r6[0x0]
80005d96:	fe b0 e6 0d 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bDescriptorType : ");
80005d9a:	fe fc 01 fe 	ld.w	r12,pc[510]
80005d9e:	fe b0 e6 61 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bDescriptorType);
80005da2:	0d 9c       	ld.ub	r12,r6[0x1]
80005da4:	fe b0 e6 06 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bcdUSB : ");
80005da8:	4f dc       	lddpc	r12,80005f9c <uhc_enumeration_step14+0x24c>
80005daa:	fe b0 e6 5b 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bcdUSB);
80005dae:	8c 9c       	ld.uh	r12,r6[0x2]
80005db0:	fe b0 e6 00 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bDeviceClass : ");
80005db4:	4f bc       	lddpc	r12,80005fa0 <uhc_enumeration_step14+0x250>
80005db6:	fe b0 e6 55 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceClass);
80005dba:	0d cc       	ld.ub	r12,r6[0x4]
80005dbc:	fe b0 e5 fa 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bDeviceSubClass : ");
80005dc0:	4f 9c       	lddpc	r12,80005fa4 <uhc_enumeration_step14+0x254>
80005dc2:	fe b0 e6 4f 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceSubClass);
80005dc6:	0d dc       	ld.ub	r12,r6[0x5]
80005dc8:	fe b0 e5 f4 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bDeviceProtocol : ");
80005dcc:	4f 7c       	lddpc	r12,80005fa8 <uhc_enumeration_step14+0x258>
80005dce:	fe b0 e6 49 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceProtocol);
80005dd2:	0d ec       	ld.ub	r12,r6[0x6]
80005dd4:	fe b0 e5 ee 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bMaxPacketSize0 : ");
80005dd8:	4f 5c       	lddpc	r12,80005fac <uhc_enumeration_step14+0x25c>
80005dda:	fe b0 e6 43 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bMaxPacketSize0);
80005dde:	0d fc       	ld.ub	r12,r6[0x7]
80005de0:	fe b0 e5 e8 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> idVendor : ");
80005de4:	4f 3c       	lddpc	r12,80005fb0 <uhc_enumeration_step14+0x260>
80005de6:	fe b0 e6 3d 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.idVendor);
80005dea:	8c cc       	ld.uh	r12,r6[0x8]
80005dec:	fe b0 e5 e2 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> idProduct : ");
80005df0:	4f 1c       	lddpc	r12,80005fb4 <uhc_enumeration_step14+0x264>
80005df2:	fe b0 e6 37 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.idProduct);
80005df6:	8c dc       	ld.uh	r12,r6[0xa]
80005df8:	fe b0 e5 dc 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bcdDevice : ");
80005dfc:	4e fc       	lddpc	r12,80005fb8 <uhc_enumeration_step14+0x268>
80005dfe:	fe b0 e6 31 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bcdDevice);
80005e02:	8c ec       	ld.uh	r12,r6[0xc]
80005e04:	fe b0 e5 d6 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> iManufacturer : ");
80005e08:	4e dc       	lddpc	r12,80005fbc <uhc_enumeration_step14+0x26c>
80005e0a:	fe b0 e6 2b 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.iManufacturer);
80005e0e:	ed 3c 00 0e 	ld.ub	r12,r6[14]
80005e12:	fe b0 e5 cf 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> iProduct : ");
80005e16:	4e bc       	lddpc	r12,80005fc0 <uhc_enumeration_step14+0x270>
80005e18:	fe b0 e6 24 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.iProduct);
80005e1c:	ed 3c 00 0f 	ld.ub	r12,r6[15]
80005e20:	fe b0 e5 c8 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> iSerialNumber : ");
80005e24:	4e 8c       	lddpc	r12,80005fc4 <uhc_enumeration_step14+0x274>
80005e26:	fe b0 e6 1d 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.iSerialNumber);
80005e2a:	ed 3c 00 10 	ld.ub	r12,r6[16]
80005e2e:	fe b0 e5 c1 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n dev desc -> bNumConfigurations : ");
80005e32:	4e 6c       	lddpc	r12,80005fc8 <uhc_enumeration_step14+0x278>
80005e34:	fe b0 e6 16 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->dev_desc.bNumConfigurations);
80005e38:	ed 3c 00 11 	ld.ub	r12,r6[17]
80005e3c:	fe b0 e5 ba 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n\r\n");
80005e40:	4d 4c       	lddpc	r12,80005f90 <uhc_enumeration_step14+0x240>
80005e42:	fe b0 e6 0f 	rcall	80002a60 <print_dbg>
	
	print_dbg("\r\n conf desc -> bLength : ");
80005e46:	4e 2c       	lddpc	r12,80005fcc <uhc_enumeration_step14+0x27c>
80005e48:	fe b0 e6 0c 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bLength);
80005e4c:	6c 68       	ld.w	r8,r6[0x18]
80005e4e:	11 8c       	ld.ub	r12,r8[0x0]
80005e50:	fe b0 e5 b0 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> bDescriptorType : ");
80005e54:	4d fc       	lddpc	r12,80005fd0 <uhc_enumeration_step14+0x280>
80005e56:	fe b0 e6 05 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bDescriptorType);
80005e5a:	6c 68       	ld.w	r8,r6[0x18]
80005e5c:	11 9c       	ld.ub	r12,r8[0x1]
80005e5e:	fe b0 e5 a9 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> wTotalLength : ");
80005e62:	4d dc       	lddpc	r12,80005fd4 <uhc_enumeration_step14+0x284>
80005e64:	fe b0 e5 fe 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->wTotalLength);
80005e68:	6c 68       	ld.w	r8,r6[0x18]
80005e6a:	11 b9       	ld.ub	r9,r8[0x3]
80005e6c:	11 ac       	ld.ub	r12,r8[0x2]
80005e6e:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
80005e72:	fe b0 e5 9f 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> bNumInterfaces : ");
80005e76:	4d 9c       	lddpc	r12,80005fd8 <uhc_enumeration_step14+0x288>
80005e78:	fe b0 e5 f4 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bNumInterfaces);
80005e7c:	6c 68       	ld.w	r8,r6[0x18]
80005e7e:	11 cc       	ld.ub	r12,r8[0x4]
80005e80:	fe b0 e5 98 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> bConfigurationValue : ");
80005e84:	4d 6c       	lddpc	r12,80005fdc <uhc_enumeration_step14+0x28c>
80005e86:	fe b0 e5 ed 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bConfigurationValue);
80005e8a:	6c 68       	ld.w	r8,r6[0x18]
80005e8c:	11 dc       	ld.ub	r12,r8[0x5]
80005e8e:	fe b0 e5 91 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> iConfiguration : ");
80005e92:	4d 4c       	lddpc	r12,80005fe0 <uhc_enumeration_step14+0x290>
80005e94:	fe b0 e5 e6 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->iConfiguration);
80005e98:	6c 68       	ld.w	r8,r6[0x18]
80005e9a:	11 ec       	ld.ub	r12,r8[0x6]
80005e9c:	fe b0 e5 8a 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> bmAttributes : ");
80005ea0:	4d 1c       	lddpc	r12,80005fe4 <uhc_enumeration_step14+0x294>
80005ea2:	fe b0 e5 df 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bmAttributes);
80005ea6:	6c 68       	ld.w	r8,r6[0x18]
80005ea8:	11 fc       	ld.ub	r12,r8[0x7]
80005eaa:	fe b0 e5 83 	rcall	800029b0 <print_dbg_hex>
	print_dbg("\r\n conf desc -> bMaxPower : ");
80005eae:	4c fc       	lddpc	r12,80005fe8 <uhc_enumeration_step14+0x298>
80005eb0:	fe b0 e5 d8 	rcall	80002a60 <print_dbg>
	print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
80005eb4:	6c 68       	ld.w	r8,r6[0x18]
80005eb6:	f1 3c 00 08 	ld.ub	r12,r8[8]
80005eba:	fe b0 e5 7b 	rcall	800029b0 <print_dbg_hex>

	/////////////////////////////////
	/////////////////////////////////

	if ((status != UHD_TRANS_NOERROR)
80005ebe:	58 07       	cp.w	r7,0
80005ec0:	5f 18       	srne	r8
80005ec2:	30 89       	mov	r9,8
80005ec4:	f2 05 19 00 	cp.h	r5,r9
80005ec8:	5f 89       	srls	r9
80005eca:	f3 e8 10 08 	or	r8,r9,r8
80005ece:	c0 d1       	brne	80005ee8 <uhc_enumeration_step14+0x198>
			|| (payload_trans < sizeof(usb_conf_desc_t))
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
80005ed0:	6c 68       	ld.w	r8,r6[0x18]
	print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);

	/////////////////////////////////
	/////////////////////////////////

	if ((status != UHD_TRANS_NOERROR)
80005ed2:	30 29       	mov	r9,2
80005ed4:	11 9a       	ld.ub	r10,r8[0x1]
80005ed6:	f2 0a 18 00 	cp.b	r10,r9
80005eda:	c0 b0       	breq	80005ef0 <uhc_enumeration_step14+0x1a0>
			|| (payload_trans < sizeof(usb_conf_desc_t))
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
			|| (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
		uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80005edc:	30 3c       	mov	r12,3
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			&req,
			NULL,
			0,
			NULL, uhc_enumeration_step15)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005ede:	fe b0 fd 67 	rcall	800059ac <uhc_enumeration_error>
		return;
	}
}
80005ee2:	2f ed       	sub	sp,-8
80005ee4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

	if ((status != UHD_TRANS_NOERROR)
			|| (payload_trans < sizeof(usb_conf_desc_t))
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
			|| (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
		uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80005ee8:	58 17       	cp.w	r7,1
80005eea:	cf 91       	brne	80005edc <uhc_enumeration_step14+0x18c>
80005eec:	30 7c       	mov	r12,7
80005eee:	cf 8b       	rjmp	80005ede <uhc_enumeration_step14+0x18e>
	/////////////////////////////////

	if ((status != UHD_TRANS_NOERROR)
			|| (payload_trans < sizeof(usb_conf_desc_t))
			|| (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
			|| (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
80005ef0:	11 b9       	ld.ub	r9,r8[0x3]
80005ef2:	11 a8       	ld.ub	r8,r8[0x2]
80005ef4:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80005ef8:	5c c8       	swap.bh	r8
	print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);

	/////////////////////////////////
	/////////////////////////////////

	if ((status != UHD_TRANS_NOERROR)
80005efa:	ea 08 19 00 	cp.h	r8,r5
80005efe:	ce f1       	brne	80005edc <uhc_enumeration_step14+0x18c>
				UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
		return;
	}
	// Check if unless one USB interface is supported by UHIs
	for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
		switch (uhc_uhis[i].install(uhc_dev_enum)) {
80005f00:	4b b7       	lddpc	r7,80005fec <uhc_enumeration_step14+0x29c>
80005f02:	0c 9c       	mov	r12,r6
80005f04:	6e 08       	ld.w	r8,r7[0x0]
80005f06:	5d 18       	icall	r8
80005f08:	c1 61       	brne	80005f34 <uhc_enumeration_step14+0x1e4>
80005f0a:	30 15       	mov	r5,1
80005f0c:	6e 48       	ld.w	r8,r7[0x10]
80005f0e:	e0 6c 07 0c 	mov	r12,1804
80005f12:	5d 18       	icall	r8
80005f14:	c1 40       	breq	80005f3c <uhc_enumeration_step14+0x1ec>
80005f16:	58 1c       	cp.w	r12,1
			break;

		default:
			// USB host hardware limitation
			// Free all endpoints
			uhd_ep_free(UHC_DEVICE_ENUM_ADD,0xFF);
80005f18:	c2 c0       	breq	80005f70 <uhc_enumeration_step14+0x220>
80005f1a:	e0 6b 00 ff 	mov	r11,255
80005f1e:	30 1c       	mov	r12,1
80005f20:	fe b0 f3 70 	rcall	80004600 <uhd_ep_free>
			UHC_ENUM_EVENT(uhc_dev_enum,UHC_ENUM_HARDWARE_LIMIT);
80005f24:	30 4b       	mov	r11,4
80005f26:	e0 6c 07 0c 	mov	r12,1804
		uhi_hub_suspend(uhc_dev_enum);
	} else
#endif
	{
		// Suspend USB line
		uhd_suspend();
80005f2a:	e0 a0 15 e5 	rcall	80008af4 <usb_enum>
80005f2e:	fe b0 ef 1d 	rcall	80003d68 <uhd_suspend>
				UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
		return;
	}
	// Check if unless one USB interface is supported by UHIs
	for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
		switch (uhc_uhis[i].install(uhc_dev_enum)) {
80005f32:	cd 8b       	rjmp	80005ee2 <uhc_enumeration_step14+0x192>
80005f34:	58 1c       	cp.w	r12,1
80005f36:	cf 21       	brne	80005f1a <uhc_enumeration_step14+0x1ca>
	// Enable device configuration
	req.bmRequestType = USB_REQ_RECIP_DEVICE
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_CONFIGURATION;
	req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
	req.wIndex = 0;
80005f38:	30 05       	mov	r5,0
		// Abort enumeration, set line in suspend mode
		uhc_enumeration_suspend();
		return;
	}
	// Enable device configuration
	req.bmRequestType = USB_REQ_RECIP_DEVICE
80005f3a:	ce 9b       	rjmp	80005f0c <uhc_enumeration_step14+0x1bc>
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_CONFIGURATION;
	req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
80005f3c:	30 09       	mov	r9,0
		// Abort enumeration, set line in suspend mode
		uhc_enumeration_suspend();
		return;
	}
	// Enable device configuration
	req.bmRequestType = USB_REQ_RECIP_DEVICE
80005f3e:	30 0b       	mov	r11,0
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_CONFIGURATION;
80005f40:	6c 6a       	ld.w	r10,r6[0x18]
80005f42:	ba 8b       	st.b	sp[0x0],r11
	req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
80005f44:	30 9b       	mov	r11,9
	req.wIndex = 0;
	req.wLength = 0;
80005f46:	ba 9b       	st.b	sp[0x1],r11
	// Enable device configuration
	req.bmRequestType = USB_REQ_RECIP_DEVICE
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_CONFIGURATION;
	req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
	req.wIndex = 0;
80005f48:	15 da       	ld.ub	r10,r10[0x5]
	req.wLength = 0;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005f4a:	ba 39       	st.h	sp[0x6],r9
	}
	// Enable device configuration
	req.bmRequestType = USB_REQ_RECIP_DEVICE
			| USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
	req.bRequest = USB_REQ_SET_CONFIGURATION;
	req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
80005f4c:	ba 29       	st.h	sp[0x4],r9
	req.wIndex = 0;
	req.wLength = 0;
	if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005f4e:	fe c9 02 6e 	sub	r9,pc,622
80005f52:	ba 1a       	st.h	sp[0x2],r10
80005f54:	30 08       	mov	r8,0
80005f56:	1a d9       	st.w	--sp,r9
80005f58:	10 9a       	mov	r10,r8
80005f5a:	fa cb ff fc 	sub	r11,sp,-4
80005f5e:	10 99       	mov	r9,r8
80005f60:	30 1c       	mov	r12,1
80005f62:	fe b0 f2 53 	rcall	80004408 <uhd_setup_request>
			&req,
			NULL,
			0,
			NULL, uhc_enumeration_step15)) {
		uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005f66:	2f fd       	sub	sp,-4
80005f68:	58 0c       	cp.w	r12,0
			// Abort enumeration, set line in suspend mode
			uhc_enumeration_suspend();
			return;
		}
	}
	if (!b_conf_supported) {
80005f6a:	cb c1       	brne	80005ee2 <uhc_enumeration_step14+0x192>
80005f6c:	30 6c       	mov	r12,6
		// No USB interface supported
		UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_UNSUPPORTED);
80005f6e:	cb 8b       	rjmp	80005ede <uhc_enumeration_step14+0x18e>
80005f70:	58 05       	cp.w	r5,0
80005f72:	ce 51       	brne	80005f3c <uhc_enumeration_step14+0x1ec>
80005f74:	18 9b       	mov	r11,r12
		uhi_hub_suspend(uhc_dev_enum);
	} else
#endif
	{
		// Suspend USB line
		uhd_suspend();
80005f76:	e0 6c 07 0c 	mov	r12,1804
80005f7a:	e0 a0 15 bd 	rcall	80008af4 <usb_enum>
80005f7e:	fe b0 ee f5 	rcall	80003d68 <uhd_suspend>
80005f82:	cb 0b       	rjmp	80005ee2 <uhc_enumeration_step14+0x192>
80005f84:	80 01       	ld.sh	r1,r0[0x0]
80005f86:	3e 10       	mov	r0,-31
80005f88:	80 01       	ld.sh	r1,r0[0x0]
80005f8a:	3e 30       	mov	r0,-29
80005f8c:	80 01       	ld.sh	r1,r0[0x0]
80005f8e:	3e 40       	mov	r0,-28
80005f90:	80 01       	ld.sh	r1,r0[0x0]
80005f92:	3e 4c       	mov	r12,-28
80005f94:	80 01       	ld.sh	r1,r0[0x0]
80005f96:	3e 54       	mov	r4,-27
80005f98:	80 01       	ld.sh	r1,r0[0x0]
80005f9a:	3e 70       	mov	r0,-25
80005f9c:	80 01       	ld.sh	r1,r0[0x0]
80005f9e:	3e 94       	mov	r4,-23
80005fa0:	80 01       	ld.sh	r1,r0[0x0]
80005fa2:	3e b0       	mov	r0,-21
80005fa4:	80 01       	ld.sh	r1,r0[0x0]
80005fa6:	3e d0       	mov	r0,-19
80005fa8:	80 01       	ld.sh	r1,r0[0x0]
80005faa:	3e f4       	mov	r4,-17
80005fac:	80 01       	ld.sh	r1,r0[0x0]
80005fae:	3f 18       	mov	r8,-15
80005fb0:	80 01       	ld.sh	r1,r0[0x0]
80005fb2:	3f 3c       	mov	r12,-13
80005fb4:	80 01       	ld.sh	r1,r0[0x0]
80005fb6:	3f 58       	mov	r8,-11
80005fb8:	80 01       	ld.sh	r1,r0[0x0]
80005fba:	3f 74       	mov	r4,-9
80005fbc:	80 01       	ld.sh	r1,r0[0x0]
80005fbe:	3f 90       	mov	r0,-7
80005fc0:	80 01       	ld.sh	r1,r0[0x0]
80005fc2:	3f b0       	mov	r0,-5
80005fc4:	80 01       	ld.sh	r1,r0[0x0]
80005fc6:	3f cc       	mov	r12,-4
80005fc8:	80 01       	ld.sh	r1,r0[0x0]
80005fca:	3f ec       	mov	r12,-2
80005fcc:	80 01       	ld.sh	r1,r0[0x0]
80005fce:	40 14       	lddsp	r4,sp[0x4]
80005fd0:	80 01       	ld.sh	r1,r0[0x0]
80005fd2:	40 30       	lddsp	r0,sp[0xc]
80005fd4:	80 01       	ld.sh	r1,r0[0x0]
80005fd6:	40 54       	lddsp	r4,sp[0x14]
80005fd8:	80 01       	ld.sh	r1,r0[0x0]
80005fda:	40 74       	lddsp	r4,sp[0x1c]
80005fdc:	80 01       	ld.sh	r1,r0[0x0]
80005fde:	40 98       	lddsp	r8,sp[0x24]
80005fe0:	80 01       	ld.sh	r1,r0[0x0]
80005fe2:	40 c0       	lddsp	r0,sp[0x30]
80005fe4:	80 01       	ld.sh	r1,r0[0x0]
80005fe6:	40 e4       	lddsp	r4,sp[0x38]
80005fe8:	80 01       	ld.sh	r1,r0[0x0]
80005fea:	41 04       	lddsp	r4,sp[0x40]
80005fec:	80 01       	ld.sh	r1,r0[0x0]
80005fee:	41 24       	lddsp	r4,sp[0x48]

80005ff0 <uhc_notify_connection>:
80005ff0:	d4 21       	pushm	r4-r7,lr
80005ff2:	18 96       	mov	r6,r12
80005ff4:	58 0c       	cp.w	r12,0
80005ff6:	c2 31       	brne	8000603c <uhc_notify_connection+0x4c>
80005ff8:	e0 67 07 0c 	mov	r7,1804
80005ffc:	3f f5       	mov	r5,-1
80005ffe:	ef 3c 00 12 	ld.ub	r12,r7[18]
80006002:	ea 0c 18 00 	cp.b	r12,r5
80006006:	c2 e0       	breq	80006062 <uhc_notify_connection+0x72>
80006008:	e0 68 28 d2 	mov	r8,10450
		UHC_CONNECTION_EVENT(uhc_dev_enum, true);
		uhc_enumeration_step1();
	} else {
		if (uhc_dev_enum == dev) {
			// Eventually stop enumeration timeout on-going on this device
			uhc_sof_timeout = 0;
8000600c:	e0 6b 00 ff 	mov	r11,255
		}
		// Abort all transfers (endpoint control and other) and free pipe(s)
		uhd_ep_free(dev->address, 0xFF);
80006010:	b0 86       	st.b	r8[0x0],r6

		// Disable all USB interfaces (this includes HUB interface)
		for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
			uhc_uhis[i].uninstall(dev);
80006012:	fe b0 f2 f7 	rcall	80004600 <uhd_ep_free>
80006016:	49 44       	lddpc	r4,80006064 <uhc_notify_connection+0x74>
80006018:	0e 9c       	mov	r12,r7
8000601a:	68 28       	ld.w	r8,r4[0x8]
8000601c:	5d 18       	icall	r8
8000601e:	68 68       	ld.w	r8,r4[0x18]
		}

		UHC_CONNECTION_EVENT(dev, false);
80006020:	0e 9c       	mov	r12,r7
80006022:	5d 18       	icall	r8
80006024:	0e 9c       	mov	r12,r7
80006026:	0c 9b       	mov	r11,r6
		dev->address = UHC_USB_ADD_NOT_VALID;
80006028:	e0 a0 15 63 	rcall	80008aee <usb_connection>
		// Free USB configuration descriptor buffer
		if (dev->conf_desc != NULL) {
8000602c:	ef 65 00 12 	st.b	r7[18],r5
80006030:	6e 6c       	ld.w	r12,r7[0x18]
			free(dev->conf_desc);
80006032:	58 0c       	cp.w	r12,0
80006034:	c0 30       	breq	8000603a <uhc_notify_connection+0x4a>
80006036:	e0 a0 43 9d 	rcall	8000e770 <free>
	if (b_plug) {
		uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
		uhc_dev_enum = dev;
#endif
		uhc_dev_enum->conf_desc = NULL;
8000603a:	d8 22       	popm	r4-r7,pc
		uhc_dev_enum->address = 0;
		UHC_CONNECTION_EVENT(uhc_dev_enum, true);
8000603c:	e0 68 07 0c 	mov	r8,1804
		uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
		uhc_dev_enum = dev;
#endif
		uhc_dev_enum->conf_desc = NULL;
		uhc_dev_enum->address = 0;
80006040:	30 09       	mov	r9,0
	if (b_plug) {
		uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
		uhc_dev_enum = dev;
#endif
		uhc_dev_enum->conf_desc = NULL;
80006042:	10 9c       	mov	r12,r8
 * \param dev      Information about device connected or disconnected
 */
static void uhc_connection_tree(bool b_plug, uhc_device_t* dev)
{
	if (b_plug) {
		uhc_enum_try = 1;
80006044:	f1 69 00 12 	st.b	r8[18],r9
#ifdef USB_HOST_HUB_SUPPORT
		uhc_dev_enum = dev;
#endif
		uhc_dev_enum->conf_desc = NULL;
		uhc_dev_enum->address = 0;
		UHC_CONNECTION_EVENT(uhc_dev_enum, true);
80006048:	91 69       	st.w	r8[0x18],r9
 * \param dev      Information about device connected or disconnected
 */
static void uhc_connection_tree(bool b_plug, uhc_device_t* dev)
{
	if (b_plug) {
		uhc_enum_try = 1;
8000604a:	30 19       	mov	r9,1
#ifdef USB_HOST_HUB_SUPPORT
		uhc_dev_enum = dev;
#endif
		uhc_dev_enum->conf_desc = NULL;
		uhc_dev_enum->address = 0;
		UHC_CONNECTION_EVENT(uhc_dev_enum, true);
8000604c:	e0 68 07 28 	mov	r8,1832
		// Device connected on USB hub
		uhi_hub_send_reset(uhc_dev_enum, callback);
	} else
#endif
	{
		uhd_send_reset(callback);
80006050:	30 1b       	mov	r11,1
80006052:	b0 89       	st.b	r8[0x0],r9
80006054:	e0 a0 15 4d 	rcall	80008aee <usb_connection>
80006058:	fe cc 07 74 	sub	r12,pc,1908
8000605c:	fe b0 ee 7c 	rcall	80003d54 <uhd_send_reset>
80006060:	d8 22       	popm	r4-r7,pc
80006062:	d8 22       	popm	r4-r7,pc
80006064:	80 01       	ld.sh	r1,r0[0x0]
80006066:	41 24       	lddsp	r4,sp[0x48]

80006068 <uhc_notify_resume>:
80006068:	d4 01       	pushm	lr
8000606a:	20 2d       	sub	sp,8
8000606c:	e0 69 07 0c 	mov	r9,1804
80006070:	72 68       	ld.w	r8,r9[0x18]
80006072:	11 f8       	ld.ub	r8,r8[0x7]
80006074:	ed b8 00 05 	bld	r8,0x5
80006078:	c1 61       	brne	800060a4 <uhc_notify_resume+0x3c>
8000607a:	f3 3c 00 12 	ld.ub	r12,r9[18]
8000607e:	30 08       	mov	r8,0
			}
			req.bmRequestType = USB_REQ_RECIP_DEVICE
					|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
			req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
			req.wIndex = 0;
			req.wLength = 0;
80006080:	30 09       	mov	r9,0
				req.bRequest = USB_REQ_CLEAR_FEATURE;
			}
			req.bmRequestType = USB_REQ_RECIP_DEVICE
					|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
			req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
			req.wIndex = 0;
80006082:	ba 38       	st.h	sp[0x6],r8
			req.wLength = 0;
			uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80006084:	ba 28       	st.h	sp[0x4],r8
80006086:	1a d9       	st.w	--sp,r9
	while(1) {
		if (dev->conf_desc->bmAttributes & USB_CONFIG_ATTR_REMOTE_WAKEUP) {
			if (b_enable) {
				req.bRequest = USB_REQ_SET_FEATURE;
			} else {
				req.bRequest = USB_REQ_CLEAR_FEATURE;
80006088:	12 98       	mov	r8,r9
8000608a:	30 19       	mov	r9,1
			}
			req.bmRequestType = USB_REQ_RECIP_DEVICE
8000608c:	ba d9       	st.b	sp[0x5],r9
8000608e:	30 09       	mov	r9,0
					|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
			req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
80006090:	ba c9       	st.b	sp[0x4],r9
			req.wIndex = 0;
			req.wLength = 0;
			uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80006092:	30 19       	mov	r9,1
80006094:	fa cb ff fc 	sub	r11,sp,-4
80006098:	ba 39       	st.h	sp[0x6],r9
8000609a:	10 9a       	mov	r10,r8
8000609c:	10 99       	mov	r9,r8
8000609e:	fe b0 f1 b5 	rcall	80004408 <uhd_setup_request>
}

void uhc_notify_resume(void)
{
	uhc_remotewakeup(false);
	UHC_WAKEUP_EVENT();
800060a2:	2f fd       	sub	sp,-4
800060a4:	e0 a0 15 26 	rcall	80008af0 <usb_wakeup>
}
800060a8:	2f ed       	sub	sp,-8
800060aa:	d8 02       	popm	pc

800060ac <init_adc>:

  //  cpu_irq_enable();
}

// setup ad7923
void init_adc(void) {
800060ac:	eb cd 40 80 	pushm	r7,lr
  u16 cmd;

  //  cpu_irq_disable();

  // at powerup, the part wants a dummy conversion with DIN high
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
800060b0:	30 1b       	mov	r11,1
800060b2:	fe 7c 28 00 	mov	r12,-55296
800060b6:	fe b0 e2 2d 	rcall	80002510 <spi_selectChip>
  spi_write(ADC_SPI, 0xffff);
800060ba:	e0 6b ff ff 	mov	r11,65535
800060be:	fe 7c 28 00 	mov	r12,-55296
800060c2:	fe b0 e2 bc 	rcall	8000263a <spi_write>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800060c6:	30 1b       	mov	r11,1
800060c8:	fe 7c 28 00 	mov	r12,-55296
800060cc:	fe b0 e2 4a 	rcall	80002560 <spi_unselectChip>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800060d0:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800060d4:	ee 78 42 40 	mov	r8,1000000
800060d8:	30 09       	mov	r9,0
800060da:	e0 6a a8 bf 	mov	r10,43199
800060de:	ea 1a 13 ba 	orh	r10,0x13ba
800060e2:	30 0b       	mov	r11,0
800060e4:	e0 a0 3e d3 	rcall	8000de8a <__avr32_udiv64>
800060e8:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800060ec:	e1 b8 00 42 	mfsr	r8,0x108
800060f0:	14 37       	cp.w	r7,r10
800060f2:	e0 8b 00 1b 	brhi	80006128 <init_adc+0x7c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800060f6:	10 37       	cp.w	r7,r8
800060f8:	e0 8b 00 04 	brhi	80006100 <init_adc+0x54>
800060fc:	10 3a       	cp.w	r10,r8
800060fe:	c1 b2       	brcc	80006134 <init_adc+0x88>
  // wait for powerup time (5us in datasheet)
  delay_us(5);
  
  // write base configuration
  cmd = AD7923_CMD_BASE << 4;
  spi_selectChip( ADC_SPI, ADC_SPI_NPCS );
80006100:	30 1b       	mov	r11,1
80006102:	fe 7c 28 00 	mov	r12,-55296
80006106:	fe b0 e2 05 	rcall	80002510 <spi_selectChip>
  spi_write( ADC_SPI, cmd );
8000610a:	e0 6b 83 10 	mov	r11,33552
8000610e:	fe 7c 28 00 	mov	r12,-55296
80006112:	fe b0 e2 94 	rcall	8000263a <spi_write>
  spi_unselectChip( ADC_SPI, ADC_SPI_NPCS );
80006116:	30 1b       	mov	r11,1
80006118:	fe 7c 28 00 	mov	r12,-55296
8000611c:	fe b0 e2 22 	rcall	80002560 <spi_unselectChip>

  //  cpu_irq_enable();
}
80006120:	e3 cd 80 80 	ldm	sp++,r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006124:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006128:	10 37       	cp.w	r7,r8
8000612a:	fe 98 ff fd 	brls	80006124 <init_adc+0x78>
8000612e:	10 3a       	cp.w	r10,r8
80006130:	cf a2       	brcc	80006124 <init_adc+0x78>
80006132:	ce 7b       	rjmp	80006100 <init_adc+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006134:	e1 b8 00 42 	mfsr	r8,0x108
80006138:	cd fb       	rjmp	800060f6 <init_adc+0x4a>
8000613a:	d7 03       	nop

8000613c <adc_poll>:
8000613c:	eb cd 40 c0 	pushm	r6-r7,lr
80006140:	20 1d       	sub	sp,4
80006142:	30 1b       	mov	r11,1
80006144:	fe 7c 28 00 	mov	r12,-55296
80006148:	fe b0 e1 e4 	rcall	80002510 <spi_selectChip>

  // data into AD7923 is a left-justified 12-bit value in a 16-bit word
  // so, always lshift the command before sending
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
8000614c:	e0 6b 83 10 	mov	r11,33552
80006150:	fe 7c 28 00 	mov	r12,-55296
80006154:	fe b0 e2 73 	rcall	8000263a <spi_write>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
80006158:	30 1b       	mov	r11,1
8000615a:	fe 7c 28 00 	mov	r12,-55296
8000615e:	fe b0 e2 01 	rcall	80002560 <spi_unselectChip>

  // get channel 0, setup channel 1
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80006162:	30 1b       	mov	r11,1
80006164:	fe 7c 28 00 	mov	r12,-55296
80006168:	fe b0 e1 d4 	rcall	80002510 <spi_selectChip>
  spi_write(ADC_SPI, cmd);
8000616c:	e0 6b 87 10 	mov	r11,34576
80006170:	fe 7c 28 00 	mov	r12,-55296
80006174:	fe b0 e2 63 	rcall	8000263a <spi_write>
  spi_read(ADC_SPI, &val);
80006178:	fa c6 ff fe 	sub	r6,sp,-2
8000617c:	fe 7c 28 00 	mov	r12,-55296
80006180:	0c 9b       	mov	r11,r6
80006182:	fe b0 e2 6a 	rcall	80002656 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
80006186:	30 1b       	mov	r11,1
80006188:	fe 7c 28 00 	mov	r12,-55296
8000618c:	fe b0 e1 ea 	rcall	80002560 <spi_unselectChip>
  (*dst)[0] = val & 0xfff; 
80006190:	9a 18       	ld.sh	r8,sp[0x2]
80006192:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
80006196:	e0 67 07 30 	mov	r7,1840
8000619a:	30 1b       	mov	r11,1

  // get channel 1, setup channel 2
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
8000619c:	ae 08       	st.h	r7[0x0],r8
8000619e:	fe 7c 28 00 	mov	r12,-55296
800061a2:	fe b0 e1 b7 	rcall	80002510 <spi_selectChip>
  spi_write(ADC_SPI, cmd);
800061a6:	e0 6b 8b 10 	mov	r11,35600
800061aa:	fe 7c 28 00 	mov	r12,-55296
800061ae:	fe b0 e2 46 	rcall	8000263a <spi_write>
  spi_read(ADC_SPI, &val);
800061b2:	0c 9b       	mov	r11,r6
800061b4:	fe 7c 28 00 	mov	r12,-55296
800061b8:	fe b0 e2 4f 	rcall	80002656 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800061bc:	30 1b       	mov	r11,1
800061be:	fe 7c 28 00 	mov	r12,-55296
800061c2:	fe b0 e1 cf 	rcall	80002560 <spi_unselectChip>
  (*dst)[1] = val & 0xfff;
800061c6:	9a 18       	ld.sh	r8,sp[0x2]
800061c8:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800061cc:	30 1b       	mov	r11,1

  // get channel 2, setup channel 3
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
800061ce:	ae 18       	st.h	r7[0x2],r8
800061d0:	fe 7c 28 00 	mov	r12,-55296
800061d4:	fe b0 e1 9e 	rcall	80002510 <spi_selectChip>
  spi_write(ADC_SPI, cmd);
800061d8:	e0 6b 8f 10 	mov	r11,36624
800061dc:	fe 7c 28 00 	mov	r12,-55296
800061e0:	fe b0 e2 2d 	rcall	8000263a <spi_write>
  spi_read(ADC_SPI, &val);
800061e4:	0c 9b       	mov	r11,r6
800061e6:	fe 7c 28 00 	mov	r12,-55296
800061ea:	fe b0 e2 36 	rcall	80002656 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800061ee:	30 1b       	mov	r11,1
800061f0:	fe 7c 28 00 	mov	r12,-55296
800061f4:	fe b0 e1 b6 	rcall	80002560 <spi_unselectChip>
  (*dst)[2] = val & 0xfff;
800061f8:	9a 18       	ld.sh	r8,sp[0x2]
800061fa:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800061fe:	30 1b       	mov	r11,1

  // get channel 3, dummy write
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80006200:	ae 28       	st.h	r7[0x4],r8
80006202:	fe 7c 28 00 	mov	r12,-55296
80006206:	fe b0 e1 85 	rcall	80002510 <spi_selectChip>
  spi_write(ADC_SPI, cmd);
8000620a:	e0 6b 83 10 	mov	r11,33552
8000620e:	fe 7c 28 00 	mov	r12,-55296
80006212:	fe b0 e2 14 	rcall	8000263a <spi_write>
  spi_read(ADC_SPI, &val);
80006216:	0c 9b       	mov	r11,r6
80006218:	fe 7c 28 00 	mov	r12,-55296
8000621c:	fe b0 e2 1d 	rcall	80002656 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
80006220:	30 1b       	mov	r11,1
80006222:	fe 7c 28 00 	mov	r12,-55296
80006226:	fe b0 e1 9d 	rcall	80002560 <spi_unselectChip>
  (*dst)[3] = val & 0xfff;
8000622a:	9a 18       	ld.sh	r8,sp[0x2]
8000622c:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
  for(i=0; i<4; i++) {        
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
80006230:	ae 38       	st.h	r7[0x6],r8
80006232:	8e 09       	ld.sh	r9,r7[0x0]
80006234:	e0 66 07 38 	mov	r6,1848
80006238:	8c 88       	ld.uh	r8,r6[0x0]
8000623a:	f3 e8 20 08 	eor	r8,r9,r8
8000623e:	e2 18 0f fc 	andl	r8,0xffc,COH
80006242:	c1 91       	brne	80006274 <adc_poll+0x138>
80006244:	8e 19       	ld.sh	r9,r7[0x2]
80006246:	8c 98       	ld.uh	r8,r6[0x2]
80006248:	f3 e8 20 08 	eor	r8,r9,r8
8000624c:	e2 18 0f fc 	andl	r8,0xffc,COH
80006250:	c3 61       	brne	800062bc <adc_poll+0x180>
80006252:	8e 29       	ld.sh	r9,r7[0x4]
80006254:	8c a8       	ld.uh	r8,r6[0x4]
80006256:	f3 e8 20 08 	eor	r8,r9,r8
8000625a:	e2 18 0f fc 	andl	r8,0xffc,COH
8000625e:	c2 31       	brne	800062a4 <adc_poll+0x168>
80006260:	8e 39       	ld.sh	r9,r7[0x6]
80006262:	8c b8       	ld.uh	r8,r6[0x6]
80006264:	f3 e8 20 08 	eor	r8,r9,r8
80006268:	e2 18 0f fc 	andl	r8,0xffc,COH
      e.eventType = adcEventTypes[i];
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
    }
  }
}
8000626c:	c0 e1       	brne	80006288 <adc_poll+0x14c>
8000626e:	2f fd       	sub	sp,-4
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
80006270:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      e.eventData = (S16)(adcVal[i]);
80006274:	e0 68 07 40 	mov	r8,1856
      post_event(&e);
80006278:	ac 09       	st.h	r6[0x0],r9
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
8000627a:	91 19       	st.w	r8[0x4],r9
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
8000627c:	30 09       	mov	r9,0
8000627e:	10 9c       	mov	r12,r8
80006280:	91 09       	st.w	r8[0x0],r9
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
80006282:	e0 a0 05 77 	rcall	80006d70 <post_event>
      e.eventType = adcEventTypes[i];
80006286:	cd fb       	rjmp	80006244 <adc_poll+0x108>
      e.eventData = (S16)(adcVal[i]);
80006288:	e0 68 07 38 	mov	r8,1848
      post_event(&e);
8000628c:	b0 39       	st.h	r8[0x6],r9
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
8000628e:	e0 68 07 40 	mov	r8,1856
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
80006292:	91 19       	st.w	r8[0x4],r9
    }
  }
}
80006294:	30 39       	mov	r9,3
80006296:	10 9c       	mov	r12,r8
80006298:	91 09       	st.w	r8[0x0],r9
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
8000629a:	e0 a0 05 6b 	rcall	80006d70 <post_event>
      e.eventType = adcEventTypes[i];
8000629e:	2f fd       	sub	sp,-4
      e.eventData = (S16)(adcVal[i]);
800062a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      post_event(&e);
800062a4:	e0 68 07 38 	mov	r8,1848
800062a8:	b0 29       	st.h	r8[0x4],r9
800062aa:	e0 68 07 40 	mov	r8,1856
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
800062ae:	91 19       	st.w	r8[0x4],r9
800062b0:	30 29       	mov	r9,2
      e.eventType = adcEventTypes[i];
800062b2:	10 9c       	mov	r12,r8
      e.eventData = (S16)(adcVal[i]);
800062b4:	91 09       	st.w	r8[0x0],r9
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
800062b6:	e0 a0 05 5d 	rcall	80006d70 <post_event>
800062ba:	cd 3b       	rjmp	80006260 <adc_poll+0x124>
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
800062bc:	e0 68 07 38 	mov	r8,1848
800062c0:	b0 19       	st.h	r8[0x2],r9
800062c2:	e0 68 07 40 	mov	r8,1856
800062c6:	91 19       	st.w	r8[0x4],r9
800062c8:	30 19       	mov	r9,1
800062ca:	10 9c       	mov	r12,r8
800062cc:	91 09       	st.w	r8[0x0],r9
800062ce:	e0 a0 05 51 	rcall	80006d70 <post_event>
800062d2:	cc 0b       	rjmp	80006252 <adc_poll+0x116>

800062d4 <init_app_timers>:
static void adc_timer_callback(int tag) {
  adc_poll();
}

//====== external
void init_app_timers(void) {
800062d4:	d4 01       	pushm	lr
  set_timer(&screenTimer, eScreenTimerTag, 30,   &screen_timer_callback, 1);
800062d6:	30 18       	mov	r8,1
800062d8:	fe c9 ff 48 	sub	r9,pc,-184
800062dc:	31 ea       	mov	r10,30
800062de:	30 0b       	mov	r11,0
800062e0:	e0 6c 07 60 	mov	r12,1888
  set_timer(&encTimer,    eEncTimerTag,    20,    &enc_timer_callback,    1);
800062e4:	e0 a0 11 ba 	rcall	80008658 <set_timer>
800062e8:	30 18       	mov	r8,1
800062ea:	fe c9 ff d2 	sub	r9,pc,-46
800062ee:	10 9b       	mov	r11,r8
800062f0:	31 4a       	mov	r10,20
  set_timer(&adcTimer,    eAdcTimerTag,    5,    &adc_timer_callback,    1);
800062f2:	e0 6c 07 78 	mov	r12,1912
800062f6:	e0 a0 11 b1 	rcall	80008658 <set_timer>
800062fa:	30 18       	mov	r8,1
800062fc:	fe c9 ff ec 	sub	r9,pc,-20
}
80006300:	30 5a       	mov	r10,5
80006302:	30 3b       	mov	r11,3
80006304:	e0 6c 07 4c 	mov	r12,1868
80006308:	e0 a0 11 a8 	rcall	80008658 <set_timer>
8000630c:	d8 02       	popm	pc
8000630e:	d7 03       	nop

80006310 <adc_timer_callback>:
80006310:	d4 01       	pushm	lr
80006312:	c1 5f       	rcall	8000613c <adc_poll>
80006314:	d8 02       	popm	pc
80006316:	d7 03       	nop

80006318 <enc_timer_callback>:
80006318:	eb cd 40 fc 	pushm	r2-r7,lr
8000631c:	30 08       	mov	r8,0
8000631e:	30 0b       	mov	r11,0

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80006320:	e0 66 07 48 	mov	r6,1864
80006324:	e0 67 28 d4 	mov	r7,10452
80006328:	ac 88       	st.b	r6[0x0],r8
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
8000632a:	e0 63 07 74 	mov	r3,1908

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
8000632e:	16 98       	mov	r8,r11
80006330:	e0 65 07 8c 	mov	r5,1932
    val = enc[i].val;
80006334:	16 92       	mov	r2,r11
80006336:	30 34       	mov	r4,3
80006338:	c0 28       	rjmp	8000633c <enc_timer_callback+0x24>
8000633a:	10 9b       	mov	r11,r8
8000633c:	f0 08 00 18 	add	r8,r8,r8<<0x1
80006340:	f0 ca ff ff 	sub	r10,r8,-1
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
80006344:	ee 0a 04 29 	ld.sh	r9,r7[r10<<0x2]
80006348:	a6 09       	st.h	r3[0x0],r9
8000634a:	ee 0a 00 2a 	add	r10,r7,r10<<0x2
8000634e:	94 1a       	ld.sh	r10,r10[0x2]
80006350:	f4 09 19 00 	cp.h	r9,r10
80006354:	e0 89 00 05 	brgt	8000635e <enc_timer_callback+0x46>
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
      e.eventData = val;
      enc[i].val = 0;
80006358:	5c 3a       	neg	r10
8000635a:	14 39       	cp.w	r9,r10
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
8000635c:	c0 f4       	brge	8000637a <enc_timer_callback+0x62>
8000635e:	8b 19       	st.w	r5[0x4],r9
80006360:	f0 c9 ff ff 	sub	r9,r8,-1
      e.eventData = val;
      enc[i].val = 0;
80006364:	ee 08 00 28 	add	r8,r7,r8<<0x2
      post_event(&e);
80006368:	70 28       	ld.w	r8,r8[0x8]
8000636a:	ee 09 0a 22 	st.h	r7[r9<<0x2],r2
8000636e:	8b 08       	st.w	r5[0x0],r8

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80006370:	e0 6c 07 8c 	mov	r12,1932
80006374:	e0 a0 04 fe 	rcall	80006d70 <post_event>
80006378:	0d 8b       	ld.ub	r11,r6[0x0]
8000637a:	f6 c8 ff ff 	sub	r8,r11,-1
8000637e:	5c 58       	castu.b	r8
80006380:	ac 88       	st.b	r6[0x0],r8
80006382:	e8 08 18 00 	cp.b	r8,r4
80006386:	fe 98 ff da 	brls	8000633a <enc_timer_callback+0x22>
8000638a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000638e:	d7 03       	nop

80006390 <screen_timer_callback>:
80006390:	eb cd 40 80 	pushm	r7,lr
80006394:	e0 67 08 a1 	mov	r7,2209
  cyclesNow = Get_system_register(AVR32_COUNT);
  print_dbg(" \lcycles:"); print_dbg_ulong(cyclesNow - cycles);
  cycles = cyclesNow;
  */

  if(refresh) {
80006398:	0f 88       	ld.ub	r8,r7[0x0]
8000639a:	58 08       	cp.w	r8,0
    e.eventType = kEventRefresh;
8000639c:	c0 a0       	breq	800063b0 <screen_timer_callback+0x20>
8000639e:	e0 68 07 8c 	mov	r8,1932
800063a2:	30 49       	mov	r9,4
    post_event(&e);
800063a4:	10 9c       	mov	r12,r8
800063a6:	91 09       	st.w	r8[0x0],r9
    refresh = 0;
800063a8:	e0 a0 04 e4 	rcall	80006d70 <post_event>
800063ac:	30 08       	mov	r8,0
800063ae:	ae 88       	st.b	r7[0x0],r8
800063b0:	e3 cd 80 80 	ldm	sp++,r7,pc

800063b4 <bfin_set_param>:
  bfin_report_params();
  
}

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {
800063b4:	eb cd 40 e0 	pushm	r5-r7,lr

  static ParamValue pval;
  pval.asInt = (s32)x;
800063b8:	f6 08 16 18 	lsr	r8,r11,0x18
800063bc:	e0 66 07 94 	mov	r6,1940
800063c0:	ac bb       	st.b	r6[0x3],r11
800063c2:	ac 88       	st.b	r6[0x0],r8
800063c4:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
800063c8:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
800063cc:	30 07       	mov	r7,0
  bfin_report_params();
  
}

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {
800063ce:	ac 98       	st.b	r6[0x1],r8

  static ParamValue pval;
  pval.asInt = (s32)x;
800063d0:	18 95       	mov	r5,r12

  // command
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800063d2:	ac ab       	st.b	r6[0x2],r11
800063d4:	fe 7c 24 00 	mov	r12,-56320
800063d8:	0e 9b       	mov	r11,r7
800063da:	fe b0 e0 9b 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, MSG_SET_PARAM_COM);
800063de:	0e 9b       	mov	r11,r7
800063e0:	fe 7c 24 00 	mov	r12,-56320
800063e4:	fe b0 e1 2b 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800063e8:	0e 9b       	mov	r11,r7
800063ea:	fe 7c 24 00 	mov	r12,-56320
800063ee:	fe b0 e0 b9 	rcall	80002560 <spi_unselectChip>
  //idx
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800063f2:	0e 9b       	mov	r11,r7
800063f4:	fe 7c 24 00 	mov	r12,-56320
800063f8:	fe b0 e0 8c 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, idx);
800063fc:	0a 9b       	mov	r11,r5
800063fe:	fe 7c 24 00 	mov	r12,-56320
80006402:	fe b0 e1 1c 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006406:	0e 9b       	mov	r11,r7
80006408:	fe 7c 24 00 	mov	r12,-56320
8000640c:	fe b0 e0 aa 	rcall	80002560 <spi_unselectChip>
  //val0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006410:	0e 9b       	mov	r11,r7
80006412:	fe 7c 24 00 	mov	r12,-56320
80006416:	fe b0 e0 7d 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[0]);
8000641a:	0d 8b       	ld.ub	r11,r6[0x0]
8000641c:	fe 7c 24 00 	mov	r12,-56320
80006420:	fe b0 e1 0d 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006424:	0e 9b       	mov	r11,r7
80006426:	fe 7c 24 00 	mov	r12,-56320
8000642a:	fe b0 e0 9b 	rcall	80002560 <spi_unselectChip>
  // val1
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000642e:	0e 9b       	mov	r11,r7
80006430:	fe 7c 24 00 	mov	r12,-56320
80006434:	fe b0 e0 6e 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[1]);
80006438:	0d 9b       	ld.ub	r11,r6[0x1]
8000643a:	fe 7c 24 00 	mov	r12,-56320
8000643e:	fe b0 e0 fe 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006442:	0e 9b       	mov	r11,r7
80006444:	fe 7c 24 00 	mov	r12,-56320
80006448:	fe b0 e0 8c 	rcall	80002560 <spi_unselectChip>
  //val2
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000644c:	0e 9b       	mov	r11,r7
8000644e:	fe 7c 24 00 	mov	r12,-56320
80006452:	fe b0 e0 5f 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[2]);
80006456:	0d ab       	ld.ub	r11,r6[0x2]
80006458:	fe 7c 24 00 	mov	r12,-56320
8000645c:	fe b0 e0 ef 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006460:	0e 9b       	mov	r11,r7
80006462:	fe 7c 24 00 	mov	r12,-56320
80006466:	fe b0 e0 7d 	rcall	80002560 <spi_unselectChip>
  //val3
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000646a:	0e 9b       	mov	r11,r7
8000646c:	fe 7c 24 00 	mov	r12,-56320
80006470:	fe b0 e0 50 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[3]);
80006474:	0d bb       	ld.ub	r11,r6[0x3]
80006476:	fe 7c 24 00 	mov	r12,-56320
8000647a:	fe b0 e0 e0 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000647e:	0e 9b       	mov	r11,r7
80006480:	fe 7c 24 00 	mov	r12,-56320
80006484:	fe b0 e0 6e 	rcall	80002560 <spi_unselectChip>
}
80006488:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000648c <bfin_get_param_desc>:
8000648c:	eb cd 40 e0 	pushm	r5-r7,lr
80006490:	20 2d       	sub	sp,8
80006492:	16 97       	mov	r7,r11
80006494:	18 96       	mov	r6,r12
80006496:	30 0b       	mov	r11,0
80006498:	fe 7c 24 00 	mov	r12,-56320
void bfin_get_param_desc(u16 paramIdx, volatile ParamDesc* pDesc) {
  ParamValue pval;
  u16 x; // u16 for spi_read()
  u8 i;
  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000649c:	fe b0 e0 3a 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, MSG_GET_PARAM_DESC_COM);
800064a0:	30 3b       	mov	r11,3
800064a2:	fe 7c 24 00 	mov	r12,-56320
800064a6:	fe b0 e0 ca 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800064aa:	30 0b       	mov	r11,0
800064ac:	fe 7c 24 00 	mov	r12,-56320
800064b0:	fe b0 e0 58 	rcall	80002560 <spi_unselectChip>
  // idx
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800064b4:	30 0b       	mov	r11,0
800064b6:	fe 7c 24 00 	mov	r12,-56320
800064ba:	fe b0 e0 2b 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, paramIdx);
800064be:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800064c2:	fe 7c 24 00 	mov	r12,-56320
800064c6:	fe b0 e0 ba 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800064ca:	30 0b       	mov	r11,0
800064cc:	fe 7c 24 00 	mov	r12,-56320
800064d0:	fe b0 e0 48 	rcall	80002560 <spi_unselectChip>
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800064d4:	30 0b       	mov	r11,0
800064d6:	fe 7c 24 00 	mov	r12,-56320
800064da:	fe b0 e0 1b 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800064de:	30 0b       	mov	r11,0
800064e0:	fe 7c 24 00 	mov	r12,-56320
800064e4:	fe b0 e0 ab 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800064e8:	fa c6 ff fa 	sub	r6,sp,-6
800064ec:	fe 7c 24 00 	mov	r12,-56320
800064f0:	0c 9b       	mov	r11,r6
800064f2:	fe b0 e0 b2 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800064f6:	30 0b       	mov	r11,0
800064f8:	fe 7c 24 00 	mov	r12,-56320
800064fc:	fe b0 e0 32 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006500:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006502:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006504:	ae 88       	st.b	r7[0x0],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006506:	fe 7c 24 00 	mov	r12,-56320
8000650a:	fe b0 e0 03 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000650e:	30 0b       	mov	r11,0
80006510:	fe 7c 24 00 	mov	r12,-56320
80006514:	fe b0 e0 93 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006518:	0c 9b       	mov	r11,r6
8000651a:	fe 7c 24 00 	mov	r12,-56320
8000651e:	fe b0 e0 9c 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006522:	30 0b       	mov	r11,0
80006524:	fe 7c 24 00 	mov	r12,-56320
80006528:	fe b0 e0 1c 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
8000652c:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000652e:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006530:	ae 98       	st.b	r7[0x1],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006532:	fe 7c 24 00 	mov	r12,-56320
80006536:	fe b0 df ed 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000653a:	30 0b       	mov	r11,0
8000653c:	fe 7c 24 00 	mov	r12,-56320
80006540:	fe b0 e0 7d 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006544:	0c 9b       	mov	r11,r6
80006546:	fe 7c 24 00 	mov	r12,-56320
8000654a:	fe b0 e0 86 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000654e:	30 0b       	mov	r11,0
80006550:	fe 7c 24 00 	mov	r12,-56320
80006554:	fe b0 e0 06 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006558:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000655a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
8000655c:	ae a8       	st.b	r7[0x2],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000655e:	fe 7c 24 00 	mov	r12,-56320
80006562:	fe b0 df d7 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006566:	30 0b       	mov	r11,0
80006568:	fe 7c 24 00 	mov	r12,-56320
8000656c:	fe b0 e0 67 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006570:	0c 9b       	mov	r11,r6
80006572:	fe 7c 24 00 	mov	r12,-56320
80006576:	fe b0 e0 70 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000657a:	30 0b       	mov	r11,0
8000657c:	fe 7c 24 00 	mov	r12,-56320
80006580:	fe b0 df f0 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006584:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006586:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006588:	ae b8       	st.b	r7[0x3],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000658a:	fe 7c 24 00 	mov	r12,-56320
8000658e:	fe b0 df c1 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006592:	30 0b       	mov	r11,0
80006594:	fe 7c 24 00 	mov	r12,-56320
80006598:	fe b0 e0 51 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
8000659c:	0c 9b       	mov	r11,r6
8000659e:	fe 7c 24 00 	mov	r12,-56320
800065a2:	fe b0 e0 5a 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065a6:	30 0b       	mov	r11,0
800065a8:	fe 7c 24 00 	mov	r12,-56320
800065ac:	fe b0 df da 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
800065b0:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065b2:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800065b4:	ae c8       	st.b	r7[0x4],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065b6:	fe 7c 24 00 	mov	r12,-56320
800065ba:	fe b0 df ab 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800065be:	30 0b       	mov	r11,0
800065c0:	fe 7c 24 00 	mov	r12,-56320
800065c4:	fe b0 e0 3b 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800065c8:	0c 9b       	mov	r11,r6
800065ca:	fe 7c 24 00 	mov	r12,-56320
800065ce:	fe b0 e0 44 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065d2:	30 0b       	mov	r11,0
800065d4:	fe 7c 24 00 	mov	r12,-56320
800065d8:	fe b0 df c4 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
800065dc:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065de:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800065e0:	ae d8       	st.b	r7[0x5],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065e2:	fe 7c 24 00 	mov	r12,-56320
800065e6:	fe b0 df 95 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800065ea:	30 0b       	mov	r11,0
800065ec:	fe 7c 24 00 	mov	r12,-56320
800065f0:	fe b0 e0 25 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800065f4:	0c 9b       	mov	r11,r6
800065f6:	fe 7c 24 00 	mov	r12,-56320
800065fa:	fe b0 e0 2e 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800065fe:	30 0b       	mov	r11,0
80006600:	fe 7c 24 00 	mov	r12,-56320
80006604:	fe b0 df ae 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006608:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000660a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
8000660c:	ae e8       	st.b	r7[0x6],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000660e:	fe 7c 24 00 	mov	r12,-56320
80006612:	fe b0 df 7f 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006616:	30 0b       	mov	r11,0
80006618:	fe 7c 24 00 	mov	r12,-56320
8000661c:	fe b0 e0 0f 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006620:	0c 9b       	mov	r11,r6
80006622:	fe 7c 24 00 	mov	r12,-56320
80006626:	fe b0 e0 18 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000662a:	30 0b       	mov	r11,0
8000662c:	fe 7c 24 00 	mov	r12,-56320
80006630:	fe b0 df 98 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006634:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006636:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006638:	ae f8       	st.b	r7[0x7],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000663a:	fe 7c 24 00 	mov	r12,-56320
8000663e:	fe b0 df 69 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006642:	30 0b       	mov	r11,0
80006644:	fe 7c 24 00 	mov	r12,-56320
80006648:	fe b0 df f9 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
8000664c:	0c 9b       	mov	r11,r6
8000664e:	fe 7c 24 00 	mov	r12,-56320
80006652:	fe b0 e0 02 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006656:	30 0b       	mov	r11,0
80006658:	fe 7c 24 00 	mov	r12,-56320
8000665c:	fe b0 df 82 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006660:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006662:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006664:	ef 68 00 08 	st.b	r7[8],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006668:	fe 7c 24 00 	mov	r12,-56320
8000666c:	fe b0 df 52 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006670:	30 0b       	mov	r11,0
80006672:	fe 7c 24 00 	mov	r12,-56320
80006676:	fe b0 df e2 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
8000667a:	0c 9b       	mov	r11,r6
8000667c:	fe 7c 24 00 	mov	r12,-56320
80006680:	fe b0 df eb 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006684:	30 0b       	mov	r11,0
80006686:	fe 7c 24 00 	mov	r12,-56320
8000668a:	fe b0 df 6b 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
8000668e:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006690:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006692:	ef 68 00 09 	st.b	r7[9],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006696:	fe 7c 24 00 	mov	r12,-56320
8000669a:	fe b0 df 3b 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000669e:	30 0b       	mov	r11,0
800066a0:	fe 7c 24 00 	mov	r12,-56320
800066a4:	fe b0 df cb 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800066a8:	0c 9b       	mov	r11,r6
800066aa:	fe 7c 24 00 	mov	r12,-56320
800066ae:	fe b0 df d4 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066b2:	30 0b       	mov	r11,0
800066b4:	fe 7c 24 00 	mov	r12,-56320
800066b8:	fe b0 df 54 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
800066bc:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066be:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800066c0:	ef 68 00 0a 	st.b	r7[10],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066c4:	fe 7c 24 00 	mov	r12,-56320
800066c8:	fe b0 df 24 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800066cc:	30 0b       	mov	r11,0
800066ce:	fe 7c 24 00 	mov	r12,-56320
800066d2:	fe b0 df b4 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800066d6:	0c 9b       	mov	r11,r6
800066d8:	fe 7c 24 00 	mov	r12,-56320
800066dc:	fe b0 df bd 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066e0:	30 0b       	mov	r11,0
800066e2:	fe 7c 24 00 	mov	r12,-56320
800066e6:	fe b0 df 3d 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
800066ea:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066ec:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800066ee:	ef 68 00 0b 	st.b	r7[11],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800066f2:	fe 7c 24 00 	mov	r12,-56320
800066f6:	fe b0 df 0d 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800066fa:	30 0b       	mov	r11,0
800066fc:	fe 7c 24 00 	mov	r12,-56320
80006700:	fe b0 df 9d 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006704:	0c 9b       	mov	r11,r6
80006706:	fe 7c 24 00 	mov	r12,-56320
8000670a:	fe b0 df a6 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000670e:	30 0b       	mov	r11,0
80006710:	fe 7c 24 00 	mov	r12,-56320
80006714:	fe b0 df 26 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006718:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000671a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
8000671c:	ef 68 00 0c 	st.b	r7[12],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006720:	fe 7c 24 00 	mov	r12,-56320
80006724:	fe b0 de f6 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006728:	30 0b       	mov	r11,0
8000672a:	fe 7c 24 00 	mov	r12,-56320
8000672e:	fe b0 df 86 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006732:	0c 9b       	mov	r11,r6
80006734:	fe 7c 24 00 	mov	r12,-56320
80006738:	fe b0 df 8f 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000673c:	30 0b       	mov	r11,0
8000673e:	fe 7c 24 00 	mov	r12,-56320
80006742:	fe b0 df 0f 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006746:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006748:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
8000674a:	ef 68 00 0d 	st.b	r7[13],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000674e:	fe 7c 24 00 	mov	r12,-56320
80006752:	fe b0 de df 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006756:	30 0b       	mov	r11,0
80006758:	fe 7c 24 00 	mov	r12,-56320
8000675c:	fe b0 df 6f 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006760:	0c 9b       	mov	r11,r6
80006762:	fe 7c 24 00 	mov	r12,-56320
80006766:	fe b0 df 78 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000676a:	30 0b       	mov	r11,0
8000676c:	fe 7c 24 00 	mov	r12,-56320
80006770:	fe b0 de f8 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
80006774:	1b f8       	ld.ub	r8,sp[0x7]
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006776:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80006778:	ef 68 00 0e 	st.b	r7[14],r8
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000677c:	fe 7c 24 00 	mov	r12,-56320
80006780:	fe b0 de c8 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006784:	30 0b       	mov	r11,0
80006786:	fe 7c 24 00 	mov	r12,-56320
8000678a:	fe b0 df 58 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
8000678e:	0c 9b       	mov	r11,r6
80006790:	fe 7c 24 00 	mov	r12,-56320
80006794:	fe b0 df 61 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006798:	30 0b       	mov	r11,0
8000679a:	fe 7c 24 00 	mov	r12,-56320
8000679e:	fe b0 de e1 	rcall	80002560 <spi_unselectChip>
    pDesc->label[i] = (char)(x & 0xff);
800067a2:	1b f8       	ld.ub	r8,sp[0x7]
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067a4:	30 0b       	mov	r11,0
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800067a6:	ef 68 00 0f 	st.b	r7[15],r8
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067aa:	fe 7c 24 00 	mov	r12,-56320
800067ae:	fe b0 de b1 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800067b2:	30 0b       	mov	r11,0
800067b4:	fe 7c 24 00 	mov	r12,-56320
800067b8:	fe b0 df 41 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800067bc:	0c 9b       	mov	r11,r6
800067be:	fe 7c 24 00 	mov	r12,-56320
800067c2:	fe b0 df 4a 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067c6:	30 0b       	mov	r11,0
800067c8:	fe 7c 24 00 	mov	r12,-56320
800067cc:	fe b0 de ca 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
800067d0:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067d2:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
800067d4:	ef 68 00 10 	st.b	r7[16],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067d8:	fe 7c 24 00 	mov	r12,-56320
800067dc:	fe b0 de 9a 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800067e0:	30 0b       	mov	r11,0
800067e2:	fe 7c 24 00 	mov	r12,-56320
800067e6:	fe b0 df 2a 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800067ea:	0c 9b       	mov	r11,r6
800067ec:	fe 7c 24 00 	mov	r12,-56320
800067f0:	fe b0 df 33 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800067f4:	30 0b       	mov	r11,0
800067f6:	fe 7c 24 00 	mov	r12,-56320
800067fa:	fe b0 de b3 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
800067fe:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006800:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80006802:	ef 68 00 11 	st.b	r7[17],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006806:	fe 7c 24 00 	mov	r12,-56320
8000680a:	fe b0 de 83 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000680e:	30 0b       	mov	r11,0
80006810:	fe 7c 24 00 	mov	r12,-56320
80006814:	fe b0 df 13 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006818:	0c 9b       	mov	r11,r6
8000681a:	fe 7c 24 00 	mov	r12,-56320
8000681e:	fe b0 df 1c 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006822:	30 0b       	mov	r11,0
80006824:	fe 7c 24 00 	mov	r12,-56320
80006828:	fe b0 de 9c 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
8000682c:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000682e:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80006830:	ef 68 00 12 	st.b	r7[18],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006834:	fe 7c 24 00 	mov	r12,-56320
80006838:	fe b0 de 6c 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000683c:	30 0b       	mov	r11,0
8000683e:	fe 7c 24 00 	mov	r12,-56320
80006842:	fe b0 de fc 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006846:	0c 9b       	mov	r11,r6
80006848:	fe 7c 24 00 	mov	r12,-56320
8000684c:	fe b0 df 05 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006850:	30 0b       	mov	r11,0
80006852:	fe 7c 24 00 	mov	r12,-56320
80006856:	fe b0 de 85 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
8000685a:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000685c:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
8000685e:	ef 68 00 13 	st.b	r7[19],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006862:	fe 7c 24 00 	mov	r12,-56320
80006866:	fe b0 de 55 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000686a:	30 0b       	mov	r11,0
8000686c:	fe 7c 24 00 	mov	r12,-56320
80006870:	fe b0 de e5 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006874:	0c 9b       	mov	r11,r6
80006876:	fe 7c 24 00 	mov	r12,-56320
8000687a:	fe b0 de ee 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000687e:	30 0b       	mov	r11,0
80006880:	fe 7c 24 00 	mov	r12,-56320
80006884:	fe b0 de 6e 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
80006888:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000688a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
8000688c:	ef 68 00 14 	st.b	r7[20],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006890:	fe 7c 24 00 	mov	r12,-56320
80006894:	fe b0 de 3e 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006898:	30 0b       	mov	r11,0
8000689a:	fe 7c 24 00 	mov	r12,-56320
8000689e:	fe b0 de ce 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800068a2:	0c 9b       	mov	r11,r6
800068a4:	fe 7c 24 00 	mov	r12,-56320
800068a8:	fe b0 de d7 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068ac:	30 0b       	mov	r11,0
800068ae:	fe 7c 24 00 	mov	r12,-56320
800068b2:	fe b0 de 57 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
800068b6:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068b8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
800068ba:	ef 68 00 15 	st.b	r7[21],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068be:	fe 7c 24 00 	mov	r12,-56320
800068c2:	fe b0 de 27 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800068c6:	30 0b       	mov	r11,0
800068c8:	fe 7c 24 00 	mov	r12,-56320
800068cc:	fe b0 de b7 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800068d0:	0c 9b       	mov	r11,r6
800068d2:	fe 7c 24 00 	mov	r12,-56320
800068d6:	fe b0 de c0 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068da:	30 0b       	mov	r11,0
800068dc:	fe 7c 24 00 	mov	r12,-56320
800068e0:	fe b0 de 40 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
800068e4:	1b f8       	ld.ub	r8,sp[0x7]
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068e6:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
800068e8:	ef 68 00 16 	st.b	r7[22],r8
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800068ec:	fe 7c 24 00 	mov	r12,-56320
800068f0:	fe b0 de 10 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800068f4:	30 0b       	mov	r11,0
800068f6:	fe 7c 24 00 	mov	r12,-56320
800068fa:	fe b0 de a0 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800068fe:	0c 9b       	mov	r11,r6
80006900:	fe 7c 24 00 	mov	r12,-56320
80006904:	fe b0 de a9 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006908:	30 0b       	mov	r11,0
8000690a:	fe 7c 24 00 	mov	r12,-56320
8000690e:	fe b0 de 29 	rcall	80002560 <spi_unselectChip>
    pDesc->unit[i] = (char)(x & 0xff);
80006912:	1b f8       	ld.ub	r8,sp[0x7]
  }
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006914:	30 0b       	mov	r11,0
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80006916:	ef 68 00 17 	st.b	r7[23],r8
  }
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000691a:	fe 7c 24 00 	mov	r12,-56320
8000691e:	fe b0 dd f9 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, 0); //dont care
80006922:	30 0b       	mov	r11,0
80006924:	fe 7c 24 00 	mov	r12,-56320
80006928:	fe b0 de 89 	rcall	8000263a <spi_write>
  spi_read(BFIN_SPI, &x);
8000692c:	0c 9b       	mov	r11,r6
8000692e:	fe 7c 24 00 	mov	r12,-56320
80006932:	fe b0 de 92 	rcall	80002656 <spi_read>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006936:	30 0b       	mov	r11,0
80006938:	fe 7c 24 00 	mov	r12,-56320
8000693c:	fe b0 de 12 	rcall	80002560 <spi_unselectChip>
  pDesc->type = (U8)(x & 0xff);
80006940:	1b f8       	ld.ub	r8,sp[0x7]
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006942:	30 0b       	mov	r11,0
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, 0); //dont care
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
80006944:	ef 68 00 18 	st.b	r7[24],r8
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006948:	fe 7c 24 00 	mov	r12,-56320
8000694c:	fe b0 dd e2 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006950:	30 0b       	mov	r11,0
80006952:	fe 7c 24 00 	mov	r12,-56320
80006956:	fe b0 de 72 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
8000695a:	0c 9b       	mov	r11,r6
8000695c:	fe 7c 24 00 	mov	r12,-56320
80006960:	fe b0 de 7b 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006964:	30 0b       	mov	r11,0
80006966:	fe 7c 24 00 	mov	r12,-56320
8000696a:	fe b0 dd fb 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
8000696e:	9a 38       	ld.sh	r8,sp[0x6]
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006970:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80006972:	ba a8       	st.b	sp[0x2],r8
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006974:	fe 7c 24 00 	mov	r12,-56320
80006978:	fe b0 dd cc 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
8000697c:	30 0b       	mov	r11,0
8000697e:	fe 7c 24 00 	mov	r12,-56320
80006982:	fe b0 de 5c 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006986:	0c 9b       	mov	r11,r6
80006988:	fe 7c 24 00 	mov	r12,-56320
8000698c:	fe b0 de 65 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006990:	30 0b       	mov	r11,0
80006992:	fe 7c 24 00 	mov	r12,-56320
80006996:	fe b0 dd e5 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
8000699a:	9a 38       	ld.sh	r8,sp[0x6]
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000699c:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
8000699e:	ba b8       	st.b	sp[0x3],r8
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800069a0:	fe 7c 24 00 	mov	r12,-56320
800069a4:	fe b0 dd b6 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800069a8:	30 0b       	mov	r11,0
800069aa:	fe 7c 24 00 	mov	r12,-56320
800069ae:	fe b0 de 46 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800069b2:	0c 9b       	mov	r11,r6
800069b4:	fe 7c 24 00 	mov	r12,-56320
800069b8:	fe b0 de 4f 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800069bc:	30 0b       	mov	r11,0
800069be:	fe 7c 24 00 	mov	r12,-56320
800069c2:	fe b0 dd cf 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
800069c6:	9a 38       	ld.sh	r8,sp[0x6]
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800069c8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
800069ca:	ba c8       	st.b	sp[0x4],r8
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800069cc:	fe 7c 24 00 	mov	r12,-56320
800069d0:	fe b0 dd a0 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
800069d4:	30 0b       	mov	r11,0
800069d6:	fe 7c 24 00 	mov	r12,-56320
800069da:	fe b0 de 30 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
800069de:	0c 9b       	mov	r11,r6
800069e0:	fe 7c 24 00 	mov	r12,-56320
800069e4:	fe b0 de 39 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800069e8:	30 0b       	mov	r11,0
800069ea:	fe 7c 24 00 	mov	r12,-56320
800069ee:	fe b0 dd b9 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
800069f2:	9a 38       	ld.sh	r8,sp[0x6]
800069f4:	ba d8       	st.b	sp[0x5],r8
  }
  pDesc->min = pval.asFloat;
800069f6:	9a a8       	ld.uh	r8,sp[0x4]
800069f8:	9a 9c       	ld.uh	r12,sp[0x2]
800069fa:	f1 ec 11 0c 	or	r12,r8,r12<<0x10
800069fe:	e0 a0 3a 37 	rcall	8000de6c <__avr32_f32_to_s32>
80006a02:	ef 38 00 19 	ld.ub	r8,r7[25]
80006a06:	f8 08 16 18 	lsr	r8,r12,0x18
80006a0a:	ef 68 00 19 	st.b	r7[25],r8
80006a0e:	ef 38 00 1a 	ld.ub	r8,r7[26]
80006a12:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80006a16:	ef 68 00 1a 	st.b	r7[26],r8
80006a1a:	ef 38 00 1b 	ld.ub	r8,r7[27]
80006a1e:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80006a22:	f9 dc c0 08 	bfextu	r12,r12,0x0,0x8
80006a26:	ef 68 00 1b 	st.b	r7[27],r8
80006a2a:	ef 38 00 1c 	ld.ub	r8,r7[28]
80006a2e:	30 05       	mov	r5,0
80006a30:	ef 6c 00 1c 	st.b	r7[28],r12
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a34:	0a 9b       	mov	r11,r5
80006a36:	fe 7c 24 00 	mov	r12,-56320
80006a3a:	fe b0 dd 6b 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006a3e:	0a 9b       	mov	r11,r5
80006a40:	fe 7c 24 00 	mov	r12,-56320
80006a44:	fe b0 dd fb 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006a48:	0c 9b       	mov	r11,r6
80006a4a:	fe 7c 24 00 	mov	r12,-56320
80006a4e:	fe b0 de 04 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a52:	0a 9b       	mov	r11,r5
80006a54:	fe 7c 24 00 	mov	r12,-56320
80006a58:	fe b0 dd 84 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
80006a5c:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a5e:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80006a60:	ba a8       	st.b	sp[0x2],r8
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a62:	fe 7c 24 00 	mov	r12,-56320
80006a66:	fe b0 dd 55 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006a6a:	0a 9b       	mov	r11,r5
80006a6c:	fe 7c 24 00 	mov	r12,-56320
80006a70:	fe b0 dd e5 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006a74:	0c 9b       	mov	r11,r6
80006a76:	fe 7c 24 00 	mov	r12,-56320
80006a7a:	fe b0 dd ee 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a7e:	0a 9b       	mov	r11,r5
80006a80:	fe 7c 24 00 	mov	r12,-56320
80006a84:	fe b0 dd 6e 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
80006a88:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a8a:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80006a8c:	ba b8       	st.b	sp[0x3],r8
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006a8e:	fe 7c 24 00 	mov	r12,-56320
80006a92:	fe b0 dd 3f 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006a96:	0a 9b       	mov	r11,r5
80006a98:	fe 7c 24 00 	mov	r12,-56320
80006a9c:	fe b0 dd cf 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006aa0:	0c 9b       	mov	r11,r6
80006aa2:	fe 7c 24 00 	mov	r12,-56320
80006aa6:	fe b0 dd d8 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006aaa:	0a 9b       	mov	r11,r5
80006aac:	fe 7c 24 00 	mov	r12,-56320
80006ab0:	fe b0 dd 58 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
80006ab4:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006ab6:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80006ab8:	ba c8       	st.b	sp[0x4],r8
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asFloat;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006aba:	fe 7c 24 00 	mov	r12,-56320
80006abe:	fe b0 dd 29 	rcall	80002510 <spi_selectChip>
    spi_write(BFIN_SPI, 0); //dont care
80006ac2:	0a 9b       	mov	r11,r5
80006ac4:	fe 7c 24 00 	mov	r12,-56320
80006ac8:	fe b0 dd b9 	rcall	8000263a <spi_write>
    spi_read(BFIN_SPI, &x);
80006acc:	0c 9b       	mov	r11,r6
80006ace:	fe 7c 24 00 	mov	r12,-56320
80006ad2:	fe b0 dd c2 	rcall	80002656 <spi_read>
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006ad6:	0a 9b       	mov	r11,r5
80006ad8:	fe 7c 24 00 	mov	r12,-56320
80006adc:	fe b0 dd 42 	rcall	80002560 <spi_unselectChip>
    pval.asByte[i] = (u8)(x & 0xff);
80006ae0:	9a 38       	ld.sh	r8,sp[0x6]
80006ae2:	ba d8       	st.b	sp[0x5],r8
  }
  pDesc->max = pval.asFloat;
80006ae4:	9a a8       	ld.uh	r8,sp[0x4]
80006ae6:	9a 9c       	ld.uh	r12,sp[0x2]
80006ae8:	f1 ec 11 0c 	or	r12,r8,r12<<0x10
80006aec:	e0 a0 39 c0 	rcall	8000de6c <__avr32_f32_to_s32>
80006af0:	ef 38 00 1d 	ld.ub	r8,r7[29]
80006af4:	f8 08 16 18 	lsr	r8,r12,0x18
80006af8:	ef 68 00 1d 	st.b	r7[29],r8
80006afc:	ef 38 00 1e 	ld.ub	r8,r7[30]
80006b00:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80006b04:	ef 68 00 1e 	st.b	r7[30],r8
80006b08:	ef 38 00 1f 	ld.ub	r8,r7[31]
80006b0c:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80006b10:	ef 68 00 1f 	st.b	r7[31],r8
80006b14:	f9 dc c0 08 	bfextu	r12,r12,0x0,0x8
80006b18:	ef 38 00 20 	ld.ub	r8,r7[32]
80006b1c:	ef 6c 00 20 	st.b	r7[32],r12
}
80006b20:	2f ed       	sub	sp,-8
80006b22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006b26:	d7 03       	nop

80006b28 <bfin_get_num_params>:
80006b28:	eb cd 40 80 	pushm	r7,lr
80006b2c:	20 1d       	sub	sp,4
80006b2e:	30 0b       	mov	r11,0
80006b30:	18 97       	mov	r7,r12
80006b32:	fe 7c 24 00 	mov	r12,-56320
80006b36:	fe b0 dc ed 	rcall	80002510 <spi_selectChip>
80006b3a:	30 2b       	mov	r11,2

void bfin_get_num_params(volatile u32* num) {
  u16 x;
  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, MSG_GET_NUM_PARAMS_COM);
80006b3c:	fe 7c 24 00 	mov	r12,-56320
80006b40:	fe b0 dd 7d 	rcall	8000263a <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006b44:	30 0b       	mov	r11,0
80006b46:	fe 7c 24 00 	mov	r12,-56320
80006b4a:	fe b0 dd 0b 	rcall	80002560 <spi_unselectChip>
  // read num
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006b4e:	30 0b       	mov	r11,0
80006b50:	fe 7c 24 00 	mov	r12,-56320
80006b54:	fe b0 dc de 	rcall	80002510 <spi_selectChip>
  spi_write(BFIN_SPI, 0); //dont care
80006b58:	30 0b       	mov	r11,0
80006b5a:	fe 7c 24 00 	mov	r12,-56320
80006b5e:	fe b0 dd 6e 	rcall	8000263a <spi_write>
  spi_read(BFIN_SPI, &x);
80006b62:	fa cb ff fe 	sub	r11,sp,-2
80006b66:	fe 7c 24 00 	mov	r12,-56320
80006b6a:	fe b0 dd 76 	rcall	80002656 <spi_read>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006b6e:	30 0b       	mov	r11,0
80006b70:	fe 7c 24 00 	mov	r12,-56320
80006b74:	fe b0 dc f6 	rcall	80002560 <spi_unselectChip>
  *num = (u8)(x & 0xff);
80006b78:	1b b8       	ld.ub	r8,sp[0x3]
80006b7a:	8f 08       	st.w	r7[0x0],r8
}
80006b7c:	2f fd       	sub	sp,-4
80006b7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b82:	d7 03       	nop

80006b84 <bfin_report_params>:
80006b84:	eb cd 40 c0 	pushm	r6-r7,lr
80006b88:	20 ad       	sub	sp,40
80006b8a:	fa cc ff dc 	sub	r12,sp,-36
80006b8e:	cc df       	rcall	80006b28 <bfin_get_num_params>
80006b90:	48 fc       	lddpc	r12,80006bcc <bfin_report_params+0x48>
80006b92:	fe b0 df 67 	rcall	80002a60 <print_dbg>
  volatile ParamDesc pdesc;
  u32 numParams;
  u8 i;

  bfin_get_num_params(&numParams);
  print_dbg("\r\nnumparams: ");
80006b96:	40 9c       	lddsp	r12,sp[0x24]
  print_dbg_ulong(numParams);
80006b98:	fe b0 df 42 	rcall	80002a1c <print_dbg_ulong>
80006b9c:	40 98       	lddsp	r8,sp[0x24]

  if(numParams > 0) {
80006b9e:	58 08       	cp.w	r8,0
80006ba0:	c1 30       	breq	80006bc6 <bfin_report_params+0x42>
80006ba2:	fa c6 ff fd 	sub	r6,sp,-3
80006ba6:	30 07       	mov	r7,0
80006ba8:	0c 9b       	mov	r11,r6
    //net_clear_params();
    for(i=0; i<numParams; i++) {
      bfin_get_param_desc(i, &pdesc);
80006baa:	0e 9c       	mov	r12,r7
80006bac:	fe b0 fc 70 	rcall	8000648c <bfin_get_param_desc>
80006bb0:	48 8c       	lddpc	r12,80006bd0 <bfin_report_params+0x4c>

      //      net_add_param(i, &pdesc);

      print_dbg("\r\n got pdesc : ");
80006bb2:	fe b0 df 57 	rcall	80002a60 <print_dbg>
80006bb6:	0c 9c       	mov	r12,r6
      print_dbg((const char* )pdesc.label);
80006bb8:	fe b0 df 54 	rcall	80002a60 <print_dbg>
80006bbc:	40 98       	lddsp	r8,sp[0x24]
  print_dbg("\r\nnumparams: ");
  print_dbg_ulong(numParams);

  if(numParams > 0) {
    //net_clear_params();
    for(i=0; i<numParams; i++) {
80006bbe:	2f f7       	sub	r7,-1
80006bc0:	5c 57       	castu.b	r7
80006bc2:	10 37       	cp.w	r7,r8
80006bc4:	cf 23       	brcs	80006ba8 <bfin_report_params+0x24>
80006bc6:	2f 6d       	sub	sp,-40

      print_dbg("\r\n got pdesc : ");
      print_dbg((const char* )pdesc.label);
    }
  }
}
80006bc8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bcc:	80 01       	ld.sh	r1,r0[0x0]
80006bce:	41 44       	lddsp	r4,sp[0x50]
80006bd0:	80 01       	ld.sh	r1,r0[0x0]
80006bd2:	41 54       	lddsp	r4,sp[0x54]

80006bd4 <bfin_load>:
80006bd4:	d4 31       	pushm	r0-r7,lr
80006bd6:	20 2d       	sub	sp,8
80006bd8:	18 97       	mov	r7,r12
80006bda:	16 91       	mov	r1,r11
80006bdc:	30 6c       	mov	r12,6
80006bde:	fe b0 da 9a 	rcall	80002112 <gpio_set_gpio_pin>
80006be2:	31 e8       	mov	r8,30
80006be4:	30 09       	mov	r9,0
80006be6:	3f fa       	mov	r10,-1
  u8 data;
  volatile U64 delay;

  // reset bfin
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
  delay = 30; while (--delay > 0) {;;}
80006be8:	fa e9 00 00 	st.d	sp[0],r8
80006bec:	3f fb       	mov	r11,-1
80006bee:	fa e8 00 00 	ld.d	r8,sp[0]
80006bf2:	14 08       	add	r8,r10
80006bf4:	f2 0b 00 49 	adc	r9,r9,r11
80006bf8:	fa e9 00 00 	st.d	sp[0],r8
80006bfc:	fa e8 00 00 	ld.d	r8,sp[0]
80006c00:	58 08       	cp.w	r8,0
80006c02:	5c 29       	cpc	r9
80006c04:	cf 51       	brne	80006bee <bfin_load+0x1a>
  gpio_clr_gpio_pin(BFIN_RESET_PIN);
80006c06:	30 6c       	mov	r12,6
80006c08:	fe b0 da 92 	rcall	8000212c <gpio_clr_gpio_pin>
  delay = 30; while (--delay > 0) {;;}
80006c0c:	31 e8       	mov	r8,30
80006c0e:	30 09       	mov	r9,0
80006c10:	3f fa       	mov	r10,-1
80006c12:	fa e9 00 00 	st.d	sp[0],r8
80006c16:	3f fb       	mov	r11,-1
80006c18:	fa e8 00 00 	ld.d	r8,sp[0]
80006c1c:	14 08       	add	r8,r10
80006c1e:	f2 0b 00 49 	adc	r9,r9,r11
80006c22:	fa e9 00 00 	st.d	sp[0],r8
80006c26:	fa e8 00 00 	ld.d	r8,sp[0]
80006c2a:	58 08       	cp.w	r8,0
80006c2c:	5c 29       	cpc	r9
80006c2e:	cf 51       	brne	80006c18 <bfin_load+0x44>
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
80006c30:	30 6c       	mov	r12,6
80006c32:	fe b0 da 70 	rcall	80002112 <gpio_set_gpio_pin>
  delay = 3000; while (--delay > 0) {;;}
80006c36:	e0 68 0b b8 	mov	r8,3000
80006c3a:	30 09       	mov	r9,0
80006c3c:	3f fa       	mov	r10,-1
80006c3e:	fa e9 00 00 	st.d	sp[0],r8
80006c42:	3f fb       	mov	r11,-1
80006c44:	fa e8 00 00 	ld.d	r8,sp[0]
80006c48:	14 08       	add	r8,r10
80006c4a:	f2 0b 00 49 	adc	r9,r9,r11
80006c4e:	fa e9 00 00 	st.d	sp[0],r8
80006c52:	fa e8 00 00 	ld.d	r8,sp[0]
80006c56:	58 08       	cp.w	r8,0
80006c58:	5c 29       	cpc	r9
80006c5a:	cf 51       	brne	80006c44 <bfin_load+0x70>
  // send the .ldr data
  i = 0;
  print_dbg("\r\n loading bfin, ");
80006c5c:	4b 6c       	lddpc	r12,80006d34 <bfin_load+0x160>
80006c5e:	fe b0 df 01 	rcall	80002a60 <print_dbg>
  print_dbg_ulong(size);
80006c62:	0e 9c       	mov	r12,r7
80006c64:	fe b0 de dc 	rcall	80002a1c <print_dbg_ulong>
  print_dbg(" bytes, FP: ");
80006c68:	4b 4c       	lddpc	r12,80006d38 <bfin_load+0x164>
80006c6a:	fe b0 de fb 	rcall	80002a60 <print_dbg>
  print_dbg_hex((long unsigned int)fp);
80006c6e:	02 9c       	mov	r12,r1
80006c70:	fe b0 de a0 	rcall	800029b0 <print_dbg_hex>
  print_dbg("\r\n");
80006c74:	4b 2c       	lddpc	r12,80006d3c <bfin_load+0x168>
80006c76:	fe b0 de f5 	rcall	80002a60 <print_dbg>

  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006c7a:	30 0b       	mov	r11,0
80006c7c:	fe 7c 24 00 	mov	r12,-56320
  while(i<size) {
80006c80:	0e 92       	mov	r2,r7
  print_dbg_ulong(size);
  print_dbg(" bytes, FP: ");
  print_dbg_hex((long unsigned int)fp);
  print_dbg("\r\n");

  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006c82:	fe b0 dc 47 	rcall	80002510 <spi_selectChip>
  while(i<size) {
80006c86:	30 03       	mov	r3,0
80006c88:	58 02       	cp.w	r2,0
80006c8a:	5c 23       	cpc	r3
80006c8c:	c2 30       	breq	80006cd2 <bfin_load+0xfe>
80006c8e:	30 16       	mov	r6,1
80006c90:	30 07       	mov	r7,0
    data = fl_fgetc(fp);
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
      print_dbg("\r\n HWAIT asserted..."); 
    }
    spi_write(BFIN_SPI, data);
80006c92:	0c 94       	mov	r4,r6
80006c94:	0e 95       	mov	r5,r7
  print_dbg_hex((long unsigned int)fp);
  print_dbg("\r\n");

  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  while(i<size) {
    data = fl_fgetc(fp);
80006c96:	02 9c       	mov	r12,r1
80006c98:	e0 a0 25 2c 	rcall	8000b6f0 <fl_fgetc>
80006c9c:	18 90       	mov	r0,r12
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
80006c9e:	c0 48       	rjmp	80006ca6 <bfin_load+0xd2>
      print_dbg("\r\n HWAIT asserted..."); 
80006ca0:	4a 8c       	lddpc	r12,80006d40 <bfin_load+0x16c>
80006ca2:	fe b0 de df 	rcall	80002a60 <print_dbg>
  print_dbg("\r\n");

  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  while(i<size) {
    data = fl_fgetc(fp);
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
80006ca6:	30 5c       	mov	r12,5
80006ca8:	fe b0 da 2a 	rcall	800020fc <gpio_get_pin_value>
80006cac:	cf a1       	brne	80006ca0 <bfin_load+0xcc>
      print_dbg("\r\n HWAIT asserted..."); 
    }
    spi_write(BFIN_SPI, data);
80006cae:	08 06       	add	r6,r4
80006cb0:	ee 05 00 47 	adc	r7,r7,r5
80006cb4:	f7 d0 c0 08 	bfextu	r11,r0,0x0,0x8
80006cb8:	fe 7c 24 00 	mov	r12,-56320
80006cbc:	fe b0 dc bf 	rcall	8000263a <spi_write>
  print_dbg(" bytes, FP: ");
  print_dbg_hex((long unsigned int)fp);
  print_dbg("\r\n");

  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  while(i<size) {
80006cc0:	ec 04 01 08 	sub	r8,r6,r4
80006cc4:	ee 05 01 49 	sbc	r9,r7,r5
80006cc8:	10 32       	cp.w	r2,r8
80006cca:	f2 03 13 00 	cpc	r3,r9
80006cce:	fe 9b ff e4 	brhi	80006c96 <bfin_load+0xc2>
      print_dbg("\r\n HWAIT asserted..."); 
    }
    spi_write(BFIN_SPI, data);
    i++;
  }
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80006cd2:	30 0b       	mov	r11,0
80006cd4:	fe 7c 24 00 	mov	r12,-56320
80006cd8:	fe b0 dc 44 	rcall	80002560 <spi_unselectChip>

  print_dbg("\r\n done loading; waiting... ");
80006cdc:	49 ac       	lddpc	r12,80006d44 <bfin_load+0x170>
80006cde:	fe b0 de c1 	rcall	80002a60 <print_dbg>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006ce2:	30 09       	mov	r9,0
80006ce4:	e0 68 03 e8 	mov	r8,1000
80006ce8:	e0 6a 07 e7 	mov	r10,2023
80006cec:	ea 1a 12 c8 	orh	r10,0x12c8
80006cf0:	30 3b       	mov	r11,3
80006cf2:	e0 a0 38 cc 	rcall	8000de8a <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006cf6:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006cfa:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006cfe:	e1 b8 00 42 	mfsr	r8,0x108
80006d02:	14 39       	cp.w	r9,r10
80006d04:	e0 8b 00 0f 	brhi	80006d22 <bfin_load+0x14e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006d08:	12 38       	cp.w	r8,r9
80006d0a:	c0 43       	brcs	80006d12 <bfin_load+0x13e>
80006d0c:	14 38       	cp.w	r8,r10
80006d0e:	e0 88 00 10 	brls	80006d2e <bfin_load+0x15a>
  delay_ms(200);
  print_dbg("\r\n done waiting; reporting... ");
80006d12:	48 ec       	lddpc	r12,80006d48 <bfin_load+0x174>
80006d14:	fe b0 de a6 	rcall	80002a60 <print_dbg>

  bfin_report_params();
80006d18:	c3 6f       	rcall	80006b84 <bfin_report_params>
80006d1a:	2f ed       	sub	sp,-8
  
}
80006d1c:	d8 32       	popm	r0-r7,pc
80006d1e:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006d22:	10 39       	cp.w	r9,r8
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006d24:	fe 98 ff fd 	brls	80006d1e <bfin_load+0x14a>
80006d28:	10 3a       	cp.w	r10,r8
80006d2a:	cf a2       	brcc	80006d1e <bfin_load+0x14a>
80006d2c:	cf 3b       	rjmp	80006d12 <bfin_load+0x13e>
80006d2e:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006d32:	ce bb       	rjmp	80006d08 <bfin_load+0x134>
80006d34:	80 01       	ld.sh	r1,r0[0x0]
80006d36:	41 64       	lddsp	r4,sp[0x58]
80006d38:	80 01       	ld.sh	r1,r0[0x0]
80006d3a:	41 78       	lddsp	r8,sp[0x5c]
80006d3c:	80 01       	ld.sh	r1,r0[0x0]
80006d3e:	41 88       	lddsp	r8,sp[0x60]
80006d40:	80 01       	ld.sh	r1,r0[0x0]
80006d42:	41 8c       	lddsp	r12,sp[0x60]
80006d44:	80 01       	ld.sh	r1,r0[0x0]
80006d46:	41 a4       	lddsp	r4,sp[0x68]
80006d48:	80 01       	ld.sh	r1,r0[0x0]
80006d4a:	41 c4       	lddsp	r4,sp[0x70]

80006d4c <init_events>:
// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
80006d4c:	e0 6a 07 98 	mov	r10,1944
80006d50:	30 08       	mov	r8,0
  getIdx = 0;
80006d52:	95 08       	st.w	r10[0x0],r8

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
80006d54:	e0 6a 07 9c 	mov	r10,1948
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;
80006d58:	10 99       	mov	r9,r8

// The system event queue is a circular array of event records.
static event_t sysEvents[ MAX_EVENTS ];

// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
80006d5a:	95 08       	st.w	r10[0x0],r8
80006d5c:	e0 68 07 a0 	mov	r8,1952
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
80006d60:	f0 ca ff 00 	sub	r10,r8,-256
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
80006d64:	91 09       	st.w	r8[0x0],r9
80006d66:	91 19       	st.w	r8[0x4],r9
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
  }
}
80006d68:	2f 88       	sub	r8,-8
80006d6a:	14 38       	cp.w	r8,r10
80006d6c:	cf c1       	brne	80006d64 <init_events+0x18>
80006d6e:	5e fc       	retal	r12

80006d70 <post_event>:
80006d70:	d4 01       	pushm	lr
80006d72:	d3 33       	ssrf	0x13
80006d74:	e0 69 07 98 	mov	r9,1944
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // increment write idx, posbily wrapping
  saveIndex = putIdx;
  INCR_EVENT_INDEX( putIdx );
80006d78:	72 0a       	ld.w	r10,r9[0x0]
80006d7a:	f4 c8 ff ff 	sub	r8,r10,-1
80006d7e:	93 08       	st.w	r9[0x0],r8
80006d80:	e0 48 00 20 	cp.w	r8,32
80006d84:	f9 b8 00 00 	moveq	r8,0
80006d88:	f3 f8 0a 00 	st.weq	r9[0x0],r8
  if ( putIdx != getIdx  ) {
80006d8c:	e0 6b 07 9c 	mov	r11,1948
80006d90:	76 0b       	ld.w	r11,r11[0x0]
    sysEvents[ putIdx ].eventType = e->eventType;
80006d92:	10 3b       	cp.w	r11,r8
80006d94:	c0 d0       	breq	80006dae <post_event+0x3e>
80006d96:	78 0a       	ld.w	r10,r12[0x0]
80006d98:	e0 69 07 a0 	mov	r9,1952
    sysEvents[ putIdx ].eventData = e->eventData;
80006d9c:	f2 08 09 3a 	st.w	r9[r8<<0x3],r10
80006da0:	f2 08 00 38 	add	r8,r9,r8<<0x3
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
    print_dbg("\r\n event queue full!");
  } 

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006da4:	78 19       	ld.w	r9,r12[0x4]
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
80006da6:	30 1c       	mov	r12,1
    sysEvents[ putIdx ].eventType = e->eventType;
    sysEvents[ putIdx ].eventData = e->eventData;
    status = true;
  } else {
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
80006da8:	91 19       	st.w	r8[0x4],r9
    print_dbg("\r\n event queue full!");
80006daa:	d5 33       	csrf	0x13
80006dac:	d8 02       	popm	pc
80006dae:	93 0a       	st.w	r9[0x0],r10
80006db0:	48 3c       	lddpc	r12,80006dbc <post_event+0x4c>
  } 

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006db2:	fe b0 de 57 	rcall	80002a60 <print_dbg>
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
80006db6:	30 0c       	mov	r12,0
80006db8:	d5 33       	csrf	0x13
80006dba:	d8 02       	popm	pc
80006dbc:	80 01       	ld.sh	r1,r0[0x0]
80006dbe:	41 e4       	lddsp	r4,sp[0x78]

80006dc0 <get_next_event>:
80006dc0:	18 99       	mov	r9,r12
80006dc2:	d3 33       	ssrf	0x13
80006dc4:	e0 68 07 98 	mov	r8,1944
80006dc8:	e0 6a 07 9c 	mov	r10,1948
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
80006dcc:	70 0b       	ld.w	r11,r8[0x0]
80006dce:	74 08       	ld.w	r8,r10[0x0]
    INCR_EVENT_INDEX( getIdx );
80006dd0:	16 38       	cp.w	r8,r11
80006dd2:	c1 50       	breq	80006dfc <get_next_event+0x3c>
80006dd4:	2f f8       	sub	r8,-1
80006dd6:	95 08       	st.w	r10[0x0],r8
80006dd8:	e0 48 00 20 	cp.w	r8,32
80006ddc:	f9 b8 00 00 	moveq	r8,0
    e->eventType = sysEvents[ getIdx ].eventType;
80006de0:	f5 f8 0a 00 	st.weq	r10[0x0],r8
    e->eventData = sysEvents[ getIdx ].eventData;
80006de4:	e0 6a 07 a0 	mov	r10,1952
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
80006de8:	f4 08 00 3b 	add	r11,r10,r8<<0x3
    e->eventData = sysEvents[ getIdx ].eventData;
80006dec:	f4 08 03 38 	ld.w	r8,r10[r8<<0x3]
80006df0:	99 08       	st.w	r12[0x0],r8
    e->eventType  = 0xff;
    e->eventData = 0;
    status = false;
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006df2:	76 18       	ld.w	r8,r11[0x4]
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
80006df4:	99 18       	st.w	r12[0x4],r8
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
    e->eventData = 0;
80006df6:	30 1c       	mov	r12,1
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
80006df8:	d5 33       	csrf	0x13
80006dfa:	5e fc       	retal	r12
    e->eventData = 0;
80006dfc:	30 0c       	mov	r12,0
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
80006dfe:	e0 68 00 ff 	mov	r8,255
  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
80006e02:	93 1c       	st.w	r9[0x4],r12
80006e04:	93 08       	st.w	r9[0x0],r8
80006e06:	d5 33       	csrf	0x13
80006e08:	5e fc       	retal	r12
80006e0a:	d7 03       	nop

80006e0c <set_enc_thresh>:
    enc[idx].pos = pos;
  }
}
  
void set_enc_thresh( const u8 idx, const u8 v ) {
  enc[idx].thresh = v;
80006e0c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80006e10:	e0 68 28 d4 	mov	r8,10452
80006e14:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
}
80006e18:	b8 3b       	st.h	r12[0x6],r11
80006e1a:	5e fc       	retal	r12

80006e1c <process_enc>:
80006e1c:	eb cd 40 f8 	pushm	r3-r7,lr

// apply pin mapping to deteremine movement
void process_enc( const U8 idx) {
  U8 pos;
  
  pos = gpio_get_pin_value(enc[idx].pin[0]) + (gpio_get_pin_value(enc[idx].pin[1]) << 1);
80006e20:	e0 65 28 d4 	mov	r5,10452
80006e24:	f8 0c 00 14 	add	r4,r12,r12<<0x1
80006e28:	ea 04 00 26 	add	r6,r5,r4<<0x2
80006e2c:	0c 97       	mov	r7,r6
80006e2e:	0f 3c       	ld.ub	r12,r7++
80006e30:	fe b0 d9 66 	rcall	800020fc <gpio_get_pin_value>
80006e34:	18 93       	mov	r3,r12
80006e36:	0f 8c       	ld.ub	r12,r7[0x0]
80006e38:	fe b0 d9 62 	rcall	800020fc <gpio_get_pin_value>
80006e3c:	0d a8       	ld.ub	r8,r6[0x2]
80006e3e:	e6 0c 00 13 	add	r3,r3,r12<<0x1
  
  if (pos != enc[idx].pos) {
80006e42:	5c 53       	castu.b	r3
80006e44:	e6 08 18 00 	cp.b	r8,r3
    enc[idx].val -= enc_map[enc[idx].pos][pos];
80006e48:	c0 d0       	breq	80006e62 <process_enc+0x46>
80006e4a:	2f f4       	sub	r4,-1
80006e4c:	e6 08 00 28 	add	r8,r3,r8<<0x2
80006e50:	ea 04 04 29 	ld.sh	r9,r5[r4<<0x2]
80006e54:	48 5a       	lddpc	r10,80006e68 <process_enc+0x4c>
80006e56:	f4 08 06 08 	ld.sb	r8,r10[r8]
80006e5a:	10 19       	sub	r9,r8
80006e5c:	ea 04 0a 29 	st.h	r5[r4<<0x2],r9
    enc[idx].pos = pos;
80006e60:	ac a3       	st.b	r6[0x2],r3
80006e62:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006e66:	d7 03       	nop
80006e68:	80 01       	ld.sh	r1,r0[0x0]
80006e6a:	41 f9       	lddsp	r9,sp[0x7c]

80006e6c <init_encoders>:
80006e6c:	eb cd 40 e0 	pushm	r5-r7,lr

// initialize encoder positions
void init_encoders(void) {
  U8 i;
  // constant data
  enc[0].pin[0] = ENC0_S0_PIN;
80006e70:	32 28       	mov	r8,34
80006e72:	e0 67 28 d4 	mov	r7,10452
  enc[0].pin[1] = ENC0_S1_PIN;
80006e76:	ae 88       	st.b	r7[0x0],r8
80006e78:	32 38       	mov	r8,35
  enc[0].event = kEventEncoder0;
80006e7a:	ae 98       	st.b	r7[0x1],r8
80006e7c:	30 58       	mov	r8,5
  enc[1].pin[0] = ENC1_S0_PIN;
80006e7e:	8f 28       	st.w	r7[0x8],r8
80006e80:	32 48       	mov	r8,36
80006e82:	ef 68 00 0c 	st.b	r7[12],r8
  enc[1].pin[1] = ENC1_S1_PIN;
80006e86:	32 58       	mov	r8,37
80006e88:	ef 68 00 0d 	st.b	r7[13],r8
  enc[1].event = kEventEncoder1;
80006e8c:	30 68       	mov	r8,6
  enc[2].pin[0] = ENC2_S0_PIN;
80006e8e:	8f 58       	st.w	r7[0x14],r8
80006e90:	32 68       	mov	r8,38
80006e92:	ef 68 00 18 	st.b	r7[24],r8
  enc[2].pin[1] = ENC2_S1_PIN;
80006e96:	32 78       	mov	r8,39
80006e98:	ef 68 00 19 	st.b	r7[25],r8
  enc[2].event = kEventEncoder2;
80006e9c:	30 78       	mov	r8,7
  enc[3].pin[0] = ENC3_S0_PIN;
80006e9e:	8f 88       	st.w	r7[0x20],r8
80006ea0:	32 88       	mov	r8,40
80006ea2:	ef 68 00 24 	st.b	r7[36],r8
  enc[3].pin[1] = ENC3_S1_PIN;
80006ea6:	32 98       	mov	r8,41
80006ea8:	ef 68 00 25 	st.b	r7[37],r8
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006eac:	30 88       	mov	r8,8
  enc[2].pin[0] = ENC2_S0_PIN;
  enc[2].pin[1] = ENC2_S1_PIN;
  enc[2].event = kEventEncoder2;
  enc[3].pin[0] = ENC3_S0_PIN;
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
80006eae:	32 2c       	mov	r12,34
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006eb0:	8f b8       	st.w	r7[0x2c],r8
80006eb2:	fe b0 d9 25 	rcall	800020fc <gpio_get_pin_value>
80006eb6:	18 96       	mov	r6,r12
80006eb8:	0f 9c       	ld.ub	r12,r7[0x1]
80006eba:	fe b0 d9 21 	rcall	800020fc <gpio_get_pin_value>
80006ebe:	ec 0c 00 1c 	add	r12,r6,r12<<0x1
80006ec2:	30 06       	mov	r6,0
    enc[i].thresh = ENC_THRESH_DEFAULT;
80006ec4:	ae ac       	st.b	r7[0x2],r12
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006ec6:	ae 36       	st.h	r7[0x6],r6
80006ec8:	ef 3c 00 0c 	ld.ub	r12,r7[12]
80006ecc:	fe b0 d9 18 	rcall	800020fc <gpio_get_pin_value>
80006ed0:	18 95       	mov	r5,r12
80006ed2:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80006ed6:	fe b0 d9 13 	rcall	800020fc <gpio_get_pin_value>
80006eda:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
    enc[i].thresh = ENC_THRESH_DEFAULT;
80006ede:	ef 56 00 12 	st.h	r7[18],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006ee2:	ef 6c 00 0e 	st.b	r7[14],r12
80006ee6:	ef 3c 00 18 	ld.ub	r12,r7[24]
80006eea:	fe b0 d9 09 	rcall	800020fc <gpio_get_pin_value>
80006eee:	18 95       	mov	r5,r12
80006ef0:	ef 3c 00 19 	ld.ub	r12,r7[25]
80006ef4:	fe b0 d9 04 	rcall	800020fc <gpio_get_pin_value>
80006ef8:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
    enc[i].thresh = ENC_THRESH_DEFAULT;
80006efc:	ef 56 00 1e 	st.h	r7[30],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006f00:	ef 6c 00 1a 	st.b	r7[26],r12
80006f04:	ef 3c 00 24 	ld.ub	r12,r7[36]
80006f08:	fe b0 d8 fa 	rcall	800020fc <gpio_get_pin_value>
80006f0c:	18 95       	mov	r5,r12
80006f0e:	ef 3c 00 25 	ld.ub	r12,r7[37]
80006f12:	fe b0 d8 f5 	rcall	800020fc <gpio_get_pin_value>
    enc[i].thresh = ENC_THRESH_DEFAULT;
80006f16:	ef 56 00 2a 	st.h	r7[42],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80006f1a:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
80006f1e:	ef 6c 00 26 	st.b	r7[38],r12
    enc[i].thresh = ENC_THRESH_DEFAULT;
  }
}
80006f22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f26:	d7 03       	nop

80006f28 <files_get_dsp_name>:
    }
  }
}

// return filename for given index
const volatile char* files_get_dsp_name(u8 idx) {
80006f28:	e0 68 29 04 	mov	r8,10500
  return dsp_name_buf + (idx * DSP_NAME_LEN);
}
80006f2c:	a5 7c       	lsl	r12,0x5
80006f2e:	f0 0c 00 0c 	add	r12,r8,r12
80006f32:	5e fc       	retal	r12

80006f34 <files_get_dsp_count>:
80006f34:	e0 68 08 a0 	mov	r8,2208
}

// return count of dsp files
u8 files_get_dsp_count(void) {
  return numDsp;
}
80006f38:	11 8c       	ld.ub	r12,r8[0x0]
80006f3a:	5e fc       	retal	r12

80006f3c <files_load_dsp_name>:
80006f3c:	eb cd 40 e0 	pushm	r5-r7,lr
void files_load_dsp(u8 idx) { 
  files_load_dsp_name((const char*)files_get_dsp_name(idx));
}

 // search for specified dsp file and load it
void files_load_dsp_name(const char* name) {
80006f40:	fa cd 01 5c 	sub	sp,sp,348
80006f44:	18 95       	mov	r5,r12
  struct fs_dir_ent dirent;
  char path[64];
  void* fp;
  //  unsigned long int i;

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80006f46:	d3 33       	ssrf	0x13
  cpu_irq_disable_level(UI_IRQ_PRIORITY);
80006f48:	d3 33       	ssrf	0x13

  if( fl_opendir("/dsp", &dirstat) ) {      
80006f4a:	4a ac       	lddpc	r12,80006ff0 <files_load_dsp_name+0xb4>
80006f4c:	fa c6 fe b0 	sub	r6,sp,-336
80006f50:	0c 9b       	mov	r11,r6
80006f52:	e0 a0 22 c7 	rcall	8000b4e0 <fl_opendir>
80006f56:	c4 80       	breq	80006fe6 <files_load_dsp_name+0xaa>
80006f58:	1a 97       	mov	r7,sp
80006f5a:	c0 f8       	rjmp	80006f78 <files_load_dsp_name+0x3c>
    while (fl_readdir(&dirstat, &dirent) == 0) {
      if (strcmp(dirent.filename, name) == 0) {
80006f5c:	0a 9b       	mov	r11,r5
80006f5e:	1a 9c       	mov	r12,sp
80006f60:	e0 a0 3f 48 	rcall	8000edf0 <strcmp>
80006f64:	c1 40       	breq	80006f8c <files_load_dsp_name+0x50>
	}
	print_dbg("\r\n done loading bfin. \r\n");
	// processed a filename match, get out
	return;
      } else {
	print_dbg("\r\n tested " );
80006f66:	4a 4c       	lddpc	r12,80006ff4 <files_load_dsp_name+0xb8>
80006f68:	fe b0 dd 7c 	rcall	80002a60 <print_dbg>
	print_dbg(dirent.filename);
80006f6c:	1a 9c       	mov	r12,sp
80006f6e:	fe b0 dd 79 	rcall	80002a60 <print_dbg>
	print_dbg(", no match ");
80006f72:	4a 2c       	lddpc	r12,80006ff8 <files_load_dsp_name+0xbc>
80006f74:	fe b0 dd 76 	rcall	80002a60 <print_dbg>

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  cpu_irq_disable_level(UI_IRQ_PRIORITY);

  if( fl_opendir("/dsp", &dirstat) ) {      
    while (fl_readdir(&dirstat, &dirent) == 0) {
80006f78:	1a 9b       	mov	r11,sp
80006f7a:	0c 9c       	mov	r12,r6
80006f7c:	e0 a0 22 74 	rcall	8000b464 <fl_readdir>
80006f80:	ce e0       	breq	80006f5c <files_load_dsp_name+0x20>
    }
  } else {
    print_dbg("\r\n error opening dsp dir in load_dsp_name \r\n");
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006f82:	d5 33       	csrf	0x13
  cpu_irq_enable_level(UI_IRQ_PRIORITY);
80006f84:	d5 33       	csrf	0x13
}
80006f86:	2a 9d       	sub	sp,-348
80006f88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  cpu_irq_disable_level(UI_IRQ_PRIORITY);

  if( fl_opendir("/dsp", &dirstat) ) {      
    while (fl_readdir(&dirstat, &dirent) == 0) {
      if (strcmp(dirent.filename, name) == 0) {
	print_dbg("\r\n matched " );
80006f8c:	49 cc       	lddpc	r12,80006ffc <files_load_dsp_name+0xc0>
80006f8e:	fe b0 dd 69 	rcall	80002a60 <print_dbg>
	print_dbg(name);
80006f92:	0a 9c       	mov	r12,r5
80006f94:	fe b0 dd 66 	rcall	80002a60 <print_dbg>
	strcpy(path, "/dsp/");
80006f98:	49 a8       	lddpc	r8,80007000 <files_load_dsp_name+0xc4>
80006f9a:	11 d9       	ld.ub	r9,r8[0x5]
80006f9c:	fa c7 fe f0 	sub	r7,sp,-272
80006fa0:	ae d9       	st.b	r7[0x5],r9
80006fa2:	70 09       	ld.w	r9,r8[0x0]
80006fa4:	8f 09       	st.w	r7[0x0],r9
80006fa6:	11 c8       	ld.ub	r8,r8[0x4]
	strncat(path, dirent.filename, 58);
80006fa8:	1a 9b       	mov	r11,sp
  if( fl_opendir("/dsp", &dirstat) ) {      
    while (fl_readdir(&dirstat, &dirent) == 0) {
      if (strcmp(dirent.filename, name) == 0) {
	print_dbg("\r\n matched " );
	print_dbg(name);
	strcpy(path, "/dsp/");
80006faa:	ae c8       	st.b	r7[0x4],r8
	strncat(path, dirent.filename, 58);
80006fac:	33 aa       	mov	r10,58
80006fae:	0e 9c       	mov	r12,r7
80006fb0:	e0 a0 3f 88 	rcall	8000eec0 <strncat>
	fp = fl_fopen(path, "r");
80006fb4:	0e 9c       	mov	r12,r7
80006fb6:	49 4b       	lddpc	r11,80007004 <files_load_dsp_name+0xc8>
80006fb8:	e0 a0 25 ac 	rcall	8000bb10 <fl_fopen>
80006fbc:	18 97       	mov	r7,r12
	if( fp != NULL) {	  
80006fbe:	c1 00       	breq	80006fde <files_load_dsp_name+0xa2>
	  print_dbg("\r\n found file, loading dsp... \r\n");
80006fc0:	49 2c       	lddpc	r12,80007008 <files_load_dsp_name+0xcc>
80006fc2:	fe b0 dd 4f 	rcall	80002a60 <print_dbg>

	  //// we need to buffer the LDR file to save memory.
	  //// this sort of breaks modularity, oh well.
	  bfin_load(dirent.size, fp);
80006fc6:	44 3c       	lddsp	r12,sp[0x10c]
80006fc8:	0e 9b       	mov	r11,r7
80006fca:	c0 5e       	rcall	80006bd4 <bfin_load>
80006fcc:	0e 9c       	mov	r12,r7
	  fl_fclose(fp);
80006fce:	e0 a0 23 9f 	rcall	8000b70c <fl_fclose>
80006fd2:	48 fc       	lddpc	r12,8000700c <files_load_dsp_name+0xd0>

	} else {
	  print_dbg("\r\n error: fp was null in load_dsp_name \r\n");
	}
	print_dbg("\r\n done loading bfin. \r\n");
80006fd4:	fe b0 dd 46 	rcall	80002a60 <print_dbg>
80006fd8:	2a 9d       	sub	sp,-348
    print_dbg("\r\n error opening dsp dir in load_dsp_name \r\n");
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
  cpu_irq_enable_level(UI_IRQ_PRIORITY);
}
80006fda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006fde:	48 dc       	lddpc	r12,80007010 <files_load_dsp_name+0xd4>
	  //// this sort of breaks modularity, oh well.
	  bfin_load(dirent.size, fp);
	  fl_fclose(fp);

	} else {
	  print_dbg("\r\n error: fp was null in load_dsp_name \r\n");
80006fe0:	fe b0 dd 40 	rcall	80002a60 <print_dbg>
80006fe4:	cf 7b       	rjmp	80006fd2 <files_load_dsp_name+0x96>
80006fe6:	48 cc       	lddpc	r12,80007014 <files_load_dsp_name+0xd8>
	print_dbg(dirent.filename);
	print_dbg(", no match ");
      }
    }
  } else {
    print_dbg("\r\n error opening dsp dir in load_dsp_name \r\n");
80006fe8:	fe b0 dd 3c 	rcall	80002a60 <print_dbg>
80006fec:	cc bb       	rjmp	80006f82 <files_load_dsp_name+0x46>
80006fee:	d7 03       	nop
80006ff0:	80 01       	ld.sh	r1,r0[0x0]
80006ff2:	42 0c       	lddsp	r12,sp[0x80]
80006ff4:	80 01       	ld.sh	r1,r0[0x0]
80006ff6:	42 98       	lddsp	r8,sp[0xa4]
80006ff8:	80 01       	ld.sh	r1,r0[0x0]
80006ffa:	42 a4       	lddsp	r4,sp[0xa8]
80006ffc:	80 01       	ld.sh	r1,r0[0x0]
80006ffe:	42 14       	lddsp	r4,sp[0x84]
80007000:	80 01       	ld.sh	r1,r0[0x0]
80007002:	42 20       	lddsp	r0,sp[0x88]
80007004:	80 01       	ld.sh	r1,r0[0x0]
80007006:	42 28       	lddsp	r8,sp[0x88]
80007008:	80 01       	ld.sh	r1,r0[0x0]
8000700a:	42 2c       	lddsp	r12,sp[0x88]
8000700c:	80 01       	ld.sh	r1,r0[0x0]
8000700e:	42 7c       	lddsp	r12,sp[0x9c]
80007010:	80 01       	ld.sh	r1,r0[0x0]
80007012:	42 50       	lddsp	r0,sp[0x94]
80007014:	80 01       	ld.sh	r1,r0[0x0]
80007016:	42 b0       	lddsp	r0,sp[0xac]

80007018 <files_load_dsp>:
80007018:	d4 01       	pushm	lr
8000701a:	e0 68 29 04 	mov	r8,10500
8000701e:	a5 7c       	lsl	r12,0x5
80007020:	f0 0c 00 0c 	add	r12,r8,r12
80007024:	c8 cf       	rcall	80006f3c <files_load_dsp_name>
80007026:	d8 02       	popm	pc

80007028 <files_scan_dsp>:
80007028:	d4 21       	pushm	r4-r7,lr
8000702a:	fa cd 01 1c 	sub	sp,sp,284
8000702e:	30 08       	mov	r8,0
80007030:	e0 65 08 a0 	mov	r5,2208
80007034:	fa c6 fe f0 	sub	r6,sp,-272
// ( keeping the list is because the interface will ask us for strings a lot)
void files_scan_dsp(void) {
  FL_DIR dirstat;
  struct fs_dir_ent dirent;
  numDsp = 0;
  if( fl_opendir("/dsp", &dirstat) ) {      
80007038:	aa 88       	st.b	r5[0x0],r8
8000703a:	49 3c       	lddpc	r12,80007084 <files_scan_dsp+0x5c>
8000703c:	0c 9b       	mov	r11,r6
8000703e:	e0 a0 22 51 	rcall	8000b4e0 <fl_opendir>
80007042:	c1 f0       	breq	80007080 <files_scan_dsp+0x58>
    while (fl_readdir(&dirstat, &dirent) == 0) {
      if( !(dirent.is_dir) ) {
	print_dbg("\r\n adding dsp file : ");
	print_dbg(dirent.filename);
	strcpy((char *)dsp_name_buf + (numDsp * DSP_NAME_LEN), dirent.filename);
80007044:	1a 97       	mov	r7,sp
void files_scan_dsp(void) {
  FL_DIR dirstat;
  struct fs_dir_ent dirent;
  numDsp = 0;
  if( fl_opendir("/dsp", &dirstat) ) {      
    while (fl_readdir(&dirstat, &dirent) == 0) {
80007046:	e0 64 29 04 	mov	r4,10500
8000704a:	1a 9b       	mov	r11,sp
8000704c:	0c 9c       	mov	r12,r6
8000704e:	e0 a0 22 0b 	rcall	8000b464 <fl_readdir>
      if( !(dirent.is_dir) ) {
80007052:	c1 71       	brne	80007080 <files_scan_dsp+0x58>
80007054:	fb 38 01 04 	ld.ub	r8,sp[260]
80007058:	f8 08 18 00 	cp.b	r8,r12
	print_dbg("\r\n adding dsp file : ");
8000705c:	cf 71       	brne	8000704a <files_scan_dsp+0x22>
8000705e:	48 bc       	lddpc	r12,80007088 <files_scan_dsp+0x60>
	print_dbg(dirent.filename);
80007060:	fe b0 dd 00 	rcall	80002a60 <print_dbg>
80007064:	1a 9c       	mov	r12,sp
	strcpy((char *)dsp_name_buf + (numDsp * DSP_NAME_LEN), dirent.filename);
80007066:	fe b0 dc fd 	rcall	80002a60 <print_dbg>
8000706a:	0b 8c       	ld.ub	r12,r5[0x0]
8000706c:	1a 9b       	mov	r11,sp
8000706e:	a5 7c       	lsl	r12,0x5
80007070:	e8 0c 00 0c 	add	r12,r4,r12
	numDsp++;
80007074:	e0 a0 3f 12 	rcall	8000ee98 <strcpy>
80007078:	0b 88       	ld.ub	r8,r5[0x0]
8000707a:	2f f8       	sub	r8,-1
      }
    }
  }
}
8000707c:	aa 88       	st.b	r5[0x0],r8
8000707e:	ce 6b       	rjmp	8000704a <files_scan_dsp+0x22>
80007080:	2b 9d       	sub	sp,-284
80007082:	d8 22       	popm	r4-r7,pc
80007084:	80 01       	ld.sh	r1,r0[0x0]
80007086:	42 0c       	lddsp	r12,sp[0x80]
80007088:	80 01       	ld.sh	r1,r0[0x0]
8000708a:	42 e0       	lddsp	r0,sp[0xb8]

8000708c <init_files>:
8000708c:	d4 01       	pushm	lr
8000708e:	c0 3c       	rcall	80007094 <fat_init>
80007090:	cc cf       	rcall	80007028 <files_scan_dsp>
80007092:	d8 02       	popm	pc

80007094 <fat_init>:


//=========
// extern

int fat_init(void) {
80007094:	eb cd 40 80 	pushm	r7,lr
  // Initialise File IO Library
  print_dbg("\r\n beginning FAT library init.");
80007098:	48 ec       	lddpc	r12,800070d0 <fat_init+0x3c>
8000709a:	fe b0 dc e3 	rcall	80002a60 <print_dbg>
  fl_init();
8000709e:	e0 a0 1f 95 	rcall	8000afc8 <fl_init>
  print_dbg("\r\n finished FAT library init.");
800070a2:	48 dc       	lddpc	r12,800070d4 <fat_init+0x40>
800070a4:	fe b0 dc de 	rcall	80002a60 <print_dbg>
  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
800070a8:	fe cb ff c8 	sub	r11,pc,-56
800070ac:	fe cc ff 64 	sub	r12,pc,-156
800070b0:	e0 a0 23 be 	rcall	8000b82c <fl_attach_media>
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
    return 1;
  } else {
    print_dbg("\r\n attached media access functions to fat_io_lib");
800070b4:	18 97       	mov	r7,r12
800070b6:	c0 71       	brne	800070c4 <fat_init+0x30>
800070b8:	48 8c       	lddpc	r12,800070d8 <fat_init+0x44>
800070ba:	fe b0 dc d3 	rcall	80002a60 <print_dbg>
    return 0;
  }
}
800070be:	0e 9c       	mov	r12,r7
  print_dbg("\r\n beginning FAT library init.");
  fl_init();
  print_dbg("\r\n finished FAT library init.");
  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
800070c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800070c4:	48 6c       	lddpc	r12,800070dc <fat_init+0x48>
800070c6:	fe b0 dc cd 	rcall	80002a60 <print_dbg>
800070ca:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800070ce:	d7 03       	nop
800070d0:	80 01       	ld.sh	r1,r0[0x0]
800070d2:	42 f8       	lddsp	r8,sp[0xbc]
800070d4:	80 01       	ld.sh	r1,r0[0x0]
800070d6:	43 18       	lddsp	r8,sp[0xc4]
800070d8:	80 01       	ld.sh	r1,r0[0x0]
800070da:	43 74       	lddsp	r4,sp[0xdc]
800070dc:	80 01       	ld.sh	r1,r0[0x0]
800070de:	43 38       	lddsp	r8,sp[0xcc]

800070e0 <media_write>:
800070e0:	eb cd 40 f8 	pushm	r3-r7,lr
800070e4:	16 97       	mov	r7,r11
800070e6:	14 94       	mov	r4,r10
800070e8:	18 93       	mov	r3,r12
800070ea:	fe b0 dd a1 	rcall	80002c2c <sd_mmc_spi_write_open>
800070ee:	18 96       	mov	r6,r12
  // PDCA write isn't implemented in ASF... 
  // for the moment use slower blocking write.

  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
800070f0:	c1 e0       	breq	8000712c <media_write+0x4c>
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
800070f2:	58 04       	cp.w	r4,0
800070f4:	c1 80       	breq	80007124 <media_write+0x44>
  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
800070f6:	30 06       	mov	r6,0
800070f8:	c0 48       	rjmp	80007100 <media_write+0x20>
  }

  for (i=0;i<sector_count;i++) {
800070fa:	0c 34       	cp.w	r4,r6
800070fc:	e0 88 00 14 	brls	80007124 <media_write+0x44>
  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
80007100:	ec 03 00 05 	add	r5,r6,r3
  }

  for (i=0;i<sector_count;i++) {
    status = sd_mmc_spi_write_sector_from_ram(buffer);
80007104:	0e 9c       	mov	r12,r7
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
80007106:	2f f6       	sub	r6,-1
      print_dbg("\r\n error writing sd_mmc_spi, sector: ");
      print_dbg_hex(sector);
    }
    //////////////
    sector++;
    buffer += 512;
80007108:	ee c7 fe 00 	sub	r7,r7,-512
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
    status = sd_mmc_spi_write_sector_from_ram(buffer);
8000710c:	fe b0 df aa 	rcall	80003060 <sd_mmc_spi_write_sector_from_ram>
    /////////// dbg
    if(status == false) {
80007110:	cf 51       	brne	800070fa <media_write+0x1a>
      print_dbg("\r\n error writing sd_mmc_spi, sector: ");
80007112:	48 cc       	lddpc	r12,80007140 <media_write+0x60>
80007114:	fe b0 dc a6 	rcall	80002a60 <print_dbg>
      print_dbg_hex(sector);
80007118:	0a 9c       	mov	r12,r5
8000711a:	fe b0 dc 4b 	rcall	800029b0 <print_dbg_hex>
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
8000711e:	0c 34       	cp.w	r4,r6
80007120:	fe 9b ff f0 	brhi	80007100 <media_write+0x20>
    }
    //////////////
    sector++;
    buffer += 512;
  }
  sd_mmc_spi_write_close();
80007124:	fe b0 dd 2e 	rcall	80002b80 <sd_mmc_spi_write_close>
80007128:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
  // for the moment use slower blocking write.

  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
8000712c:	48 6c       	lddpc	r12,80007144 <media_write+0x64>
8000712e:	fe b0 dc 99 	rcall	80002a60 <print_dbg>
    print_dbg_hex(sector);
80007132:	06 9c       	mov	r12,r3
80007134:	fe b0 dc 3e 	rcall	800029b0 <print_dbg_hex>
80007138:	0c 9c       	mov	r12,r6
    return 0;
8000713a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000713e:	d7 03       	nop
80007140:	80 01       	ld.sh	r1,r0[0x0]
80007142:	43 d0       	lddsp	r0,sp[0xf4]
80007144:	80 01       	ld.sh	r1,r0[0x0]
80007146:	43 a8       	lddsp	r8,sp[0xe8]

80007148 <media_read>:
80007148:	d4 31       	pushm	r0-r7,lr
8000714a:	18 94       	mov	r4,r12
8000714c:	16 97       	mov	r7,r11
8000714e:	14 91       	mov	r1,r10
80007150:	58 0a       	cp.w	r10,0
80007152:	c5 30       	breq	800071f8 <media_read+0xb0>
80007154:	30 03       	mov	r3,0
80007156:	e0 66 2f 10 	mov	r6,12048
8000715a:	e0 65 2d 08 	mov	r5,11528
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_RX,
8000715e:	30 10       	mov	r0,1
80007160:	06 92       	mov	r2,r3
80007162:	e0 6a 02 00 	mov	r10,512
80007166:	e0 6b 2f 10 	mov	r11,12048
		       &pdcaRxBuf,
		       FS_BUF_SIZE);
    
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_TX,
8000716a:	30 0c       	mov	r12,0
8000716c:	fe b0 d9 33 	rcall	800023d2 <pdca_load_channel>
80007170:	30 1c       	mov	r12,1
80007172:	e0 6a 02 00 	mov	r10,512
		       (void *)&pdcaTxBuf,
		       FS_BUF_SIZE); //send dummy to activate the clock
    
    fsEndTransfer = false;
    
    if(sd_mmc_spi_read_open_PDCA (sector)) {
80007176:	e0 6b 2d 10 	mov	r11,11536
8000717a:	fe b0 d9 2c 	rcall	800023d2 <pdca_load_channel>
8000717e:	08 9c       	mov	r12,r4

      spi_write(SD_MMC_SPI,0xFF); // dummy byte synchronizes transfer
80007180:	aa 82       	st.b	r5[0x0],r2
80007182:	fe b0 de a9 	rcall	80002ed4 <sd_mmc_spi_read_open_PDCA>
80007186:	c2 f0       	breq	800071e4 <media_read+0x9c>
80007188:	e0 6b 00 ff 	mov	r11,255

      pdca_enable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
8000718c:	fe 7c 28 00 	mov	r12,-55296
80007190:	fe b0 da 55 	rcall	8000263a <spi_write>
      pdcaRxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_RX);
80007194:	30 0c       	mov	r12,0
80007196:	fe b0 d8 fa 	rcall	8000238a <pdca_enable_interrupt_transfer_complete>
8000719a:	30 0c       	mov	r12,0
      pdcaTxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_TX);
8000719c:	fe b0 d8 de 	rcall	80002358 <pdca_get_handler>
800071a0:	e0 63 2d 04 	mov	r3,11524
800071a4:	87 0c       	st.w	r3[0x0],r12
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
800071a6:	30 1c       	mov	r12,1
800071a8:	fe b0 d8 d8 	rcall	80002358 <pdca_get_handler>
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
800071ac:	e0 68 2d 0c 	mov	r8,11532
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
800071b0:	91 0c       	st.w	r8[0x0],r12
800071b2:	66 09       	ld.w	r9,r3[0x0]
800071b4:	93 50       	st.w	r9[0x14],r0
      // copy FIXME: could optimize
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
800071b6:	70 08       	ld.w	r8,r8[0x0]
800071b8:	91 50       	st.w	r8[0x14],r0
800071ba:	0b 88       	ld.ub	r8,r5[0x0]
800071bc:	58 08       	cp.w	r8,0
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
      // copy FIXME: could optimize
      for(i=0; i<FS_BUF_SIZE; i++) {
800071be:	cf e0       	breq	800071ba <media_read+0x72>
800071c0:	30 08       	mov	r8,0
800071c2:	ec 08 07 09 	ld.ub	r9,r6[r8]
800071c6:	ee 08 0b 09 	st.b	r7[r8],r9
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
800071ca:	2f f8       	sub	r8,-1
800071cc:	e0 48 02 00 	cp.w	r8,512
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
      print_dbg_ulong(sector);
    }
    sector ++;
800071d0:	cf 91       	brne	800071c2 <media_read+0x7a>
    buffer += FS_BUF_SIZE;
800071d2:	e0 63 02 01 	mov	r3,513
800071d6:	06 31       	cp.w	r1,r3
      // copy FIXME: could optimize
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
800071d8:	e0 88 00 10 	brls	800071f8 <media_read+0xb0>
800071dc:	2f f4       	sub	r4,-1
      print_dbg_ulong(sector);
800071de:	ee c7 fe 00 	sub	r7,r7,-512
800071e2:	cc 0b       	rjmp	80007162 <media_read+0x1a>
800071e4:	48 6c       	lddpc	r12,800071fc <media_read+0xb4>
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
800071e6:	fe b0 dc 3d 	rcall	80002a60 <print_dbg>
800071ea:	2f f3       	sub	r3,-1
    }
    sector ++;
    buffer += FS_BUF_SIZE;
  }
  return 1;
}
800071ec:	08 9c       	mov	r12,r4
800071ee:	fe b0 dc 17 	rcall	80002a1c <print_dbg_ulong>
800071f2:	06 31       	cp.w	r1,r3
800071f4:	fe 9b ff f4 	brhi	800071dc <media_read+0x94>
800071f8:	da 3a       	popm	r0-r7,pc,r12=1
800071fa:	d7 03       	nop
800071fc:	80 01       	ld.sh	r1,r0[0x0]
800071fe:	43 f8       	lddsp	r8,sp[0xfc]

80007200 <test_flash>:
 /*  //  test_write_nv(data); */
 /*  //  test_print_nv(data); */

 /*  test_print_flash_status(); */

}
80007200:	5e fc       	retal	r12
80007202:	d7 03       	nop

80007204 <init_usb_host>:
  gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
}


// initialize USB host stack
void init_usb_host (void) {
80007204:	d4 01       	pushm	lr
  //  pm_configure_usb_clock();
  uhc_start();
80007206:	fe b0 f3 a9 	rcall	80005958 <uhc_start>
}
8000720a:	d8 02       	popm	pc

8000720c <init_bfin_resources>:
8000720c:	eb cd 40 80 	pushm	r7,lr
  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
}

// intialize resources for bf533 communication: SPI, GPIO
void init_bfin_resources(void) {
80007210:	20 4d       	sub	sp,16
    //    .trans_delay  = 0,
    .trans_delay = 20,
    .stay_act     = 1,
    .spi_mode     = 1,
    .modfdis      = 1
  };
80007212:	49 78       	lddpc	r8,8000726c <init_bfin_resources+0x60>
80007214:	f0 ea 00 08 	ld.d	r10,r8[8]
80007218:	fa eb 00 08 	st.d	sp[8],r10
8000721c:	f0 e8 00 00 	ld.d	r8,r8[0]
80007220:	1a 97       	mov	r7,sp
80007222:	fa e9 00 00 	st.d	sp[0],r8

  // assign pins to SPI.
  gpio_enable_module(BFIN_SPI_GPIO_MAP,
80007226:	30 4b       	mov	r11,4
80007228:	49 2c       	lddpc	r12,80007270 <init_bfin_resources+0x64>
8000722a:	fe b0 d7 d3 	rcall	800021d0 <gpio_enable_module>
		     sizeof(BFIN_SPI_GPIO_MAP) / sizeof(BFIN_SPI_GPIO_MAP[0]));

  // intialize as master
  spi_initMaster(BFIN_SPI, &spiOptions);
8000722e:	1a 9b       	mov	r11,sp
80007230:	fe 7c 24 00 	mov	r12,-56320
80007234:	fe b0 d9 3a 	rcall	800024a8 <spi_initMaster>

  // set selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(BFIN_SPI, 0, 0, 0);
80007238:	30 09       	mov	r9,0
8000723a:	fe 7c 24 00 	mov	r12,-56320
8000723e:	12 9a       	mov	r10,r9
80007240:	12 9b       	mov	r11,r9
80007242:	fe b0 d9 52 	rcall	800024e6 <spi_selectionMode>

  // enable SPI.
  spi_enable(BFIN_SPI);
80007246:	fe 7c 24 00 	mov	r12,-56320
8000724a:	fe b0 d9 f5 	rcall	80002634 <spi_enable>

  // intialize the chip register
  spi_setupChipReg(BFIN_SPI, &spiOptions, FPBA_HZ);
8000724e:	1a 9b       	mov	r11,sp
80007250:	e0 6a 14 80 	mov	r10,5248
80007254:	ea 1a 03 ef 	orh	r10,0x3ef
80007258:	fe 7c 24 00 	mov	r12,-56320
8000725c:	fe b0 d9 96 	rcall	80002588 <spi_setupChipReg>
  // enable pulldown on bfin HWAIT line
  //// shit! not implemented... 
  // gpio_enable_pin_pull_down(BFIN_HWAIT_PIN);
  
  // enable pullup on bfin RESET line
  gpio_enable_pin_pull_up(BFIN_RESET_PIN);
80007260:	30 6c       	mov	r12,6
80007262:	fe b0 d7 43 	rcall	800020e8 <gpio_enable_pin_pull_up>
}
80007266:	2f cd       	sub	sp,-16
80007268:	e3 cd 80 80 	ldm	sp++,r7,pc
8000726c:	80 01       	ld.sh	r1,r0[0x0]
8000726e:	44 bc       	lddsp	r12,sp[0x12c]
80007270:	80 01       	ld.sh	r1,r0[0x0]
80007272:	44 8c       	lddsp	r12,sp[0x120]

80007274 <init_local_pdca>:
80007274:	eb cd 40 b0 	pushm	r4-r5,r7,lr
80007278:	20 cd       	sub	sp,48
8000727a:	49 4a       	lddpc	r10,800072c8 <init_local_pdca+0x54>
8000727c:	f4 e4 00 10 	ld.d	r4,r10[16]
80007280:	fa c7 ff e8 	sub	r7,sp,-24
80007284:	49 29       	lddpc	r9,800072cc <init_local_pdca+0x58>
80007286:	ee e5 00 10 	st.d	r7[16],r4
8000728a:	f2 e4 00 10 	ld.d	r4,r9[16]
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
8000728e:	fa e5 00 10 	st.d	sp[16],r4
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_RX,        // select peripheral ID - SPI1 RX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80007292:	f4 e4 00 00 	ld.d	r4,r10[0]
80007296:	ee e5 00 00 	st.d	r7[0],r4
8000729a:	f4 e4 00 08 	ld.d	r4,r10[8]
8000729e:	ee e5 00 08 	st.d	r7[8],r4
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
800072a2:	f2 e4 00 00 	ld.d	r4,r9[0]

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
800072a6:	1a 9b       	mov	r11,sp
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
800072a8:	fa e5 00 00 	st.d	sp[0],r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
800072ac:	30 1c       	mov	r12,1
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
800072ae:	f2 e4 00 08 	ld.d	r4,r9[8]
800072b2:	fa e5 00 08 	st.d	sp[8],r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
800072b6:	fe b0 d8 a6 	rcall	80002402 <pdca_init_channel>

  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
800072ba:	0e 9b       	mov	r11,r7
800072bc:	30 0c       	mov	r12,0
800072be:	fe b0 d8 a2 	rcall	80002402 <pdca_init_channel>
}
800072c2:	2f 4d       	sub	sp,-48
800072c4:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
800072c8:	80 01       	ld.sh	r1,r0[0x0]
800072ca:	44 cc       	lddsp	r12,sp[0x130]
800072cc:	80 01       	ld.sh	r1,r0[0x0]
800072ce:	44 74       	lddsp	r4,sp[0x11c]

800072d0 <init_spi1>:
800072d0:	d4 21       	pushm	r4-r7,lr
800072d2:	20 4d       	sub	sp,16
    .trans_delay = 0,
    .spck_delay = 0,
    .stay_act = 1,
    .spi_mode = 3,
    .modfdis = 1
  };
800072d4:	4b 68       	lddpc	r8,800073ac <init_spi1+0xdc>
800072d6:	f0 ea 00 08 	ld.d	r10,r8[8]
800072da:	fa eb 00 08 	st.d	sp[8],r10
800072de:	f0 e8 00 00 	ld.d	r8,r8[0]
800072e2:	1a 97       	mov	r7,sp
800072e4:	fa e9 00 00 	st.d	sp[0],r8

  // Assign GPIO to SPI.
  gpio_enable_module(OLED_SPI_GPIO_MAP,
800072e8:	30 6b       	mov	r11,6
800072ea:	4b 2c       	lddpc	r12,800073b0 <init_spi1+0xe0>
800072ec:	fe b0 d7 72 	rcall	800021d0 <gpio_enable_module>
		     sizeof(OLED_SPI_GPIO_MAP) / sizeof(OLED_SPI_GPIO_MAP[0]));
  // Initialize as master.
  spi_initMaster(OLED_SPI, &spiOptions);
800072f0:	1a 9b       	mov	r11,sp
800072f2:	fe 7c 28 00 	mov	r12,-55296
800072f6:	fe b0 d8 d9 	rcall	800024a8 <spi_initMaster>
  // Set SPI selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(OLED_SPI, 0, 0, 0);
800072fa:	30 09       	mov	r9,0
800072fc:	fe 7c 28 00 	mov	r12,-55296
80007300:	12 9a       	mov	r10,r9
80007302:	12 9b       	mov	r11,r9
80007304:	fe b0 d8 f1 	rcall	800024e6 <spi_selectionMode>
  // Enable SPI module.
  spi_enable(OLED_SPI);
80007308:	fe 7c 28 00 	mov	r12,-55296
8000730c:	fe b0 d9 94 	rcall	80002634 <spi_enable>

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );
80007310:	1a 9b       	mov	r11,sp
80007312:	e0 6a 14 80 	mov	r10,5248
80007316:	ea 1a 03 ef 	orh	r10,0x3ef
8000731a:	fe 7c 28 00 	mov	r12,-55296
8000731e:	fe b0 d9 35 	rcall	80002588 <spi_setupChipReg>

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
80007322:	e0 68 2d 00 	mov	r8,11520
80007326:	ea 18 01 31 	orh	r8,0x131
8000732a:	50 18       	stdsp	sp[0x4],r8
  spiOptions.bits         = 16;
8000732c:	31 08       	mov	r8,16
8000732e:	fb 68 00 08 	st.b	sp[8],r8
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
80007332:	30 58       	mov	r8,5
  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
80007334:	30 06       	mov	r6,0

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
80007336:	30 15       	mov	r5,1
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80007338:	1a 9b       	mov	r11,sp
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
8000733a:	fb 68 00 0a 	st.b	sp[10],r8
  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
8000733e:	fb 66 00 09 	st.b	sp[9],r6
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
80007342:	fb 66 00 0b 	st.b	sp[11],r6
  spiOptions.modfdis      = 0;
80007346:	fb 66 00 0d 	st.b	sp[13],r6

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
8000734a:	ba 85       	st.b	sp[0x0],r5
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
8000734c:	30 24       	mov	r4,2
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
8000734e:	e0 6a 14 80 	mov	r10,5248
80007352:	ea 1a 03 ef 	orh	r10,0x3ef

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
80007356:	fb 64 00 0c 	st.b	sp[12],r4
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
8000735a:	fe 7c 28 00 	mov	r12,-55296
8000735e:	fe b0 d9 15 	rcall	80002588 <spi_setupChipReg>

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
80007362:	e0 68 1b 00 	mov	r8,6912
80007366:	ea 18 00 b7 	orh	r8,0xb7
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
8000736a:	ba 84       	st.b	sp[0x0],r4
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
  spiOptions.spck_delay  = 0;
  spiOptions.trans_delay = 0;
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
8000736c:	fb 66 00 0c 	st.b	sp[12],r6
  spiOptions.modfdis     = 1;
80007370:	fb 65 00 0d 	st.b	sp[13],r5

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
80007374:	20 4d       	sub	sp,16

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
80007376:	50 58       	stdsp	sp[0x14],r8
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80007378:	30 88       	mov	r8,8
  spiOptions.spck_delay  = 0;
8000737a:	fb 66 00 19 	st.b	sp[25],r6
  spiOptions.trans_delay = 0;
8000737e:	fb 66 00 1a 	st.b	sp[26],r6
  spiOptions.stay_act    = 1;
80007382:	fb 65 00 1b 	st.b	sp[27],r5
  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80007386:	fb 68 00 18 	st.b	sp[24],r8
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
  spiOptions.modfdis     = 1;

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
8000738a:	ee e8 00 08 	ld.d	r8,r7[8]
8000738e:	fa e9 00 08 	st.d	sp[8],r8
80007392:	ee e8 00 00 	ld.d	r8,r7[0]
80007396:	e0 6c 14 80 	mov	r12,5248
8000739a:	ea 1c 03 ef 	orh	r12,0x3ef
8000739e:	fa e9 00 00 	st.d	sp[0],r8
800073a2:	fe b0 e3 5d 	rcall	80003a5c <sd_mmc_spi_init>
800073a6:	2f cd       	sub	sp,-16
}
800073a8:	2f cd       	sub	sp,-16
800073aa:	d8 22       	popm	r4-r7,pc
800073ac:	80 01       	ld.sh	r1,r0[0x0]
800073ae:	44 ac       	lddsp	r12,sp[0x128]
800073b0:	80 01       	ld.sh	r1,r0[0x0]
800073b2:	44 3c       	lddsp	r12,sp[0x10c]

800073b4 <init_ftdi_usart>:
800073b4:	d4 01       	pushm	lr
800073b6:	30 2b       	mov	r11,2
800073b8:	48 7c       	lddpc	r12,800073d4 <init_ftdi_usart+0x20>
800073ba:	fe b0 d7 0b 	rcall	800021d0 <gpio_enable_module>
800073be:	e0 6a 14 80 	mov	r10,5248
800073c2:	ea 1a 03 ef 	orh	r10,0x3ef
800073c6:	48 5b       	lddpc	r11,800073d8 <init_ftdi_usart+0x24>
800073c8:	fe 7c 14 00 	mov	r12,-60416
  // Set up GPIO for FTDI_USART
  gpio_enable_module(FTDI_USART_GPIO_MAP,
                     sizeof(FTDI_USART_GPIO_MAP) / sizeof(FTDI_USART_GPIO_MAP[0]));

  // Initialize in RS232 mode.
  usart_init_rs232(FTDI_USART, &FTDI_USART_OPTIONS, FPBA_HZ);
800073cc:	fe b0 da 80 	rcall	800028cc <usart_init_rs232>
}
800073d0:	d8 02       	popm	pc
800073d2:	d7 03       	nop
800073d4:	80 01       	ld.sh	r1,r0[0x0]
800073d6:	44 2c       	lddsp	r12,sp[0x108]
800073d8:	80 01       	ld.sh	r1,r0[0x0]
800073da:	44 20       	lddsp	r0,sp[0x108]

800073dc <init_tc>:
800073dc:	eb cd 40 80 	pushm	r7,lr
800073e0:	48 bb       	lddpc	r11,8000740c <init_tc+0x30>
800073e2:	18 97       	mov	r7,r12
    .cpas  = 0,
    .lovrs = 0,
    .covfs = 0
  };
  // Initialize the timer/counter.
  tc_init_waveform(tc, &waveform_opt);
800073e4:	fe b0 d9 4a 	rcall	80002678 <tc_init_waveform>

  // set timer compare trigger.
  // we want it to overflow and generate an interrupt every 1 ms
  // so (1 / fPBA / 128) * RC = 0.001
  // so RC = fPBA / 128 / 1000
  tc_write_rc(tc, APP_TC_CHANNEL, (FPBA_HZ / 128 / 1000));
800073e8:	e0 6a 02 03 	mov	r10,515
800073ec:	30 0b       	mov	r11,0
800073ee:	0e 9c       	mov	r12,r7
800073f0:	fe b0 d9 a5 	rcall	8000273a <tc_write_rc>
  // configure the timer interrupt
  tc_configure_interrupts(tc, APP_TC_CHANNEL, &tc_interrupt);
800073f4:	30 0b       	mov	r11,0
800073f6:	48 7a       	lddpc	r10,80007410 <init_tc+0x34>
800073f8:	0e 9c       	mov	r12,r7
800073fa:	fe b0 d9 bc 	rcall	80002772 <tc_configure_interrupts>
  // Start the timer/counter.
  tc_start(tc, APP_TC_CHANNEL);
800073fe:	0e 9c       	mov	r12,r7
80007400:	30 0b       	mov	r11,0
80007402:	fe b0 d9 8a 	rcall	80002716 <tc_start>
}
80007406:	e3 cd 80 80 	ldm	sp++,r7,pc
8000740a:	d7 03       	nop
8000740c:	80 01       	ld.sh	r1,r0[0x0]
8000740e:	44 6c       	lddsp	r12,sp[0x118]
80007410:	80 01       	ld.sh	r1,r0[0x0]
80007412:	44 1c       	lddsp	r12,sp[0x104]

80007414 <init_gpio>:
80007414:	d4 01       	pushm	lr
80007416:	32 2c       	mov	r12,34
80007418:	fe b0 d6 68 	rcall	800020e8 <gpio_enable_pin_pull_up>
8000741c:	32 3c       	mov	r12,35
8000741e:	fe b0 d6 65 	rcall	800020e8 <gpio_enable_pin_pull_up>
80007422:	32 4c       	mov	r12,36
// initialize non-peripheral GPIO
void init_gpio(void) {
  
  gpio_enable_pin_pull_up(ENC0_S0_PIN);
  gpio_enable_pin_pull_up(ENC0_S1_PIN);
  gpio_enable_pin_pull_up(ENC1_S0_PIN);
80007424:	fe b0 d6 62 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC1_S1_PIN);
80007428:	32 5c       	mov	r12,37
8000742a:	fe b0 d6 5f 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S0_PIN);
8000742e:	32 6c       	mov	r12,38
80007430:	fe b0 d6 5c 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S1_PIN);
80007434:	32 7c       	mov	r12,39
80007436:	fe b0 d6 59 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S0_PIN);
8000743a:	32 8c       	mov	r12,40
8000743c:	fe b0 d6 56 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S1_PIN);
80007440:	32 9c       	mov	r12,41
80007442:	fe b0 d6 53 	rcall	800020e8 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(SW2_PIN);
  gpio_enable_pin_pull_up(SW3_PIN);
  gpio_enable_pin_pull_up(SW_MODE_PIN);
#endif

  gpio_enable_pin_pull_up(SW_POWER_PIN);
80007446:	33 0c       	mov	r12,48
80007448:	fe b0 d6 50 	rcall	800020e8 <gpio_enable_pin_pull_up>
  /// trying this...
  /* gpio_enable_pin_glitch_filter(SW0_PIN); */
  /* gpio_enable_pin_glitch_filter(SW1_PIN); */
  /* gpio_enable_pin_glitch_filter(SW2_PIN); */
  /* gpio_enable_pin_glitch_filter(SW3_PIN); */
  gpio_enable_pin_glitch_filter(SW_MODE_PIN); 
8000744c:	31 8c       	mov	r12,24
8000744e:	fe b0 d6 7c 	rcall	80002146 <gpio_enable_pin_glitch_filter>
}
80007452:	d8 02       	popm	pc

80007454 <register_interrupts>:

  //-----------------------------
  //---- external function definitions

  // register interrupts
  void register_interrupts(void) {
80007454:	d4 01       	pushm	lr
    // enable interrupts on GPIO inputs

    // BFIN_HWAIT
    // gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_PIN_CHANGE);
    gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_RISING_EDGE);
80007456:	30 1b       	mov	r11,1
80007458:	30 5c       	mov	r12,5
8000745a:	fe b0 d6 80 	rcall	8000215a <gpio_enable_pin_interrupt>

    // encoders
    gpio_enable_pin_interrupt( ENC0_S0_PIN,	GPIO_PIN_CHANGE);
8000745e:	30 0b       	mov	r11,0
80007460:	32 2c       	mov	r12,34
80007462:	fe b0 d6 7c 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC0_S1_PIN,	GPIO_PIN_CHANGE);
80007466:	30 0b       	mov	r11,0
80007468:	32 3c       	mov	r12,35
8000746a:	fe b0 d6 78 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S0_PIN,	GPIO_PIN_CHANGE);
8000746e:	30 0b       	mov	r11,0
80007470:	32 4c       	mov	r12,36
80007472:	fe b0 d6 74 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S1_PIN,	GPIO_PIN_CHANGE);
80007476:	30 0b       	mov	r11,0
80007478:	32 5c       	mov	r12,37
8000747a:	fe b0 d6 70 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S0_PIN,	GPIO_PIN_CHANGE);
8000747e:	30 0b       	mov	r11,0
80007480:	32 6c       	mov	r12,38
80007482:	fe b0 d6 6c 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S1_PIN,	GPIO_PIN_CHANGE);
80007486:	30 0b       	mov	r11,0
80007488:	32 7c       	mov	r12,39
8000748a:	fe b0 d6 68 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S0_PIN,	GPIO_PIN_CHANGE);
8000748e:	30 0b       	mov	r11,0
80007490:	32 8c       	mov	r12,40
80007492:	fe b0 d6 64 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S1_PIN,	GPIO_PIN_CHANGE);
80007496:	30 0b       	mov	r11,0
80007498:	32 9c       	mov	r12,41
8000749a:	fe b0 d6 60 	rcall	8000215a <gpio_enable_pin_interrupt>

    // switches
    gpio_enable_pin_interrupt( SW0_PIN,	        GPIO_PIN_CHANGE);
8000749e:	30 0b       	mov	r11,0
800074a0:	31 9c       	mov	r12,25
800074a2:	fe b0 d6 5c 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW1_PIN,	        GPIO_PIN_CHANGE);
800074a6:	30 0b       	mov	r11,0
800074a8:	31 ac       	mov	r12,26
800074aa:	fe b0 d6 58 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW2_PIN,	        GPIO_PIN_CHANGE);
800074ae:	30 0b       	mov	r11,0
800074b0:	31 bc       	mov	r12,27
800074b2:	fe b0 d6 54 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW3_PIN,	        GPIO_PIN_CHANGE);
800074b6:	30 0b       	mov	r11,0
800074b8:	31 cc       	mov	r12,28
800074ba:	fe b0 d6 50 	rcall	8000215a <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( FS0_PIN,	GPIO_PIN_CHANGE);
800074be:	30 0b       	mov	r11,0
800074c0:	33 ec       	mov	r12,62
800074c2:	fe b0 d6 4c 	rcall	8000215a <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( FS1_PIN,	GPIO_PIN_CHANGE);
800074c6:	30 0b       	mov	r11,0
800074c8:	33 fc       	mov	r12,63
800074ca:	fe b0 d6 48 	rcall	8000215a <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( SW_MODE_PIN,	GPIO_PIN_CHANGE);
800074ce:	30 0b       	mov	r11,0
800074d0:	31 8c       	mov	r12,24
800074d2:	fe b0 d6 44 	rcall	8000215a <gpio_enable_pin_interrupt>
    //  gpio_enable_pin_interrupt( SW_POWER_PIN,	GPIO_PIN_CHANGE);
 
    // PA24 - PA31
    INTC_register_interrupt( &irq_port0_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PA24 / 8), UI_IRQ_PRIORITY);
800074d6:	30 2a       	mov	r10,2
800074d8:	34 3b       	mov	r11,67
800074da:	fe cc fe fa 	sub	r12,pc,-262
800074de:	fe b0 d6 b7 	rcall	8000224c <INTC_register_interrupt>

    // PB00 - PB07
    INTC_register_interrupt( &irq_port1_line0, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB00 / 8), UI_IRQ_PRIORITY );
800074e2:	30 2a       	mov	r10,2
800074e4:	34 4b       	mov	r11,68
800074e6:	fe cc fe 62 	sub	r12,pc,-414

    // PB08 - PB15
    INTC_register_interrupt( &irq_port1_line1, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB08 / 8), UI_IRQ_PRIORITY);
800074ea:	fe b0 d6 b1 	rcall	8000224c <INTC_register_interrupt>
800074ee:	30 2a       	mov	r10,2
800074f0:	34 5b       	mov	r11,69
800074f2:	fe cc fe 9e 	sub	r12,pc,-354

    // PB16 - PB23
    //  INTC_register_interrupt( &irq_port1_line2, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB16 / 8), UI_IRQ_PRIORITY);

    // PB24 - PB31
    INTC_register_interrupt( &irq_port1_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB24 / 8), UI_IRQ_PRIORITY);
800074f6:	fe b0 d6 ab 	rcall	8000224c <INTC_register_interrupt>
800074fa:	30 2a       	mov	r10,2
800074fc:	34 7b       	mov	r11,71


    // register IRQ for PDCA transfer
    INTC_register_interrupt(&irq_pdca, AVR32_PDCA_IRQ_0, SYS_IRQ_PRIORITY);
800074fe:	fe cc ff 4e 	sub	r12,pc,-178
80007502:	fe b0 d6 a5 	rcall	8000224c <INTC_register_interrupt>
80007506:	30 1a       	mov	r10,1

    // register TC interrupt
    INTC_register_interrupt(&irq_tc, APP_TC_IRQ, APP_TC_IRQ_PRIORITY);
80007508:	36 0b       	mov	r11,96
8000750a:	fe cc ff 82 	sub	r12,pc,-126
8000750e:	fe b0 d6 9f 	rcall	8000224c <INTC_register_interrupt>
80007512:	30 2a       	mov	r10,2
  }
80007514:	e0 6b 01 c0 	mov	r11,448
80007518:	fe cc ff f4 	sub	r12,pc,-12
8000751c:	fe b0 d6 98 	rcall	8000224c <INTC_register_interrupt>
80007520:	d8 02       	popm	pc
80007522:	d7 03       	nop

80007524 <irq_tc>:
80007524:	eb cd 40 c0 	pushm	r6-r7,lr
80007528:	e0 68 08 a4 	mov	r8,2212
8000752c:	30 1a       	mov	r10,1
8000752e:	f0 e6 00 00 	ld.d	r6,r8[0]
80007532:	30 0b       	mov	r11,0
80007534:	ec 0a 00 0a 	add	r10,r6,r10
}

// timer irq
__attribute__((__interrupt__))
static void irq_tc(void) {
  tcTicks++;
80007538:	ee 0b 00 4b 	adc	r11,r7,r11
8000753c:	f0 eb 00 00 	st.d	r8[0],r10
  // overflow control
  if(tcTicks > tcMax) { 
80007540:	e0 66 ff ff 	mov	r6,65535
80007544:	ea 16 7f ff 	orh	r6,0x7fff
80007548:	f0 ea 00 00 	ld.d	r10,r8[0]
8000754c:	30 07       	mov	r7,0
8000754e:	0c 3a       	cp.w	r10,r6
80007550:	ee 0b 13 00 	cpc	r11,r7
80007554:	e0 8b 00 10 	brhi	80007574 <irq_tc+0x50>
    tcTicks = 0;
    tcOverflow = 1;
  } else {
    tcOverflow = 0;
80007558:	30 09       	mov	r9,0
8000755a:	e0 68 08 a2 	mov	r8,2210
  }
  process_timers();
8000755e:	b0 89       	st.b	r8[0x0],r9
  // clear interrupt flag by reading timer SR
  tc_read_sr(APP_TC, APP_TC_CHANNEL);
80007560:	e0 a0 07 b6 	rcall	800084cc <process_timers>
80007564:	30 0b       	mov	r11,0
80007566:	fe 7c 38 00 	mov	r12,-51200
}
8000756a:	fe b0 d8 df 	rcall	80002728 <tc_read_sr>
8000756e:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
__attribute__((__interrupt__))
static void irq_tc(void) {
  tcTicks++;
  // overflow control
  if(tcTicks > tcMax) { 
    tcTicks = 0;
80007572:	d6 03       	rete
80007574:	30 0a       	mov	r10,0
80007576:	30 0b       	mov	r11,0
    tcOverflow = 1;
80007578:	f0 eb 00 00 	st.d	r8[0],r10
8000757c:	30 19       	mov	r9,1
8000757e:	e0 68 08 a2 	mov	r8,2210
80007582:	b0 89       	st.b	r8[0x0],r9
80007584:	ce eb       	rjmp	80007560 <irq_tc+0x3c>
80007586:	d7 03       	nop

80007588 <irq_pdca>:
80007588:	d4 01       	pushm	lr
8000758a:	d3 03       	ssrf	0x10
8000758c:	30 0c       	mov	r12,0
8000758e:	fe b0 d7 0d 	rcall	800023a8 <pdca_disable_interrupt_transfer_complete>
  // Disable all interrupts.
  Disable_global_interrupt();
  // Disable interrupt channel.
  pdca_disable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
  //unselects the SD/MMC memory.
  sd_mmc_spi_read_close_PDCA();
80007592:	fe b0 da f9 	rcall	80002b84 <sd_mmc_spi_read_close_PDCA>
  //.... example has a 5000 clock gimpy delay here.
  // doesn't seem to need it , but if that changes use delay_us instead
  // Disable unnecessary channel
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
80007596:	30 1c       	mov	r12,1
80007598:	fe b0 d6 ea 	rcall	8000236c <pdca_disable>
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_RX);
8000759c:	30 0c       	mov	r12,0
8000759e:	fe b0 d6 e7 	rcall	8000236c <pdca_disable>
  // Enable all interrupts.
  Enable_global_interrupt();
800075a2:	d5 03       	csrf	0x10
  //  print_dbg("\r\n handled PDCA interrupt. \r\n");
  fsEndTransfer = true;
800075a4:	30 19       	mov	r9,1
800075a6:	e0 68 2d 08 	mov	r8,11528
}
800075aa:	b0 89       	st.b	r8[0x0],r9
800075ac:	d4 02       	popm	lr
800075ae:	d6 03       	rete

800075b0 <irq_port1_line3>:
800075b0:	d4 01       	pushm	lr
800075b2:	33 ec       	mov	r12,62
800075b4:	fe b0 d5 f8 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800075b8:	c0 d1       	brne	800075d2 <irq_port1_line3+0x22>
800075ba:	33 fc       	mov	r12,63
800075bc:	fe b0 d5 f4 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
  //  print_dbg("\r\n irq_port1_line3");
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
    process_sw(6);
  }
  if(gpio_get_pin_interrupt_flag(FS1_PIN)) {
800075c0:	c0 70       	breq	800075ce <irq_port1_line3+0x1e>
    gpio_clear_pin_interrupt_flag(FS1_PIN);
800075c2:	33 fc       	mov	r12,63
800075c4:	fe b0 d5 fc 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(7);
800075c8:	30 7c       	mov	r12,7
800075ca:	e0 a0 07 5f 	rcall	80008488 <process_sw>
  }
}
800075ce:	d4 02       	popm	lr
800075d0:	d6 03       	rete
// interrupt handler for PB24-PB31
__attribute__((__interrupt__))
static void irq_port1_line3(void) {
  //  print_dbg("\r\n irq_port1_line3");
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
800075d2:	33 ec       	mov	r12,62
800075d4:	fe b0 d5 f4 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(6);
800075d8:	30 6c       	mov	r12,6
800075da:	e0 a0 07 57 	rcall	80008488 <process_sw>
800075de:	ce eb       	rjmp	800075ba <irq_port1_line3+0xa>

800075e0 <irq_port0_line3>:
800075e0:	d4 01       	pushm	lr
800075e2:	31 9c       	mov	r12,25
800075e4:	fe b0 d5 e0 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800075e8:	c2 e1       	brne	80007644 <irq_port0_line3+0x64>
800075ea:	31 ac       	mov	r12,26
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
800075ec:	fe b0 d5 dc 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800075f0:	c2 31       	brne	80007636 <irq_port0_line3+0x56>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
800075f2:	31 bc       	mov	r12,27
800075f4:	fe b0 d5 d8 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800075f8:	c1 81       	brne	80007628 <irq_port0_line3+0x48>
    gpio_clear_pin_interrupt_flag(SW2_PIN);
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
800075fa:	31 cc       	mov	r12,28
800075fc:	fe b0 d5 d4 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
80007600:	c0 d1       	brne	8000761a <irq_port0_line3+0x3a>
    gpio_clear_pin_interrupt_flag(SW3_PIN);
    process_sw(3);
  }
  // SW_MODE
  if(gpio_get_pin_interrupt_flag(SW_MODE_PIN)) {
80007602:	31 8c       	mov	r12,24
80007604:	fe b0 d5 d0 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
80007608:	c0 70       	breq	80007616 <irq_port0_line3+0x36>
    gpio_clear_pin_interrupt_flag(SW_MODE_PIN);
8000760a:	31 8c       	mov	r12,24
8000760c:	fe b0 d5 d8 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(4);
80007610:	30 4c       	mov	r12,4
80007612:	e0 a0 07 3b 	rcall	80008488 <process_sw>
  }
}
80007616:	d4 02       	popm	lr
80007618:	d6 03       	rete
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
    gpio_clear_pin_interrupt_flag(SW3_PIN);
8000761a:	31 cc       	mov	r12,28
8000761c:	fe b0 d5 d0 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(3);
80007620:	30 3c       	mov	r12,3
80007622:	e0 a0 07 33 	rcall	80008488 <process_sw>
80007626:	ce eb       	rjmp	80007602 <irq_port0_line3+0x22>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
    gpio_clear_pin_interrupt_flag(SW2_PIN);
80007628:	31 bc       	mov	r12,27
8000762a:	fe b0 d5 c9 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(2);
8000762e:	30 2c       	mov	r12,2
80007630:	e0 a0 07 2c 	rcall	80008488 <process_sw>
80007634:	ce 3b       	rjmp	800075fa <irq_port0_line3+0x1a>
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
    gpio_clear_pin_interrupt_flag(SW1_PIN);
80007636:	31 ac       	mov	r12,26
80007638:	fe b0 d5 c2 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    process_sw(1);
8000763c:	30 1c       	mov	r12,1
8000763e:	e0 a0 07 25 	rcall	80008488 <process_sw>
80007642:	cd 8b       	rjmp	800075f2 <irq_port0_line3+0x12>
__attribute__((__interrupt__))
static void irq_port0_line3(void) {
  //  print_dbg("\r\n interrupt on port0_line3");
  //SW_F0
  if(gpio_get_pin_interrupt_flag(SW0_PIN)) {
    gpio_clear_pin_interrupt_flag(SW0_PIN);
80007644:	31 9c       	mov	r12,25
80007646:	fe b0 d5 bb 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
    /// process_sw() will post an event, which calls cpu_irq_disable().
    /// apparently, this also clears the GPIO interrupt flags (!?)
    /// so clear the flag first to avoid triggering an infinite series of interrupts.
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
8000764a:	30 0c       	mov	r12,0
8000764c:	e0 a0 07 1e 	rcall	80008488 <process_sw>
80007650:	cc db       	rjmp	800075ea <irq_port0_line3+0xa>
80007652:	d7 03       	nop

80007654 <irq_port1_line1>:
80007654:	d4 01       	pushm	lr
80007656:	32 8c       	mov	r12,40
80007658:	fe b0 d5 a6 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
8000765c:	c0 d1       	brne	80007676 <irq_port1_line1+0x22>
8000765e:	32 9c       	mov	r12,41
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
  }  
  // ENC3_1
  if(gpio_get_pin_interrupt_flag(ENC3_S1_PIN)) {
80007660:	fe b0 d5 a2 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
80007664:	c0 70       	breq	80007672 <irq_port1_line1+0x1e>
    process_enc(3);
80007666:	30 3c       	mov	r12,3
80007668:	fe b0 fb da 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S1_PIN);
8000766c:	32 9c       	mov	r12,41
8000766e:	fe b0 d5 a7 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
  }

}
80007672:	d4 02       	popm	lr
80007674:	d6 03       	rete
__attribute__((__interrupt__))
static void irq_port1_line1(void) {
  //    print_dbg("\r\b\interrupt on PB08-PB15.");
  // ENC3_0
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
80007676:	30 3c       	mov	r12,3
80007678:	fe b0 fb d2 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
8000767c:	32 8c       	mov	r12,40
8000767e:	fe b0 d5 9f 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
80007682:	ce eb       	rjmp	8000765e <irq_port1_line1+0xa>

80007684 <irq_port1_line0>:
80007684:	d4 01       	pushm	lr
80007686:	32 2c       	mov	r12,34
80007688:	fe b0 d5 8e 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
8000768c:	c3 91       	brne	800076fe <irq_port1_line0+0x7a>
8000768e:	32 3c       	mov	r12,35
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
80007690:	fe b0 d5 8a 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
80007694:	c2 e1       	brne	800076f0 <irq_port1_line0+0x6c>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
80007696:	32 4c       	mov	r12,36
80007698:	fe b0 d5 86 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
8000769c:	c2 31       	brne	800076e2 <irq_port1_line0+0x5e>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
8000769e:	32 5c       	mov	r12,37
800076a0:	fe b0 d5 82 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800076a4:	c1 81       	brne	800076d4 <irq_port1_line0+0x50>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
800076a6:	32 6c       	mov	r12,38
800076a8:	fe b0 d5 7e 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800076ac:	c0 d1       	brne	800076c6 <irq_port1_line0+0x42>
    process_enc(2);
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
  }  
  // ENC2_1
  if(gpio_get_pin_interrupt_flag(ENC2_S1_PIN)) {
800076ae:	32 7c       	mov	r12,39
800076b0:	fe b0 d5 7a 	rcall	800021a4 <gpio_get_pin_interrupt_flag>
800076b4:	c0 70       	breq	800076c2 <irq_port1_line0+0x3e>
    process_enc(2);
800076b6:	30 2c       	mov	r12,2
800076b8:	fe b0 fb b2 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S1_PIN);
800076bc:	32 7c       	mov	r12,39
800076be:	fe b0 d5 7f 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
  }
}
800076c2:	d4 02       	popm	lr
800076c4:	d6 03       	rete
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
    process_enc(2);
800076c6:	30 2c       	mov	r12,2
800076c8:	fe b0 fb aa 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
800076cc:	32 6c       	mov	r12,38
800076ce:	fe b0 d5 77 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
800076d2:	ce eb       	rjmp	800076ae <irq_port1_line0+0x2a>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
    process_enc(1);
800076d4:	30 1c       	mov	r12,1
800076d6:	fe b0 fb a3 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
800076da:	32 5c       	mov	r12,37
800076dc:	fe b0 d5 70 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
800076e0:	ce 3b       	rjmp	800076a6 <irq_port1_line0+0x22>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
    process_enc(1);
800076e2:	30 1c       	mov	r12,1
800076e4:	fe b0 fb 9c 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
800076e8:	32 4c       	mov	r12,36
800076ea:	fe b0 d5 69 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
800076ee:	cd 8b       	rjmp	8000769e <irq_port1_line0+0x1a>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
    process_enc(0);
800076f0:	30 0c       	mov	r12,0
800076f2:	fe b0 fb 95 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
800076f6:	32 3c       	mov	r12,35
800076f8:	fe b0 d5 62 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
800076fc:	cc db       	rjmp	80007696 <irq_port1_line0+0x12>
__attribute__((__interrupt__))
static void irq_port1_line0(void) {
  // print_dbg("\r\b\interrupt on PB00-PB07.");
  // ENC0_0
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
800076fe:	30 0c       	mov	r12,0
80007700:	fe b0 fb 8e 	rcall	80006e1c <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
80007704:	32 2c       	mov	r12,34
80007706:	fe b0 d5 5b 	rcall	800021bc <gpio_clear_pin_interrupt_flag>
8000770a:	cc 2b       	rjmp	8000768e <irq_port1_line0+0xa>

8000770c <alloc_mem>:
  heapOffset = 0;
}

// allocate and return pointer
heap_t alloc_mem(u32 bytes) {
  u32 tmp = heapOffset + bytes;
8000770c:	e0 68 08 b0 	mov	r8,2224
80007710:	70 09       	ld.w	r9,r8[0x0]
80007712:	f8 09 00 09 	add	r9,r12,r9
  u8 mtmp = tmp % 4;
80007716:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
  heap_t ret;
  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
8000771a:	f7 b9 01 fc 	subne	r9,-4
8000771e:	f3 da e1 19 	subne	r9,r9,r10
  }
  if (tmp < heapSize) {
80007722:	e0 6a 08 b4 	mov	r10,2228
80007726:	74 0a       	ld.w	r10,r10[0x0]
    ret = pHeapStart;
    heapOffset = tmp;
80007728:	14 39       	cp.w	r9,r10
  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
  }
  if (tmp < heapSize) {
    ret = pHeapStart;
8000772a:	c0 62       	brcc	80007736 <alloc_mem+0x2a>
8000772c:	91 09       	st.w	r8[0x0],r9
    heapOffset = tmp;
  } else {
    ret = (heap_t)ALLOC_FAIL;
  }
  return ret;
}
8000772e:	e0 68 08 ac 	mov	r8,2220
  heap_t ret;
  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
  }
  if (tmp < heapSize) {
80007732:	70 0c       	ld.w	r12,r8[0x0]
80007734:	5e fc       	retal	r12
80007736:	5e fd       	retal	0

80007738 <init_mem>:
80007738:	d4 01       	pushm	lr
8000773a:	30 1c       	mov	r12,1
8000773c:	fe b0 d4 66 	rcall	80002008 <smc_get_cs_size>


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
80007740:	fc 18 d0 00 	movh	r8,0xd000
static u32 heapSize;


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
80007744:	30 19       	mov	r9,1
80007746:	f2 0c 09 49 	lsl	r9,r9,r12
8000774a:	e0 6b 08 b4 	mov	r11,2228
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
8000774e:	f2 08 00 0a 	add	r10,r9,r8


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
80007752:	97 09       	st.w	r11[0x0],r9
80007754:	e0 69 08 ac 	mov	r9,2220
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
  heapOffset = 0;
80007758:	93 08       	st.w	r9[0x0],r8

// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
8000775a:	e0 68 08 b8 	mov	r8,2232
  heapOffset = 0;
8000775e:	30 09       	mov	r9,0
}
80007760:	91 0a       	st.w	r8[0x0],r10
80007762:	e0 68 08 b0 	mov	r8,2224
80007766:	91 09       	st.w	r8[0x0],r9
80007768:	d8 02       	popm	pc
8000776a:	d7 03       	nop

8000776c <write_command>:
  spi_write(OLED_SPI, c);
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
8000776c:	eb cd 40 80 	pushm	r7,lr
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007770:	30 0b       	mov	r11,0
  spi_write(OLED_SPI, c);
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
80007772:	18 97       	mov	r7,r12
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007774:	fe 7c 28 00 	mov	r12,-55296
80007778:	fe b0 d6 cc 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000777c:	30 9c       	mov	r12,9
8000777e:	fe b0 d4 d7 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007782:	0e 9b       	mov	r11,r7
80007784:	fe 7c 28 00 	mov	r12,-55296
80007788:	fe b0 d7 59 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000778c:	30 0b       	mov	r11,0
8000778e:	fe 7c 28 00 	mov	r12,-55296
80007792:	fe b0 d6 e7 	rcall	80002560 <spi_unselectChip>
}
80007796:	e3 cd 80 80 	ldm	sp++,r7,pc
8000779a:	d7 03       	nop

8000779c <screen_hl_line>:
8000779c:	d4 31       	pushm	r0-r7,lr
8000779e:	20 2d       	sub	sp,8
800077a0:	4d 48       	lddpc	r8,800078f0 <screen_hl_line+0x154>
800077a2:	5c 7b       	castu.h	r11
800077a4:	e7 dc c0 08 	bfextu	r3,r12,0x0,0x8
800077a8:	f0 0b 07 04 	ld.ub	r4,r8[r11]

// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
800077ac:	30 08       	mov	r8,0
800077ae:	f0 03 18 00 	cp.b	r3,r8
800077b2:	c4 25       	brlt	80007836 <screen_hl_line+0x9a>
  pos = (y << COLS_LSHIFT) + (x >> 1);

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
800077b4:	f7 da c0 04 	bfextu	r11,r10,0x0,0x4
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
800077b8:	a5 6a       	lsl	r10,0x4
800077ba:	5c 5a       	castu.b	r10

// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
800077bc:	18 92       	mov	r2,r12
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
800077be:	50 0a       	stdsp	sp[0x0],r10
800077c0:	30 07       	mov	r7,0
800077c2:	e0 6c 08 cc 	mov	r12,2252

// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
800077c6:	50 1b       	stdsp	sp[0x4],r11
800077c8:	e8 ce ff f9 	sub	lr,r4,-7
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
  if (x&1) {
    return screen[pos] & 0x0f; 
   } else {
    return (screen[pos] & 0xf0) >> 4;
800077cc:	18 96       	mov	r6,r12

// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
800077ce:	0e 9a       	mov	r10,r7
800077d0:	e6 07 00 0b 	add	r11,r3,r7
// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
800077d4:	5c 5b       	castu.b	r11
800077d6:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
800077da:	a1 9b       	lsr	r11,0x1

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
800077dc:	16 95       	mov	r5,r11
800077de:	58 09       	cp.w	r9,0
800077e0:	c2 d0       	breq	8000783a <screen_hl_line+0x9e>
800077e2:	c6 81       	brne	800078b2 <screen_hl_line+0x116>
800077e4:	08 91       	mov	r1,r4
800077e6:	08 99       	mov	r9,r4
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
800077e8:	c0 48       	rjmp	800077f0 <screen_hl_line+0x54>
800077ea:	12 91       	mov	r1,r9
800077ec:	12 3e       	cp.w	lr,r9
800077ee:	c1 b5       	brlt	80007824 <screen_hl_line+0x88>
  }
}

// get value of pixel
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
800077f0:	2f f9       	sub	r9,-1
800077f2:	e2 08 15 06 	lsl	r8,r1,0x6
800077f6:	5c 59       	castu.b	r9
  if (x&1) {
    return screen[pos] & 0x0f; 
800077f8:	16 08       	add	r8,r11
800077fa:	f8 08 07 00 	ld.ub	r0,r12[r8]
800077fe:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80007802:	f4 00 18 00 	cp.b	r0,r10
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007806:	cf 21       	brne	800077ea <screen_hl_line+0x4e>
80007808:	e2 08 15 06 	lsl	r8,r1,0x6
8000780c:	40 00       	lddsp	r0,sp[0x0]
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
8000780e:	0a 08       	add	r8,r5
80007810:	ec 08 07 01 	ld.ub	r1,r6[r8]
80007814:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
80007818:	00 41       	or	r1,r0
8000781a:	ec 08 0b 01 	st.b	r6[r8],r1
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
8000781e:	12 91       	mov	r1,r9
80007820:	12 3e       	cp.w	lr,r9
80007822:	ce 74       	brge	800077f0 <screen_hl_line+0x54>

// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007824:	2f f7       	sub	r7,-1
80007826:	e4 07 00 09 	add	r9,r2,r7
8000782a:	f4 09 18 00 	cp.b	r9,r10
    for(j=y; j<(y+FONT_CHARH); j++) {
8000782e:	cd 14       	brge	800077d0 <screen_hl_line+0x34>
80007830:	e0 69 08 c8 	mov	r9,2248
      if (screen_get_pixel(i, j) == 0) {
	screen_pixel(i, j, a);
      }
    }
  }
}
80007834:	93 08       	st.w	r9[0x0],r8
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
80007836:	2f ed       	sub	sp,-8
80007838:	d8 32       	popm	r0-r7,pc
8000783a:	58 09       	cp.w	r9,0
8000783c:	c1 e1       	brne	80007878 <screen_hl_line+0xdc>
8000783e:	08 91       	mov	r1,r4
80007840:	08 99       	mov	r9,r4
80007842:	c0 48       	rjmp	8000784a <screen_hl_line+0xae>
80007844:	12 91       	mov	r1,r9
80007846:	12 3e       	cp.w	lr,r9
  }
}

// get value of pixel
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
80007848:	ce e5       	brlt	80007824 <screen_hl_line+0x88>
8000784a:	2f f9       	sub	r9,-1
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
8000784c:	e2 08 15 06 	lsl	r8,r1,0x6
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
  if (x&1) {
    return screen[pos] & 0x0f; 
   } else {
    return (screen[pos] & 0xf0) >> 4;
80007850:	5c 59       	castu.b	r9
80007852:	16 08       	add	r8,r11
80007854:	f8 08 07 00 	ld.ub	r0,r12[r8]
80007858:	a5 80       	lsr	r0,0x4
8000785a:	f4 00 18 00 	cp.b	r0,r10
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
8000785e:	cf 31       	brne	80007844 <screen_hl_line+0xa8>
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007860:	e2 08 15 06 	lsl	r8,r1,0x6
80007864:	40 00       	lddsp	r0,sp[0x0]
80007866:	0a 08       	add	r8,r5
80007868:	ec 08 07 01 	ld.ub	r1,r6[r8]
8000786c:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
80007870:	00 41       	or	r1,r0
80007872:	ec 08 0b 01 	st.b	r6[r8],r1
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
80007876:	ce 7b       	rjmp	80007844 <screen_hl_line+0xa8>
80007878:	08 91       	mov	r1,r4
8000787a:	08 99       	mov	r9,r4
8000787c:	c0 48       	rjmp	80007884 <screen_hl_line+0xe8>
8000787e:	12 91       	mov	r1,r9
80007880:	12 3e       	cp.w	lr,r9
  }
}

// get value of pixel
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
80007882:	cd 15       	brlt	80007824 <screen_hl_line+0x88>
80007884:	2f f9       	sub	r9,-1
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
80007886:	e2 08 15 06 	lsl	r8,r1,0x6
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
  if (x&1) {
    return screen[pos] & 0x0f; 
   } else {
    return (screen[pos] & 0xf0) >> 4;
8000788a:	5c 59       	castu.b	r9
8000788c:	16 08       	add	r8,r11
8000788e:	f8 08 07 00 	ld.ub	r0,r12[r8]
80007892:	a5 80       	lsr	r0,0x4
80007894:	f4 00 18 00 	cp.b	r0,r10
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007898:	cf 31       	brne	8000787e <screen_hl_line+0xe2>

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
8000789a:	e2 08 15 06 	lsl	r8,r1,0x6
8000789e:	40 10       	lddsp	r0,sp[0x4]
800078a0:	0a 08       	add	r8,r5
800078a2:	ec 08 07 01 	ld.ub	r1,r6[r8]
800078a6:	e0 11 ff f0 	andl	r1,0xfff0
800078aa:	00 41       	or	r1,r0
800078ac:	ec 08 0b 01 	st.b	r6[r8],r1
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
800078b0:	ce 7b       	rjmp	8000787e <screen_hl_line+0xe2>
800078b2:	08 91       	mov	r1,r4
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
800078b4:	08 99       	mov	r9,r4
800078b6:	c0 58       	rjmp	800078c0 <screen_hl_line+0x124>
800078b8:	12 91       	mov	r1,r9
800078ba:	1c 39       	cp.w	r9,lr
800078bc:	fe 99 ff b4 	brgt	80007824 <screen_hl_line+0x88>
  }
}

// get value of pixel
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
800078c0:	2f f9       	sub	r9,-1
// highlight a line
void screen_hl_line(U16 x, U16 l, U8 a) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(y+FONT_CHARH); j++) {
800078c2:	e2 08 15 06 	lsl	r8,r1,0x6

// get value of pixel
U8 screen_get_pixel(U8 x, U8 y) {
  pos = (y << COLS_LSHIFT) + (x>>1);
  if (x&1) {
    return screen[pos] & 0x0f; 
800078c6:	5c 59       	castu.b	r9
800078c8:	16 08       	add	r8,r11
800078ca:	f8 08 07 00 	ld.ub	r0,r12[r8]
800078ce:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
800078d2:	f4 00 18 00 	cp.b	r0,r10
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
800078d6:	cf 11       	brne	800078b8 <screen_hl_line+0x11c>

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
800078d8:	e2 08 15 06 	lsl	r8,r1,0x6
800078dc:	40 10       	lddsp	r0,sp[0x4]
800078de:	0a 08       	add	r8,r5
800078e0:	ec 08 07 01 	ld.ub	r1,r6[r8]
800078e4:	e0 11 ff f0 	andl	r1,0xfff0
800078e8:	00 41       	or	r1,r0
800078ea:	ec 08 0b 01 	st.b	r6[r8],r1
800078ee:	ce 5b       	rjmp	800078b8 <screen_hl_line+0x11c>
800078f0:	80 01       	ld.sh	r1,r0[0x0]
800078f2:	44 e4       	lddsp	r4,sp[0x138]

800078f4 <screen_blank_line>:
800078f4:	eb cd 40 f8 	pushm	r3-r7,lr
}

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
800078f8:	4a 68       	lddpc	r8,80007990 <screen_blank_line+0x9c>
800078fa:	5c 7b       	castu.h	r11
  for(i=x; i<NCOLS; i++) {
800078fc:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
}

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
80007900:	f0 0b 07 05 	ld.ub	r5,r8[r11]
  for(i=x; i<NCOLS; i++) {
80007904:	30 08       	mov	r8,0
80007906:	f0 04 18 00 	cp.b	r4,r8
8000790a:	c2 85       	brlt	8000795a <screen_blank_line+0x66>
8000790c:	30 06       	mov	r6,0
8000790e:	ea c7 ff f9 	sub	r7,r5,-7
80007912:	e0 6a 08 cc 	mov	r10,2252
80007916:	0c 93       	mov	r3,r6
80007918:	08 9e       	mov	lr,r4
8000791a:	0c 0e       	add	lr,r6
8000791c:	5c 5e       	castu.b	lr
8000791e:	f1 de c0 01 	bfextu	r8,lr,0x0,0x1
80007922:	a1 9e       	lsr	lr,0x1
80007924:	58 08       	cp.w	r8,0
80007926:	c1 c1       	brne	8000795e <screen_blank_line+0x6a>
80007928:	0a 9b       	mov	r11,r5
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
8000792a:	0a 99       	mov	r9,r5
8000792c:	f6 08 15 06 	lsl	r8,r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007930:	1c 08       	add	r8,lr
80007932:	f4 08 07 0b 	ld.ub	r11,r10[r8]
80007936:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
8000793a:	f4 08 0b 0b 	st.b	r10[r8],r11
// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(FONT_CHARH + y); j++) {
8000793e:	2f f9       	sub	r9,-1
80007940:	5c 59       	castu.b	r9
80007942:	12 9b       	mov	r11,r9
80007944:	12 37       	cp.w	r7,r9
80007946:	cf 34       	brge	8000792c <screen_blank_line+0x38>

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007948:	2f f6       	sub	r6,-1
8000794a:	f8 06 00 09 	add	r9,r12,r6
8000794e:	e6 09 18 00 	cp.b	r9,r3
    for(j=y; j<(FONT_CHARH + y); j++) {
80007952:	ce 34       	brge	80007918 <screen_blank_line+0x24>
80007954:	e0 69 08 c8 	mov	r9,2248
80007958:	93 08       	st.w	r9[0x0],r8

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
8000795a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
8000795e:	0a 9b       	mov	r11,r5
80007960:	0a 99       	mov	r9,r5
80007962:	f6 08 15 06 	lsl	r8,r11,0x6

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007966:	1c 08       	add	r8,lr
80007968:	f4 08 07 0b 	ld.ub	r11,r10[r8]
8000796c:	e0 1b ff f0 	andl	r11,0xfff0
// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(FONT_CHARH + y); j++) {
80007970:	f4 08 0b 0b 	st.b	r10[r8],r11
80007974:	2f f9       	sub	r9,-1
80007976:	5c 59       	castu.b	r9
80007978:	12 9b       	mov	r11,r9
8000797a:	0e 39       	cp.w	r9,r7
8000797c:	fe 9a ff f3 	brle	80007962 <screen_blank_line+0x6e>

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007980:	2f f6       	sub	r6,-1
80007982:	f8 06 00 09 	add	r9,r12,r6
80007986:	e6 09 18 00 	cp.b	r9,r3
8000798a:	cc 74       	brge	80007918 <screen_blank_line+0x24>
8000798c:	ce 4b       	rjmp	80007954 <screen_blank_line+0x60>
8000798e:	d7 03       	nop
80007990:	80 01       	ld.sh	r1,r0[0x0]
80007992:	44 e4       	lddsp	r4,sp[0x138]

80007994 <screen_string_squeeze>:
80007994:	d4 31       	pushm	r0-r7,lr
80007996:	20 ad       	sub	sp,40
}

// draw a string with proportional spacing
U8 screen_string_squeeze(U16 x, U16 l, char *str, U8 a) {
  //  static u8 y;
  y = lines[l];
80007998:	fe f8 02 c4 	ld.w	r8,pc[708]
8000799c:	5c 7b       	castu.h	r11
  }
  return x;
}

// draw a string with proportional spacing
U8 screen_string_squeeze(U16 x, U16 l, char *str, U8 a) {
8000799e:	50 2a       	stdsp	sp[0x8],r10
  //  static u8 y;
  y = lines[l];
800079a0:	f0 0b 07 0b 	ld.ub	r11,r8[r11]
  }
  return x;
}

// draw a string with proportional spacing
U8 screen_string_squeeze(U16 x, U16 l, char *str, U8 a) {
800079a4:	50 1c       	stdsp	sp[0x4],r12
  //  static u8 y;
  y = lines[l];
800079a6:	e0 68 08 c4 	mov	r8,2244
800079aa:	50 3b       	stdsp	sp[0xc],r11
800079ac:	b0 8b       	st.b	r8[0x0],r11
  while(*str != 0) {
800079ae:	15 88       	ld.ub	r8,r10[0x0]
800079b0:	58 08       	cp.w	r8,0
800079b2:	e0 80 00 f1 	breq	80007b94 <screen_string_squeeze+0x200>
  pos = (y << COLS_LSHIFT) + (x >> 1);

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
800079b6:	e3 d9 c0 04 	bfextu	r1,r9,0x0,0x4
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
800079ba:	a5 69       	lsl	r9,0x4
800079bc:	e7 d9 c0 08 	bfextu	r3,r9,0x0,0x8
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
800079c0:	16 99       	mov	r9,r11
800079c2:	2f f9       	sub	r9,-1
800079c4:	a7 69       	lsl	r9,0x6
800079c6:	50 89       	stdsp	sp[0x20],r9
800079c8:	16 99       	mov	r9,r11
800079ca:	5c 7b       	castu.h	r11
800079cc:	2f e9       	sub	r9,-2
800079ce:	50 4b       	stdsp	sp[0x10],r11
800079d0:	a7 69       	lsl	r9,0x6
800079d2:	40 3b       	lddsp	r11,sp[0xc]
800079d4:	2f db       	sub	r11,-3
800079d6:	50 99       	stdsp	sp[0x24],r9
800079d8:	fb 5b 00 16 	st.h	sp[22],r11
800079dc:	40 39       	lddsp	r9,sp[0xc]
800079de:	40 3b       	lddsp	r11,sp[0xc]
800079e0:	2f c9       	sub	r9,-4
800079e2:	2f bb       	sub	r11,-5
800079e4:	fb 59 00 18 	st.h	sp[24],r9
800079e8:	fb 5b 00 1a 	st.h	sp[26],r11
800079ec:	40 39       	lddsp	r9,sp[0xc]
800079ee:	40 3b       	lddsp	r11,sp[0xc]
800079f0:	2f a9       	sub	r9,-6
800079f2:	2f 9b       	sub	r11,-7
800079f4:	e0 6a 08 cc 	mov	r10,2252
800079f8:	fb 59 00 1c 	st.h	sp[28],r9
800079fc:	fb 5b 00 1e 	st.h	sp[30],r11
// draw a single character glyph with proportional spacing
U8 screen_char_squeeze(U16 col, U16 row, char gl, U8 a) {
  //  static U8 x;
  static U8 xnum;
  static const glyph_t * g;
  g = &(font_data[gl - FONT_ASCII_OFFSET]);
80007a00:	22 08       	sub	r8,32
80007a02:	fe f9 02 5e 	ld.w	r9,pc[606]
80007a06:	f2 08 00 36 	add	r6,r9,r8<<0x3
  xnum = FONT_CHARW - g->first - g->last;
80007a0a:	0d 85       	ld.ub	r5,r6[0x0]
80007a0c:	0d 98       	ld.ub	r8,r6[0x1]
80007a0e:	ea 09 11 00 	rsub	r9,r5,0
80007a12:	f2 08 01 08 	sub	r8,r9,r8
80007a16:	40 32       	lddsp	r2,sp[0xc]
80007a18:	f0 cc ff fa 	sub	r12,r8,-6
80007a1c:	30 04       	mov	r4,0
  //  print_dbg("\r\n char at row: ");
  //  print_dbg_ulong(row);
  for(j=0; j<FONT_CHARH; j++) {
    for(i=0; i<xnum; i++) {
80007a1e:	40 18       	lddsp	r8,sp[0x4]
U8 screen_char_squeeze(U16 col, U16 row, char gl, U8 a) {
  //  static U8 x;
  static U8 xnum;
  static const glyph_t * g;
  g = &(font_data[gl - FONT_ASCII_OFFSET]);
  xnum = FONT_CHARW - g->first - g->last;
80007a20:	5c 5c       	castu.b	r12
  //  print_dbg("\r\n char at row: ");
  //  print_dbg_ulong(row);
  for(j=0; j<FONT_CHARH; j++) {
    for(i=0; i<xnum; i++) {
80007a22:	5c 88       	casts.h	r8
80007a24:	50 08       	stdsp	sp[0x0],r8
80007a26:	58 0c       	cp.w	r12,0
80007a28:	c3 d0       	breq	80007aa2 <screen_string_squeeze+0x10e>
80007a2a:	ef d2 c0 10 	bfextu	r7,r2,0x0,0x10
80007a2e:	30 1b       	mov	r11,1
80007a30:	a7 67       	lsl	r7,0x6
80007a32:	f6 04 09 4e 	lsl	lr,r11,r4
80007a36:	40 09       	lddsp	r9,sp[0x0]
80007a38:	30 08       	mov	r8,0
80007a3a:	c1 88       	rjmp	80007a6a <screen_string_squeeze+0xd6>
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007a3c:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
80007a40:	e1 db c0 01 	bfextu	r0,r11,0x0,0x1
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007a44:	a1 9b       	lsr	r11,0x1
80007a46:	0e 0b       	add	r11,r7

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
80007a48:	58 00       	cp.w	r0,0
80007a4a:	e0 81 00 ad 	brne	80007ba4 <screen_string_squeeze+0x210>
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007a4e:	f4 0b 07 00 	ld.ub	r0,r10[r11]
80007a52:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80007a56:	06 40       	or	r0,r3
80007a58:	f4 0b 0b 00 	st.b	r10[r11],r0
80007a5c:	2f f9       	sub	r9,-1
80007a5e:	2f f8       	sub	r8,-1
80007a60:	5c 89       	casts.h	r9
  g = &(font_data[gl - FONT_ASCII_OFFSET]);
  xnum = FONT_CHARW - g->first - g->last;
  //  print_dbg("\r\n char at row: ");
  //  print_dbg_ulong(row);
  for(j=0; j<FONT_CHARH; j++) {
    for(i=0; i<xnum; i++) {
80007a62:	f0 0c 18 00 	cp.b	r12,r8
80007a66:	e0 88 00 1e 	brls	80007aa2 <screen_string_squeeze+0x10e>
      if( (g->data[i + g->first] & (1 << j))) {
80007a6a:	ec 08 00 0b 	add	r11,r6,r8
80007a6e:	0a 0b       	add	r11,r5
80007a70:	17 ab       	ld.ub	r11,r11[0x2]
80007a72:	1c 6b       	and	r11,lr
80007a74:	ce 41       	brne	80007a3c <screen_string_squeeze+0xa8>
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007a76:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
80007a7a:	e1 db c0 01 	bfextu	r0,r11,0x0,0x1
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007a7e:	a1 9b       	lsr	r11,0x1
80007a80:	0e 0b       	add	r11,r7

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
80007a82:	58 00       	cp.w	r0,0
80007a84:	e0 81 00 98 	brne	80007bb4 <screen_string_squeeze+0x220>
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007a88:	f4 0b 07 00 	ld.ub	r0,r10[r11]
80007a8c:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80007a90:	f4 0b 0b 00 	st.b	r10[r11],r0
80007a94:	2f f9       	sub	r9,-1
80007a96:	2f f8       	sub	r8,-1
80007a98:	5c 89       	casts.h	r9
  g = &(font_data[gl - FONT_ASCII_OFFSET]);
  xnum = FONT_CHARW - g->first - g->last;
  //  print_dbg("\r\n char at row: ");
  //  print_dbg_ulong(row);
  for(j=0; j<FONT_CHARH; j++) {
    for(i=0; i<xnum; i++) {
80007a9a:	f0 0c 18 00 	cp.b	r12,r8
80007a9e:	fe 9b ff e6 	brhi	80007a6a <screen_string_squeeze+0xd6>
80007aa2:	2f f2       	sub	r2,-1
80007aa4:	2f f4       	sub	r4,-1
80007aa6:	5c 82       	casts.h	r2
  static const glyph_t * g;
  g = &(font_data[gl - FONT_ASCII_OFFSET]);
  xnum = FONT_CHARW - g->first - g->last;
  //  print_dbg("\r\n char at row: ");
  //  print_dbg_ulong(row);
  for(j=0; j<FONT_CHARH; j++) {
80007aa8:	58 84       	cp.w	r4,8
80007aaa:	cb e1       	brne	80007a26 <screen_string_squeeze+0x92>
// draw a string with proportional spacing
U8 screen_string_squeeze(U16 x, U16 l, char *str, U8 a) {
  //  static u8 y;
  y = lines[l];
  while(*str != 0) {
    x += screen_char_squeeze(x, y, *str, a);
80007aac:	40 18       	lddsp	r8,sp[0x4]
80007aae:	18 08       	add	r8,r12
80007ab0:	5c 88       	casts.h	r8
80007ab2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80007ab6:	f7 d9 c0 01 	bfextu	r11,r9,0x0,0x1
80007aba:	a1 99       	lsr	r9,0x1
80007abc:	58 0b       	cp.w	r11,0
80007abe:	e0 81 00 82 	brne	80007bc2 <screen_string_squeeze+0x22e>
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007ac2:	40 4b       	lddsp	r11,sp[0x10]
80007ac4:	a7 6b       	lsl	r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007ac6:	12 0b       	add	r11,r9
80007ac8:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007acc:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007ad0:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007ad4:	40 8b       	lddsp	r11,sp[0x20]
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007ad6:	12 0b       	add	r11,r9
80007ad8:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007adc:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007ae0:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007ae4:	40 9b       	lddsp	r11,sp[0x24]
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007ae6:	12 0b       	add	r11,r9
80007ae8:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007aec:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007af0:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007af4:	fb 1b 00 16 	ld.uh	r11,sp[22]
80007af8:	a7 6b       	lsl	r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007afa:	12 0b       	add	r11,r9
80007afc:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007b00:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007b04:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007b08:	fb 1b 00 18 	ld.uh	r11,sp[24]
80007b0c:	a7 6b       	lsl	r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007b0e:	12 0b       	add	r11,r9
80007b10:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007b14:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007b18:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007b1c:	fb 1b 00 1a 	ld.uh	r11,sp[26]
80007b20:	a7 6b       	lsl	r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007b22:	12 0b       	add	r11,r9
80007b24:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007b28:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007b2c:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007b30:	fb 1b 00 1c 	ld.uh	r11,sp[28]
80007b34:	a7 6b       	lsl	r11,0x6
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007b36:	12 0b       	add	r11,r9
80007b38:	f4 0b 07 0e 	ld.ub	lr,r10[r11]
80007b3c:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
80007b40:	f4 0b 0b 0e 	st.b	r10[r11],lr
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007b44:	fb 1b 00 1e 	ld.uh	r11,sp[30]
80007b48:	a7 6b       	lsl	r11,0x6
80007b4a:	f6 09 00 09 	add	r9,r11,r9
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007b4e:	f4 09 07 0b 	ld.ub	r11,r10[r9]
80007b52:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
80007b56:	f4 09 0b 0b 	st.b	r10[r9],r11
  y = lines[l];
  while(*str != 0) {
    x += screen_char_squeeze(x, y, *str, a);
    zero_col(x, y);
    // extra pixel... TODO: maybe variable spacing here
    x++;
80007b5a:	40 2b       	lddsp	r11,sp[0x8]
    str++;
80007b5c:	2f f8       	sub	r8,-1
  y = lines[l];
  while(*str != 0) {
    x += screen_char_squeeze(x, y, *str, a);
    zero_col(x, y);
    // extra pixel... TODO: maybe variable spacing here
    x++;
80007b5e:	2f fb       	sub	r11,-1
    str++;
80007b60:	5c 88       	casts.h	r8
  y = lines[l];
  while(*str != 0) {
    x += screen_char_squeeze(x, y, *str, a);
    zero_col(x, y);
    // extra pixel... TODO: maybe variable spacing here
    x++;
80007b62:	50 2b       	stdsp	sp[0x8],r11

// draw a string with proportional spacing
U8 screen_string_squeeze(U16 x, U16 l, char *str, U8 a) {
  //  static u8 y;
  y = lines[l];
  while(*str != 0) {
80007b64:	50 18       	stdsp	sp[0x4],r8
80007b66:	17 88       	ld.ub	r8,r11[0x0]
80007b68:	58 08       	cp.w	r8,0
80007b6a:	fe 91 ff 4b 	brne	80007a00 <screen_string_squeeze+0x6c>
80007b6e:	e0 6a 08 c0 	mov	r10,2240
80007b72:	95 06       	st.w	r10[0x0],r6
80007b74:	e0 6a 08 bf 	mov	r10,2239
80007b78:	b4 8c       	st.b	r10[0x0],r12
80007b7a:	e0 6a 08 bd 	mov	r10,2237
80007b7e:	30 88       	mov	r8,8
80007b80:	b4 88       	st.b	r10[0x0],r8
80007b82:	e0 6a 08 bc 	mov	r10,2236
    x++;
    str++;
  }
  refresh = 1;
  return x;
}
80007b86:	b4 8c       	st.b	r10[0x0],r12
    zero_col(x, y);
    // extra pixel... TODO: maybe variable spacing here
    x++;
    str++;
  }
  refresh = 1;
80007b88:	e0 6a 08 c8 	mov	r10,2248
  return x;
}
80007b8c:	95 09       	st.w	r10[0x0],r9
    zero_col(x, y);
    // extra pixel... TODO: maybe variable spacing here
    x++;
    str++;
  }
  refresh = 1;
80007b8e:	e0 69 08 be 	mov	r9,2238
  return x;
}
80007b92:	b2 88       	st.b	r9[0x0],r8
  pos = (y << COLS_LSHIFT) + (x >> 1);

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007b94:	40 1c       	lddsp	r12,sp[0x4]
80007b96:	30 19       	mov	r9,1
80007b98:	e0 68 08 a1 	mov	r8,2209
80007b9c:	5c 5c       	castu.b	r12
80007b9e:	b0 89       	st.b	r8[0x0],r9
80007ba0:	2f 6d       	sub	sp,-40
80007ba2:	d8 32       	popm	r0-r7,pc
80007ba4:	f4 0b 07 00 	ld.ub	r0,r10[r11]
80007ba8:	e0 10 ff f0 	andl	r0,0xfff0
80007bac:	02 40       	or	r0,r1
80007bae:	f4 0b 0b 00 	st.b	r10[r11],r0
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007bb2:	c5 5b       	rjmp	80007a5c <screen_string_squeeze+0xc8>
80007bb4:	f4 0b 07 00 	ld.ub	r0,r10[r11]

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007bb8:	e0 10 ff f0 	andl	r0,0xfff0
80007bbc:	f4 0b 0b 00 	st.b	r10[r11],r0
80007bc0:	c4 eb       	rjmp	80007a5c <screen_string_squeeze+0xc8>
80007bc2:	40 4e       	lddsp	lr,sp[0x10]
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007bc4:	a7 6e       	lsl	lr,0x6
80007bc6:	12 0e       	add	lr,r9

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007bc8:	f4 0e 07 0b 	ld.ub	r11,r10[lr]
80007bcc:	e0 1b ff f0 	andl	r11,0xfff0
80007bd0:	f4 0e 0b 0b 	st.b	r10[lr],r11
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007bd4:	40 8e       	lddsp	lr,sp[0x20]
80007bd6:	12 0e       	add	lr,r9

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007bd8:	f4 0e 07 0b 	ld.ub	r11,r10[lr]
80007bdc:	e0 1b ff f0 	andl	r11,0xfff0
80007be0:	f4 0e 0b 0b 	st.b	r10[lr],r11
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007be4:	40 9e       	lddsp	lr,sp[0x24]
80007be6:	12 0e       	add	lr,r9
80007be8:	f4 0e 07 0b 	ld.ub	r11,r10[lr]

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007bec:	e0 1b ff f0 	andl	r11,0xfff0
80007bf0:	f4 0e 0b 0b 	st.b	r10[lr],r11
80007bf4:	fb 1e 00 16 	ld.uh	lr,sp[22]
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007bf8:	a7 6e       	lsl	lr,0x6
80007bfa:	12 0e       	add	lr,r9
80007bfc:	f4 0e 07 0b 	ld.ub	r11,r10[lr]

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007c00:	e0 1b ff f0 	andl	r11,0xfff0
80007c04:	f4 0e 0b 0b 	st.b	r10[lr],r11
80007c08:	fb 1e 00 18 	ld.uh	lr,sp[24]
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007c0c:	a7 6e       	lsl	lr,0x6
80007c0e:	12 0e       	add	lr,r9
80007c10:	f4 0e 07 0b 	ld.ub	r11,r10[lr]

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007c14:	e0 1b ff f0 	andl	r11,0xfff0
80007c18:	f4 0e 0b 0b 	st.b	r10[lr],r11
80007c1c:	fb 1e 00 1a 	ld.uh	lr,sp[26]
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007c20:	a7 6e       	lsl	lr,0x6
80007c22:	12 0e       	add	lr,r9
80007c24:	f4 0e 07 0b 	ld.ub	r11,r10[lr]

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007c28:	e0 1b ff f0 	andl	r11,0xfff0
80007c2c:	f4 0e 0b 0b 	st.b	r10[lr],r11
80007c30:	fb 1e 00 1c 	ld.uh	lr,sp[28]
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007c34:	a7 6e       	lsl	lr,0x6
80007c36:	12 0e       	add	lr,r9
80007c38:	f4 0e 07 0b 	ld.ub	r11,r10[lr]
80007c3c:	e0 1b ff f0 	andl	r11,0xfff0

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007c40:	f4 0e 0b 0b 	st.b	r10[lr],r11
80007c44:	fb 1b 00 1e 	ld.uh	r11,sp[30]
80007c48:	a7 6b       	lsl	r11,0x6
80007c4a:	f6 09 00 09 	add	r9,r11,r9
80007c4e:	f4 09 07 0b 	ld.ub	r11,r10[r9]
80007c52:	e0 1b ff f0 	andl	r11,0xfff0
80007c56:	f4 09 0b 0b 	st.b	r10[r9],r11
80007c5a:	c8 0b       	rjmp	80007b5a <screen_string_squeeze+0x1c6>
80007c5c:	80 01       	ld.sh	r1,r0[0x0]
80007c5e:	44 e4       	lddsp	r4,sp[0x138]
80007c60:	80 01       	ld.sh	r1,r0[0x0]
80007c62:	4b 25       	lddpc	r5,80007d28 <screen_refresh+0x14>

80007c64 <screen_string>:
80007c64:	d4 01       	pushm	lr
80007c66:	5c 7b       	castu.h	r11
80007c68:	5c 7c       	castu.h	r12
80007c6a:	c9 5e       	rcall	80007994 <screen_string_squeeze>
80007c6c:	d8 02       	popm	pc
80007c6e:	d7 03       	nop

80007c70 <screen_line>:
80007c70:	eb cd 40 e0 	pushm	r5-r7,lr
80007c74:	ef db c0 10 	bfextu	r7,r11,0x0,0x10
  return x;
}

// draw a string (default) 
inline U8 screen_string(U16 x, U16 l, char *str, U8 a) {
  return screen_string_squeeze(x, l, str, a);
80007c78:	5c 7c       	castu.h	r12
80007c7a:	0e 9b       	mov	r11,r7
80007c7c:	c8 ce       	rcall	80007994 <screen_string_squeeze>
80007c7e:	4a 58       	lddpc	r8,80007d10 <screen_line+0xa0>
}

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
80007c80:	30 05       	mov	r5,0
  for(i=x; i<NCOLS; i++) {
80007c82:	f0 07 07 06 	ld.ub	r6,r8[r7]
}

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
80007c86:	ea 0c 18 00 	cp.b	r12,r5
  for(i=x; i<NCOLS; i++) {
80007c8a:	c2 45       	brlt	80007cd2 <screen_line+0x62>
80007c8c:	ec ce ff f9 	sub	lr,r6,-7
80007c90:	e0 6a 08 cc 	mov	r10,2252
80007c94:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
80007c98:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80007c9c:	a1 97       	lsr	r7,0x1
80007c9e:	58 08       	cp.w	r8,0
80007ca0:	c2 11       	brne	80007ce2 <screen_line+0x72>
80007ca2:	0c 9b       	mov	r11,r6
80007ca4:	0c 99       	mov	r9,r6
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007ca6:	f6 08 15 06 	lsl	r8,r11,0x6
80007caa:	0e 08       	add	r8,r7
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
  } else {
    screen[pos] &= 0x0f;
    screen[pos] |= (a << 4);
80007cac:	f4 08 07 0b 	ld.ub	r11,r10[r8]
80007cb0:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
80007cb4:	f4 08 0b 0b 	st.b	r10[r8],r11
// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(FONT_CHARH + y); j++) {
80007cb8:	2f f9       	sub	r9,-1
80007cba:	5c 59       	castu.b	r9
80007cbc:	12 9b       	mov	r11,r9
80007cbe:	12 3e       	cp.w	lr,r9
80007cc0:	cf 34       	brge	80007ca6 <screen_line+0x36>

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007cc2:	2f fc       	sub	r12,-1
80007cc4:	5c 5c       	castu.b	r12
80007cc6:	ea 0c 18 00 	cp.b	r12,r5
80007cca:	ce 54       	brge	80007c94 <screen_line+0x24>
    for(j=y; j<(FONT_CHARH + y); j++) {
80007ccc:	e0 69 08 c8 	mov	r9,2248
  x = screen_string(x, l, str, hl);
  screen_blank_line(x, l);
  //// test
  //  print_dbg("\r\n");
  //  print_dbg(str);
  refresh = 1;
80007cd0:	93 08       	st.w	r9[0x0],r8
80007cd2:	30 19       	mov	r9,1
  return NCOLS;
}
80007cd4:	e0 68 08 a1 	mov	r8,2209
  x = screen_string(x, l, str, hl);
  screen_blank_line(x, l);
  //// test
  //  print_dbg("\r\n");
  //  print_dbg(str);
  refresh = 1;
80007cd8:	e0 6c 00 80 	mov	r12,128
  return NCOLS;
}
80007cdc:	b0 89       	st.b	r8[0x0],r9

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007cde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  cpu_irq_enable();
}

// draw a single pixel
void screen_pixel(U16 x, U16 y, U8 a) {
  pos = (y << COLS_LSHIFT) + (x >> 1);
80007ce2:	0c 9b       	mov	r11,r6
80007ce4:	0c 99       	mov	r9,r6
80007ce6:	f6 08 15 06 	lsl	r8,r11,0x6

 // rotate: swap (and read backwards in refresh)
  if (x&1) {
    screen[pos] &= 0xf0;
    screen[pos] |= (a & 0x0f);
80007cea:	0e 08       	add	r8,r7
80007cec:	f4 08 07 0b 	ld.ub	r11,r10[r8]
80007cf0:	e0 1b ff f0 	andl	r11,0xfff0
// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
    for(j=y; j<(FONT_CHARH + y); j++) {
80007cf4:	f4 08 0b 0b 	st.b	r10[r8],r11
80007cf8:	2f f9       	sub	r9,-1
80007cfa:	5c 59       	castu.b	r9
80007cfc:	12 9b       	mov	r11,r9
80007cfe:	1c 39       	cp.w	r9,lr

// fill a line with blank space to end
void screen_blank_line(U16 x, U16 l) {
  U8 i, j;
  const u8 y = lines[l];
  for(i=x; i<NCOLS; i++) {
80007d00:	fe 9a ff f3 	brle	80007ce6 <screen_line+0x76>
80007d04:	2f fc       	sub	r12,-1
80007d06:	5c 5c       	castu.b	r12
80007d08:	ea 0c 18 00 	cp.b	r12,r5
80007d0c:	cc 44       	brge	80007c94 <screen_line+0x24>
80007d0e:	cd fb       	rjmp	80007ccc <screen_line+0x5c>
80007d10:	80 01       	ld.sh	r1,r0[0x0]
80007d12:	44 e4       	lddsp	r4,sp[0x138]

80007d14 <screen_refresh>:
80007d14:	eb cd 40 c0 	pushm	r6-r7,lr
80007d18:	d3 03       	ssrf	0x10
80007d1a:	30 0b       	mov	r11,0
80007d1c:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007d20:	fe b0 d3 f8 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007d24:	30 9c       	mov	r12,9
80007d26:	fe b0 d2 03 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007d2a:	31 5b       	mov	r11,21
80007d2c:	fe 7c 28 00 	mov	r12,-55296
80007d30:	fe b0 d4 85 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007d34:	30 0b       	mov	r11,0
80007d36:	fe 7c 28 00 	mov	r12,-55296
80007d3a:	fe b0 d4 13 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007d3e:	30 0b       	mov	r11,0
80007d40:	fe 7c 28 00 	mov	r12,-55296
80007d44:	fe b0 d3 e6 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007d48:	30 9c       	mov	r12,9
80007d4a:	fe b0 d1 f1 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007d4e:	30 0b       	mov	r11,0
80007d50:	fe 7c 28 00 	mov	r12,-55296
80007d54:	fe b0 d4 73 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007d58:	30 0b       	mov	r11,0
80007d5a:	fe 7c 28 00 	mov	r12,-55296
80007d5e:	fe b0 d4 01 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007d62:	30 0b       	mov	r11,0
80007d64:	fe 7c 28 00 	mov	r12,-55296
80007d68:	fe b0 d3 d4 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007d6c:	30 9c       	mov	r12,9
80007d6e:	fe b0 d1 df 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007d72:	33 fb       	mov	r11,63
80007d74:	fe 7c 28 00 	mov	r12,-55296
80007d78:	fe b0 d4 61 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007d7c:	30 0b       	mov	r11,0
80007d7e:	fe 7c 28 00 	mov	r12,-55296
80007d82:	fe b0 d3 ef 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007d86:	30 0b       	mov	r11,0
80007d88:	fe 7c 28 00 	mov	r12,-55296
80007d8c:	fe b0 d3 c2 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007d90:	30 9c       	mov	r12,9
80007d92:	fe b0 d1 cd 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007d96:	37 5b       	mov	r11,117
80007d98:	fe 7c 28 00 	mov	r12,-55296
80007d9c:	fe b0 d4 4f 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007da0:	30 0b       	mov	r11,0
80007da2:	fe 7c 28 00 	mov	r12,-55296
80007da6:	fe b0 d3 dd 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007daa:	30 0b       	mov	r11,0
80007dac:	fe 7c 28 00 	mov	r12,-55296
80007db0:	fe b0 d3 b0 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007db4:	30 9c       	mov	r12,9
80007db6:	fe b0 d1 bb 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007dba:	30 0b       	mov	r11,0
80007dbc:	fe 7c 28 00 	mov	r12,-55296
80007dc0:	fe b0 d4 3d 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007dc4:	30 0b       	mov	r11,0
80007dc6:	fe 7c 28 00 	mov	r12,-55296
80007dca:	fe b0 d3 cb 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007dce:	30 0b       	mov	r11,0
80007dd0:	fe 7c 28 00 	mov	r12,-55296
80007dd4:	fe b0 d3 9e 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007dd8:	30 9c       	mov	r12,9
80007dda:	fe b0 d1 a9 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007dde:	33 fb       	mov	r11,63
80007de0:	fe 7c 28 00 	mov	r12,-55296
80007de4:	fe b0 d4 2b 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007de8:	30 0b       	mov	r11,0
80007dea:	fe 7c 28 00 	mov	r12,-55296
80007dee:	fe b0 d3 b9 	rcall	80002560 <spi_unselectChip>
  write_command(0x75);
  write_command(0);
  write_command(63);

  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
80007df2:	30 9c       	mov	r12,9
80007df4:	fe b0 d1 8f 	rcall	80002112 <gpio_set_gpio_pin>
  Enable_global_interrupt();
}


// send screen buffer contents to OLED
void screen_refresh(void) {
80007df8:	e0 66 08 cc 	mov	r6,2252
  write_command(0);
  write_command(63);

  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007dfc:	30 0b       	mov	r11,0
80007dfe:	fe 7c 28 00 	mov	r12,-55296
80007e02:	fe b0 d3 87 	rcall	80002510 <spi_selectChip>
  Enable_global_interrupt();
}


// send screen buffer contents to OLED
void screen_refresh(void) {
80007e06:	ec c7 f0 01 	sub	r7,r6,-4095
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);

  pScreen=&(screen[GRAM_BYTES_1]);
  for(i=0; i<GRAM_BYTES; i++) {     
    spi_write(OLED_SPI, *pScreen);
80007e0a:	20 16       	sub	r6,1
80007e0c:	0f 8b       	ld.ub	r11,r7[0x0]
80007e0e:	fe 7c 28 00 	mov	r12,-55296
80007e12:	20 17       	sub	r7,1
80007e14:	fe b0 d4 13 	rcall	8000263a <spi_write>
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);

  pScreen=&(screen[GRAM_BYTES_1]);
  for(i=0; i<GRAM_BYTES; i++) {     
80007e18:	0c 37       	cp.w	r7,r6
    spi_write(OLED_SPI, *pScreen);
    pScreen--;
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007e1a:	cf 91       	brne	80007e0c <screen_refresh+0xf8>
80007e1c:	30 0b       	mov	r11,0
80007e1e:	fe 7c 28 00 	mov	r12,-55296
80007e22:	fe b0 d3 9f 	rcall	80002560 <spi_unselectChip>
  cpu_irq_enable();
}
80007e26:	d5 03       	csrf	0x10
80007e28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007e2c <init_oled>:
80007e2c:	eb cd 40 e0 	pushm	r5-r7,lr
80007e30:	20 2d       	sub	sp,8
80007e32:	d3 03       	ssrf	0x10
80007e34:	e0 68 fb c5 	mov	r8,64453
80007e38:	30 09       	mov	r9,0
80007e3a:	fa e9 00 00 	st.d	sp[0],r8
80007e3e:	fa e8 00 00 	ld.d	r8,sp[0]
80007e42:	58 08       	cp.w	r8,0
void init_oled(void) {
  U32 i;
  volatile u64 delay;
  //  cpu_irq_disable();
  Disable_global_interrupt();
  delay = FCPU_HZ >> 10 ; while(delay > 0) { delay--; }
80007e44:	5c 29       	cpc	r9
80007e46:	c0 f0       	breq	80007e64 <init_oled+0x38>
80007e48:	3f fa       	mov	r10,-1
80007e4a:	3f fb       	mov	r11,-1
80007e4c:	fa e8 00 00 	ld.d	r8,sp[0]
80007e50:	14 08       	add	r8,r10
80007e52:	f2 0b 00 49 	adc	r9,r9,r11
80007e56:	fa e9 00 00 	st.d	sp[0],r8
80007e5a:	fa e8 00 00 	ld.d	r8,sp[0]
80007e5e:	58 08       	cp.w	r8,0
80007e60:	5c 29       	cpc	r9
80007e62:	cf 51       	brne	80007e4c <init_oled+0x20>
  // flip the reset pin
  gpio_set_gpio_pin(OLED_RESET_PIN);
80007e64:	30 7c       	mov	r12,7
80007e66:	fe b0 d1 56 	rcall	80002112 <gpio_set_gpio_pin>
  //  delay_ms(1);
  delay = FCPU_HZ >> 10 ; while(delay > 0) { delay--; }
80007e6a:	e0 68 fb c5 	mov	r8,64453
80007e6e:	30 09       	mov	r9,0
80007e70:	fa e9 00 00 	st.d	sp[0],r8
80007e74:	fa e8 00 00 	ld.d	r8,sp[0]
80007e78:	58 08       	cp.w	r8,0
80007e7a:	5c 29       	cpc	r9
80007e7c:	c0 f0       	breq	80007e9a <init_oled+0x6e>
80007e7e:	3f fa       	mov	r10,-1
80007e80:	3f fb       	mov	r11,-1
80007e82:	fa e8 00 00 	ld.d	r8,sp[0]
80007e86:	14 08       	add	r8,r10
80007e88:	f2 0b 00 49 	adc	r9,r9,r11
80007e8c:	fa e9 00 00 	st.d	sp[0],r8
80007e90:	fa e8 00 00 	ld.d	r8,sp[0]
80007e94:	58 08       	cp.w	r8,0
80007e96:	5c 29       	cpc	r9
80007e98:	cf 51       	brne	80007e82 <init_oled+0x56>
  gpio_clr_gpio_pin(OLED_RESET_PIN);
80007e9a:	30 7c       	mov	r12,7
80007e9c:	fe b0 d1 48 	rcall	8000212c <gpio_clr_gpio_pin>
  // delay_ms(1);
  delay=FCPU_HZ >> 10; while(delay > 0) { delay--; }
80007ea0:	e0 68 fb c5 	mov	r8,64453
80007ea4:	30 09       	mov	r9,0
80007ea6:	fa e9 00 00 	st.d	sp[0],r8
80007eaa:	fa e8 00 00 	ld.d	r8,sp[0]
80007eae:	58 08       	cp.w	r8,0
80007eb0:	5c 29       	cpc	r9
80007eb2:	c0 f0       	breq	80007ed0 <init_oled+0xa4>
80007eb4:	3f fa       	mov	r10,-1
80007eb6:	3f fb       	mov	r11,-1
80007eb8:	fa e8 00 00 	ld.d	r8,sp[0]
80007ebc:	14 08       	add	r8,r10
80007ebe:	f2 0b 00 49 	adc	r9,r9,r11
80007ec2:	fa e9 00 00 	st.d	sp[0],r8
80007ec6:	fa e8 00 00 	ld.d	r8,sp[0]
80007eca:	58 08       	cp.w	r8,0
80007ecc:	5c 29       	cpc	r9
80007ece:	cf 51       	brne	80007eb8 <init_oled+0x8c>
  gpio_set_gpio_pin(OLED_RESET_PIN);
80007ed0:	30 7c       	mov	r12,7
80007ed2:	fe b0 d1 20 	rcall	80002112 <gpio_set_gpio_pin>
  //delay_ms(10);
  delay = FCPU_HZ >> 8; while(delay > 0) { delay--; }
80007ed6:	e2 78 ef 14 	mov	r8,257812
80007eda:	30 09       	mov	r9,0
80007edc:	fa e9 00 00 	st.d	sp[0],r8
80007ee0:	fa e8 00 00 	ld.d	r8,sp[0]
80007ee4:	58 08       	cp.w	r8,0
80007ee6:	5c 29       	cpc	r9
80007ee8:	c0 f0       	breq	80007f06 <init_oled+0xda>
80007eea:	3f fa       	mov	r10,-1
80007eec:	3f fb       	mov	r11,-1
80007eee:	fa e8 00 00 	ld.d	r8,sp[0]
80007ef2:	14 08       	add	r8,r10
80007ef4:	f2 0b 00 49 	adc	r9,r9,r11
80007ef8:	fa e9 00 00 	st.d	sp[0],r8
80007efc:	fa e8 00 00 	ld.d	r8,sp[0]
80007f00:	58 08       	cp.w	r8,0
80007f02:	5c 29       	cpc	r9
80007f04:	cf 51       	brne	80007eee <init_oled+0xc2>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007f06:	30 0b       	mov	r11,0
80007f08:	fe 7c 28 00 	mov	r12,-55296
80007f0c:	fe b0 d3 02 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007f10:	30 9c       	mov	r12,9
80007f12:	fe b0 d1 0d 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007f16:	e0 6b 00 ae 	mov	r11,174
80007f1a:	fe 7c 28 00 	mov	r12,-55296
80007f1e:	fe b0 d3 8e 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007f22:	30 0b       	mov	r11,0
80007f24:	fe 7c 28 00 	mov	r12,-55296
80007f28:	fe b0 d3 1c 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007f2c:	30 0b       	mov	r11,0
80007f2e:	fe 7c 28 00 	mov	r12,-55296
80007f32:	fe b0 d2 ef 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007f36:	30 9c       	mov	r12,9
80007f38:	fe b0 d0 fa 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007f3c:	e0 6b 00 b3 	mov	r11,179
80007f40:	fe 7c 28 00 	mov	r12,-55296
80007f44:	fe b0 d3 7b 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007f48:	30 0b       	mov	r11,0
80007f4a:	fe 7c 28 00 	mov	r12,-55296
80007f4e:	fe b0 d3 09 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007f52:	30 0b       	mov	r11,0
80007f54:	fe 7c 28 00 	mov	r12,-55296
80007f58:	fe b0 d2 dc 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007f5c:	30 9c       	mov	r12,9
80007f5e:	fe b0 d0 e7 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007f62:	e0 6b 00 91 	mov	r11,145
80007f66:	fe 7c 28 00 	mov	r12,-55296
80007f6a:	fe b0 d3 68 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007f6e:	30 0b       	mov	r11,0
80007f70:	fe 7c 28 00 	mov	r12,-55296
80007f74:	fe b0 d2 f6 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007f78:	30 0b       	mov	r11,0
80007f7a:	fe 7c 28 00 	mov	r12,-55296
80007f7e:	fe b0 d2 c9 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007f82:	30 9c       	mov	r12,9
80007f84:	fe b0 d0 d4 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007f88:	e0 6b 00 a8 	mov	r11,168
80007f8c:	fe 7c 28 00 	mov	r12,-55296
80007f90:	fe b0 d3 55 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007f94:	30 0b       	mov	r11,0
80007f96:	fe 7c 28 00 	mov	r12,-55296
80007f9a:	fe b0 d2 e3 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007f9e:	30 0b       	mov	r11,0
80007fa0:	fe 7c 28 00 	mov	r12,-55296
80007fa4:	fe b0 d2 b6 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007fa8:	30 9c       	mov	r12,9
80007faa:	fe b0 d0 c1 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007fae:	33 fb       	mov	r11,63
80007fb0:	fe 7c 28 00 	mov	r12,-55296
80007fb4:	fe b0 d3 43 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007fb8:	30 0b       	mov	r11,0
80007fba:	fe 7c 28 00 	mov	r12,-55296
80007fbe:	fe b0 d2 d1 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007fc2:	30 0b       	mov	r11,0
80007fc4:	fe 7c 28 00 	mov	r12,-55296
80007fc8:	fe b0 d2 a4 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007fcc:	30 9c       	mov	r12,9
80007fce:	fe b0 d0 af 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007fd2:	e0 6b 00 86 	mov	r11,134
80007fd6:	fe 7c 28 00 	mov	r12,-55296
80007fda:	fe b0 d3 30 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80007fde:	30 0b       	mov	r11,0
80007fe0:	fe 7c 28 00 	mov	r12,-55296
80007fe4:	fe b0 d2 be 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80007fe8:	30 0b       	mov	r11,0
80007fea:	fe 7c 28 00 	mov	r12,-55296
80007fee:	fe b0 d2 91 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80007ff2:	30 9c       	mov	r12,9
80007ff4:	fe b0 d0 9c 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80007ff8:	e0 6b 00 81 	mov	r11,129
80007ffc:	fe 7c 28 00 	mov	r12,-55296
80008000:	fe b0 d3 1d 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008004:	30 0b       	mov	r11,0
80008006:	fe 7c 28 00 	mov	r12,-55296
8000800a:	fe b0 d2 ab 	rcall	80002560 <spi_unselectChip>
  write_command(0x91);
  write_command(0xA8);	// multiplex
  write_command(0x3F);
  write_command(0x86);	// full current range
  write_command(0x81);	// contrast to full
  write_command(0x7F);
8000800e:	37 fc       	mov	r12,127
80008010:	fe b0 fb ae 	rcall	8000776c <write_command>
  write_command(0xB2);	// frame freq
80008014:	e0 6c 00 b2 	mov	r12,178
80008018:	fe b0 fb aa 	rcall	8000776c <write_command>
  write_command(0x51);
8000801c:	35 1c       	mov	r12,81
8000801e:	fe b0 fb a7 	rcall	8000776c <write_command>
  write_command(0xA8);	// multiplex
80008022:	e0 6c 00 a8 	mov	r12,168
80008026:	fe b0 fb a3 	rcall	8000776c <write_command>
  write_command(0x3F);
8000802a:	33 fc       	mov	r12,63
8000802c:	fe b0 fb a0 	rcall	8000776c <write_command>
  write_command(0xBC);	// precharge
80008030:	e0 6c 00 bc 	mov	r12,188
80008034:	fe b0 fb 9c 	rcall	8000776c <write_command>
  write_command(0x10);
80008038:	31 0c       	mov	r12,16
8000803a:	fe b0 fb 99 	rcall	8000776c <write_command>
  write_command(0xBE);	// voltage
8000803e:	e0 6c 00 be 	mov	r12,190
80008042:	fe b0 fb 95 	rcall	8000776c <write_command>
  write_command(0x1C);
80008046:	31 cc       	mov	r12,28
80008048:	fe b0 fb 92 	rcall	8000776c <write_command>
  write_command(0xAD);	// dcdc
8000804c:	e0 6c 00 ad 	mov	r12,173
80008050:	fe b0 fb 8e 	rcall	8000776c <write_command>
  write_command(0x02);
80008054:	30 2c       	mov	r12,2
80008056:	fe b0 fb 8b 	rcall	8000776c <write_command>
  write_command(0xA0);	// remap
8000805a:	e0 6c 00 a0 	mov	r12,160
8000805e:	fe b0 fb 87 	rcall	8000776c <write_command>
  write_command(0x50);
80008062:	35 0c       	mov	r12,80
80008064:	fe b0 fb 84 	rcall	8000776c <write_command>
  write_command(0xA1);	// start
80008068:	e0 6c 00 a1 	mov	r12,161
8000806c:	fe b0 fb 80 	rcall	8000776c <write_command>
  write_command(0x0);
80008070:	30 0c       	mov	r12,0
80008072:	fe b0 fb 7d 	rcall	8000776c <write_command>
  write_command(0xA2);	// offset
80008076:	e0 6c 00 a2 	mov	r12,162
8000807a:	fe b0 fb 79 	rcall	8000776c <write_command>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8000807e:	30 0b       	mov	r11,0
80008080:	fe 7c 28 00 	mov	r12,-55296
80008084:	fe b0 d2 46 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008088:	30 9c       	mov	r12,9
8000808a:	fe b0 d0 51 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8000808e:	34 cb       	mov	r11,76
80008090:	fe 7c 28 00 	mov	r12,-55296
80008094:	fe b0 d2 d3 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008098:	30 0b       	mov	r11,0
8000809a:	fe 7c 28 00 	mov	r12,-55296
8000809e:	fe b0 d2 61 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800080a2:	30 0b       	mov	r11,0
800080a4:	fe 7c 28 00 	mov	r12,-55296
800080a8:	fe b0 d2 34 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800080ac:	30 9c       	mov	r12,9
800080ae:	fe b0 d0 3f 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800080b2:	e0 6b 00 b1 	mov	r11,177
800080b6:	fe 7c 28 00 	mov	r12,-55296
800080ba:	fe b0 d2 c0 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800080be:	30 0b       	mov	r11,0
800080c0:	fe 7c 28 00 	mov	r12,-55296
800080c4:	fe b0 d2 4e 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800080c8:	30 0b       	mov	r11,0
800080ca:	fe 7c 28 00 	mov	r12,-55296
800080ce:	fe b0 d2 21 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800080d2:	30 9c       	mov	r12,9
800080d4:	fe b0 d0 2c 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800080d8:	35 5b       	mov	r11,85
800080da:	fe 7c 28 00 	mov	r12,-55296
800080de:	fe b0 d2 ae 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800080e2:	30 0b       	mov	r11,0
800080e4:	fe 7c 28 00 	mov	r12,-55296
800080e8:	fe b0 d2 3c 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800080ec:	30 0b       	mov	r11,0
800080ee:	fe 7c 28 00 	mov	r12,-55296
800080f2:	fe b0 d2 0f 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800080f6:	30 9c       	mov	r12,9
800080f8:	fe b0 d0 1a 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800080fc:	e0 6b 00 b4 	mov	r11,180
80008100:	fe 7c 28 00 	mov	r12,-55296
80008104:	fe b0 d2 9b 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008108:	30 0b       	mov	r11,0
8000810a:	fe 7c 28 00 	mov	r12,-55296
8000810e:	fe b0 d2 29 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008112:	30 0b       	mov	r11,0
80008114:	fe 7c 28 00 	mov	r12,-55296
80008118:	fe b0 d1 fc 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000811c:	30 9c       	mov	r12,9
8000811e:	fe b0 d0 07 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008122:	30 2b       	mov	r11,2
80008124:	fe 7c 28 00 	mov	r12,-55296
80008128:	fe b0 d2 89 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000812c:	30 0b       	mov	r11,0
8000812e:	fe 7c 28 00 	mov	r12,-55296
80008132:	fe b0 d2 17 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008136:	30 0b       	mov	r11,0
80008138:	fe 7c 28 00 	mov	r12,-55296
8000813c:	fe b0 d1 ea 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008140:	30 9c       	mov	r12,9
80008142:	fe b0 cf f5 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008146:	e0 6b 00 b0 	mov	r11,176
8000814a:	fe 7c 28 00 	mov	r12,-55296
8000814e:	fe b0 d2 76 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008152:	30 0b       	mov	r11,0
80008154:	fe 7c 28 00 	mov	r12,-55296
80008158:	fe b0 d2 04 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8000815c:	30 0b       	mov	r11,0
8000815e:	fe 7c 28 00 	mov	r12,-55296
80008162:	fe b0 d1 d7 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008166:	30 9c       	mov	r12,9
80008168:	fe b0 cf e2 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8000816c:	32 8b       	mov	r11,40
8000816e:	fe 7c 28 00 	mov	r12,-55296
80008172:	fe b0 d2 64 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008176:	30 0b       	mov	r11,0
80008178:	fe 7c 28 00 	mov	r12,-55296
8000817c:	fe b0 d1 f2 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008180:	30 0b       	mov	r11,0
80008182:	fe 7c 28 00 	mov	r12,-55296
80008186:	fe b0 d1 c5 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000818a:	30 9c       	mov	r12,9
8000818c:	fe b0 cf d0 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008190:	e0 6b 00 bf 	mov	r11,191
80008194:	fe 7c 28 00 	mov	r12,-55296
80008198:	fe b0 d2 51 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000819c:	30 0b       	mov	r11,0
8000819e:	fe 7c 28 00 	mov	r12,-55296
800081a2:	fe b0 d1 df 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800081a6:	30 0b       	mov	r11,0
800081a8:	fe 7c 28 00 	mov	r12,-55296
800081ac:	fe b0 d1 b2 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800081b0:	30 9c       	mov	r12,9
800081b2:	fe b0 cf bd 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800081b6:	30 fb       	mov	r11,15
800081b8:	fe 7c 28 00 	mov	r12,-55296
800081bc:	fe b0 d2 3f 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800081c0:	30 0b       	mov	r11,0
800081c2:	fe 7c 28 00 	mov	r12,-55296
800081c6:	fe b0 d1 cd 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800081ca:	30 0b       	mov	r11,0
800081cc:	fe 7c 28 00 	mov	r12,-55296
800081d0:	fe b0 d1 a0 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800081d4:	30 9c       	mov	r12,9
800081d6:	fe b0 cf ab 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800081da:	e0 6b 00 a4 	mov	r11,164
800081de:	fe 7c 28 00 	mov	r12,-55296
800081e2:	fe b0 d2 2c 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800081e6:	30 0b       	mov	r11,0
800081e8:	fe 7c 28 00 	mov	r12,-55296
800081ec:	fe b0 d1 ba 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800081f0:	30 0b       	mov	r11,0
800081f2:	fe 7c 28 00 	mov	r12,-55296
800081f6:	fe b0 d1 8d 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800081fa:	30 9c       	mov	r12,9
800081fc:	fe b0 cf 98 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008200:	e0 6b 00 b8 	mov	r11,184
80008204:	fe 7c 28 00 	mov	r12,-55296
80008208:	fe b0 d2 19 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000820c:	30 0b       	mov	r11,0
8000820e:	fe 7c 28 00 	mov	r12,-55296
80008212:	fe b0 d1 a7 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008216:	30 0b       	mov	r11,0
80008218:	fe 7c 28 00 	mov	r12,-55296
8000821c:	fe b0 d1 7a 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008220:	30 9c       	mov	r12,9
80008222:	fe b0 cf 85 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008226:	30 1b       	mov	r11,1
80008228:	fe 7c 28 00 	mov	r12,-55296
8000822c:	fe b0 d2 07 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008230:	30 0b       	mov	r11,0
80008232:	fe 7c 28 00 	mov	r12,-55296
80008236:	fe b0 d1 95 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8000823a:	30 0b       	mov	r11,0
8000823c:	fe 7c 28 00 	mov	r12,-55296
80008240:	fe b0 d1 68 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008244:	30 9c       	mov	r12,9
80008246:	fe b0 cf 73 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8000824a:	31 1b       	mov	r11,17
8000824c:	fe 7c 28 00 	mov	r12,-55296
80008250:	fe b0 d1 f5 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008254:	30 0b       	mov	r11,0
80008256:	fe 7c 28 00 	mov	r12,-55296
8000825a:	fe b0 d1 83 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8000825e:	30 0b       	mov	r11,0
80008260:	fe 7c 28 00 	mov	r12,-55296
80008264:	fe b0 d1 56 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008268:	30 9c       	mov	r12,9
8000826a:	fe b0 cf 61 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8000826e:	32 2b       	mov	r11,34
80008270:	fe 7c 28 00 	mov	r12,-55296
80008274:	fe b0 d1 e3 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008278:	30 0b       	mov	r11,0
8000827a:	fe 7c 28 00 	mov	r12,-55296
8000827e:	fe b0 d1 71 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008282:	30 0b       	mov	r11,0
80008284:	fe 7c 28 00 	mov	r12,-55296
80008288:	fe b0 d1 44 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000828c:	30 9c       	mov	r12,9
8000828e:	fe b0 cf 4f 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008292:	33 2b       	mov	r11,50
80008294:	fe 7c 28 00 	mov	r12,-55296
80008298:	fe b0 d1 d1 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000829c:	30 0b       	mov	r11,0
8000829e:	fe 7c 28 00 	mov	r12,-55296
800082a2:	fe b0 d1 5f 	rcall	80002560 <spi_unselectChip>
  write_command(0xB8);		// greyscale table
  write_command(0x01);
  write_command(0x11);
  write_command(0x22);
  write_command(0x32);
  write_command(0x43);
800082a6:	34 3c       	mov	r12,67
800082a8:	fe b0 fa 62 	rcall	8000776c <write_command>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800082ac:	30 0b       	mov	r11,0
800082ae:	fe 7c 28 00 	mov	r12,-55296
800082b2:	fe b0 d1 2f 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800082b6:	30 9c       	mov	r12,9
800082b8:	fe b0 cf 3a 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800082bc:	35 4b       	mov	r11,84
800082be:	fe 7c 28 00 	mov	r12,-55296
800082c2:	fe b0 d1 bc 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800082c6:	30 0b       	mov	r11,0
800082c8:	fe 7c 28 00 	mov	r12,-55296
800082cc:	fe b0 d1 4a 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800082d0:	30 0b       	mov	r11,0
800082d2:	fe 7c 28 00 	mov	r12,-55296
800082d6:	fe b0 d1 1d 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800082da:	30 9c       	mov	r12,9
800082dc:	fe b0 cf 28 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800082e0:	36 5b       	mov	r11,101
800082e2:	fe 7c 28 00 	mov	r12,-55296
800082e6:	fe b0 d1 aa 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800082ea:	30 0b       	mov	r11,0
800082ec:	fe 7c 28 00 	mov	r12,-55296
800082f0:	fe b0 d1 38 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800082f4:	30 0b       	mov	r11,0
800082f6:	fe 7c 28 00 	mov	r12,-55296
800082fa:	fe b0 d1 0b 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800082fe:	30 9c       	mov	r12,9
80008300:	fe b0 cf 16 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008304:	37 6b       	mov	r11,118
80008306:	fe 7c 28 00 	mov	r12,-55296
8000830a:	fe b0 d1 98 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000830e:	30 0b       	mov	r11,0
80008310:	fe 7c 28 00 	mov	r12,-55296
80008314:	fe b0 d1 26 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008318:	30 0b       	mov	r11,0
8000831a:	fe 7c 28 00 	mov	r12,-55296
8000831e:	fe b0 d0 f9 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008322:	30 9c       	mov	r12,9
80008324:	fe b0 cf 04 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008328:	31 5b       	mov	r11,21
8000832a:	fe 7c 28 00 	mov	r12,-55296
8000832e:	fe b0 d1 86 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008332:	30 0b       	mov	r11,0
80008334:	fe 7c 28 00 	mov	r12,-55296
80008338:	fe b0 d1 14 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8000833c:	30 0b       	mov	r11,0
8000833e:	fe 7c 28 00 	mov	r12,-55296
80008342:	fe b0 d0 e7 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80008346:	30 9c       	mov	r12,9
80008348:	fe b0 ce f2 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8000834c:	30 0b       	mov	r11,0
8000834e:	fe 7c 28 00 	mov	r12,-55296
80008352:	fe b0 d1 74 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008356:	30 0b       	mov	r11,0
80008358:	fe 7c 28 00 	mov	r12,-55296
8000835c:	fe b0 d1 02 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008360:	30 0b       	mov	r11,0
80008362:	fe 7c 28 00 	mov	r12,-55296
80008366:	fe b0 d0 d5 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000836a:	30 9c       	mov	r12,9
8000836c:	fe b0 ce e0 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008370:	33 fb       	mov	r11,63
80008372:	fe 7c 28 00 	mov	r12,-55296
80008376:	fe b0 d1 62 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000837a:	30 0b       	mov	r11,0
8000837c:	fe 7c 28 00 	mov	r12,-55296
80008380:	fe b0 d0 f0 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008384:	30 0b       	mov	r11,0
80008386:	fe 7c 28 00 	mov	r12,-55296
8000838a:	fe b0 d0 c3 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000838e:	30 9c       	mov	r12,9
80008390:	fe b0 ce ce 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008394:	37 5b       	mov	r11,117
80008396:	fe 7c 28 00 	mov	r12,-55296
8000839a:	fe b0 d1 50 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8000839e:	30 0b       	mov	r11,0
800083a0:	fe 7c 28 00 	mov	r12,-55296
800083a4:	fe b0 d0 de 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800083a8:	30 0b       	mov	r11,0
800083aa:	fe 7c 28 00 	mov	r12,-55296
800083ae:	fe b0 d0 b1 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800083b2:	30 9c       	mov	r12,9
800083b4:	fe b0 ce bc 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800083b8:	30 0b       	mov	r11,0
800083ba:	fe 7c 28 00 	mov	r12,-55296
800083be:	fe b0 d1 3e 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800083c2:	30 0b       	mov	r11,0
800083c4:	fe 7c 28 00 	mov	r12,-55296
800083c8:	fe b0 d0 cc 	rcall	80002560 <spi_unselectChip>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800083cc:	30 0b       	mov	r11,0
800083ce:	fe 7c 28 00 	mov	r12,-55296
800083d2:	fe b0 d0 9f 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800083d6:	30 9c       	mov	r12,9
800083d8:	fe b0 ce aa 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800083dc:	33 fb       	mov	r11,63
800083de:	fe 7c 28 00 	mov	r12,-55296
800083e2:	fe b0 d1 2c 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800083e6:	30 0b       	mov	r11,0
800083e8:	fe 7c 28 00 	mov	r12,-55296
  write_command(0);
  write_command(63);

  // clear OLED RAM and local screenbuffer
  for(i=0; i<GRAM_BYTES; i++) { 
    screen[i] = 0;
800083ec:	30 05       	mov	r5,0
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800083ee:	fe b0 d0 b9 	rcall	80002560 <spi_unselectChip>
800083f2:	e0 67 08 cc 	mov	r7,2252
  }
}

//------------------
// external functions
void init_oled(void) {
800083f6:	ee c6 f0 00 	sub	r6,r7,-4096

//-----------------------------
//---- static functions
static void write_data(U8 c);
static void write_data(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800083fa:	0e c5       	st.b	r7++,r5
800083fc:	30 0b       	mov	r11,0
800083fe:	fe 7c 28 00 	mov	r12,-55296
80008402:	fe b0 d0 87 	rcall	80002510 <spi_selectChip>
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
80008406:	30 9c       	mov	r12,9
80008408:	fe b0 ce 85 	rcall	80002112 <gpio_set_gpio_pin>
  spi_write(OLED_SPI, c);
8000840c:	30 0b       	mov	r11,0
8000840e:	fe 7c 28 00 	mov	r12,-55296
80008412:	fe b0 d1 14 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008416:	30 0b       	mov	r11,0
80008418:	fe 7c 28 00 	mov	r12,-55296
8000841c:	fe b0 d0 a2 	rcall	80002560 <spi_unselectChip>
  write_command(0x75);
  write_command(0);
  write_command(63);

  // clear OLED RAM and local screenbuffer
  for(i=0; i<GRAM_BYTES; i++) { 
80008420:	0c 37       	cp.w	r7,r6
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
}

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80008422:	ce c1       	brne	800083fa <init_oled+0x5ce>
80008424:	30 0b       	mov	r11,0
80008426:	fe 7c 28 00 	mov	r12,-55296
8000842a:	fe b0 d0 73 	rcall	80002510 <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8000842e:	30 9c       	mov	r12,9
80008430:	fe b0 ce 7e 	rcall	8000212c <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80008434:	e0 6b 00 af 	mov	r11,175
80008438:	fe 7c 28 00 	mov	r12,-55296
8000843c:	fe b0 d0 ff 	rcall	8000263a <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80008440:	30 0b       	mov	r11,0
80008442:	fe 7c 28 00 	mov	r12,-55296
80008446:	fe b0 d0 8d 	rcall	80002560 <spi_unselectChip>
    write_data(0);
  }
  write_command(0xAF);	// on

  //  delay_ms(10) 
  delay = FCPU_HZ >> 8; while(delay > 0) { delay--; }
8000844a:	e2 78 ef 14 	mov	r8,257812
8000844e:	30 09       	mov	r9,0
80008450:	fa e9 00 00 	st.d	sp[0],r8
80008454:	fa e8 00 00 	ld.d	r8,sp[0]
80008458:	58 08       	cp.w	r8,0
8000845a:	5c 29       	cpc	r9
8000845c:	c0 f0       	breq	8000847a <init_oled+0x64e>
8000845e:	3f fa       	mov	r10,-1
80008460:	3f fb       	mov	r11,-1
80008462:	fa e8 00 00 	ld.d	r8,sp[0]
80008466:	14 08       	add	r8,r10
80008468:	f2 0b 00 49 	adc	r9,r9,r11
8000846c:	fa e9 00 00 	st.d	sp[0],r8
80008470:	fa e8 00 00 	ld.d	r8,sp[0]
80008474:	58 08       	cp.w	r8,0
80008476:	5c 29       	cpc	r9
  //  cpu_irq_enable();
  Enable_global_interrupt();
80008478:	cf 51       	brne	80008462 <init_oled+0x636>
}
8000847a:	d5 03       	csrf	0x10
8000847c:	2f ed       	sub	sp,-8
8000847e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008482:	d7 03       	nop

80008484 <scene_init>:
/*     itoa_whole(i, sceneData[i].sceneName + 6, 4); */
/*     str_copy("no module               ", sceneData[i].moduleName, MODULE_NAME_LEN); */
/*   } */
/* #endif */

}
80008484:	5e fc       	retal	r12
80008486:	d7 03       	nop

80008488 <process_sw>:
  { kEventSwitchDown7, kEventSwitchUp7 },
};


// generate events from switch interrupts
void process_sw( const U8 swIdx )  {
80008488:	eb cd 40 c0 	pushm	r6-r7,lr
  static event_t e;   
    e.eventType = kSwitchEvents[swIdx][gpio_get_pin_value(kSwitchPins[swIdx])];
8000848c:	48 d8       	lddpc	r8,800084c0 <process_sw+0x38>
  { kEventSwitchDown7, kEventSwitchUp7 },
};


// generate events from switch interrupts
void process_sw( const U8 swIdx )  {
8000848e:	18 97       	mov	r7,r12
  static event_t e;   
    e.eventType = kSwitchEvents[swIdx][gpio_get_pin_value(kSwitchPins[swIdx])];
80008490:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80008494:	fe b0 ce 34 	rcall	800020fc <gpio_get_pin_value>
80008498:	48 b8       	lddpc	r8,800084c4 <process_sw+0x3c>
8000849a:	f8 07 00 1c 	add	r12,r12,r7<<0x1
8000849e:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
800084a2:	e0 66 18 cc 	mov	r6,6348
800084a6:	48 9c       	lddpc	r12,800084c8 <process_sw+0x40>
    print_dbg("\r\n post switch event, idx: ");
800084a8:	8d 08       	st.w	r6[0x0],r8
800084aa:	fe b0 d2 db 	rcall	80002a60 <print_dbg>
    print_dbg_ulong(swIdx);
800084ae:	0e 9c       	mov	r12,r7
800084b0:	fe b0 d2 b6 	rcall	80002a1c <print_dbg_ulong>
    post_event(&e);
800084b4:	0c 9c       	mov	r12,r6
800084b6:	fe b0 f4 5d 	rcall	80006d70 <post_event>
}
800084ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800084be:	d7 03       	nop
800084c0:	80 01       	ld.sh	r1,r0[0x0]
800084c2:	45 48       	lddsp	r8,sp[0x150]
800084c4:	80 01       	ld.sh	r1,r0[0x0]
800084c6:	44 ec       	lddsp	r12,sp[0x138]
800084c8:	80 01       	ld.sh	r1,r0[0x0]
800084ca:	45 2c       	lddsp	r12,sp[0x148]

800084cc <process_timers>:
}


// process the list of timers.
// called by client at desired tick interval.
void process_timers( void ) {
800084cc:	eb cd 40 c0 	pushm	r6-r7,lr
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
800084d0:	e0 67 18 d4 	mov	r7,6356
    if ( t == 0 ) { continue; }
800084d4:	6e 06       	ld.w	r6,r7[0x0]
800084d6:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
800084d8:	c0 80       	breq	800084e8 <process_timers+0x1c>
800084da:	6c 28       	ld.w	r8,r6[0x8]
800084dc:	58 08       	cp.w	r8,0
800084de:	e0 8a 00 05 	brle	800084e8 <process_timers+0x1c>
      // time remaining, decrement tick counter
      t->timeout--;
800084e2:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
800084e4:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
800084e6:	c5 50       	breq	80008590 <process_timers+0xc4>
    if ( t == 0 ) { continue; }
800084e8:	6e 16       	ld.w	r6,r7[0x4]
800084ea:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
800084ec:	c0 80       	breq	800084fc <process_timers+0x30>
800084ee:	6c 28       	ld.w	r8,r6[0x8]
800084f0:	58 08       	cp.w	r8,0
800084f2:	e0 8a 00 05 	brle	800084fc <process_timers+0x30>
      // time remaining, decrement tick counter
      t->timeout--;
800084f6:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
800084f8:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
800084fa:	c5 90       	breq	800085ac <process_timers+0xe0>
    if ( t == 0 ) { continue; }
800084fc:	6e 26       	ld.w	r6,r7[0x8]
800084fe:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80008500:	c0 80       	breq	80008510 <process_timers+0x44>
80008502:	6c 28       	ld.w	r8,r6[0x8]
80008504:	58 08       	cp.w	r8,0
80008506:	e0 8a 00 05 	brle	80008510 <process_timers+0x44>
      // time remaining, decrement tick counter
      t->timeout--;
8000850a:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
8000850c:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
8000850e:	c5 d0       	breq	800085c8 <process_timers+0xfc>
    if ( t == 0 ) { continue; }
80008510:	6e 36       	ld.w	r6,r7[0xc]
80008512:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80008514:	c0 80       	breq	80008524 <process_timers+0x58>
80008516:	6c 28       	ld.w	r8,r6[0x8]
80008518:	58 08       	cp.w	r8,0
8000851a:	e0 8a 00 05 	brle	80008524 <process_timers+0x58>
      // time remaining, decrement tick counter
      t->timeout--;
8000851e:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80008520:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80008522:	c6 10       	breq	800085e4 <process_timers+0x118>
    if ( t == 0 ) { continue; }
80008524:	6e 46       	ld.w	r6,r7[0x10]
80008526:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80008528:	c0 80       	breq	80008538 <process_timers+0x6c>
8000852a:	6c 28       	ld.w	r8,r6[0x8]
8000852c:	58 08       	cp.w	r8,0
8000852e:	e0 8a 00 05 	brle	80008538 <process_timers+0x6c>
      // time remaining, decrement tick counter
      t->timeout--;
80008532:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80008534:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80008536:	c6 50       	breq	80008600 <process_timers+0x134>
    if ( t == 0 ) { continue; }
80008538:	6e 56       	ld.w	r6,r7[0x14]
8000853a:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
8000853c:	c0 80       	breq	8000854c <process_timers+0x80>
8000853e:	6c 28       	ld.w	r8,r6[0x8]
80008540:	58 08       	cp.w	r8,0
80008542:	e0 8a 00 05 	brle	8000854c <process_timers+0x80>
      // time remaining, decrement tick counter
      t->timeout--;
80008546:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80008548:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
8000854a:	c6 90       	breq	8000861c <process_timers+0x150>
    if ( t == 0 ) { continue; }
8000854c:	6e 66       	ld.w	r6,r7[0x18]
8000854e:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80008550:	c0 80       	breq	80008560 <process_timers+0x94>
80008552:	6c 28       	ld.w	r8,r6[0x8]
80008554:	58 08       	cp.w	r8,0
80008556:	e0 8a 00 05 	brle	80008560 <process_timers+0x94>
      // time remaining, decrement tick counter
      t->timeout--;
8000855a:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
8000855c:	8d 28       	st.w	r6[0x8],r8
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
8000855e:	c6 d0       	breq	80008638 <process_timers+0x16c>
    if ( t == 0 ) { continue; }
80008560:	6e 76       	ld.w	r6,r7[0x1c]
80008562:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80008564:	c0 80       	breq	80008574 <process_timers+0xa8>
80008566:	6c 28       	ld.w	r8,r6[0x8]
80008568:	58 08       	cp.w	r8,0
8000856a:	e0 8a 00 05 	brle	80008574 <process_timers+0xa8>
      // time remaining, decrement tick counter
      t->timeout--;
8000856e:	20 18       	sub	r8,1

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80008570:	8d 28       	st.w	r6[0x8],r8
80008572:	c0 30       	breq	80008578 <process_timers+0xac>
80008574:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	if ( t->callback != 0 ) {
80008578:	6c 48       	ld.w	r8,r6[0x10]
8000857a:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
8000857c:	c0 30       	breq	80008582 <process_timers+0xb6>
8000857e:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80008580:	5d 18       	icall	r8
80008582:	6c 08       	ld.w	r8,r6[0x0]
80008584:	58 08       	cp.w	r8,0
	  t->timeout = t->timeoutReload;
80008586:	c6 70       	breq	80008654 <process_timers+0x188>
80008588:	6c 38       	ld.w	r8,r6[0xc]
8000858a:	8d 28       	st.w	r6[0x8],r8
8000858c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
80008590:	6c 48       	ld.w	r8,r6[0x10]
80008592:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
80008594:	c0 30       	breq	8000859a <process_timers+0xce>
80008596:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80008598:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8000859a:	6c 08       	ld.w	r8,r6[0x0]
8000859c:	58 08       	cp.w	r8,0
8000859e:	ef f8 0a 00 	st.weq	r7[0x0],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
800085a2:	ed f8 10 03 	ld.wne	r8,r6[0xc]
800085a6:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
800085aa:	c9 fb       	rjmp	800084e8 <process_timers+0x1c>
800085ac:	6c 48       	ld.w	r8,r6[0x10]
800085ae:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
800085b0:	c0 30       	breq	800085b6 <process_timers+0xea>
800085b2:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
800085b4:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
800085b6:	6c 08       	ld.w	r8,r6[0x0]
800085b8:	58 08       	cp.w	r8,0
800085ba:	ef f8 0a 01 	st.weq	r7[0x4],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
800085be:	ed f8 10 03 	ld.wne	r8,r6[0xc]
800085c2:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
800085c6:	c9 bb       	rjmp	800084fc <process_timers+0x30>
800085c8:	6c 48       	ld.w	r8,r6[0x10]
800085ca:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
800085cc:	c0 30       	breq	800085d2 <process_timers+0x106>
800085ce:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
800085d0:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
800085d2:	6c 08       	ld.w	r8,r6[0x0]
800085d4:	58 08       	cp.w	r8,0
800085d6:	ef f8 0a 02 	st.weq	r7[0x8],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
800085da:	ed f8 10 03 	ld.wne	r8,r6[0xc]
800085de:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
800085e2:	c9 7b       	rjmp	80008510 <process_timers+0x44>
800085e4:	6c 48       	ld.w	r8,r6[0x10]
800085e6:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
800085e8:	c0 30       	breq	800085ee <process_timers+0x122>
800085ea:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
800085ec:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
800085ee:	6c 08       	ld.w	r8,r6[0x0]
800085f0:	58 08       	cp.w	r8,0
800085f2:	ef f8 0a 03 	st.weq	r7[0xc],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
800085f6:	ed f8 10 03 	ld.wne	r8,r6[0xc]
800085fa:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
800085fe:	c9 3b       	rjmp	80008524 <process_timers+0x58>
80008600:	6c 48       	ld.w	r8,r6[0x10]
80008602:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
80008604:	c0 30       	breq	8000860a <process_timers+0x13e>
80008606:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80008608:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8000860a:	6c 08       	ld.w	r8,r6[0x0]
8000860c:	58 08       	cp.w	r8,0
8000860e:	ef f8 0a 04 	st.weq	r7[0x10],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
80008612:	ed f8 10 03 	ld.wne	r8,r6[0xc]
80008616:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8000861a:	c8 fb       	rjmp	80008538 <process_timers+0x6c>
8000861c:	6c 48       	ld.w	r8,r6[0x10]
8000861e:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
80008620:	c0 30       	breq	80008626 <process_timers+0x15a>
80008622:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80008624:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80008626:	6c 08       	ld.w	r8,r6[0x0]
80008628:	58 08       	cp.w	r8,0
8000862a:	ef f8 0a 05 	st.weq	r7[0x14],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8000862e:	ed f8 10 03 	ld.wne	r8,r6[0xc]
80008632:	ed f8 1a 02 	st.wne	r6[0x8],r8
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
80008636:	c8 bb       	rjmp	8000854c <process_timers+0x80>
80008638:	6c 48       	ld.w	r8,r6[0x10]
8000863a:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
8000863c:	c0 30       	breq	80008642 <process_timers+0x176>
8000863e:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80008640:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80008642:	6c 08       	ld.w	r8,r6[0x0]
80008644:	58 08       	cp.w	r8,0
80008646:	ef f8 0a 06 	st.weq	r7[0x18],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8000864a:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8000864e:	ed f8 1a 02 	st.wne	r6[0x8],r8
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80008652:	c8 7b       	rjmp	80008560 <process_timers+0x94>
80008654:	8f 78       	st.w	r7[0x1c],r8
80008656:	c8 fb       	rjmp	80008574 <process_timers+0xa8>

80008658 <set_timer>:
80008658:	eb cd 40 c0 	pushm	r6-r7,lr
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
8000865c:	58 09       	cp.w	r9,0
8000865e:	c5 80       	breq	8000870e <set_timer+0xb6>
  int k;
  swTimer_t* t;

  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80008660:	d3 33       	ssrf	0x13

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
80008662:	e0 6e 18 d4 	mov	lr,6356
    if ( t == NULL ) {
80008666:	7c 07       	ld.w	r7,lr[0x0]
80008668:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8000866a:	c0 40       	breq	80008672 <set_timer+0x1a>
8000866c:	6e 16       	ld.w	r6,r7[0x4]
8000866e:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
80008670:	c5 20       	breq	80008714 <set_timer+0xbc>
    if ( t == NULL ) {
80008672:	7c 17       	ld.w	r7,lr[0x4]
80008674:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
80008676:	c0 40       	breq	8000867e <set_timer+0x26>
80008678:	6e 16       	ld.w	r6,r7[0x4]
8000867a:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8000867c:	c5 20       	breq	80008720 <set_timer+0xc8>
    if ( t == NULL ) {
8000867e:	7c 27       	ld.w	r7,lr[0x8]
80008680:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
80008682:	c0 40       	breq	8000868a <set_timer+0x32>
80008684:	6e 16       	ld.w	r6,r7[0x4]
80008686:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
80008688:	c5 00       	breq	80008728 <set_timer+0xd0>
    if ( t == NULL ) {
8000868a:	7c 37       	ld.w	r7,lr[0xc]
8000868c:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8000868e:	c0 40       	breq	80008696 <set_timer+0x3e>
80008690:	6e 16       	ld.w	r6,r7[0x4]
80008692:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
80008694:	c4 e0       	breq	80008730 <set_timer+0xd8>
    if ( t == NULL ) {
80008696:	7c 47       	ld.w	r7,lr[0x10]
80008698:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8000869a:	c0 40       	breq	800086a2 <set_timer+0x4a>
8000869c:	6e 16       	ld.w	r6,r7[0x4]
8000869e:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
800086a0:	c4 c0       	breq	80008738 <set_timer+0xe0>
    if ( t == NULL ) {
800086a2:	7c 57       	ld.w	r7,lr[0x14]
800086a4:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
800086a6:	c0 40       	breq	800086ae <set_timer+0x56>
800086a8:	6e 16       	ld.w	r6,r7[0x4]
800086aa:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
800086ac:	c4 a0       	breq	80008740 <set_timer+0xe8>
    if ( t == NULL ) {
800086ae:	7c 67       	ld.w	r7,lr[0x18]
800086b0:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
800086b2:	c0 40       	breq	800086ba <set_timer+0x62>
800086b4:	6e 16       	ld.w	r6,r7[0x4]
800086b6:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
800086b8:	c4 80       	breq	80008748 <set_timer+0xf0>
    if ( t == NULL ) {
800086ba:	7c 77       	ld.w	r7,lr[0x1c]
800086bc:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
800086be:	c0 40       	breq	800086c6 <set_timer+0x6e>
800086c0:	6e 16       	ld.w	r6,r7[0x4]
800086c2:	0c 3b       	cp.w	r11,r6
      return t;
	//      }
    }
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
800086c4:	c4 60       	breq	80008750 <set_timer+0xf8>
   
  if ( find_timer( callback, tag ) != NULL ) {
    return false;
  }

  t->callback = callback;
800086c6:	d5 33       	csrf	0x13
  t->tag = tag;
800086c8:	99 49       	st.w	r12[0x10],r9
  t->timeout = ticks;
  t->fperiodic = fPeriodic;
800086ca:	99 1b       	st.w	r12[0x4],r11
  t->timeoutReload = ticks;
800086cc:	99 08       	st.w	r12[0x0],r8
    return false;
  }

  t->callback = callback;
  t->tag = tag;
  t->timeout = ticks;
800086ce:	99 3a       	st.w	r12[0xc],r10
// Add timer to pointer array. Finds first empty slot.
static bool add_timer( swTimer_t* newTimer) {
  int k;
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
800086d0:	99 2a       	st.w	r12[0x8],r10
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
800086d2:	d3 33       	ssrf	0x13
800086d4:	e0 68 18 d4 	mov	r8,6356
800086d8:	7c 09       	ld.w	r9,lr[0x0]
800086da:	58 09       	cp.w	r9,0
800086dc:	c3 f0       	breq	8000875a <set_timer+0x102>
800086de:	70 19       	ld.w	r9,r8[0x4]
800086e0:	58 09       	cp.w	r9,0
800086e2:	c3 b0       	breq	80008758 <set_timer+0x100>
800086e4:	70 29       	ld.w	r9,r8[0x8]
800086e6:	58 09       	cp.w	r9,0
800086e8:	c3 e0       	breq	80008764 <set_timer+0x10c>
800086ea:	70 39       	ld.w	r9,r8[0xc]
800086ec:	58 09       	cp.w	r9,0
800086ee:	c3 d0       	breq	80008768 <set_timer+0x110>
800086f0:	70 49       	ld.w	r9,r8[0x10]
800086f2:	58 09       	cp.w	r9,0
800086f4:	c3 c0       	breq	8000876c <set_timer+0x114>
800086f6:	70 59       	ld.w	r9,r8[0x14]
800086f8:	58 09       	cp.w	r9,0
800086fa:	c3 b0       	breq	80008770 <set_timer+0x118>
800086fc:	70 69       	ld.w	r9,r8[0x18]
800086fe:	58 09       	cp.w	r9,0
80008700:	c3 a0       	breq	80008774 <set_timer+0x11c>
80008702:	70 78       	ld.w	r8,r8[0x1c]
      //      Enable_interrupt_level( TIMER_INT_LEVEL );
      return true;
    }
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80008704:	58 08       	cp.w	r8,0
80008706:	c3 90       	breq	80008778 <set_timer+0x120>
80008708:	d5 33       	csrf	0x13
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
8000870a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000870e:	12 9c       	mov	r12,r9
      continue;
    }

    if ( t->tag == tag ) {
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
80008710:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008714:	6e 47       	ld.w	r7,r7[0x10]
	  // tag and callback both specified and matched
	  //	  if (fReenableInterrupts)
	  //	    Enable_interrupt_level( TIMER_INT_LEVEL );
	  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80008716:	0e 39       	cp.w	r9,r7
80008718:	ca d1       	brne	80008672 <set_timer+0x1a>
8000871a:	d5 33       	csrf	0x13
      continue;
    }

    if ( t->tag == tag ) {
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
8000871c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80008720:	6e 47       	ld.w	r7,r7[0x10]
80008722:	0e 39       	cp.w	r9,r7
80008724:	ca d1       	brne	8000867e <set_timer+0x26>
80008726:	cf ab       	rjmp	8000871a <set_timer+0xc2>
80008728:	6e 47       	ld.w	r7,r7[0x10]
8000872a:	0e 39       	cp.w	r9,r7
8000872c:	ca f1       	brne	8000868a <set_timer+0x32>
8000872e:	cf 6b       	rjmp	8000871a <set_timer+0xc2>
80008730:	6e 47       	ld.w	r7,r7[0x10]
80008732:	0e 39       	cp.w	r9,r7
80008734:	cb 11       	brne	80008696 <set_timer+0x3e>
80008736:	cf 2b       	rjmp	8000871a <set_timer+0xc2>
80008738:	6e 47       	ld.w	r7,r7[0x10]
8000873a:	0e 39       	cp.w	r9,r7
8000873c:	cb 31       	brne	800086a2 <set_timer+0x4a>
8000873e:	ce eb       	rjmp	8000871a <set_timer+0xc2>
80008740:	6e 47       	ld.w	r7,r7[0x10]
80008742:	0e 39       	cp.w	r9,r7
80008744:	cb 51       	brne	800086ae <set_timer+0x56>
80008746:	ce ab       	rjmp	8000871a <set_timer+0xc2>
80008748:	6e 47       	ld.w	r7,r7[0x10]
8000874a:	0e 39       	cp.w	r9,r7
8000874c:	cb 71       	brne	800086ba <set_timer+0x62>
8000874e:	ce 6b       	rjmp	8000871a <set_timer+0xc2>
80008750:	6e 47       	ld.w	r7,r7[0x10]
80008752:	0e 39       	cp.w	r9,r7
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
80008754:	cb 91       	brne	800086c6 <set_timer+0x6e>
      timers[k] = newTimer;
80008756:	ce 2b       	rjmp	8000871a <set_timer+0xc2>
80008758:	30 19       	mov	r9,1
      cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
8000875a:	fc 09 09 2c 	st.w	lr[r9<<0x2],r12
8000875e:	d5 33       	csrf	0x13
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
80008760:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008764:	30 29       	mov	r9,2
80008766:	cf ab       	rjmp	8000875a <set_timer+0x102>
80008768:	30 39       	mov	r9,3
8000876a:	cf 8b       	rjmp	8000875a <set_timer+0x102>
8000876c:	30 49       	mov	r9,4
8000876e:	cf 6b       	rjmp	8000875a <set_timer+0x102>
80008770:	30 59       	mov	r9,5
80008772:	cf 4b       	rjmp	8000875a <set_timer+0x102>
80008774:	30 69       	mov	r9,6
80008776:	cf 2b       	rjmp	8000875a <set_timer+0x102>
80008778:	30 79       	mov	r9,7
8000877a:	cf 0b       	rjmp	8000875a <set_timer+0x102>

8000877c <main>:
  } // if !startup
}

//int main(void) {
////main function
int main (void) {
8000877c:	eb cd 40 f8 	pushm	r3-r7,lr
// top-level peripheral init
static void init_avr32(void) {
  volatile avr32_tc_t *tc = APP_TC;
  // clocks
  // setup clocks
  sysclk_init();
80008780:	fe b0 e8 74 	rcall	80005868 <sysclk_init>
  // why need here?
  sysclk_enable_pbb_module(SYSCLK_SMC_REGS);
80008784:	30 4c       	mov	r12,4
80008786:	fe b0 e7 d9 	rcall	80005738 <sysclk_enable_pbb_module>
  flashc_set_bus_freq(FCPU_HZ);
8000878a:	e0 6c 14 80 	mov	r12,5248
8000878e:	ea 1c 03 ef 	orh	r12,0x3ef
80008792:	fe b0 cc 94 	rcall	800020ba <flashc_set_bus_freq>
  flashc_set_wait_state(1);
80008796:	30 1c       	mov	r12,1
80008798:	fe b0 cc 8a 	rcall	800020ac <flashc_set_wait_state>

  /// interrupts
  irq_initialize_vectors();
8000879c:	fe b0 cd 9c 	rcall	800022d4 <INTC_init_interrupts>

  // disable all interrupts for now
  cpu_irq_disable();
800087a0:	d3 03       	ssrf	0x10
  // serial usb
  init_ftdi_usart();
800087a2:	fe b0 f6 09 	rcall	800073b4 <init_ftdi_usart>
  // external sram
  smc_init(FHSB_HZ);
800087a6:	e0 6c 14 80 	mov	r12,5248
800087aa:	ea 1c 03 ef 	orh	r12,0x3ef
800087ae:	fe b0 cc 33 	rcall	80002014 <smc_init>
  // initialize spi1: OLED, ADC, SD/MMC
  init_spi1();
800087b2:	fe b0 f5 8f 	rcall	800072d0 <init_spi1>
  // initialize PDCA controller
  init_local_pdca();
800087b6:	fe b0 f5 5f 	rcall	80007274 <init_local_pdca>
  // initialize blackfin resources
  init_bfin_resources();
800087ba:	fe b0 f5 29 	rcall	8000720c <init_bfin_resources>
  // initialize application timer
  init_tc(tc);
800087be:	fe 7c 38 00 	mov	r12,-51200
800087c2:	fe b0 f6 0d 	rcall	800073dc <init_tc>
  // initialize other GPIO
  init_gpio();
800087c6:	fe b0 f6 27 	rcall	80007414 <init_gpio>
  // register interrupts
  register_interrupts();
800087ca:	fe b0 f6 45 	rcall	80007454 <register_interrupts>
  // initialize the OLED screen
  init_oled();
800087ce:	fe b0 fb 2f 	rcall	80007e2c <init_oled>
  // enable interrupts
  cpu_irq_enable();
800087d2:	d5 03       	csrf	0x10

  // usb host controller
  init_usb_host();
800087d4:	fe b0 f5 18 	rcall	80007204 <init_usb_host>
  
  print_dbg("\r\n avr32 init done ");
800087d8:	fe fc 02 98 	ld.w	r12,pc[664]
800087dc:	fe b0 d1 42 	rcall	80002a60 <print_dbg>

  // set up avr32 hardware and peripherals
  init_avr32();

  // wait for sd card
  screen_line(0, 0, "ALEPH", 0x3f);
800087e0:	30 0b       	mov	r11,0
800087e2:	33 f9       	mov	r9,63
800087e4:	fe fa 02 90 	ld.w	r10,pc[656]
800087e8:	16 9c       	mov	r12,r11
800087ea:	fe b0 fa 43 	rcall	80007c70 <screen_line>
  screen_line(0, 1, "waiting for SD card...", 0x3f);
800087ee:	33 f9       	mov	r9,63
800087f0:	fe fa 02 88 	ld.w	r10,pc[648]
800087f4:	30 1b       	mov	r11,1
800087f6:	30 0c       	mov	r12,0
800087f8:	fe b0 fa 3c 	rcall	80007c70 <screen_line>
  screen_refresh();
800087fc:	fe b0 fa 8c 	rcall	80007d14 <screen_refresh>
  
  print_dbg("\r\n SD check... ");
80008800:	fe fc 02 7c 	ld.w	r12,pc[636]
80008804:	fe b0 d1 2e 	rcall	80002a60 <print_dbg>
  while (!sd_mmc_spi_mem_check()) {
80008808:	fe b0 d9 40 	rcall	80003a88 <sd_mmc_spi_mem_check>
8000880c:	cf e0       	breq	80008808 <main+0x8c>
    waitForCard++;
  }
  print_dbg("\r\nfound SD card. ");
8000880e:	fe fc 02 72 	ld.w	r12,pc[626]
80008812:	fe b0 d1 27 	rcall	80002a60 <print_dbg>

  screen_blank_line(0, 0);
80008816:	30 0b       	mov	r11,0
80008818:	16 9c       	mov	r12,r11
8000881a:	fe b0 f8 6d 	rcall	800078f4 <screen_blank_line>
  screen_blank_line(0, 1);
8000881e:	30 1b       	mov	r11,1
80008820:	30 0c       	mov	r12,0
80008822:	fe b0 f8 69 	rcall	800078f4 <screen_blank_line>
  screen_line(0, 0, "SD card detected.", 0x3f);
80008826:	30 0b       	mov	r11,0
80008828:	33 f9       	mov	r9,63
8000882a:	fe fa 02 5a 	ld.w	r10,pc[602]
8000882e:	16 9c       	mov	r12,r11
80008830:	fe b0 fa 20 	rcall	80007c70 <screen_line>

  /// initialize filesystem
  init_files();
80008834:	fe b0 f4 2c 	rcall	8000708c <init_files>
}

// control / network / logic init
static void init_ctl(void) {
  // disable interrupts
    cpu_irq_disable();
80008838:	d3 03       	ssrf	0x10

  // intialize the event queue
  init_events();
8000883a:	fe b0 f2 89 	rcall	80006d4c <init_events>
  print_dbg("\r\n init_events");
8000883e:	fe fc 02 4a 	ld.w	r12,pc[586]
80008842:	fe b0 d1 0f 	rcall	80002a60 <print_dbg>

  // intialize encoders
  init_encoders();
80008846:	fe b0 f3 13 	rcall	80006e6c <init_encoders>
  print_dbg("\r\n init_encoders");
8000884a:	fe fc 02 42 	ld.w	r12,pc[578]
8000884e:	fe b0 d1 09 	rcall	80002a60 <print_dbg>

  //memory manager
  init_mem();  
80008852:	fe b0 f7 73 	rcall	80007738 <init_mem>
  print_dbg("\r\n init_mem");
80008856:	fe fc 02 3a 	ld.w	r12,pc[570]
8000885a:	fe b0 d1 03 	rcall	80002a60 <print_dbg>

  // send ADC config
  init_adc();
8000885e:	fe b0 ec 27 	rcall	800060ac <init_adc>
  print_dbg("\r\n init_adc");
80008862:	fe fc 02 32 	ld.w	r12,pc[562]
80008866:	fe b0 d0 fd 	rcall	80002a60 <print_dbg>

  // start application timers
  init_app_timers();
8000886a:	fe b0 ed 35 	rcall	800062d4 <init_app_timers>
  print_dbg("\r\n init_timers");
8000886e:	fe fc 02 2a 	ld.w	r12,pc[554]
80008872:	fe b0 d0 f7 	rcall	80002a60 <print_dbg>
  
  //// BEES:
  net_init();
80008876:	e0 a0 05 1d 	rcall	800092b0 <net_init>
  print_dbg("\r\n net_init");
8000887a:	fe fc 02 22 	ld.w	r12,pc[546]
8000887e:	fe b0 d0 f1 	rcall	80002a60 <print_dbg>

  preset_init();
80008882:	e0 a0 05 c1 	rcall	80009404 <preset_init>
  print_dbg("\r\n preset_init");
80008886:	fe fc 02 1a 	ld.w	r12,pc[538]
8000888a:	fe b0 d0 eb 	rcall	80002a60 <print_dbg>

  scene_init();
8000888e:	fe b0 fd fb 	rcall	80008484 <scene_init>
  print_dbg("\r\n scene_init");
80008892:	fe fc 02 12 	ld.w	r12,pc[530]
80008896:	fe b0 d0 e5 	rcall	80002a60 <print_dbg>

  menu_init();
8000889a:	e0 a0 03 a5 	rcall	80008fe4 <menu_init>
  print_dbg("\r\n menu_init");
8000889e:	fe fc 02 0a 	ld.w	r12,pc[522]
800088a2:	fe b0 d0 df 	rcall	80002a60 <print_dbg>

  // enable interrupts
  cpu_irq_enable();
800088a6:	d5 03       	csrf	0x10

  // setup control logic
  init_ctl();

  /// boot default dsp
  screen_line(0, 1, "loading default DSP...", 0x3f);
800088a8:	33 f9       	mov	r9,63
800088aa:	fe fa 02 02 	ld.w	r10,pc[514]
800088ae:	30 1b       	mov	r11,1
800088b0:	30 0c       	mov	r12,0
800088b2:	fe b0 f9 df 	rcall	80007c70 <screen_line>
  screen_refresh();
800088b6:	fe b0 fa 2f 	rcall	80007d14 <screen_refresh>
  files_load_dsp_name("default.ldr");
800088ba:	4f ec       	lddpc	r12,80008ab0 <main+0x334>
800088bc:	fe b0 f3 40 	rcall	80006f3c <files_load_dsp_name>
800088c0:	33 f9       	mov	r9,63

  screen_line(0, 1, "finished. press any key to continue...", 0x3f);
800088c2:	4f da       	lddpc	r10,80008ab4 <main+0x338>
800088c4:	30 1b       	mov	r11,1
800088c6:	30 0c       	mov	r12,0
800088c8:	fe b0 f9 d4 	rcall	80007c70 <screen_line>
800088cc:	fe b0 fa 24 	rcall	80007d14 <screen_refresh>
  screen_refresh();
800088d0:	4f ac       	lddpc	r12,80008ab8 <main+0x33c>
800088d2:	e0 66 18 f4 	mov	r6,6388

  print_dbg("\r\n starting event loop.\r\n");
800088d6:	fe b0 d0 c5 	rcall	80002a60 <print_dbg>
800088da:	4f 95       	lddpc	r5,80008abc <main+0x340>
800088dc:	fe b0 f4 92 	rcall	80007200 <test_flash>
800088e0:	e0 64 18 fc 	mov	r4,6396


  //////
  test_flash();
800088e4:	30 87       	mov	r7,8
800088e6:	e0 63 18 f4 	mov	r3,6388
800088ea:	06 9c       	mov	r12,r3
800088ec:	fe b0 f2 6a 	rcall	80006dc0 <get_next_event>

// app event loop
static void check_events(void) {
  static event_t e;  

  if( get_next_event(&e) ) {
800088f0:	cf b0       	breq	800088e6 <main+0x16a>
800088f2:	0f 89       	ld.ub	r9,r7[0x0]
800088f4:	30 08       	mov	r8,0
800088f6:	f0 09 18 00 	cp.b	r9,r8
800088fa:	c1 40       	breq	80008922 <main+0x1a6>
  /* print_dbg("\r\n handling event, type: "); */
  /* print_dbg_hex(e.eventType); */
  /* print_dbg("\r\n , data: "); */
  /* print_dbg_hex(e.eventData); */

    if(startup) {
800088fc:	66 09       	ld.w	r9,r3[0x0]
800088fe:	58 b9       	cp.w	r9,11
80008900:	5f 0b       	sreq	r11
80008902:	58 99       	cp.w	r9,9
80008904:	5f 0a       	sreq	r10
      if( e.eventType == kEventSwitchDown0
	  || e.eventType == kEventSwitchDown1
	  || e.eventType == kEventSwitchDown2
80008906:	f7 ea 10 0a 	or	r10,r11,r10
  /* print_dbg_hex(e.eventType); */
  /* print_dbg("\r\n , data: "); */
  /* print_dbg_hex(e.eventData); */

    if(startup) {
      if( e.eventType == kEventSwitchDown0
8000890a:	f0 0a 18 00 	cp.b	r10,r8
8000890e:	c0 71       	brne	8000891c <main+0x1a0>
80008910:	58 d9       	cp.w	r9,13
80008912:	c0 50       	breq	8000891c <main+0x1a0>
80008914:	58 f9       	cp.w	r9,15
80008916:	c0 30       	breq	8000891c <main+0x1a0>
80008918:	59 19       	cp.w	r9,17
8000891a:	ce 61       	brne	800088e6 <main+0x16a>
8000891c:	30 08       	mov	r8,0
8000891e:	ae 88       	st.b	r7[0x0],r8
80008920:	ce 3b       	rjmp	800088e6 <main+0x16a>
80008922:	66 08       	ld.w	r8,r3[0x0]
80008924:	20 48       	sub	r8,4
	  || e.eventType == kEventSwitchDown1
	  || e.eventType == kEventSwitchDown2
	  || e.eventType == kEventSwitchDown3
	  || e.eventType == kEventSwitchDown4
	  ) {  
	startup = 0;
80008926:	59 48       	cp.w	r8,20
80008928:	fe 9b ff df 	brhi	800088e6 <main+0x16a>
	/// FIXME: should go to some default UI state here
	return;
      }
    } else {
    
      switch(e.eventType) {
8000892c:	ea 08 03 2f 	ld.w	pc,r5[r8<<0x2]
80008930:	4e 4c       	lddpc	r12,80008ac0 <main+0x344>
80008932:	fe b0 d0 97 	rcall	80002a60 <print_dbg>
80008936:	cd 8b       	rjmp	800088e6 <main+0x16a>
80008938:	4e 3c       	lddpc	r12,80008ac4 <main+0x348>
	/// footswitches
      case kEventSwitchDown6:
	print_dbg("\r\n footswitch1 down");
	break;
      case kEventSwitchUp6:
	print_dbg("\r\n footswitch1 up");
8000893a:	fe b0 d0 93 	rcall	80002a60 <print_dbg>
8000893e:	cd 4b       	rjmp	800088e6 <main+0x16a>
80008940:	4e 2c       	lddpc	r12,80008ac8 <main+0x34c>
80008942:	fe b0 d0 8f 	rcall	80002a60 <print_dbg>
      case kEventSwitchUp3:
	menu_handleKey(eKeyFnUpD, e.eventData);
	break;
	/// footswitches
      case kEventSwitchDown6:
	print_dbg("\r\n footswitch1 down");
80008946:	cd 0b       	rjmp	800088e6 <main+0x16a>
80008948:	30 0b       	mov	r11,0
8000894a:	33 f9       	mov	r9,63
8000894c:	4e 0a       	lddpc	r10,80008acc <main+0x350>
	break;
      case kEventSwitchUp6:
	print_dbg("\r\n footswitch1 up");
	break;
      case kEventSwitchDown7:
	print_dbg("\r\n footswitch2 down");
8000894e:	16 9c       	mov	r12,r11
80008950:	fe b0 f9 90 	rcall	80007c70 <screen_line>
80008954:	4d fc       	lddpc	r12,80008ad0 <main+0x354>
80008956:	fe b0 d0 85 	rcall	80002a60 <print_dbg>
	break;
      case kEventSwitchUp4:
	break;
	// power switch
      case kEventSwitchDown5:
	screen_line(0, 0, "powering down!", 0x3f);
8000895a:	fe b0 f9 dd 	rcall	80007d14 <screen_refresh>
8000895e:	32 fc       	mov	r12,47
80008960:	fe b0 cb e6 	rcall	8000212c <gpio_clr_gpio_pin>
80008964:	cc 1b       	rjmp	800088e6 <main+0x16a>
	print_dbg("\r\n AVR32 received power down switch event");
80008966:	4d cc       	lddpc	r12,80008ad4 <main+0x358>
80008968:	fe b0 d0 7c 	rcall	80002a60 <print_dbg>
8000896c:	cb db       	rjmp	800088e6 <main+0x16a>
	screen_refresh();
8000896e:	09 88       	ld.ub	r8,r4[0x0]
80008970:	ec 18 00 01 	eorl	r8,0x1
	gpio_clr_gpio_pin(POWER_CTL_PIN);
80008974:	a8 88       	st.b	r4[0x0],r8
80008976:	c6 40       	breq	80008a3e <main+0x2c2>
80008978:	31 7c       	mov	r12,23
	break;
      case kEventSwitchDown7:
	print_dbg("\r\n footswitch2 down");
	break;
      case kEventSwitchUp7:
	print_dbg("\r\n footswitch2 up");
8000897a:	fe b0 cb cc 	rcall	80002112 <gpio_set_gpio_pin>
8000897e:	8c 3b       	ld.sh	r11,r6[0x6]
80008980:	30 0c       	mov	r12,0
80008982:	e0 a0 03 01 	rcall	80008f84 <menu_handleKey>
	break;
	// mode switch
      case kEventSwitchDown4:
	mode ^= 1;
80008986:	cb 0b       	rjmp	800088e6 <main+0x16a>
80008988:	8c 3b       	ld.sh	r11,r6[0x6]
8000898a:	30 8c       	mov	r12,8
	if(mode) { gpio_set_gpio_pin(LED_MODE_PIN); }
8000898c:	e0 a0 02 fc 	rcall	80008f84 <menu_handleKey>
80008990:	ca bb       	rjmp	800088e6 <main+0x16a>
80008992:	8c 3b       	ld.sh	r11,r6[0x6]
	else { gpio_clr_gpio_pin(LED_MODE_PIN); }
	menu_handleKey(eKeyMode, e.eventData);
80008994:	30 7c       	mov	r12,7
80008996:	e0 a0 02 f7 	rcall	80008f84 <menu_handleKey>
8000899a:	ca 6b       	rjmp	800088e6 <main+0x16a>
8000899c:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchDown3:
	menu_handleKey(eKeyFnDownD, e.eventData);
	break;
      case kEventSwitchUp3:
	menu_handleKey(eKeyFnUpD, e.eventData);
8000899e:	30 6c       	mov	r12,6
800089a0:	e0 a0 02 f2 	rcall	80008f84 <menu_handleKey>
800089a4:	ca 1b       	rjmp	800088e6 <main+0x16a>
800089a6:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchUp2:
	menu_handleKey(eKeyFnUpC, e.eventData);
	break;
      case kEventSwitchDown3:
	menu_handleKey(eKeyFnDownD, e.eventData);
800089a8:	30 5c       	mov	r12,5
800089aa:	e0 a0 02 ed 	rcall	80008f84 <menu_handleKey>
800089ae:	c9 cb       	rjmp	800088e6 <main+0x16a>
800089b0:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchDown2:
	menu_handleKey(eKeyFnDownC, e.eventData);
	break;
      case kEventSwitchUp2:
	menu_handleKey(eKeyFnUpC, e.eventData);
800089b2:	30 4c       	mov	r12,4
800089b4:	e0 a0 02 e8 	rcall	80008f84 <menu_handleKey>
800089b8:	c9 7b       	rjmp	800088e6 <main+0x16a>
800089ba:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchUp1:
	menu_handleKey(eKeyFnUpB, e.eventData);
	break;
      case kEventSwitchDown2:
	menu_handleKey(eKeyFnDownC, e.eventData);
800089bc:	30 3c       	mov	r12,3
800089be:	e0 a0 02 e3 	rcall	80008f84 <menu_handleKey>
800089c2:	c9 2b       	rjmp	800088e6 <main+0x16a>
800089c4:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchDown1:
	menu_handleKey(eKeyFnDownB, e.eventData);
	break;
      case kEventSwitchUp1:
	menu_handleKey(eKeyFnUpB, e.eventData);
800089c6:	30 2c       	mov	r12,2
800089c8:	e0 a0 02 de 	rcall	80008f84 <menu_handleKey>
800089cc:	c8 db       	rjmp	800088e6 <main+0x16a>
800089ce:	8c 3b       	ld.sh	r11,r6[0x6]
	break;
      case kEventSwitchUp0:
	menu_handleKey(eKeyFnUpA, e.eventData);
	break;
      case kEventSwitchDown1:
	menu_handleKey(eKeyFnDownB, e.eventData);
800089d0:	30 1c       	mov	r12,1
800089d2:	e0 a0 02 d9 	rcall	80008f84 <menu_handleKey>
800089d6:	c8 8b       	rjmp	800088e6 <main+0x16a>
800089d8:	4c 0c       	lddpc	r12,80008ad8 <main+0x35c>
	//----- function switches
      case kEventSwitchDown0: 
	menu_handleKey(eKeyFnDownA, e.eventData);
	break;
      case kEventSwitchUp0:
	menu_handleKey(eKeyFnUpA, e.eventData);
800089da:	fe b0 d0 43 	rcall	80002a60 <print_dbg>
800089de:	6c 1b       	ld.w	r11,r6[0x4]
800089e0:	58 0b       	cp.w	r11,0
800089e2:	e0 8a 00 32 	brle	80008a46 <main+0x2ca>
      case kEventRefresh:
	screen_refresh();
	break;
	//----- function switches
      case kEventSwitchDown0: 
	menu_handleKey(eKeyFnDownA, e.eventData);
800089e6:	5c 8b       	casts.h	r11
800089e8:	30 9c       	mov	r12,9
800089ea:	e0 a0 02 cd 	rcall	80008f84 <menu_handleKey>
	} else {
	  menu_handleKey(eKeyEncDownB, e.eventData);
	}
	break;
      case kEventEncoder3:
	print_dbg("\r\n encoder 3");
800089ee:	c7 cb       	rjmp	800088e6 <main+0x16a>
800089f0:	4b bc       	lddpc	r12,80008adc <main+0x360>
800089f2:	fe b0 d0 37 	rcall	80002a60 <print_dbg>
	if(e.eventData > 0) {
800089f6:	6c 1b       	ld.w	r11,r6[0x4]
800089f8:	58 0b       	cp.w	r11,0
800089fa:	e0 8a 00 30 	brle	80008a5a <main+0x2de>
	  menu_handleKey(eKeyEncUpA, e.eventData);
800089fe:	5c 8b       	casts.h	r11
80008a00:	30 bc       	mov	r12,11
80008a02:	e0 a0 02 c1 	rcall	80008f84 <menu_handleKey>
	} else {
	  menu_handleKey(eKeyEncDownC, e.eventData);
	}
	break;
      case kEventEncoder2:
	print_dbg("\r\n encoder 2");
80008a06:	c7 0b       	rjmp	800088e6 <main+0x16a>
80008a08:	4b 6c       	lddpc	r12,80008ae0 <main+0x364>
80008a0a:	fe b0 d0 2b 	rcall	80002a60 <print_dbg>
	if(e.eventData > 0) {
80008a0e:	6c 1b       	ld.w	r11,r6[0x4]
80008a10:	58 0b       	cp.w	r11,0
80008a12:	e0 8a 00 1f 	brle	80008a50 <main+0x2d4>
	  menu_handleKey(eKeyEncUpB, e.eventData);
80008a16:	5c 8b       	casts.h	r11
80008a18:	30 fc       	mov	r12,15
80008a1a:	e0 a0 02 b5 	rcall	80008f84 <menu_handleKey>
	gpio_clr_gpio_pin(POWER_CTL_PIN);
	break;
      case kEventSwitchUp5:
	break;
      case kEventEncoder0:
			print_dbg("\r\n encoder 0");
80008a1e:	c6 4b       	rjmp	800088e6 <main+0x16a>
80008a20:	4b 1c       	lddpc	r12,80008ae4 <main+0x368>
80008a22:	fe b0 d0 1f 	rcall	80002a60 <print_dbg>
      	if(e.eventData > 0) {
80008a26:	6c 1b       	ld.w	r11,r6[0x4]
80008a28:	58 0b       	cp.w	r11,0
80008a2a:	e0 8a 00 1d 	brle	80008a64 <main+0x2e8>
      	  menu_handleKey(eKeyEncUpD, e.eventData);
80008a2e:	5c 8b       	casts.h	r11
80008a30:	30 dc       	mov	r12,13
80008a32:	e0 a0 02 a9 	rcall	80008f84 <menu_handleKey>
      	} else {
      	  menu_handleKey(eKeyEncDownD, e.eventData);
      	}
      	break;
      case kEventEncoder1:
	print_dbg("\r\n encoder 1");
80008a36:	c5 8b       	rjmp	800088e6 <main+0x16a>
80008a38:	fe b0 f9 6e 	rcall	80007d14 <screen_refresh>
	if(e.eventData > 0) {
80008a3c:	c5 5b       	rjmp	800088e6 <main+0x16a>
80008a3e:	31 7c       	mov	r12,23
80008a40:	fe b0 cb 76 	rcall	8000212c <gpio_clr_gpio_pin>
	  menu_handleKey(eKeyEncUpC, e.eventData);
80008a44:	c9 db       	rjmp	8000897e <main+0x202>
80008a46:	5c 8b       	casts.h	r11
80008a48:	30 ac       	mov	r12,10
80008a4a:	e0 a0 02 9d 	rcall	80008f84 <menu_handleKey>
    } else {
    
      switch(e.eventType) {

      case kEventRefresh:
	screen_refresh();
80008a4e:	c4 cb       	rjmp	800088e6 <main+0x16a>
80008a50:	5c 8b       	casts.h	r11
80008a52:	31 0c       	mov	r12,16
	break;
	// mode switch
      case kEventSwitchDown4:
	mode ^= 1;
	if(mode) { gpio_set_gpio_pin(LED_MODE_PIN); }
	else { gpio_clr_gpio_pin(LED_MODE_PIN); }
80008a54:	e0 a0 02 98 	rcall	80008f84 <menu_handleKey>
80008a58:	c4 7b       	rjmp	800088e6 <main+0x16a>
80008a5a:	5c 8b       	casts.h	r11
      case kEventEncoder3:
	print_dbg("\r\n encoder 3");
	if(e.eventData > 0) {
	  menu_handleKey(eKeyEncUpA, e.eventData);
	} else {
	  menu_handleKey(eKeyEncDownA, e.eventData);
80008a5c:	30 cc       	mov	r12,12
80008a5e:	e0 a0 02 93 	rcall	80008f84 <menu_handleKey>
80008a62:	c4 2b       	rjmp	800088e6 <main+0x16a>
80008a64:	5c 8b       	casts.h	r11
      case kEventEncoder0:
			print_dbg("\r\n encoder 0");
      	if(e.eventData > 0) {
      	  menu_handleKey(eKeyEncUpD, e.eventData);
      	} else {
      	  menu_handleKey(eKeyEncDownD, e.eventData);
80008a66:	30 ec       	mov	r12,14
80008a68:	e0 a0 02 8e 	rcall	80008f84 <menu_handleKey>
80008a6c:	c3 db       	rjmp	800088e6 <main+0x16a>
80008a6e:	d7 03       	nop
      case kEventEncoder2:
	print_dbg("\r\n encoder 2");
	if(e.eventData > 0) {
	  menu_handleKey(eKeyEncUpB, e.eventData);
	} else {
	  menu_handleKey(eKeyEncDownB, e.eventData);
80008a70:	80 01       	ld.sh	r1,r0[0x0]
80008a72:	45 a4       	lddsp	r4,sp[0x168]
80008a74:	80 01       	ld.sh	r1,r0[0x0]
80008a76:	45 b8       	lddsp	r8,sp[0x16c]
80008a78:	80 01       	ld.sh	r1,r0[0x0]
      case kEventEncoder1:
	print_dbg("\r\n encoder 1");
	if(e.eventData > 0) {
	  menu_handleKey(eKeyEncUpC, e.eventData);
	} else {
	  menu_handleKey(eKeyEncDownC, e.eventData);
80008a7a:	45 c0       	lddsp	r0,sp[0x170]
80008a7c:	80 01       	ld.sh	r1,r0[0x0]
80008a7e:	45 d8       	lddsp	r8,sp[0x174]
80008a80:	80 01       	ld.sh	r1,r0[0x0]
80008a82:	45 e8       	lddsp	r8,sp[0x178]
80008a84:	80 01       	ld.sh	r1,r0[0x0]
80008a86:	45 fc       	lddsp	r12,sp[0x17c]
80008a88:	80 01       	ld.sh	r1,r0[0x0]
80008a8a:	46 10       	lddsp	r0,sp[0x184]
80008a8c:	80 01       	ld.sh	r1,r0[0x0]
80008a8e:	46 20       	lddsp	r0,sp[0x188]
80008a90:	80 01       	ld.sh	r1,r0[0x0]
80008a92:	46 34       	lddsp	r4,sp[0x18c]
80008a94:	80 01       	ld.sh	r1,r0[0x0]
80008a96:	46 40       	lddsp	r0,sp[0x190]
80008a98:	80 01       	ld.sh	r1,r0[0x0]
80008a9a:	46 4c       	lddsp	r12,sp[0x190]
80008a9c:	80 01       	ld.sh	r1,r0[0x0]
80008a9e:	46 5c       	lddsp	r12,sp[0x194]
80008aa0:	80 01       	ld.sh	r1,r0[0x0]
80008aa2:	46 68       	lddsp	r8,sp[0x198]
80008aa4:	80 01       	ld.sh	r1,r0[0x0]
80008aa6:	46 78       	lddsp	r8,sp[0x19c]
80008aa8:	80 01       	ld.sh	r1,r0[0x0]
80008aaa:	46 88       	lddsp	r8,sp[0x1a0]
80008aac:	80 01       	ld.sh	r1,r0[0x0]
80008aae:	46 98       	lddsp	r8,sp[0x1a4]
80008ab0:	80 01       	ld.sh	r1,r0[0x0]
80008ab2:	46 b0       	lddsp	r0,sp[0x1ac]
80008ab4:	80 01       	ld.sh	r1,r0[0x0]
80008ab6:	46 bc       	lddsp	r12,sp[0x1ac]
80008ab8:	80 01       	ld.sh	r1,r0[0x0]
80008aba:	46 e4       	lddsp	r4,sp[0x1b8]
80008abc:	80 01       	ld.sh	r1,r0[0x0]
80008abe:	45 50       	lddsp	r0,sp[0x154]
80008ac0:	80 01       	ld.sh	r1,r0[0x0]
80008ac2:	47 14       	lddsp	r4,sp[0x1c4]
80008ac4:	80 01       	ld.sh	r1,r0[0x0]
80008ac6:	47 00       	lddsp	r0,sp[0x1c0]
80008ac8:	80 01       	ld.sh	r1,r0[0x0]
80008aca:	47 28       	lddsp	r8,sp[0x1c8]
80008acc:	80 01       	ld.sh	r1,r0[0x0]
80008ace:	47 50       	lddsp	r0,sp[0x1d4]
80008ad0:	80 01       	ld.sh	r1,r0[0x0]
80008ad2:	47 60       	lddsp	r0,sp[0x1d8]
80008ad4:	80 01       	ld.sh	r1,r0[0x0]
80008ad6:	47 3c       	lddsp	r12,sp[0x1cc]
80008ad8:	80 01       	ld.sh	r1,r0[0x0]
80008ada:	47 bc       	lddsp	r12,sp[0x1ec]
80008adc:	80 01       	ld.sh	r1,r0[0x0]
80008ade:	47 ac       	lddsp	r12,sp[0x1e8]
80008ae0:	80 01       	ld.sh	r1,r0[0x0]
80008ae2:	47 8c       	lddsp	r12,sp[0x1e0]
80008ae4:	80 01       	ld.sh	r1,r0[0x0]
80008ae6:	47 9c       	lddsp	r12,sp[0x1e4]

80008ae8 <usb_mode_change>:
#include "usb.h"

// usb mode change callback
void usb_mode_change(bool b_host_mode) {
  // print_dbg("\r\n mode change (ignore) ");
}
80008ae8:	5e fc       	retal	r12

80008aea <usb_vbus_change>:
 
// usb Vbus change callback
void usb_vbus_change(bool b_vbus_present) {
  // print_dbg("\r\n usb vbus change, new status: ");
  // print_dbg_ulong(b_vbus_present);
}
80008aea:	5e fc       	retal	r12

80008aec <usb_vbus_error>:

// usb vbus error callback
void usb_vbus_error(void) {
  // print_dbg("\r\n usb vbus error: ");

}
80008aec:	5e fc       	retal	r12

80008aee <usb_connection>:
void usb_connection(uhc_device_t *dev, bool b_present) {
    // print_dbg("\r\n usb device connection: ");
    // print_dbg_hex(dev);
    // print_dbg(" , ");
    // print_dbg_ulong(b_present);
}
80008aee:	5e fc       	retal	r12

80008af0 <usb_wakeup>:

// usb wakeup callback
void usb_wakeup(void) {
    // print_dbg("\r\n usb wakeup");
}
80008af0:	5e fc       	retal	r12

80008af2 <usb_sof>:

// usb start-of-frame callback
void usb_sof(void) {
  //    // print_dbg("\r\n usb sof");
}
80008af2:	5e fc       	retal	r12

80008af4 <usb_enum>:
  // print_dbg("\r\n usb enumerated: ");
  // print_dbg_hex(dev);
  // print_dbg(" , ");
  // print_dbg_hex(status);

}
80008af4:	5e fc       	retal	r12
80008af6:	d7 03       	nop

80008af8 <hid_mouse_move>:
void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
  print_dbg_ulong(b_state);
}

void hid_mouse_move(int8_t x, int8_t y, int8_t scroll) {
80008af8:	eb cd 40 e0 	pushm	r5-r7,lr
80008afc:	16 97       	mov	r7,r11
80008afe:	14 96       	mov	r6,r10
80008b00:	18 95       	mov	r5,r12
  print_dbg("\r\n usb mouse move; x: ");
80008b02:	48 cc       	lddpc	r12,80008b30 <hid_mouse_move+0x38>
80008b04:	fe b0 cf ae 	rcall	80002a60 <print_dbg>
  print_dbg_hex(x);
80008b08:	f9 d5 b0 08 	bfexts	r12,r5,0x0,0x8
80008b0c:	fe b0 cf 52 	rcall	800029b0 <print_dbg_hex>
  print_dbg(", y: ");
80008b10:	48 9c       	lddpc	r12,80008b34 <hid_mouse_move+0x3c>
80008b12:	fe b0 cf a7 	rcall	80002a60 <print_dbg>
  print_dbg_hex(y);
80008b16:	0e 9c       	mov	r12,r7
80008b18:	5c 6c       	casts.b	r12
80008b1a:	fe b0 cf 4b 	rcall	800029b0 <print_dbg_hex>
  print_dbg(", scroll: ");
80008b1e:	48 7c       	lddpc	r12,80008b38 <hid_mouse_move+0x40>
80008b20:	fe b0 cf a0 	rcall	80002a60 <print_dbg>
  print_dbg_hex(scroll);
80008b24:	f9 d6 b0 08 	bfexts	r12,r6,0x0,0x8
80008b28:	fe b0 cf 44 	rcall	800029b0 <print_dbg_hex>
}
80008b2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008b30:	80 01       	ld.sh	r1,r0[0x0]
80008b32:	47 cc       	lddsp	r12,sp[0x1f0]
80008b34:	80 01       	ld.sh	r1,r0[0x0]
80008b36:	47 e4       	lddsp	r4,sp[0x1f8]
80008b38:	80 01       	ld.sh	r1,r0[0x0]
80008b3a:	47 ec       	lddsp	r12,sp[0x1f8]

80008b3c <hid_mouse_btn_middle>:
80008b3c:	eb cd 40 80 	pushm	r7,lr
80008b40:	18 97       	mov	r7,r12
80008b42:	48 5c       	lddpc	r12,80008b54 <hid_mouse_btn_middle+0x18>
  print_dbg("\r\n usb right mouse button: ");
  print_dbg_ulong(b_state);
}

void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
80008b44:	fe b0 cf 8e 	rcall	80002a60 <print_dbg>
  print_dbg_ulong(b_state);
80008b48:	0e 9c       	mov	r12,r7
80008b4a:	fe b0 cf 69 	rcall	80002a1c <print_dbg_ulong>
}
80008b4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b52:	d7 03       	nop
80008b54:	80 01       	ld.sh	r1,r0[0x0]
80008b56:	47 f8       	lddsp	r8,sp[0x1fc]

80008b58 <hid_mouse_btn_right>:
80008b58:	eb cd 40 80 	pushm	r7,lr
80008b5c:	18 97       	mov	r7,r12
80008b5e:	48 5c       	lddpc	r12,80008b70 <hid_mouse_btn_right+0x18>
  
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}

void hid_mouse_btn_right(bool b_state) {
  print_dbg("\r\n usb right mouse button: ");
80008b60:	fe b0 cf 80 	rcall	80002a60 <print_dbg>
  print_dbg_ulong(b_state);
80008b64:	0e 9c       	mov	r12,r7
80008b66:	fe b0 cf 5b 	rcall	80002a1c <print_dbg_ulong>
}
80008b6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b6e:	d7 03       	nop
80008b70:	80 01       	ld.sh	r1,r0[0x0]
80008b72:	48 14       	lddpc	r4,80008b74 <hid_mouse_btn_left>

80008b74 <hid_mouse_btn_left>:
80008b74:	eb cd 40 80 	pushm	r7,lr
80008b78:	18 97       	mov	r7,r12
80008b7a:	48 5c       	lddpc	r12,80008b8c <hid_mouse_btn_left+0x18>
#include "uhc.h"


// mouse event callbacks
void hid_mouse_btn_left(bool b_state) {
  print_dbg("\r\n usb left mouse button: ");
80008b7c:	fe b0 cf 72 	rcall	80002a60 <print_dbg>
  print_dbg_ulong(b_state);
80008b80:	0e 9c       	mov	r12,r7
80008b82:	fe b0 cf 4d 	rcall	80002a1c <print_dbg_ulong>
  
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}
80008b86:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b8a:	d7 03       	nop
80008b8c:	80 01       	ld.sh	r1,r0[0x0]
80008b8e:	48 30       	lddpc	r0,80008b98 <uhi_hid_mouse_uninstall+0x8>

80008b90 <uhi_hid_mouse_uninstall>:
	uhi_hid_mouse_start_trans_report(dev->address);
	UHI_HID_MOUSE_CHANGE(dev, true);
}

void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
80008b90:	d4 01       	pushm	lr
	if (uhi_hid_mouse_dev.dev != dev) {
80008b92:	e0 68 19 00 	mov	r8,6400
80008b96:	70 09       	ld.w	r9,r8[0x0]
80008b98:	18 39       	cp.w	r9,r12
80008b9a:	c0 20       	breq	80008b9e <uhi_hid_mouse_uninstall+0xe>
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
80008b9c:	d8 02       	popm	pc
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
80008b9e:	30 09       	mov	r9,0
void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
80008ba0:	70 2c       	ld.w	r12,r8[0x8]
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
80008ba2:	91 09       	st.w	r8[0x0],r9
80008ba4:	e0 a0 2d e6 	rcall	8000e770 <free>
80008ba8:	d8 02       	popm	pc
80008baa:	d7 03       	nop

80008bac <uhi_hid_mouse_enable>:
80008bac:	d4 01       	pushm	lr
80008bae:	e0 69 19 00 	mov	r9,6400
	return UHC_ENUM_UNSUPPORTED; // No interface supported
}

void uhi_hid_mouse_enable(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
80008bb2:	72 08       	ld.w	r8,r9[0x0]
80008bb4:	18 38       	cp.w	r8,r12
80008bb6:	c0 20       	breq	80008bba <uhi_hid_mouse_enable+0xe>
		return;  // No interface to enable
	}

	// Init value
	uhi_hid_mouse_dev.report_btn_prev = 0;
80008bb8:	d8 02       	popm	pc
80008bba:	30 0a       	mov	r10,0
80008bbc:	f3 6a 00 0c 	st.b	r9[12],r10
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
80008bc0:	fe ca ff e0 	sub	r10,pc,-32
80008bc4:	13 cb       	ld.ub	r11,r9[0x4]
80008bc6:	1a da       	st.w	--sp,r10
80008bc8:	30 0a       	mov	r10,0
80008bca:	1a da       	st.w	--sp,r10
80008bcc:	30 1a       	mov	r10,1
80008bce:	f1 3c 00 12 	ld.ub	r12,r8[18]
80008bd2:	13 d8       	ld.ub	r8,r9[0x5]
80008bd4:	72 29       	ld.w	r9,r9[0x8]
80008bd6:	fe b0 de 91 	rcall	800048f8 <uhd_ep_run>
80008bda:	2f ed       	sub	sp,-8
80008bdc:	d8 02       	popm	pc
80008bde:	d7 03       	nop

80008be0 <uhi_hid_mouse_report_reception>:
80008be0:	d4 21       	pushm	r4-r7,lr
80008be2:	58 0a       	cp.w	r10,0
80008be4:	5f 18       	srne	r8
80008be6:	58 39       	cp.w	r9,3
{
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80008be8:	5f 89       	srls	r9
static void uhi_hid_mouse_report_reception(
		usb_add_t add,
		usb_ep_t ep,
		uhd_trans_status_t status,
		iram_size_t nb_transfered)
{
80008bea:	18 96       	mov	r6,r12
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80008bec:	f3 e8 10 08 	or	r8,r9,r8
80008bf0:	c2 d1       	brne	80008c4a <uhi_hid_mouse_report_reception+0x6a>
		return; // HID mouse transfer aborted
	}

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
80008bf2:	e0 67 19 00 	mov	r7,6400
	if ((state_prev & 0x01) != (state_new & 0x01)) {
80008bf6:	6e 28       	ld.w	r8,r7[0x8]
80008bf8:	ef 35 00 0c 	ld.ub	r5,r7[12]
80008bfc:	11 84       	ld.ub	r4,r8[0x0]
80008bfe:	e9 e5 20 05 	eor	r5,r4,r5
80008c02:	ed b5 00 00 	bld	r5,0x0
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
80008c06:	c3 40       	breq	80008c6e <uhi_hid_mouse_report_reception+0x8e>
80008c08:	ed b5 00 01 	bld	r5,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80008c0c:	c3 70       	breq	80008c7a <uhi_hid_mouse_report_reception+0x9a>
80008c0e:	e2 15 00 04 	andl	r5,0x4,COH
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
80008c12:	c2 41       	brne	80008c5a <uhi_hid_mouse_report_reception+0x7a>
80008c14:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80008c18:	6e 29       	ld.w	r9,r7[0x8]
80008c1a:	13 9c       	ld.ub	r12,r9[0x1]
80008c1c:	58 0c       	cp.w	r12,0
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
80008c1e:	c1 b1       	brne	80008c54 <uhi_hid_mouse_report_reception+0x74>
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80008c20:	13 ab       	ld.ub	r11,r9[0x2]
80008c22:	58 0b       	cp.w	r11,0
80008c24:	c1 40       	breq	80008c4c <uhi_hid_mouse_report_reception+0x6c>
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
		UHI_HID_MOUSE_EVENT_MOUVE(
80008c26:	13 ba       	ld.ub	r10,r9[0x3]
80008c28:	5c 6a       	casts.b	r10
80008c2a:	5c 6b       	casts.b	r11
80008c2c:	5c 6c       	casts.b	r12
80008c2e:	c6 5f       	rcall	80008af8 <hid_mouse_move>
80008c30:	6e 29       	ld.w	r9,r7[0x8]
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
80008c32:	fe c8 00 52 	sub	r8,pc,82
80008c36:	0f cb       	ld.ub	r11,r7[0x4]
80008c38:	1a d8       	st.w	--sp,r8
80008c3a:	30 08       	mov	r8,0
80008c3c:	0c 9c       	mov	r12,r6
80008c3e:	1a d8       	st.w	--sp,r8
80008c40:	30 1a       	mov	r10,1
80008c42:	0f d8       	ld.ub	r8,r7[0x5]
80008c44:	fe b0 de 5a 	rcall	800048f8 <uhd_ep_run>
80008c48:	2f ed       	sub	sp,-8
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
80008c4a:	d8 22       	popm	r4-r7,pc
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80008c4c:	13 ba       	ld.ub	r10,r9[0x3]
80008c4e:	58 0a       	cp.w	r10,0
80008c50:	cf 10       	breq	80008c32 <uhi_hid_mouse_report_reception+0x52>
80008c52:	ce bb       	rjmp	80008c28 <uhi_hid_mouse_report_reception+0x48>
80008c54:	13 ba       	ld.ub	r10,r9[0x3]
80008c56:	13 ab       	ld.ub	r11,r9[0x2]
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
80008c58:	ce 8b       	rjmp	80008c28 <uhi_hid_mouse_report_reception+0x48>
80008c5a:	f9 d4 c0 41 	bfextu	r12,r4,0x2,0x1
80008c5e:	c6 ff       	rcall	80008b3c <hid_mouse_btn_middle>
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
80008c60:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80008c64:	6e 29       	ld.w	r9,r7[0x8]
80008c66:	13 9c       	ld.ub	r12,r9[0x1]
80008c68:	58 0c       	cp.w	r12,0
80008c6a:	cd b0       	breq	80008c20 <uhi_hid_mouse_report_reception+0x40>
80008c6c:	cf 4b       	rjmp	80008c54 <uhi_hid_mouse_report_reception+0x74>

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
80008c6e:	f9 d4 c0 01 	bfextu	r12,r4,0x0,0x1
80008c72:	c8 1f       	rcall	80008b74 <hid_mouse_btn_left>
80008c74:	ed b5 00 01 	bld	r5,0x1
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
80008c78:	cc b1       	brne	80008c0e <uhi_hid_mouse_report_reception+0x2e>
80008c7a:	f9 d4 c0 21 	bfextu	r12,r4,0x1,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
80008c7e:	e2 15 00 04 	andl	r5,0x4,COH
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80008c82:	c6 bf       	rcall	80008b58 <hid_mouse_btn_right>
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
80008c84:	58 05       	cp.w	r5,0
80008c86:	cc 70       	breq	80008c14 <uhi_hid_mouse_report_reception+0x34>
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80008c88:	ce 9b       	rjmp	80008c5a <uhi_hid_mouse_report_reception+0x7a>
80008c8a:	d7 03       	nop

80008c8c <uhi_hid_mouse_install>:
80008c8c:	d4 21       	pushm	r4-r7,lr
80008c8e:	e0 66 19 00 	mov	r6,6400
80008c92:	18 95       	mov	r5,r12
80008c94:	6c 09       	ld.w	r9,r6[0x0]
80008c96:	58 09       	cp.w	r9,0
80008c98:	c0 30       	breq	80008c9e <uhi_hid_mouse_install+0x12>
80008c9a:	30 5c       	mov	r12,5
80008c9c:	d8 22       	popm	r4-r7,pc
80008c9e:	78 67       	ld.w	r7,r12[0x18]
80008ca0:	0f aa       	ld.ub	r10,r7[0x2]
80008ca2:	0f b8       	ld.ub	r8,r7[0x3]
80008ca4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008ca8:	5c c8       	swap.bh	r8
80008caa:	5c 88       	casts.h	r8

	if (uhi_hid_mouse_dev.dev != NULL) {
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
80008cac:	c2 80       	breq	80008cfc <uhi_hid_mouse_install+0x70>
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
80008cae:	12 9c       	mov	r12,r9

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
80008cb0:	30 4a       	mov	r10,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
80008cb2:	30 3e       	mov	lr,3
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
80008cb4:	30 24       	mov	r4,2
80008cb6:	30 5b       	mov	r11,5
80008cb8:	c0 98       	rjmp	80008cca <uhi_hid_mouse_install+0x3e>
80008cba:	f6 09 18 00 	cp.b	r9,r11
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
80008cbe:	c1 00       	breq	80008cde <uhi_hid_mouse_install+0x52>
80008cc0:	0f 89       	ld.ub	r9,r7[0x0]
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80008cc2:	12 18       	sub	r8,r9
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
80008cc4:	12 07       	add	r7,r9
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
80008cc6:	5c 88       	casts.h	r8
		switch (ptr_iface->bDescriptorType) {
80008cc8:	c1 a0       	breq	80008cfc <uhi_hid_mouse_install+0x70>
80008cca:	0f 99       	ld.ub	r9,r7[0x1]
80008ccc:	f4 09 18 00 	cp.b	r9,r10

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
80008cd0:	cf 51       	brne	80008cba <uhi_hid_mouse_install+0x2e>
80008cd2:	0f d9       	ld.ub	r9,r7[0x5]
80008cd4:	fc 09 18 00 	cp.b	r9,lr
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
80008cd8:	c0 d0       	breq	80008cf2 <uhi_hid_mouse_install+0x66>
80008cda:	30 0c       	mov	r12,0
			}
			break;

		case USB_DT_ENDPOINT:
			//  Allocation of the endpoint
			if (!b_iface_supported) {
80008cdc:	cf 2b       	rjmp	80008cc0 <uhi_hid_mouse_install+0x34>
80008cde:	58 0c       	cp.w	r12,0
				break;
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
80008ce0:	cf 00       	breq	80008cc0 <uhi_hid_mouse_install+0x34>
80008ce2:	0e 9b       	mov	r11,r7
80008ce4:	eb 3c 00 12 	ld.ub	r12,r5[18]
80008ce8:	fe b0 d8 9a 	rcall	80003e1c <uhd_ep_alloc>
80008cec:	c0 91       	brne	80008cfe <uhi_hid_mouse_install+0x72>
80008cee:	30 4c       	mov	r12,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
80008cf0:	d8 22       	popm	r4-r7,pc
80008cf2:	0f f9       	ld.ub	r9,r7[0x7]
80008cf4:	e8 09 18 00 	cp.b	r9,r4
80008cf8:	5f 0c       	sreq	r12
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80008cfa:	ce 3b       	rjmp	80008cc0 <uhi_hid_mouse_install+0x34>
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
				return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
			}
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
80008cfc:	da 2a       	popm	r4-r7,pc,r12=1
80008cfe:	0f a8       	ld.ub	r8,r7[0x2]
			uhi_hid_mouse_dev.report_size =
80008d00:	ac c8       	st.b	r6[0x4],r8
80008d02:	0f cc       	ld.ub	r12,r7[0x4]
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
80008d04:	ac dc       	st.b	r6[0x5],r12
80008d06:	e0 a0 2d 3d 	rcall	8000e780 <malloc>
			if (uhi_hid_mouse_dev.report == NULL) {
80008d0a:	8d 2c       	st.w	r6[0x8],r12
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
80008d0c:	c0 60       	breq	80008d18 <uhi_hid_mouse_install+0x8c>
80008d0e:	e0 68 19 00 	mov	r8,6400
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
80008d12:	30 0c       	mov	r12,0
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
			uhi_hid_mouse_dev.report_size =
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
			if (uhi_hid_mouse_dev.report == NULL) {
80008d14:	91 05       	st.w	r8[0x0],r5
80008d16:	d8 22       	popm	r4-r7,pc
80008d18:	30 6c       	mov	r12,6
80008d1a:	d8 22       	popm	r4-r7,pc

80008d1c <uhi_hid_gamepad_uninstall>:
  //uhi_hid_gamepad_dev.report_btn_prev = 0;
  uhi_hid_gamepad_start_trans_report(dev->address);
  UHI_HID_GAMEPAD_CHANGE(dev, true);
}

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
80008d1c:	d4 01       	pushm	lr
  if (uhi_hid_gamepad_dev.dev != dev) {
80008d1e:	e0 68 19 10 	mov	r8,6416
80008d22:	70 09       	ld.w	r9,r8[0x0]
80008d24:	18 39       	cp.w	r9,r12
80008d26:	c0 20       	breq	80008d2a <uhi_hid_gamepad_uninstall+0xe>
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
80008d28:	d8 02       	popm	pc
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
80008d2a:	30 09       	mov	r9,0

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
80008d2c:	70 2c       	ld.w	r12,r8[0x8]
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
80008d2e:	91 09       	st.w	r8[0x0],r9
80008d30:	e0 a0 2d 20 	rcall	8000e770 <free>
80008d34:	d8 02       	popm	pc
80008d36:	d7 03       	nop

80008d38 <uhi_hid_gamepad_enable>:
80008d38:	d4 01       	pushm	lr
80008d3a:	e0 69 19 10 	mov	r9,6416
  //////////
  ////////////


void uhi_hid_gamepad_enable(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
80008d3e:	72 08       	ld.w	r8,r9[0x0]
80008d40:	18 38       	cp.w	r8,r12
80008d42:	c0 20       	breq	80008d46 <uhi_hid_gamepad_enable+0xe>
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
80008d44:	d8 02       	popm	pc
80008d46:	fe ca ff e2 	sub	r10,pc,-30
80008d4a:	13 cb       	ld.ub	r11,r9[0x4]
80008d4c:	1a da       	st.w	--sp,r10
80008d4e:	30 0a       	mov	r10,0
80008d50:	1a da       	st.w	--sp,r10
80008d52:	30 1a       	mov	r10,1
80008d54:	f1 3c 00 12 	ld.ub	r12,r8[18]
80008d58:	13 d8       	ld.ub	r8,r9[0x5]
80008d5a:	72 29       	ld.w	r9,r9[0x8]
80008d5c:	fe b0 dd ce 	rcall	800048f8 <uhd_ep_run>
80008d60:	2f ed       	sub	sp,-8
80008d62:	d8 02       	popm	pc

80008d64 <uhi_hid_gamepad_report_reception>:
80008d64:	eb cd 40 e0 	pushm	r5-r7,lr
80008d68:	58 0a       	cp.w	r10,0
80008d6a:	5f 18       	srne	r8

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80008d6c:	58 39       	cp.w	r9,3
80008d6e:	5f 89       	srls	r9
static void uhi_hid_gamepad_report_reception(
					   usb_add_t add,
					   usb_ep_t ep,
					   uhd_trans_status_t status,
					   iram_size_t nb_transfered)
{
80008d70:	18 96       	mov	r6,r12

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80008d72:	f3 e8 10 08 	or	r8,r9,r8
80008d76:	c0 30       	breq	80008d7c <uhi_hid_gamepad_report_reception+0x18>
80008d78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
80008d7c:	49 2c       	lddpc	r12,80008dc4 <uhi_hid_gamepad_report_reception+0x60>
80008d7e:	fe b0 ce 71 	rcall	80002a60 <print_dbg>
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
80008d82:	e0 67 19 10 	mov	r7,6416
80008d86:	0f d8       	ld.ub	r8,r7[0x5]
80008d88:	58 08       	cp.w	r8,0
80008d8a:	c0 f0       	breq	80008da8 <uhi_hid_gamepad_report_reception+0x44>
    print_dbg(" ");
80008d8c:	30 05       	mov	r5,0
80008d8e:	48 fc       	lddpc	r12,80008dc8 <uhi_hid_gamepad_report_reception+0x64>
80008d90:	fe b0 ce 68 	rcall	80002a60 <print_dbg>
    print_dbg_hex((unsigned long int) uhi_hid_gamepad_dev.report[i]);
80008d94:	6e 28       	ld.w	r8,r7[0x8]
80008d96:	f0 05 07 0c 	ld.ub	r12,r8[r5]
80008d9a:	fe b0 ce 0b 	rcall	800029b0 <print_dbg_hex>
  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
80008d9e:	2f f5       	sub	r5,-1
80008da0:	0f d8       	ld.ub	r8,r7[0x5]
80008da2:	0a 38       	cp.w	r8,r5
80008da4:	fe 99 ff f5 	brgt	80008d8e <uhi_hid_gamepad_report_reception+0x2a>
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
80008da8:	fe c9 00 44 	sub	r9,pc,68
80008dac:	0f cb       	ld.ub	r11,r7[0x4]
80008dae:	1a d9       	st.w	--sp,r9
80008db0:	30 09       	mov	r9,0
80008db2:	0c 9c       	mov	r12,r6
80008db4:	1a d9       	st.w	--sp,r9
80008db6:	30 1a       	mov	r10,1
80008db8:	6e 29       	ld.w	r9,r7[0x8]
80008dba:	fe b0 dd 9f 	rcall	800048f8 <uhd_ep_run>
80008dbe:	2f ed       	sub	sp,-8
80008dc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008dc4:	80 01       	ld.sh	r1,r0[0x0]
80008dc6:	48 4c       	lddpc	r12,80008dd4 <uhi_hid_gamepad_install+0x8>
80008dc8:	80 01       	ld.sh	r1,r0[0x0]
80008dca:	41 74       	lddsp	r4,sp[0x5c]

80008dcc <uhi_hid_gamepad_install>:
80008dcc:	d4 21       	pushm	r4-r7,lr
80008dce:	e0 66 19 10 	mov	r6,6416
80008dd2:	18 95       	mov	r5,r12
80008dd4:	6c 08       	ld.w	r8,r6[0x0]
80008dd6:	58 08       	cp.w	r8,0
80008dd8:	c0 30       	breq	80008dde <uhi_hid_gamepad_install+0x12>
80008dda:	30 5c       	mov	r12,5
  usb_iface_desc_t *ptr_iface;

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
80008ddc:	d8 22       	popm	r4-r7,pc
80008dde:	78 67       	ld.w	r7,r12[0x18]
80008de0:	0f a4       	ld.ub	r4,r7[0x2]
80008de2:	0f b9       	ld.ub	r9,r7[0x3]
80008de4:	f3 e4 10 84 	or	r4,r9,r4<<0x8
80008de8:	5c c4       	swap.bh	r4
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
80008dea:	5c 84       	casts.h	r4

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
80008dec:	c6 60       	breq	80008eb8 <uhi_hid_gamepad_install+0xec>
80008dee:	10 9a       	mov	r10,r8
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
80008df0:	c0 a8       	rjmp	80008e04 <uhi_hid_gamepad_install+0x38>
80008df2:	30 59       	mov	r9,5
80008df4:	f2 08 18 00 	cp.b	r8,r9
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
80008df8:	c5 60       	breq	80008ea4 <uhi_hid_gamepad_install+0xd8>
80008dfa:	0f 88       	ld.ub	r8,r7[0x0]
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80008dfc:	10 14       	sub	r4,r8
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
80008dfe:	10 07       	add	r7,r8
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
80008e00:	5c 84       	casts.h	r4
    switch (ptr_iface->bDescriptorType) {
80008e02:	c5 b0       	breq	80008eb8 <uhi_hid_gamepad_install+0xec>
80008e04:	0f 98       	ld.ub	r8,r7[0x1]
80008e06:	30 49       	mov	r9,4
80008e08:	f2 08 18 00 	cp.b	r8,r9
    case USB_DT_INTERFACE:

      /////////////////
      ///////////////  
      //#if 1
      print_dbg("\r\n\r\n");
80008e0c:	cf 31       	brne	80008df2 <uhi_hid_gamepad_install+0x26>
80008e0e:	4b 3c       	lddpc	r12,80008ed8 <uhi_hid_gamepad_install+0x10c>
80008e10:	fe b0 ce 28 	rcall	80002a60 <print_dbg>
      print_dbg("\r\n iface_desc -> bLength : ");
80008e14:	4b 2c       	lddpc	r12,80008edc <uhi_hid_gamepad_install+0x110>
80008e16:	fe b0 ce 25 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bLength);
80008e1a:	0f 8c       	ld.ub	r12,r7[0x0]
80008e1c:	fe b0 cd ca 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bDescriptorType : ");
80008e20:	4b 0c       	lddpc	r12,80008ee0 <uhi_hid_gamepad_install+0x114>
80008e22:	fe b0 ce 1f 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bDescriptorType);
80008e26:	0f 9c       	ld.ub	r12,r7[0x1]
80008e28:	fe b0 cd c4 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceNumber : ");
80008e2c:	4a ec       	lddpc	r12,80008ee4 <uhi_hid_gamepad_install+0x118>
80008e2e:	fe b0 ce 19 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceNumber);
80008e32:	0f ac       	ld.ub	r12,r7[0x2]
80008e34:	fe b0 cd be 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bAlternateSetting : ");
80008e38:	4a cc       	lddpc	r12,80008ee8 <uhi_hid_gamepad_install+0x11c>
80008e3a:	fe b0 ce 13 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bAlternateSetting);
80008e3e:	0f bc       	ld.ub	r12,r7[0x3]
80008e40:	fe b0 cd b8 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bNumEndpoints : ");
80008e44:	4a ac       	lddpc	r12,80008eec <uhi_hid_gamepad_install+0x120>
80008e46:	fe b0 ce 0d 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bNumEndpoints);
80008e4a:	0f cc       	ld.ub	r12,r7[0x4]
80008e4c:	fe b0 cd b2 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceClass : ");
80008e50:	4a 8c       	lddpc	r12,80008ef0 <uhi_hid_gamepad_install+0x124>
80008e52:	fe b0 ce 07 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceClass);
80008e56:	0f dc       	ld.ub	r12,r7[0x5]
80008e58:	fe b0 cd ac 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceSubClass : ");
80008e5c:	4a 6c       	lddpc	r12,80008ef4 <uhi_hid_gamepad_install+0x128>
80008e5e:	fe b0 ce 01 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceSubClass);
80008e62:	0f ec       	ld.ub	r12,r7[0x6]
80008e64:	fe b0 cd a6 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceProtocol : ");
80008e68:	4a 4c       	lddpc	r12,80008ef8 <uhi_hid_gamepad_install+0x12c>
80008e6a:	fe b0 cd fb 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceProtocol);
80008e6e:	0f fc       	ld.ub	r12,r7[0x7]
80008e70:	fe b0 cd a0 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n iface_desc -> iInterface : ");
80008e74:	4a 2c       	lddpc	r12,80008efc <uhi_hid_gamepad_install+0x130>
80008e76:	fe b0 cd f5 	rcall	80002a60 <print_dbg>
      print_dbg_hex(ptr_iface->iInterface);
80008e7a:	ef 3c 00 08 	ld.ub	r12,r7[8]
80008e7e:	fe b0 cd 99 	rcall	800029b0 <print_dbg_hex>
      print_dbg("\r\n\r\n");
80008e82:	49 6c       	lddpc	r12,80008ed8 <uhi_hid_gamepad_install+0x10c>
80008e84:	fe b0 cd ee 	rcall	80002a60 <print_dbg>
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
80008e88:	0f d9       	ld.ub	r9,r7[0x5]
80008e8a:	30 38       	mov	r8,3
80008e8c:	f0 09 18 00 	cp.b	r9,r8
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
80008e90:	c0 30       	breq	80008e96 <uhi_hid_gamepad_install+0xca>
80008e92:	30 0a       	mov	r10,0
      print_dbg_hex(ptr_iface->iInterface);
      print_dbg("\r\n\r\n");
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
	  && (ptr_iface->bInterfaceProtocol == HID_PROTOCOL_GENERIC) ) {
80008e94:	cb 3b       	rjmp	80008dfa <uhi_hid_gamepad_install+0x2e>
80008e96:	0f f9       	ld.ub	r9,r7[0x7]
80008e98:	30 08       	mov	r8,0
80008e9a:	f0 09 18 00 	cp.b	r9,r8
80008e9e:	cf a1       	brne	80008e92 <uhi_hid_gamepad_install+0xc6>
80008ea0:	30 1a       	mov	r10,1
      }
      break;

    case USB_DT_ENDPOINT:
      //  Allocation of the endpoint
      if (!b_iface_supported) {
80008ea2:	ca cb       	rjmp	80008dfa <uhi_hid_gamepad_install+0x2e>
80008ea4:	58 0a       	cp.w	r10,0
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
80008ea6:	ca a0       	breq	80008dfa <uhi_hid_gamepad_install+0x2e>
80008ea8:	0e 9b       	mov	r11,r7
80008eaa:	eb 3c 00 12 	ld.ub	r12,r5[18]
80008eae:	fe b0 d7 b7 	rcall	80003e1c <uhd_ep_alloc>
80008eb2:	c0 41       	brne	80008eba <uhi_hid_gamepad_install+0xee>
80008eb4:	30 4c       	mov	r12,4
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80008eb6:	d8 22       	popm	r4-r7,pc
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
      }
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
80008eb8:	da 2a       	popm	r4-r7,pc,r12=1
80008eba:	0f a8       	ld.ub	r8,r7[0x2]
      uhi_hid_gamepad_dev.report_size =
80008ebc:	ac c8       	st.b	r6[0x4],r8
80008ebe:	0f cc       	ld.ub	r12,r7[0x4]
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
80008ec0:	ac dc       	st.b	r6[0x5],r12
80008ec2:	e0 a0 2c 5f 	rcall	8000e780 <malloc>
      if (uhi_hid_gamepad_dev.report == NULL) {
80008ec6:	8d 2c       	st.w	r6[0x8],r12
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
80008ec8:	c0 60       	breq	80008ed4 <uhi_hid_gamepad_install+0x108>
80008eca:	e0 68 19 10 	mov	r8,6416
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
80008ece:	30 0c       	mov	r12,0
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
      uhi_hid_gamepad_dev.report_size =
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
      if (uhi_hid_gamepad_dev.report == NULL) {
80008ed0:	91 05       	st.w	r8[0x0],r5
80008ed2:	d8 22       	popm	r4-r7,pc
80008ed4:	30 6c       	mov	r12,6
80008ed6:	d8 22       	popm	r4-r7,pc
80008ed8:	80 01       	ld.sh	r1,r0[0x0]
80008eda:	3e 4c       	mov	r12,-28
80008edc:	80 01       	ld.sh	r1,r0[0x0]
80008ede:	48 60       	lddpc	r0,80008ef4 <uhi_hid_gamepad_install+0x128>
80008ee0:	80 01       	ld.sh	r1,r0[0x0]
80008ee2:	48 7c       	lddpc	r12,80008efc <uhi_hid_gamepad_install+0x130>
80008ee4:	80 01       	ld.sh	r1,r0[0x0]
80008ee6:	48 a0       	lddpc	r0,80008f0c <key_handler_dsp+0xc>
80008ee8:	80 01       	ld.sh	r1,r0[0x0]
80008eea:	48 c8       	lddpc	r8,80008f18 <key_handler_dsp+0x18>
80008eec:	80 01       	ld.sh	r1,r0[0x0]
80008eee:	48 f0       	lddpc	r0,80008f28 <key_handler_dsp+0x28>
80008ef0:	80 01       	ld.sh	r1,r0[0x0]
80008ef2:	49 14       	lddpc	r4,80008f34 <key_handler_dsp+0x34>
80008ef4:	80 01       	ld.sh	r1,r0[0x0]
80008ef6:	49 38       	lddpc	r8,80008f40 <key_handler_dsp+0x40>
80008ef8:	80 01       	ld.sh	r1,r0[0x0]
80008efa:	49 60       	lddpc	r0,80008f50 <key_handler_dsp+0x50>
80008efc:	80 01       	ld.sh	r1,r0[0x0]
80008efe:	49 88       	lddpc	r8,80008f5c <key_handler_dsp+0x5c>

80008f00 <key_handler_dsp>:

//========================================
//====== key handlers

/// DSP
extern void key_handler_dsp(uiKey_t key, s16 val) {
80008f00:	eb cd 40 80 	pushm	r7,lr
  switch(key) {
80008f04:	58 ac       	cp.w	r12,10
80008f06:	c3 50       	breq	80008f70 <key_handler_dsp+0x70>
80008f08:	e0 88 00 0d 	brls	80008f22 <key_handler_dsp+0x22>
80008f0c:	58 bc       	cp.w	r12,11
80008f0e:	c1 b0       	breq	80008f44 <key_handler_dsp+0x44>
80008f10:	58 cc       	cp.w	r12,12
80008f12:	c1 50       	breq	80008f3c <key_handler_dsp+0x3c>
80008f14:	e0 67 31 10 	mov	r7,12560
  case eKeyEncDownD:     
    break;
  default:
    ;; // nothing
  }  
  (*(curPage->redraw))();
80008f18:	6e 08       	ld.w	r8,r7[0x0]
80008f1a:	70 28       	ld.w	r8,r8[0x8]
}
80008f1c:	5d 18       	icall	r8
80008f1e:	e3 cd 80 80 	ldm	sp++,r7,pc
//========================================
//====== key handlers

/// DSP
extern void key_handler_dsp(uiKey_t key, s16 val) {
  switch(key) {
80008f22:	58 1c       	cp.w	r12,1
80008f24:	c1 a0       	breq	80008f58 <key_handler_dsp+0x58>
80008f26:	58 9c       	cp.w	r12,9
    break;
  case eKeyFnDownD:
    break;
    //// encoder A: scroll pages
  case eKeyEncUpA:
    scroll_page(1);
80008f28:	cf 61       	brne	80008f14 <key_handler_dsp+0x14>
80008f2a:	30 1c       	mov	r12,1
80008f2c:	c8 ac       	rcall	80009040 <scroll_page>
80008f2e:	e0 67 31 10 	mov	r7,12560
  case eKeyEncDownD:     
    break;
  default:
    ;; // nothing
  }  
  (*(curPage->redraw))();
80008f32:	6e 08       	ld.w	r8,r7[0x0]
80008f34:	70 28       	ld.w	r8,r8[0x8]
}
80008f36:	5d 18       	icall	r8
80008f38:	e3 cd 80 80 	ldm	sp++,r7,pc
    //// encoder B: scroll selection
  case eKeyEncUpB:
    scroll_select(1, SCENE_COUNT );
    break;
  case eKeyEncDownB:
    scroll_select(-1, SCENE_COUNT );
80008f3c:	30 8b       	mov	r11,8
80008f3e:	3f fc       	mov	r12,-1
80008f40:	c2 cc       	rcall	80008f98 <scroll_select>
80008f42:	ce 9b       	rjmp	80008f14 <key_handler_dsp+0x14>
  case eKeyEncDownA:
    scroll_page (-1);
    break;
    //// encoder B: scroll selection
  case eKeyEncUpB:
    scroll_select(1, SCENE_COUNT );
80008f44:	30 8b       	mov	r11,8
80008f46:	30 1c       	mov	r12,1
80008f48:	c2 8c       	rcall	80008f98 <scroll_select>
80008f4a:	e0 67 31 10 	mov	r7,12560
  case eKeyEncDownD:     
    break;
  default:
    ;; // nothing
  }  
  (*(curPage->redraw))();
80008f4e:	6e 08       	ld.w	r8,r7[0x0]
80008f50:	70 28       	ld.w	r8,r8[0x8]
80008f52:	5d 18       	icall	r8
}
80008f54:	e3 cd 80 80 	ldm	sp++,r7,pc
/// DSP
extern void key_handler_dsp(uiKey_t key, s16 val) {
  switch(key) {
  case eKeyFnDownA:
    // load DSP (and update the parameter list)
    files_load_dsp(curPage->selected);
80008f58:	e0 67 31 10 	mov	r7,12560
80008f5c:	6e 08       	ld.w	r8,r7[0x0]
80008f5e:	f1 3c 00 0d 	ld.ub	r12,r8[13]
80008f62:	fe b0 f0 5b 	rcall	80007018 <files_load_dsp>
  case eKeyEncDownD:     
    break;
  default:
    ;; // nothing
  }  
  (*(curPage->redraw))();
80008f66:	6e 08       	ld.w	r8,r7[0x0]
80008f68:	70 28       	ld.w	r8,r8[0x8]
}
80008f6a:	5d 18       	icall	r8
80008f6c:	e3 cd 80 80 	ldm	sp++,r7,pc
    //// encoder A: scroll pages
  case eKeyEncUpA:
    scroll_page(1);
    break;
  case eKeyEncDownA:
    scroll_page (-1);
80008f70:	3f fc       	mov	r12,-1
80008f72:	c6 7c       	rcall	80009040 <scroll_page>
80008f74:	e0 67 31 10 	mov	r7,12560
  case eKeyEncDownD:     
    break;
  default:
    ;; // nothing
  }  
  (*(curPage->redraw))();
80008f78:	6e 08       	ld.w	r8,r7[0x0]
80008f7a:	70 28       	ld.w	r8,r8[0x8]
}
80008f7c:	5d 18       	icall	r8
80008f7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008f82:	d7 03       	nop

80008f84 <menu_handleKey>:
// de-init
extern void menu_deinit(void) {
}

// top level key handler
void menu_handleKey(uiKey_t key, s16 val) {
80008f84:	d4 01       	pushm	lr
  if (key == eKeyMode) {
80008f86:	58 0c       	cp.w	r12,0
80008f88:	c0 60       	breq	80008f94 <menu_handleKey+0x10>
  /*     // save the page and switch to Play mode */
  /*     savedPageIdx = pageIdx; */
  /*     set_page(ePagePlay); */
  /*   } */
  } else { 
    curPage->keyHandler(key);
80008f8a:	e0 68 31 10 	mov	r8,12560
80008f8e:	70 08       	ld.w	r8,r8[0x0]
80008f90:	70 18       	ld.w	r8,r8[0x4]
80008f92:	5d 18       	icall	r8
80008f94:	d8 02       	popm	pc
80008f96:	d7 03       	nop

80008f98 <scroll_select>:
  /* } */
  set_page(pageIdx);
}

// scroll current page selection
void scroll_select(s8 dir, s32 max) {
80008f98:	d4 01       	pushm	lr
  curPage->selected += dir;
80008f9a:	e0 68 31 10 	mov	r8,12560
80008f9e:	5c 6c       	casts.b	r12
80008fa0:	70 09       	ld.w	r9,r8[0x0]
80008fa2:	92 6a       	ld.sh	r10,r9[0xc]
80008fa4:	18 0a       	add	r10,r12
  while (curPage->selected < 0) {
80008fa6:	b2 6a       	st.h	r9[0xc],r10
80008fa8:	30 0e       	mov	lr,0
80008faa:	70 09       	ld.w	r9,r8[0x0]
80008fac:	92 6a       	ld.sh	r10,r9[0xc]
80008fae:	fc 0a 19 00 	cp.h	r10,lr
80008fb2:	c0 a4       	brge	80008fc6 <scroll_select+0x2e>
80008fb4:	f9 db b0 10 	bfexts	r12,r11,0x0,0x10
    curPage->selected += max;
80008fb8:	18 0a       	add	r10,r12
}

// scroll current page selection
void scroll_select(s8 dir, s32 max) {
  curPage->selected += dir;
  while (curPage->selected < 0) {
80008fba:	b2 6a       	st.h	r9[0xc],r10
80008fbc:	70 09       	ld.w	r9,r8[0x0]
80008fbe:	92 6a       	ld.sh	r10,r9[0xc]
80008fc0:	fc 0a 19 00 	cp.h	r10,lr
    curPage->selected += max;
  }
  while (curPage->selected >= max) {
80008fc4:	cf a5       	brlt	80008fb8 <scroll_select+0x20>
80008fc6:	16 3a       	cp.w	r10,r11
80008fc8:	c0 a5       	brlt	80008fdc <scroll_select+0x44>
80008fca:	f9 db b0 10 	bfexts	r12,r11,0x0,0x10
    curPage->selected -= max;
80008fce:	18 1a       	sub	r10,r12
void scroll_select(s8 dir, s32 max) {
  curPage->selected += dir;
  while (curPage->selected < 0) {
    curPage->selected += max;
  }
  while (curPage->selected >= max) {
80008fd0:	b2 6a       	st.h	r9[0xc],r10
80008fd2:	70 09       	ld.w	r9,r8[0x0]
80008fd4:	92 6a       	ld.sh	r10,r9[0xc]
80008fd6:	14 3b       	cp.w	r11,r10
80008fd8:	fe 9a ff fb 	brle	80008fce <scroll_select+0x36>
    curPage->selected -= max;
  }
  // redraw with the new selection
  curPage->redraw();
80008fdc:	72 28       	ld.w	r8,r9[0x8]
}
80008fde:	5d 18       	icall	r8
80008fe0:	d8 02       	popm	pc
80008fe2:	d7 03       	nop

80008fe4 <menu_init>:

//-----------------------------------
//----- external function definitions

// init
extern void menu_init(void) {
80008fe4:	eb cd 40 80 	pushm	r7,lr
  set_page(pageIdx);
80008fe8:	e0 69 19 1c 	mov	r9,6428
//----- static function definitions

// set current page
void set_page(ePage n) {
  u8 i;
  pageIdx = n;
80008fec:	13 88       	ld.ub	r8,r9[0x0]
  curPage = &(pages[pageIdx]);
80008fee:	b2 88       	st.b	r9[0x0],r8
80008ff0:	5c 68       	casts.b	r8
80008ff2:	f0 09 15 03 	lsl	r9,r8,0x3
80008ff6:	f2 08 01 08 	sub	r8,r9,r8
80008ffa:	30 c9       	mov	r9,12
80008ffc:	e0 67 31 10 	mov	r7,12560
80009000:	f2 08 00 28 	add	r8,r9,r8<<0x2
  curPage->redraw();
80009004:	8f 08       	st.w	r7[0x0],r8

#if ARCH_AVR32
  // set encoder sensitivity
  for(i=0; i<4; i++) {
    set_enc_thresh(encMap[i], curPage->encSens[i]);
80009006:	70 28       	ld.w	r8,r8[0x8]
80009008:	5d 18       	icall	r8
8000900a:	6e 08       	ld.w	r8,r7[0x0]
8000900c:	30 3c       	mov	r12,3
8000900e:	f1 3b 00 15 	ld.ub	r11,r8[21]
80009012:	fe b0 ee fd 	rcall	80006e0c <set_enc_thresh>
80009016:	6e 08       	ld.w	r8,r7[0x0]
80009018:	30 2c       	mov	r12,2
8000901a:	f1 3b 00 16 	ld.ub	r11,r8[22]
8000901e:	fe b0 ee f7 	rcall	80006e0c <set_enc_thresh>
80009022:	6e 08       	ld.w	r8,r7[0x0]
80009024:	30 1c       	mov	r12,1
80009026:	f1 3b 00 17 	ld.ub	r11,r8[23]
8000902a:	fe b0 ee f1 	rcall	80006e0c <set_enc_thresh>
8000902e:	6e 08       	ld.w	r8,r7[0x0]
80009030:	30 0c       	mov	r12,0
80009032:	f1 3b 00 18 	ld.ub	r11,r8[24]
//----- external function definitions

// init
extern void menu_init(void) {
  set_page(pageIdx);
}
80009036:	fe b0 ee eb 	rcall	80006e0c <set_enc_thresh>
8000903a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000903e:	d7 03       	nop

80009040 <scroll_page>:
80009040:	eb cd 40 80 	pushm	r7,lr
80009044:	e0 69 19 1c 	mov	r9,6428
80009048:	13 88       	ld.ub	r8,r9[0x0]
8000904a:	b2 88       	st.b	r9[0x0],r8

// set current page
void set_page(ePage n) {
  u8 i;
  pageIdx = n;
  curPage = &(pages[pageIdx]);
8000904c:	5c 68       	casts.b	r8
8000904e:	f0 09 15 03 	lsl	r9,r8,0x3
80009052:	f2 08 01 08 	sub	r8,r9,r8
80009056:	30 c9       	mov	r9,12
80009058:	e0 67 31 10 	mov	r7,12560
8000905c:	f2 08 00 28 	add	r8,r9,r8<<0x2
  curPage->redraw();
80009060:	8f 08       	st.w	r7[0x0],r8

#if ARCH_AVR32
  // set encoder sensitivity
  for(i=0; i<4; i++) {
    set_enc_thresh(encMap[i], curPage->encSens[i]);
80009062:	70 28       	ld.w	r8,r8[0x8]
80009064:	5d 18       	icall	r8
80009066:	6e 08       	ld.w	r8,r7[0x0]
80009068:	30 3c       	mov	r12,3
8000906a:	f1 3b 00 15 	ld.ub	r11,r8[21]
8000906e:	fe b0 ee cf 	rcall	80006e0c <set_enc_thresh>
80009072:	6e 08       	ld.w	r8,r7[0x0]
80009074:	30 2c       	mov	r12,2
80009076:	f1 3b 00 16 	ld.ub	r11,r8[22]
8000907a:	fe b0 ee c9 	rcall	80006e0c <set_enc_thresh>
8000907e:	6e 08       	ld.w	r8,r7[0x0]
80009080:	30 1c       	mov	r12,1
80009082:	f1 3b 00 17 	ld.ub	r11,r8[23]
80009086:	fe b0 ee c3 	rcall	80006e0c <set_enc_thresh>
8000908a:	6e 08       	ld.w	r8,r7[0x0]
8000908c:	30 0c       	mov	r12,0
8000908e:	f1 3b 00 18 	ld.ub	r11,r8[24]
  /* case ePageDsp: */
  /*   pageIdx = dir>0 ? ePageIns : ePageScenes ; */
  /*   break; */
  /* } */
  set_page(pageIdx);
}
80009092:	fe b0 ee bd 	rcall	80006e0c <set_enc_thresh>
80009096:	e3 cd 80 80 	ldm	sp++,r7,pc
8000909a:	d7 03       	nop

8000909c <net_activate>:
  net->outs[idx].target = -1;
  net->outs[idx].preset = 0;
}

// activate an input node with a value
void net_activate(s16 inIdx, const io_t val) {
8000909c:	d4 01       	pushm	lr
  /* print_dbg_hex(net->ins[inIdx].opIdx); */
  /* print_dbg(" , op in idx: "); */
  /* print_dbg_hex(net->ins[inIdx].opInIdx); */

  //    param_feedback(inIdx, val);
  if(inIdx >= 0) {
8000909e:	30 09       	mov	r9,0
  net->outs[idx].target = -1;
  net->outs[idx].preset = 0;
}

// activate an input node with a value
void net_activate(s16 inIdx, const io_t val) {
800090a0:	18 98       	mov	r8,r12
800090a2:	16 9a       	mov	r10,r11
  /* print_dbg_hex(net->ins[inIdx].opIdx); */
  /* print_dbg(" , op in idx: "); */
  /* print_dbg_hex(net->ins[inIdx].opInIdx); */

  //    param_feedback(inIdx, val);
  if(inIdx >= 0) {
800090a4:	f2 0c 19 00 	cp.h	r12,r9
800090a8:	c1 55       	brlt	800090d2 <net_activate+0x36>
    if(inIdx < net->numIns) {
800090aa:	e0 69 31 14 	mov	r9,12564
800090ae:	e0 7c 00 ca 	mov	r12,65738
800090b2:	72 09       	ld.w	r9,r9[0x0]
800090b4:	f2 0c 04 0c 	ld.sh	r12,r9[r12]
800090b8:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800090bc:	1c 38       	cp.w	r8,lr
      op_set_in_val(net->ops[net->ins[inIdx].opIdx],
		    net->ins[inIdx].opInIdx,
		    val);
    } else { 
      // index in dsp param list
      inIdx -= net->numIns;
800090be:	c0 d5       	brlt	800090d8 <net_activate+0x3c>
800090c0:	f0 0c 01 0c 	sub	r12,r8,r12
      if (inIdx >= net->numParams) {
800090c4:	e0 78 00 ce 	mov	r8,65742
800090c8:	5c 8c       	casts.h	r12
800090ca:	f2 08 05 08 	ld.uh	r8,r9[r8]
800090ce:	10 3c       	cp.w	r12,r8
800090d0:	c0 25       	brlt	800090d4 <net_activate+0x38>
	return ;
      } else {
	set_param_value(inIdx, val);
800090d2:	d8 02       	popm	pc
800090d4:	c7 4d       	rcall	800093bc <set_param_value>
800090d6:	d8 02       	popm	pc

  //    param_feedback(inIdx, val);
  if(inIdx >= 0) {
    if(inIdx < net->numIns) {
      //(*(net->ins[inIdx].in))(net->ops[net->ins[inIdx].opIdx], val);
      op_set_in_val(net->ops[net->ins[inIdx].opIdx],
800090d8:	f0 cb df e6 	sub	r11,r8,-8218
800090dc:	f2 08 00 38 	add	r8,r9,r8<<0x3
800090e0:	f2 0b 03 3b 	ld.w	r11,r9[r11<<0x3]
800090e4:	fe 28 ff 2c 	sub	r8,-65748
800090e8:	f2 0b 03 2c 	ld.w	r12,r9[r11<<0x2]
800090ec:	11 8b       	ld.ub	r11,r8[0x0]
800090ee:	c5 bd       	rcall	800093a4 <op_set_in_val>
800090f0:	d8 02       	popm	pc
800090f2:	d7 03       	nop

800090f4 <net_add_op>:
800090f4:	eb cd 40 f8 	pushm	r3-r7,lr
800090f8:	e0 79 00 c8 	mov	r9,65736
800090fc:	e0 67 31 14 	mov	r7,12564
s16 net_add_op(opId_t opId) {
  u16 ins, outs;
  u8 i;
  op_t* op;

  if (net->numOps >= NET_OPS_MAX) {
80009100:	18 96       	mov	r6,r12
80009102:	6e 08       	ld.w	r8,r7[0x0]
80009104:	f0 09 04 0a 	ld.sh	r10,r8[r9]
80009108:	32 f9       	mov	r9,47
8000910a:	f2 0a 19 00 	cp.h	r10,r9
8000910e:	e0 88 00 04 	brls	80009116 <net_add_op+0x22>
    net->outs[net->numOuts].opOutIdx = i;
    net->outs[net->numOuts].target = -1;
    net->numOuts++;
  }
  net->numOps++;
  return net->numOps - 1;
80009112:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1

  if (net->numOps >= NET_OPS_MAX) {
    return -1;
  }

  if (op_registry[opId].size > NET_OP_POOL_SIZE - net->opPoolOffset) {
80009116:	e0 79 00 c4 	mov	r9,65732
8000911a:	4e 55       	lddpc	r5,800092ac <net_add_op+0x1b8>
8000911c:	f0 09 03 09 	ld.w	r9,r8[r9]
80009120:	f8 04 15 01 	lsl	r4,r12,0x1
80009124:	e0 7a 00 00 	mov	r10,65536
80009128:	e8 cb ff ff 	sub	r11,r4,-1
8000912c:	12 1a       	sub	r10,r9
8000912e:	ea 0b 03 2b 	ld.w	r11,r5[r11<<0x2]
80009132:	14 3b       	cp.w	r11,r10
80009134:	fe 9b ff ef 	brhi	80009112 <net_add_op+0x1e>
    // not enough memory in op pool
    return -1;
  }
  op = (op_t*)((u8*)net->opPool + net->opPoolOffset);
80009138:	e0 7a 00 c0 	mov	r10,65728
8000913c:	f0 0a 03 03 	ld.w	r3,r8[r10]
  // use the class ID to initialize a new object in scratch
  switch(opId) {
80009140:	12 03       	add	r3,r9
80009142:	58 2c       	cp.w	r12,2
80009144:	c6 50       	breq	8000920e <net_add_op+0x11a>
80009146:	e0 8b 00 5c 	brhi	800091fe <net_add_op+0x10a>
8000914a:	58 0c       	cp.w	r12,0
8000914c:	c6 90       	breq	8000921e <net_add_op+0x12a>
8000914e:	58 1c       	cp.w	r12,1
  case eOpSwitch:
    op_sw_init((void*) op);
    break;
  case eOpEnc:
    op_enc_init((void*)op);
80009150:	ce 11       	brne	80009112 <net_add_op+0x1e>
80009152:	06 9c       	mov	r12,r3
80009154:	e0 a0 03 f6 	rcall	80009940 <op_enc_init>
    return -1;
  }

  ins = op->numInputs;
  outs = op->numOutputs;
  op->type = opId;
80009158:	e7 66 00 20 	st.b	r3[32],r6
 
  if (ins > (NET_INS_MAX - net->numIns)) {
8000915c:	e0 6b 00 80 	mov	r11,128
80009160:	07 86       	ld.ub	r6,r3[0x0]
80009162:	6e 08       	ld.w	r8,r7[0x0]
80009164:	e0 79 00 ca 	mov	r9,65738
80009168:	07 9c       	ld.ub	r12,r3[0x1]
8000916a:	f0 09 05 0a 	ld.uh	r10,r8[r9]
8000916e:	f6 0a 01 0a 	sub	r10,r11,r10
80009172:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80009176:	14 3b       	cp.w	r11,r10
80009178:	fe 99 ff cd 	brgt	80009112 <net_add_op+0x1e>
    return -1;
  }

  if (outs > (NET_OUTS_MAX - net->numOuts)) {
8000917c:	e0 6b 00 80 	mov	r11,128
80009180:	e0 7a 00 cc 	mov	r10,65740
80009184:	f0 0a 05 0a 	ld.uh	r10,r8[r10]
80009188:	f6 0a 01 0a 	sub	r10,r11,r10
8000918c:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
80009190:	14 3b       	cp.w	r11,r10
80009192:	fe 99 ff c0 	brgt	80009112 <net_add_op+0x1e>
    return -1;
  }

  // add op pointer to list
  net->ops[net->numOps] = op;
80009196:	e0 7a 00 c8 	mov	r10,65736
8000919a:	2f f4       	sub	r4,-1
8000919c:	f0 0a 05 0b 	ld.uh	r11,r8[r10]
800091a0:	f0 0b 09 23 	st.w	r8[r11<<0x2],r3
  net->opPoolOffset += op_registry[opId].size;
800091a4:	e0 68 31 14 	mov	r8,12564
800091a8:	ea 04 03 23 	ld.w	r3,r5[r4<<0x2]
800091ac:	70 0b       	ld.w	r11,r8[0x0]
800091ae:	14 94       	mov	r4,r10
800091b0:	30 08       	mov	r8,0
800091b2:	e0 7a 00 c4 	mov	r10,65732
800091b6:	f6 0a 03 05 	ld.w	r5,r11[r10]
800091ba:	e6 05 00 05 	add	r5,r3,r5

  //---- add inputs and outputs to node list
    for(i=0; i<ins; i++) {
800091be:	f6 0a 09 05 	st.w	r11[r10],r5
800091c2:	f0 06 19 00 	cp.h	r6,r8
      net->ins[net->numIns].opIdx = net->numOps;
800091c6:	e0 88 00 30 	brls	80009226 <net_add_op+0x132>
800091ca:	6e 0a       	ld.w	r10,r7[0x0]
800091cc:	f4 09 05 0b 	ld.uh	r11,r10[r9]
800091d0:	f4 04 05 05 	ld.uh	r5,r10[r4]
800091d4:	f6 cb df e6 	sub	r11,r11,-8218
      net->ins[net->numIns].opInIdx = i;
800091d8:	f4 0b 09 35 	st.w	r10[r11<<0x3],r5
800091dc:	6e 0b       	ld.w	r11,r7[0x0]
800091de:	f6 09 05 0a 	ld.uh	r10,r11[r9]
800091e2:	f6 0a 00 3a 	add	r10,r11,r10<<0x3
800091e6:	fe 2a ff 2c 	sub	r10,-65748
      net->numIns++;
800091ea:	b4 88       	st.b	r10[0x0],r8
  // add op pointer to list
  net->ops[net->numOps] = op;
  net->opPoolOffset += op_registry[opId].size;

  //---- add inputs and outputs to node list
    for(i=0; i<ins; i++) {
800091ec:	2f f8       	sub	r8,-1
      net->ins[net->numIns].opIdx = net->numOps;
      net->ins[net->numIns].opInIdx = i;
      net->numIns++;
800091ee:	6e 0b       	ld.w	r11,r7[0x0]
800091f0:	5c 58       	castu.b	r8
800091f2:	f6 09 04 0a 	ld.sh	r10,r11[r9]
800091f6:	2f fa       	sub	r10,-1
800091f8:	f6 09 0a 0a 	st.h	r11[r9],r10
    // not enough memory in op pool
    return -1;
  }
  op = (op_t*)((u8*)net->opPool + net->opPoolOffset);
  // use the class ID to initialize a new object in scratch
  switch(opId) {
800091fc:	ce 3b       	rjmp	800091c2 <net_add_op+0xce>
800091fe:	58 3c       	cp.w	r12,3
80009200:	c0 b0       	breq	80009216 <net_add_op+0x122>
    break;
  case eOpMul:
    op_mul_init((void*)op);
    break;
  case eOpGate:
    op_gate_init((void*)op);
80009202:	58 4c       	cp.w	r12,4
80009204:	c8 71       	brne	80009112 <net_add_op+0x1e>
80009206:	06 9c       	mov	r12,r3
    break;
80009208:	e0 a0 04 b2 	rcall	80009b6c <op_gate_init>
    break;
  case eOpEnc:
    op_enc_init((void*)op);
    break;
  case eOpAdd:
    op_add_init((void*)op);
8000920c:	ca 6b       	rjmp	80009158 <net_add_op+0x64>
8000920e:	06 9c       	mov	r12,r3
    break;
80009210:	e0 a0 03 04 	rcall	80009818 <op_add_init>
  case eOpMul:
    op_mul_init((void*)op);
80009214:	ca 2b       	rjmp	80009158 <net_add_op+0x64>
80009216:	06 9c       	mov	r12,r3
    break;
80009218:	e0 a0 05 40 	rcall	80009c98 <op_mul_init>
  }
  op = (op_t*)((u8*)net->opPool + net->opPoolOffset);
  // use the class ID to initialize a new object in scratch
  switch(opId) {
  case eOpSwitch:
    op_sw_init((void*) op);
8000921c:	c9 eb       	rjmp	80009158 <net_add_op+0x64>
8000921e:	06 9c       	mov	r12,r3
    break;
80009220:	e0 a0 05 d2 	rcall	80009dc4 <op_sw_init>
      net->ins[net->numIns].opIdx = net->numOps;
      net->ins[net->numIns].opInIdx = i;
      net->numIns++;
    }
  for(i=0; i<outs; i++) {
    net->outs[net->numOuts].opIdx = net->numOps;
80009224:	c9 ab       	rjmp	80009158 <net_add_op+0x64>
80009226:	30 09       	mov	r9,0
80009228:	e0 78 00 cc 	mov	r8,65740
    net->outs[net->numOuts].opOutIdx = i;
    net->outs[net->numOuts].target = -1;
8000922c:	e0 75 00 c8 	mov	r5,65736
    for(i=0; i<ins; i++) {
      net->ins[net->numIns].opIdx = net->numOps;
      net->ins[net->numIns].opInIdx = i;
      net->numIns++;
    }
  for(i=0; i<outs; i++) {
80009230:	3f f6       	mov	r6,-1
80009232:	f2 0c 19 00 	cp.h	r12,r9
    net->outs[net->numOuts].opIdx = net->numOps;
80009236:	e0 88 00 2b 	brls	8000928c <net_add_op+0x198>
8000923a:	6e 0b       	ld.w	r11,r7[0x0]
8000923c:	f6 08 05 0a 	ld.uh	r10,r11[r8]
80009240:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
80009244:	f6 0a 00 2a 	add	r10,r11,r10<<0x2
80009248:	fe 2a fb 2c 	sub	r10,-66772
8000924c:	f6 05 05 04 	ld.uh	r4,r11[r5]
    net->outs[net->numOuts].opOutIdx = i;
80009250:	95 04       	st.w	r10[0x0],r4
80009252:	6e 0b       	ld.w	r11,r7[0x0]
80009254:	f6 08 05 0a 	ld.uh	r10,r11[r8]
80009258:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
8000925c:	f6 0a 00 2a 	add	r10,r11,r10<<0x2
80009260:	fe 2a fb 30 	sub	r10,-66768
    net->outs[net->numOuts].target = -1;
80009264:	b4 89       	st.b	r10[0x0],r9
80009266:	6e 0b       	ld.w	r11,r7[0x0]
80009268:	f6 08 05 0a 	ld.uh	r10,r11[r8]
8000926c:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
80009270:	f6 0a 00 2a 	add	r10,r11,r10<<0x2
80009274:	fe 2a fb 30 	sub	r10,-66768
    net->numOuts++;
80009278:	b4 16       	st.h	r10[0x2],r6
    for(i=0; i<ins; i++) {
      net->ins[net->numIns].opIdx = net->numOps;
      net->ins[net->numIns].opInIdx = i;
      net->numIns++;
    }
  for(i=0; i<outs; i++) {
8000927a:	2f f9       	sub	r9,-1
    net->outs[net->numOuts].opIdx = net->numOps;
    net->outs[net->numOuts].opOutIdx = i;
    net->outs[net->numOuts].target = -1;
    net->numOuts++;
8000927c:	6e 0a       	ld.w	r10,r7[0x0]
8000927e:	5c 59       	castu.b	r9
80009280:	f4 08 04 0b 	ld.sh	r11,r10[r8]
80009284:	2f fb       	sub	r11,-1
80009286:	f4 08 0a 0b 	st.h	r10[r8],r11
  }
  net->numOps++;
8000928a:	cd 4b       	rjmp	80009232 <net_add_op+0x13e>
8000928c:	6e 09       	ld.w	r9,r7[0x0]
8000928e:	e0 78 00 c8 	mov	r8,65736
80009292:	f2 08 04 0a 	ld.sh	r10,r9[r8]
80009296:	2f fa       	sub	r10,-1
  return net->numOps - 1;
80009298:	f2 08 0a 0a 	st.h	r9[r8],r10
8000929c:	6e 09       	ld.w	r9,r7[0x0]
8000929e:	f2 08 04 0c 	ld.sh	r12,r9[r8]
800092a2:	20 1c       	sub	r12,1
800092a4:	5c 8c       	casts.h	r12
800092a6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800092aa:	d7 03       	nop
800092ac:	80 01       	ld.sh	r1,r0[0x0]
800092ae:	49 d4       	lddpc	r4,80009320 <net_init+0x70>

800092b0 <net_init>:
800092b0:	d4 01       	pushm	lr
800092b2:	e0 7c 14 e8 	mov	r12,70888
800092b6:	fe b0 f2 2b 	rcall	8000770c <alloc_mem>
800092ba:	e0 68 31 14 	mov	r8,12564
800092be:	30 09       	mov	r9,0
800092c0:	91 0c       	st.w	r8[0x0],r12
800092c2:	12 9a       	mov	r10,r9
  /* *((u32*)net) = 0xDEADBEEF; */
  /* print_dbg("\r\n ; reading... result: "); */
  /* res = *((u32*)net); */
  /* print_dbg_hex(res); */
 
  for(i=0; i<NET_OP_POOL_SIZE; i++) {
800092c4:	c0 28       	rjmp	800092c8 <net_init+0x18>
    net->opPoolMem[i] = (u8)0;
800092c6:	70 0c       	ld.w	r12,r8[0x0]
800092c8:	12 0c       	add	r12,r9
800092ca:	f9 6a 00 c0 	st.b	r12[192],r10
  /* *((u32*)net) = 0xDEADBEEF; */
  /* print_dbg("\r\n ; reading... result: "); */
  /* res = *((u32*)net); */
  /* print_dbg_hex(res); */
 
  for(i=0; i<NET_OP_POOL_SIZE; i++) {
800092ce:	2f f9       	sub	r9,-1
800092d0:	e0 59 00 00 	cp.w	r9,65536
    net->opPoolMem[i] = (u8)0;
  }

  net->opPool = (void*)&(net->opPoolMem);
800092d4:	cf 91       	brne	800092c6 <net_init+0x16>
800092d6:	70 09       	ld.w	r9,r8[0x0]
800092d8:	e0 7a 00 c0 	mov	r10,65728
800092dc:	f2 cb ff 40 	sub	r11,r9,-192
800092e0:	f2 0a 09 0b 	st.w	r9[r10],r11
  net->opPoolOffset = 0;
800092e4:	30 0a       	mov	r10,0
800092e6:	70 0b       	ld.w	r11,r8[0x0]
800092e8:	e0 79 00 c4 	mov	r9,65732
800092ec:	f6 09 09 0a 	st.w	r11[r9],r10

  net->numOps = 0;
800092f0:	e0 79 00 c8 	mov	r9,65736
800092f4:	70 0b       	ld.w	r11,r8[0x0]
800092f6:	f6 09 0a 0a 	st.h	r11[r9],r10
  net->numIns = 0;
800092fa:	e0 79 00 ca 	mov	r9,65738
800092fe:	70 0b       	ld.w	r11,r8[0x0]
80009300:	f6 09 0a 0a 	st.h	r11[r9],r10
  net->numOuts = 0;
80009304:	e0 79 00 cc 	mov	r9,65740
80009308:	70 0b       	ld.w	r11,r8[0x0]
8000930a:	f6 09 0a 0a 	st.h	r11[r9],r10
  net->numParams = 0;
8000930e:	70 0c       	ld.w	r12,r8[0x0]
80009310:	e0 7b 00 ce 	mov	r11,65742
80009314:	14 99       	mov	r9,r10
80009316:	f8 0b 0a 0a 	st.h	r12[r11],r10
  ;;
}

// initialize an input node
void net_init_inode(u16 idx) {
  net->ins[idx].opIdx = -1;
8000931a:	14 9e       	mov	lr,r10
8000931c:	3f fc       	mov	r12,-1
8000931e:	70 0a       	ld.w	r10,r8[0x0]
80009320:	f2 cb df e6 	sub	r11,r9,-8218
80009324:	f4 0b 09 3c 	st.w	r10[r11<<0x3],r12
  net->ins[idx].preset = 0;
80009328:	70 0a       	ld.w	r10,r8[0x0]
8000932a:	f4 09 00 3a 	add	r10,r10,r9<<0x3
8000932e:	fe 2a ff 2c 	sub	r10,-65748
  net->numOps = 0;
  net->numIns = 0;
  net->numOuts = 0;
  net->numParams = 0;
  // unassign all I/O nodes
  for(i=0; i<NET_INS_MAX; i++) {
80009332:	b4 9e       	st.b	r10[0x1],lr
80009334:	2f f9       	sub	r9,-1
80009336:	e0 49 00 80 	cp.w	r9,128
8000933a:	cf 21       	brne	8000931e <net_init+0x6e>

// initialize an output node
void net_init_onode(u16 idx) {
  net->outs[idx].opIdx = -1;
  net->outs[idx].target = -1;
  net->outs[idx].preset = 0;
8000933c:	30 09       	mov	r9,0
  net->ins[idx].preset = 0;
}

// initialize an output node
void net_init_onode(u16 idx) {
  net->outs[idx].opIdx = -1;
8000933e:	12 9e       	mov	lr,r9
80009340:	70 0b       	ld.w	r11,r8[0x0]
80009342:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009346:	a3 6a       	lsl	r10,0x2
80009348:	14 0b       	add	r11,r10
8000934a:	fe 2b fb 2c 	sub	r11,-66772
  net->outs[idx].target = -1;
8000934e:	97 0c       	st.w	r11[0x0],r12
80009350:	70 0b       	ld.w	r11,r8[0x0]
80009352:	14 0b       	add	r11,r10
80009354:	fe 2b fb 30 	sub	r11,-66768
  net->outs[idx].preset = 0;
80009358:	b6 1c       	st.h	r11[0x2],r12
8000935a:	70 0b       	ld.w	r11,r8[0x0]
8000935c:	f6 0a 00 0a 	add	r10,r11,r10
80009360:	fe 2a fb 28 	sub	r10,-66776
  net->numParams = 0;
  // unassign all I/O nodes
  for(i=0; i<NET_INS_MAX; i++) {
    net_init_inode(i);
  }
  for(i=0; i<NET_OUTS_MAX; i++) {
80009364:	b4 8e       	st.b	r10[0x0],lr
80009366:	2f f9       	sub	r9,-1
80009368:	e0 49 00 80 	cp.w	r9,128
    net_init_onode(i);
  }
  printf("initialized network, using %d bytes\n", (int)sizeof(ctlnet_t));
8000936c:	ce a1       	brne	80009340 <net_init+0x90>
8000936e:	e0 78 14 e8 	mov	r8,70888
80009372:	48 cc       	lddpc	r12,800093a0 <net_init+0xf0>
80009374:	1a d8       	st.w	--sp,r8
80009376:	e0 a0 2c d5 	rcall	8000ed20 <printf>
// create all system operators
static void add_sys_ops(void);
static void add_sys_ops(void) {
  // print_dbg("\r\n creating system operators.");
  // 4 encoders
  net_add_op(eOpEnc);
8000937a:	30 1c       	mov	r12,1
8000937c:	cb ce       	rcall	800090f4 <net_add_op>
  net_add_op(eOpEnc);
8000937e:	30 1c       	mov	r12,1
80009380:	cb ae       	rcall	800090f4 <net_add_op>
80009382:	30 1c       	mov	r12,1
  net_add_op(eOpEnc);
80009384:	cb 8e       	rcall	800090f4 <net_add_op>
80009386:	30 1c       	mov	r12,1
80009388:	cb 6e       	rcall	800090f4 <net_add_op>
  net_add_op(eOpEnc);
8000938a:	30 0c       	mov	r12,0
8000938c:	cb 4e       	rcall	800090f4 <net_add_op>
8000938e:	30 0c       	mov	r12,0
  // 4 switches
  net_add_op(eOpSwitch);
80009390:	cb 2e       	rcall	800090f4 <net_add_op>
80009392:	30 0c       	mov	r12,0
80009394:	cb 0e       	rcall	800090f4 <net_add_op>
  net_add_op(eOpSwitch);
80009396:	30 0c       	mov	r12,0
80009398:	ca ee       	rcall	800090f4 <net_add_op>
8000939a:	2f fd       	sub	sp,-4
  net_add_op(eOpSwitch);
8000939c:	d8 02       	popm	pc
8000939e:	d7 03       	nop
800093a0:	80 01       	ld.sh	r1,r0[0x0]
  net_add_op(eOpSwitch);
800093a2:	49 ac       	lddpc	r12,80009408 <preset_init+0x4>

800093a4 <op_set_in_val>:
io_t op_get_in_val(op_t* op, s16 idx) {
  return *(op->in_val[idx]);
}

// set input value
void op_set_in_val(op_t* op, s16 idx, io_t val) {
800093a4:	d4 01       	pushm	lr
  io_t * const pIn = (op->in_val[idx]);
800093a6:	f6 08 15 02 	lsl	r8,r11,0x2
800093aa:	78 3b       	ld.w	r11,r12[0xc]
800093ac:	f6 08 03 0b 	ld.w	r11,r11[r8]
  *pIn = val;
800093b0:	97 0a       	st.w	r11[0x0],r10
  (*(op->in_func[idx]))(op, pIn);  
800093b2:	78 29       	ld.w	r9,r12[0x8]
800093b4:	f2 08 03 08 	ld.w	r8,r9[r8]
800093b8:	5d 18       	icall	r8
  //  param_feedback(idx, val);
}
800093ba:	d8 02       	popm	pc

800093bc <set_param_value>:
u8 get_param_preset(u32 idx) {
  return net->params[idx].preset;
}

// set value for param at given idx
void set_param_value(u32 idx, io_t val) {
800093bc:	eb cd 40 80 	pushm	r7,lr
  net->params[idx].data.value.asInt = val;
800093c0:	e0 69 31 14 	mov	r9,12564
800093c4:	f8 0c 00 28 	add	r8,r12,r12<<0x2
800093c8:	72 0a       	ld.w	r10,r9[0x0]
800093ca:	a3 78       	lsl	r8,0x3
800093cc:	10 0a       	add	r10,r8
800093ce:	fe 2a f5 10 	sub	r10,-68336
800093d2:	74 0e       	ld.w	lr,r10[0x0]
800093d4:	e6 1e ff 00 	andh	lr,0xff00,COH
800093d8:	fd eb 12 8e 	or	lr,lr,r11>>0x8
800093dc:	95 0e       	st.w	r10[0x0],lr
800093de:	74 1e       	ld.w	lr,r10[0x4]
800093e0:	fd de c0 18 	bfextu	lr,lr,0x0,0x18
800093e4:	fd eb 11 87 	or	r7,lr,r11<<0x18
  net->params[idx].data.changed = 1;
800093e8:	95 17       	st.w	r10[0x4],r7
800093ea:	72 09       	ld.w	r9,r9[0x0]
800093ec:	f2 08 00 08 	add	r8,r9,r8
800093f0:	30 19       	mov	r9,1
800093f2:	fe 28 f5 0c 	sub	r8,-68340
800093f6:	5c 5c       	castu.b	r12
#ifdef ARCH_AVR32
  bfin_set_param(idx, val);
800093f8:	b0 99       	st.b	r8[0x1],r9
800093fa:	fe b0 e7 dd 	rcall	800063b4 <bfin_set_param>
#endif
}
800093fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80009402:	d7 03       	nop

80009404 <preset_init>:

//=================================
//====== function definitions

// initialize
void preset_init(void) {
80009404:	eb cd 40 e0 	pushm	r5-r7,lr

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
80009408:	e0 67 31 18 	mov	r7,12568
8000940c:	30 06       	mov	r6,0
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
8000940e:	fe f5 02 6a 	ld.w	r5,pc[618]
80009412:	ee cb f7 00 	sub	r11,r7,-2304
80009416:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
80009418:	ef 66 09 00 	st.b	r7[2304],r6
8000941c:	ef 66 09 01 	st.b	r7[2305],r6
80009420:	ef 66 09 02 	st.b	r7[2306],r6
80009424:	ef 66 09 03 	st.b	r7[2307],r6
80009428:	ef 66 09 04 	st.b	r7[2308],r6
8000942c:	ef 66 09 05 	st.b	r7[2309],r6
80009430:	ef 66 09 06 	st.b	r7[2310],r6
80009434:	ef 66 09 07 	st.b	r7[2311],r6
80009438:	ef 66 09 08 	st.b	r7[2312],r6
8000943c:	ef 66 09 09 	st.b	r7[2313],r6
80009440:	ef 66 09 0a 	st.b	r7[2314],r6
80009444:	ef 66 09 0b 	st.b	r7[2315],r6
80009448:	ef 66 09 0c 	st.b	r7[2316],r6
8000944c:	ef 66 09 0d 	st.b	r7[2317],r6
80009450:	ef 66 09 0e 	st.b	r7[2318],r6
80009454:	ef 66 09 0f 	st.b	r7[2319],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
80009458:	31 0a       	mov	r10,16
8000945a:	e0 a0 05 b9 	rcall	80009fcc <str_copy>
8000945e:	ee cb ed f0 	sub	r11,r7,-4624
80009462:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
80009464:	ef 66 12 10 	st.b	r7[4624],r6
80009468:	ef 66 12 11 	st.b	r7[4625],r6
8000946c:	ef 66 12 12 	st.b	r7[4626],r6
80009470:	ef 66 12 13 	st.b	r7[4627],r6
80009474:	ef 66 12 14 	st.b	r7[4628],r6
80009478:	ef 66 12 15 	st.b	r7[4629],r6
8000947c:	ef 66 12 16 	st.b	r7[4630],r6
80009480:	ef 66 12 17 	st.b	r7[4631],r6
80009484:	ef 66 12 18 	st.b	r7[4632],r6
80009488:	ef 66 12 19 	st.b	r7[4633],r6
8000948c:	ef 66 12 1a 	st.b	r7[4634],r6
80009490:	ef 66 12 1b 	st.b	r7[4635],r6
80009494:	ef 66 12 1c 	st.b	r7[4636],r6
80009498:	ef 66 12 1d 	st.b	r7[4637],r6
8000949c:	ef 66 12 1e 	st.b	r7[4638],r6
800094a0:	ef 66 12 1f 	st.b	r7[4639],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
800094a4:	31 0a       	mov	r10,16
800094a6:	e0 a0 05 93 	rcall	80009fcc <str_copy>
800094aa:	ee cb e4 e0 	sub	r11,r7,-6944
800094ae:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
800094b0:	ef 66 1b 20 	st.b	r7[6944],r6
800094b4:	ef 66 1b 21 	st.b	r7[6945],r6
800094b8:	ef 66 1b 22 	st.b	r7[6946],r6
800094bc:	ef 66 1b 23 	st.b	r7[6947],r6
800094c0:	ef 66 1b 24 	st.b	r7[6948],r6
800094c4:	ef 66 1b 25 	st.b	r7[6949],r6
800094c8:	ef 66 1b 26 	st.b	r7[6950],r6
800094cc:	ef 66 1b 27 	st.b	r7[6951],r6
800094d0:	ef 66 1b 28 	st.b	r7[6952],r6
800094d4:	ef 66 1b 29 	st.b	r7[6953],r6
800094d8:	ef 66 1b 2a 	st.b	r7[6954],r6
800094dc:	ef 66 1b 2b 	st.b	r7[6955],r6
800094e0:	ef 66 1b 2c 	st.b	r7[6956],r6
800094e4:	ef 66 1b 2d 	st.b	r7[6957],r6
800094e8:	ef 66 1b 2e 	st.b	r7[6958],r6
800094ec:	ef 66 1b 2f 	st.b	r7[6959],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
800094f0:	31 0a       	mov	r10,16
800094f2:	e0 a0 05 6d 	rcall	80009fcc <str_copy>
800094f6:	ee cb db d0 	sub	r11,r7,-9264
800094fa:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
800094fc:	ef 66 24 30 	st.b	r7[9264],r6
80009500:	ef 66 24 31 	st.b	r7[9265],r6
80009504:	ef 66 24 32 	st.b	r7[9266],r6
80009508:	ef 66 24 33 	st.b	r7[9267],r6
8000950c:	ef 66 24 34 	st.b	r7[9268],r6
80009510:	ef 66 24 35 	st.b	r7[9269],r6
80009514:	ef 66 24 36 	st.b	r7[9270],r6
80009518:	ef 66 24 37 	st.b	r7[9271],r6
8000951c:	ef 66 24 38 	st.b	r7[9272],r6
80009520:	ef 66 24 39 	st.b	r7[9273],r6
80009524:	ef 66 24 3a 	st.b	r7[9274],r6
80009528:	ef 66 24 3b 	st.b	r7[9275],r6
8000952c:	ef 66 24 3c 	st.b	r7[9276],r6
80009530:	ef 66 24 3d 	st.b	r7[9277],r6
80009534:	ef 66 24 3e 	st.b	r7[9278],r6
80009538:	ef 66 24 3f 	st.b	r7[9279],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
8000953c:	31 0a       	mov	r10,16
8000953e:	e0 a0 05 47 	rcall	80009fcc <str_copy>
80009542:	ee cb d2 c0 	sub	r11,r7,-11584
80009546:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
80009548:	ef 66 2d 40 	st.b	r7[11584],r6
8000954c:	ef 66 2d 41 	st.b	r7[11585],r6
80009550:	ef 66 2d 42 	st.b	r7[11586],r6
80009554:	ef 66 2d 43 	st.b	r7[11587],r6
80009558:	ef 66 2d 44 	st.b	r7[11588],r6
8000955c:	ef 66 2d 45 	st.b	r7[11589],r6
80009560:	ef 66 2d 46 	st.b	r7[11590],r6
80009564:	ef 66 2d 47 	st.b	r7[11591],r6
80009568:	ef 66 2d 48 	st.b	r7[11592],r6
8000956c:	ef 66 2d 49 	st.b	r7[11593],r6
80009570:	ef 66 2d 4a 	st.b	r7[11594],r6
80009574:	ef 66 2d 4b 	st.b	r7[11595],r6
80009578:	ef 66 2d 4c 	st.b	r7[11596],r6
8000957c:	ef 66 2d 4d 	st.b	r7[11597],r6
80009580:	ef 66 2d 4e 	st.b	r7[11598],r6
80009584:	ef 66 2d 4f 	st.b	r7[11599],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
80009588:	31 0a       	mov	r10,16
8000958a:	e0 a0 05 21 	rcall	80009fcc <str_copy>
8000958e:	ee cb c9 b0 	sub	r11,r7,-13904
80009592:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
80009594:	ef 66 36 50 	st.b	r7[13904],r6
80009598:	ef 66 36 51 	st.b	r7[13905],r6
8000959c:	ef 66 36 52 	st.b	r7[13906],r6
800095a0:	ef 66 36 53 	st.b	r7[13907],r6
800095a4:	ef 66 36 54 	st.b	r7[13908],r6
800095a8:	ef 66 36 55 	st.b	r7[13909],r6
800095ac:	ef 66 36 56 	st.b	r7[13910],r6
800095b0:	ef 66 36 57 	st.b	r7[13911],r6
800095b4:	ef 66 36 58 	st.b	r7[13912],r6
800095b8:	ef 66 36 59 	st.b	r7[13913],r6
800095bc:	ef 66 36 5a 	st.b	r7[13914],r6
800095c0:	ef 66 36 5b 	st.b	r7[13915],r6
800095c4:	ef 66 36 5c 	st.b	r7[13916],r6
800095c8:	ef 66 36 5d 	st.b	r7[13917],r6
800095cc:	ef 66 36 5e 	st.b	r7[13918],r6
800095d0:	ef 66 36 5f 	st.b	r7[13919],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
800095d4:	31 0a       	mov	r10,16
800095d6:	e0 a0 04 fb 	rcall	80009fcc <str_copy>
800095da:	ee cb c0 a0 	sub	r11,r7,-16224
800095de:	0a 9c       	mov	r12,r5

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
800095e0:	ef 66 3f 60 	st.b	r7[16224],r6
800095e4:	ef 66 3f 61 	st.b	r7[16225],r6
800095e8:	ef 66 3f 62 	st.b	r7[16226],r6
800095ec:	ef 66 3f 63 	st.b	r7[16227],r6
800095f0:	ef 66 3f 64 	st.b	r7[16228],r6
800095f4:	ef 66 3f 65 	st.b	r7[16229],r6
800095f8:	ef 66 3f 66 	st.b	r7[16230],r6
800095fc:	ef 66 3f 67 	st.b	r7[16231],r6
80009600:	ef 66 3f 68 	st.b	r7[16232],r6
80009604:	ef 66 3f 69 	st.b	r7[16233],r6
80009608:	ef 66 3f 6a 	st.b	r7[16234],r6
8000960c:	ef 66 3f 6b 	st.b	r7[16235],r6
80009610:	ef 66 3f 6c 	st.b	r7[16236],r6
80009614:	ef 66 3f 6d 	st.b	r7[16237],r6
80009618:	ef 66 3f 6e 	st.b	r7[16238],r6
8000961c:	ef 66 3f 6f 	st.b	r7[16239],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
80009620:	31 0a       	mov	r10,16
80009622:	e0 a0 04 d5 	rcall	80009fcc <str_copy>
80009626:	ee cb b7 90 	sub	r11,r7,-18544

  for(i=0; i<NET_PRESETS_MAX; i++) {
    //    snprintf(presets[i].name, PRESET_NAME_LEN, "preset_%d", i);
    // presets[i].name = "[empty]";
    for(j=0; j<PRESET_NAME_LEN; j++) {
      presets[i].name[j] = 0;
8000962a:	ef 66 48 7f 	st.b	r7[18559],r6
8000962e:	ef 66 48 70 	st.b	r7[18544],r6
80009632:	ef 66 48 71 	st.b	r7[18545],r6
80009636:	ef 66 48 72 	st.b	r7[18546],r6
8000963a:	ef 66 48 73 	st.b	r7[18547],r6
8000963e:	ef 66 48 74 	st.b	r7[18548],r6
80009642:	ef 66 48 75 	st.b	r7[18549],r6
80009646:	ef 66 48 76 	st.b	r7[18550],r6
8000964a:	ef 66 48 77 	st.b	r7[18551],r6
8000964e:	ef 66 48 78 	st.b	r7[18552],r6
80009652:	ef 66 48 79 	st.b	r7[18553],r6
80009656:	ef 66 48 7a 	st.b	r7[18554],r6
8000965a:	ef 66 48 7b 	st.b	r7[18555],r6
8000965e:	ef 66 48 7c 	st.b	r7[18556],r6
80009662:	ef 66 48 7d 	st.b	r7[18557],r6
80009666:	ef 66 48 7e 	st.b	r7[18558],r6
    }
    str_copy("[empty]", presets[i].name, PRESET_NAME_LEN);
8000966a:	0a 9c       	mov	r12,r5
8000966c:	31 0a       	mov	r10,16
8000966e:	e0 a0 04 af 	rcall	80009fcc <str_copy>
  }
}
80009672:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009676:	d7 03       	nop
80009678:	80 01       	ld.sh	r1,r0[0x0]
8000967a:	4a 14       	lddpc	r4,800096fc <redraw_dsp+0x80>

8000967c <redraw_dsp>:
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
8000967c:	d4 31       	pushm	r0-r7,lr
8000967e:	20 1d       	sub	sp,4
  u8 y = 0;                       // which line
  s32 n, nCenter;         // which list entry
  u16 num = files_get_dsp_count();
80009680:	fe b0 ec 5a 	rcall	80006f34 <files_get_dsp_count>
  /* print_dbg("\r\n count of DSP files: "); */
  /* print_dbg_ulong(num); */
  // print selection at center
  nCenter = curPage->selected;
80009684:	e0 68 31 10 	mov	r8,12560
80009688:	18 97       	mov	r7,r12
8000968a:	70 08       	ld.w	r8,r8[0x0]
  if (nCenter >= num) {
8000968c:	90 65       	ld.sh	r5,r8[0xc]
8000968e:	18 35       	cp.w	r5,r12
80009690:	e0 84 00 8e 	brge	800097ac <redraw_dsp+0x130>
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);
80009694:	18 93       	mov	r3,r12
  u16 num = files_get_dsp_count();
  /* print_dbg("\r\n count of DSP files: "); */
  /* print_dbg_ulong(num); */
  // print selection at center
  nCenter = curPage->selected;
  if (nCenter >= num) {
80009696:	30 3b       	mov	r11,3
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);
80009698:	5c 83       	casts.h	r3
8000969a:	30 0c       	mov	r12,0
8000969c:	fe b0 f1 2c 	rcall	800078f4 <screen_blank_line>

  if (n < 0  || n >= num ) {
800096a0:	58 05       	cp.w	r5,0
800096a2:	c0 85       	brlt	800096b2 <redraw_dsp+0x36>
800096a4:	0a 97       	mov	r7,r5
800096a6:	f1 d3 c0 10 	bfextu	r8,r3,0x0,0x10
800096aa:	0e 38       	cp.w	r8,r7
800096ac:	e0 89 00 8b 	brgt	800097c2 <redraw_dsp+0x146>


///// snprintf replacement
// write to top of line buffer
static inline void println(const char* str, int pos) {
  pline = lineBuf + pos;
800096b0:	0e 95       	mov	r5,r7
    nCenter = num;
  }
  n = nCenter;
  y = SCREEN_ROW_CENTER;
  draw_line_dsp(n, num, y, 15);
  screen_hl_line(0, y, 1);
800096b2:	e0 62 19 20 	mov	r2,6432
800096b6:	30 1a       	mov	r10,1
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096b8:	30 3b       	mov	r11,3
800096ba:	30 0c       	mov	r12,0
    nCenter = num;
  }
  n = nCenter;
  y = SCREEN_ROW_CENTER;
  draw_line_dsp(n, num, y, 15);
  screen_hl_line(0, y, 1);
800096bc:	ea c1 00 02 	sub	r1,r5,2
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096c0:	fe b0 f0 6e 	rcall	8000779c <screen_hl_line>

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);

  if (n < 0  || n >= num ) {
800096c4:	30 26       	mov	r6,2
800096c6:	0a 97       	mov	r7,r5
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096c8:	e1 d3 c0 10 	bfextu	r0,r3,0x0,0x10
800096cc:	e4 c4 ff ce 	sub	r4,r2,-50
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);
800096d0:	50 02       	stdsp	sp[0x0],r2
800096d2:	20 17       	sub	r7,1
800096d4:	0c 9b       	mov	r11,r6
800096d6:	30 0c       	mov	r12,0

  if (n < 0  || n >= num ) {
800096d8:	fe b0 f1 0e 	rcall	800078f4 <screen_blank_line>
800096dc:	58 07       	cp.w	r7,0
800096de:	c0 35       	brlt	800096e4 <redraw_dsp+0x68>
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
800096e0:	00 37       	cp.w	r7,r0
  n = nCenter;
  y = SCREEN_ROW_CENTER;
  draw_line_dsp(n, num, y, 15);
  screen_hl_line(0, y, 1);
  // print lower entries
  while (y > 1) {
800096e2:	c4 75       	brlt	80009770 <redraw_dsp+0xf4>
800096e4:	20 16       	sub	r6,1
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096e6:	02 37       	cp.w	r7,r1

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);

  if (n < 0  || n >= num ) {
800096e8:	cf 51       	brne	800096d2 <redraw_dsp+0x56>
800096ea:	0a 97       	mov	r7,r5
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096ec:	e5 d3 c0 10 	bfextu	r2,r3,0x0,0x10
800096f0:	30 06       	mov	r6,0


///// snprintf replacement
// write to top of line buffer
static inline void println(const char* str, int pos) {
  pline = lineBuf + pos;
800096f2:	e0 63 19 20 	mov	r3,6432
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800096f6:	2f d5       	sub	r5,-3
800096f8:	32 81       	mov	r1,40
  // re-center
  n = nCenter;
  y = SCREEN_ROW_CENTER;
  // print higher entries
  while (y < CHAR_ROWS_2) {
    n++;
800096fa:	e6 c4 ff ce 	sub	r4,r3,-50
800096fe:	50 03       	stdsp	sp[0x0],r3
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);
80009700:	2f f7       	sub	r7,-1
80009702:	ec c0 ff fc 	sub	r0,r6,-4
80009706:	30 0c       	mov	r12,0

  if (n < 0  || n >= num ) {
80009708:	00 9b       	mov	r11,r0
8000970a:	fe b0 f0 f5 	rcall	800078f4 <screen_blank_line>
8000970e:	58 07       	cp.w	r7,0
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
80009710:	c0 35       	brlt	80009716 <redraw_dsp+0x9a>
  }
  // re-center
  n = nCenter;
  y = SCREEN_ROW_CENTER;
  // print higher entries
  while (y < CHAR_ROWS_2) {
80009712:	04 37       	cp.w	r7,r2
80009714:	c1 25       	brlt	80009738 <redraw_dsp+0xbc>
    n++;
    y++;
    draw_line_dsp(n, num, y, 4);
  }
  screen_line(0, 0, "DSP", 12);
80009716:	2f f6       	sub	r6,-1
80009718:	0a 37       	cp.w	r7,r5
8000971a:	cf 31       	brne	80009700 <redraw_dsp+0x84>
8000971c:	30 0b       	mov	r11,0
8000971e:	30 c9       	mov	r9,12
80009720:	4b ca       	lddpc	r10,80009810 <redraw_dsp+0x194>
  // draw footer (function labels)
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
80009722:	16 9c       	mov	r12,r11
80009724:	fe b0 f2 a6 	rcall	80007c70 <screen_line>
80009728:	30 a9       	mov	r9,10
8000972a:	4b ba       	lddpc	r10,80009814 <redraw_dsp+0x198>
8000972c:	30 7b       	mov	r11,7
}
8000972e:	30 0c       	mov	r12,0
80009730:	fe b0 f2 a0 	rcall	80007c70 <screen_line>

  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
80009734:	2f fd       	sub	sp,-4
80009736:	d8 32       	popm	r0-r7,pc
80009738:	0e 9c       	mov	r12,r7


///// snprintf replacement
// write to top of line buffer
static inline void println(const char* str, int pos) {
  pline = lineBuf + pos;
8000973a:	5c 5c       	castu.b	r12

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
8000973c:	fe b0 eb f6 	rcall	80006f28 <files_get_dsp_name>
80009740:	83 03       	st.w	r1[0x0],r3
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
80009742:	19 89       	ld.ub	r9,r12[0x0]
80009744:	58 09       	cp.w	r9,0

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
80009746:	c5 f0       	breq	80009804 <redraw_dsp+0x188>
80009748:	40 08       	lddsp	r8,sp[0x0]
    *pline++ = *str++;
8000974a:	c0 38       	rjmp	80009750 <redraw_dsp+0xd4>
8000974c:	08 38       	cp.w	r8,r4

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
8000974e:	c0 60       	breq	8000975a <redraw_dsp+0xde>
80009750:	10 c9       	st.b	r8++,r9
80009752:	2f fc       	sub	r12,-1
80009754:	19 89       	ld.ub	r9,r12[0x0]
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
80009756:	58 09       	cp.w	r9,0
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
80009758:	cf a1       	brne	8000974c <redraw_dsp+0xd0>
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
8000975a:	83 08       	st.w	r1[0x0],r8
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
8000975c:	30 09       	mov	r9,0
8000975e:	00 9b       	mov	r11,r0
80009760:	b0 89       	st.b	r8[0x0],r9
80009762:	e0 6a 19 20 	mov	r10,6432
80009766:	30 49       	mov	r9,4

  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
80009768:	30 0c       	mov	r12,0
8000976a:	fe b0 f2 7d 	rcall	80007c64 <screen_string>
8000976e:	cd 4b       	rjmp	80009716 <redraw_dsp+0x9a>


///// snprintf replacement
// write to top of line buffer
static inline void println(const char* str, int pos) {
  pline = lineBuf + pos;
80009770:	0e 9c       	mov	r12,r7
80009772:	5c 5c       	castu.b	r12

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
80009774:	fe b0 eb da 	rcall	80006f28 <files_get_dsp_name>
80009778:	32 89       	mov	r9,40
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
8000977a:	93 02       	st.w	r9[0x0],r2
8000977c:	19 89       	ld.ub	r9,r12[0x0]

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
8000977e:	58 09       	cp.w	r9,0
80009780:	c4 40       	breq	80009808 <redraw_dsp+0x18c>
    *pline++ = *str++;
80009782:	40 08       	lddsp	r8,sp[0x0]
80009784:	c0 38       	rjmp	8000978a <redraw_dsp+0x10e>

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
80009786:	08 38       	cp.w	r8,r4
80009788:	c0 60       	breq	80009794 <redraw_dsp+0x118>
8000978a:	10 c9       	st.b	r8++,r9
8000978c:	2f fc       	sub	r12,-1
8000978e:	19 89       	ld.ub	r9,r12[0x0]
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
80009790:	58 09       	cp.w	r9,0
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
80009792:	cf a1       	brne	80009786 <redraw_dsp+0x10a>
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
80009794:	32 89       	mov	r9,40
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
80009796:	93 08       	st.w	r9[0x0],r8
80009798:	30 09       	mov	r9,0
8000979a:	e0 6a 19 20 	mov	r10,6432
8000979e:	b0 89       	st.b	r8[0x0],r9
800097a0:	0c 9b       	mov	r11,r6
    draw_line_dsp(n, num, y, 4);
  }
  screen_line(0, 0, "DSP", 12);
  // draw footer (function labels)
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}
800097a2:	30 49       	mov	r9,4

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);
800097a4:	30 0c       	mov	r12,0
800097a6:	fe b0 f2 5f 	rcall	80007c64 <screen_string>
800097aa:	c9 db       	rjmp	800096e4 <redraw_dsp+0x68>
    draw_line_dsp(n, num, y, 4);
  }
  screen_line(0, 0, "DSP", 12);
  // draw footer (function labels)
  screen_line(0, CHAR_ROWS_1, "LOAD DEFAULT", 10);
}
800097ac:	18 93       	mov	r3,r12

// draw line of dsp page
void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl) {
  screen_blank_line(0, y);

  if (n < 0  || n >= num ) {
800097ae:	30 3b       	mov	r11,3
800097b0:	30 0c       	mov	r12,0
800097b2:	fe b0 f0 a1 	rcall	800078f4 <screen_blank_line>
800097b6:	5c 83       	casts.h	r3
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
800097b8:	f1 d3 c0 10 	bfextu	r8,r3,0x0,0x10
800097bc:	0e 38       	cp.w	r8,r7
800097be:	fe 9a ff 79 	brle	800096b0 <redraw_dsp+0x34>


///// snprintf replacement
// write to top of line buffer
static inline void println(const char* str, int pos) {
  pline = lineBuf + pos;
800097c2:	0e 9c       	mov	r12,r7
800097c4:	5c 5c       	castu.b	r12

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
800097c6:	fe b0 eb b1 	rcall	80006f28 <files_get_dsp_name>
800097ca:	32 8b       	mov	r11,40
static void draw_line_dsp(s32 n, u16 num, u8 y, u8 hl);


//==================================================
//==== redraw dsp page
void redraw_dsp(void) {
800097cc:	e0 6a 19 20 	mov	r10,6432
800097d0:	97 0a       	st.w	r11[0x0],r10

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
800097d2:	19 89       	ld.ub	r9,r12[0x0]
800097d4:	58 09       	cp.w	r9,0
    *pline++ = *str++;
800097d6:	c1 b0       	breq	8000980c <redraw_dsp+0x190>
800097d8:	14 98       	mov	r8,r10

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
800097da:	2c ea       	sub	r10,-50
800097dc:	c0 38       	rjmp	800097e2 <redraw_dsp+0x166>
800097de:	14 38       	cp.w	r8,r10
800097e0:	c0 60       	breq	800097ec <redraw_dsp+0x170>
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
800097e2:	10 c9       	st.b	r8++,r9
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
800097e4:	2f fc       	sub	r12,-1
static inline void clearln(void) {
  memset(pline, ' ', CHAR_COLS);
}

static inline void endln(void) {
  *(pline) = 0;
800097e6:	19 89       	ld.ub	r9,r12[0x0]
  if (n < 0  || n >= num ) {
    return;
  } 

  println( (const char*)files_get_dsp_name(n), 0);
  endln(); screen_string(0, y, lineBuf, hl); 
800097e8:	58 09       	cp.w	r9,0
800097ea:	cf a1       	brne	800097de <redraw_dsp+0x162>
800097ec:	97 08       	st.w	r11[0x0],r8
800097ee:	30 09       	mov	r9,0
800097f0:	0e 95       	mov	r5,r7
800097f2:	b0 89       	st.b	r8[0x0],r9
800097f4:	e0 6a 19 20 	mov	r10,6432

// append to line buffer
static inline void appendln(const char* str) {
  //  print_dbg("\n\r line buffer start: ");
  //  print_dbg_hex(pline);
  while((*str != 0) && (pline <= pLineEnd)) {
800097f8:	30 f9       	mov	r9,15
800097fa:	30 3b       	mov	r11,3
800097fc:	30 0c       	mov	r12,0
800097fe:	fe b0 f2 33 	rcall	80007c64 <screen_string>
80009802:	c5 8b       	rjmp	800096b2 <redraw_dsp+0x36>
80009804:	06 98       	mov	r8,r3
80009806:	ca bb       	rjmp	8000975c <redraw_dsp+0xe0>
80009808:	04 98       	mov	r8,r2
8000980a:	cc 7b       	rjmp	80009798 <redraw_dsp+0x11c>
8000980c:	14 98       	mov	r8,r10
8000980e:	cf 0b       	rjmp	800097ee <redraw_dsp+0x172>
80009810:	80 01       	ld.sh	r1,r0[0x0]
80009812:	49 a8       	lddpc	r8,80009878 <op_add_in_btrig+0x4>
80009814:	80 01       	ld.sh	r1,r0[0x0]
80009816:	4a 1c       	lddpc	r12,80009898 <op_add_in_b+0x1c>

80009818 <op_add_init>:
};

//-------------------------------------------------
//---- external func define
void op_add_init(op_add_t* add) {
  add->super.numInputs = 3;
80009818:	30 38       	mov	r8,3
8000981a:	b8 88       	st.b	r12[0x0],r8
  add->super.numOutputs = 1;
8000981c:	30 18       	mov	r8,1
8000981e:	b8 98       	st.b	r12[0x1],r8
  add->outs[0] = -1;
  add->super.inc_func = (op_inc_func)op_add_inc_input;
80009820:	fe c8 ff 5c 	sub	r8,pc,-164
  add->super.in_func = op_add_in_func;
80009824:	99 18       	st.w	r12[0x4],r8
80009826:	32 c8       	mov	r8,44
  add->super.in_val = add->in_val;
80009828:	99 28       	st.w	r12[0x8],r8
8000982a:	f8 c8 ff c8 	sub	r8,r12,-56
  add->super.out = add->outs;
8000982e:	99 38       	st.w	r12[0xc],r8
80009830:	f8 c8 ff c0 	sub	r8,r12,-64
  add->super.opString = op_add_opstring;
80009834:	99 48       	st.w	r12[0x10],r8
80009836:	48 d8       	lddpc	r8,80009868 <op_add_init+0x50>
80009838:	70 08       	ld.w	r8,r8[0x0]
  add->super.inString = op_add_instring;
8000983a:	99 58       	st.w	r12[0x14],r8
8000983c:	48 c8       	lddpc	r8,8000986c <op_add_init+0x54>
8000983e:	70 08       	ld.w	r8,r8[0x0]
  add->super.outString = op_add_outstring;
80009840:	99 68       	st.w	r12[0x18],r8
80009842:	48 c8       	lddpc	r8,80009870 <op_add_init+0x58>
80009844:	70 08       	ld.w	r8,r8[0x0]
  add->super.type = eOpAdd;  
80009846:	99 78       	st.w	r12[0x1c],r8
80009848:	30 28       	mov	r8,2
8000984a:	f9 68 00 20 	st.b	r12[32],r8
  add->super.status = eUserOp;  
8000984e:	30 08       	mov	r8,0

  add->in_val[0] = &(add->a);
80009850:	99 98       	st.w	r12[0x24],r8
80009852:	f8 c8 ff d4 	sub	r8,r12,-44
  add->in_val[1] = &(add->b);
80009856:	99 e8       	st.w	r12[0x38],r8
80009858:	f8 c8 ff d0 	sub	r8,r12,-48
  add->in_val[2] = &(add->btrig);
8000985c:	99 f8       	st.w	r12[0x3c],r8
8000985e:	f8 c8 ff cc 	sub	r8,r12,-52
80009862:	f9 48 00 40 	st.w	r12[64],r8
}
80009866:	5e fc       	retal	r12
80009868:	80 01       	ld.sh	r1,r0[0x0]
8000986a:	4a 60       	lddpc	r0,80009900 <op_add_inc_input+0x3c>
8000986c:	80 01       	ld.sh	r1,r0[0x0]
8000986e:	4a 2c       	lddpc	r12,800098f4 <op_add_inc_input+0x30>
80009870:	80 01       	ld.sh	r1,r0[0x0]
80009872:	4a 64       	lddpc	r4,80009908 <op_add_inc_input+0x44>

80009874 <op_add_in_btrig>:
80009874:	58 0b       	cp.w	r11,0
80009876:	5f 18       	srne	r8
80009878:	99 d8       	st.w	r12[0x34],r8
8000987a:	5e fc       	retal	r12

8000987c <op_add_in_b>:
  add->a = *v;
  add->val = OP_ADD(add->a, add->b);
  net_activate(add->outs[0], add->val);
}

static void op_add_in_b(op_add_t* add, const io_t* v) {
8000987c:	eb cd 40 80 	pushm	r7,lr
80009880:	18 97       	mov	r7,r12
  add->b = *v;
80009882:	76 0b       	ld.w	r11,r11[0x0]
80009884:	99 cb       	st.w	r12[0x30],r11
  add->val = OP_ADD(add->a, add->b);
80009886:	78 bc       	ld.w	r12,r12[0x2c]
80009888:	e0 a0 03 5c 	rcall	80009f40 <fix16_add>
8000988c:	8f ac       	st.w	r7[0x28],r12
  if(add->btrig) {
8000988e:	6e d8       	ld.w	r8,r7[0x34]
80009890:	58 08       	cp.w	r8,0
80009892:	c0 60       	breq	8000989e <op_add_in_b+0x22>
    net_activate(add->outs[0], add->val);
80009894:	18 9b       	mov	r11,r12
80009896:	ef 0c 00 40 	ld.sh	r12,r7[64]
8000989a:	fe b0 fc 01 	rcall	8000909c <net_activate>
8000989e:	e3 cd 80 80 	ldm	sp++,r7,pc
800098a2:	d7 03       	nop

800098a4 <op_add_in_a>:
800098a4:	eb cd 40 80 	pushm	r7,lr
800098a8:	18 97       	mov	r7,r12
800098aa:	76 0c       	ld.w	r12,r11[0x0]
//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
  add->val = OP_ADD(add->a, add->b);
800098ac:	6e cb       	ld.w	r11,r7[0x30]

//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
800098ae:	8f bc       	st.w	r7[0x2c],r12
  add->val = OP_ADD(add->a, add->b);
800098b0:	e0 a0 03 48 	rcall	80009f40 <fix16_add>
800098b4:	18 9b       	mov	r11,r12
  net_activate(add->outs[0], add->val);
800098b6:	ef 0c 00 40 	ld.sh	r12,r7[64]
//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
  add->val = OP_ADD(add->a, add->b);
800098ba:	8f ab       	st.w	r7[0x28],r11
  net_activate(add->outs[0], add->val);
800098bc:	fe b0 fb f0 	rcall	8000909c <net_activate>
}
800098c0:	e3 cd 80 80 	ldm	sp++,r7,pc

800098c4 <op_add_inc_input>:
800098c4:	eb cd 40 80 	pushm	r7,lr
800098c8:	20 1d       	sub	sp,4
800098ca:	50 0a       	stdsp	sp[0x0],r10
static void op_add_in_btrig(op_add_t* add, const io_t* v) {
  add->btrig = (v != 0);
}

//===== UI input
static void op_add_inc_input(op_add_t* add, const s16 idx, const io_t inc) {
800098cc:	18 97       	mov	r7,r12
  io_t val;
  switch(idx) {
800098ce:	30 18       	mov	r8,1
800098d0:	f0 0b 19 00 	cp.h	r11,r8
800098d4:	c2 20       	breq	80009918 <op_add_inc_input+0x54>
800098d6:	30 28       	mov	r8,2
800098d8:	f0 0b 19 00 	cp.h	r11,r8
800098dc:	c1 90       	breq	8000990e <op_add_inc_input+0x4a>
800098de:	30 08       	mov	r8,0
800098e0:	f0 0b 19 00 	cp.h	r11,r8
800098e4:	c0 40       	breq	800098ec <op_add_inc_input+0x28>
    break;
  case 2:  // trig
    op_add_in_btrig(add, &inc);
    break;
  }
}
800098e6:	2f fd       	sub	sp,-4
800098e8:	e3 cd 80 80 	ldm	sp++,r7,pc
//===== UI input
static void op_add_inc_input(op_add_t* add, const s16 idx, const io_t inc) {
  io_t val;
  switch(idx) {
  case 0:  // a
    val = OP_ADD(add->a, inc);
800098ec:	14 9b       	mov	r11,r10
800098ee:	78 bc       	ld.w	r12,r12[0x2c]
800098f0:	e0 a0 03 28 	rcall	80009f40 <fix16_add>
//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
  add->val = OP_ADD(add->a, add->b);
800098f4:	6e cb       	ld.w	r11,r7[0x30]

//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
800098f6:	8f bc       	st.w	r7[0x2c],r12
  add->val = OP_ADD(add->a, add->b);
800098f8:	e0 a0 03 24 	rcall	80009f40 <fix16_add>
800098fc:	18 9b       	mov	r11,r12
  net_activate(add->outs[0], add->val);
800098fe:	ef 0c 00 40 	ld.sh	r12,r7[64]
//-------------------------------------------------
//---- static func define

static void op_add_in_a(op_add_t* add, const io_t* v) {
  add->a = *v;
  add->val = OP_ADD(add->a, add->b);
80009902:	8f ab       	st.w	r7[0x28],r11
  net_activate(add->outs[0], add->val);
80009904:	fe b0 fb cc 	rcall	8000909c <net_activate>
    break;
  case 2:  // trig
    op_add_in_btrig(add, &inc);
    break;
  }
}
80009908:	2f fd       	sub	sp,-4
8000990a:	e3 cd 80 80 	ldm	sp++,r7,pc
    net_activate(add->outs[0], add->val);
  }
}

static void op_add_in_btrig(op_add_t* add, const io_t* v) {
  add->btrig = (v != 0);
8000990e:	30 18       	mov	r8,1
80009910:	99 d8       	st.w	r12[0x34],r8
    break;
  case 2:  // trig
    op_add_in_btrig(add, &inc);
    break;
  }
}
80009912:	2f fd       	sub	sp,-4
80009914:	e3 cd 80 80 	ldm	sp++,r7,pc
  case 0:  // a
    val = OP_ADD(add->a, inc);
    op_add_in_a(add, &val);
    break; 
  case 1:  // b
    val = OP_ADD(add->b, inc);
80009918:	14 9b       	mov	r11,r10
8000991a:	78 cc       	ld.w	r12,r12[0x30]
8000991c:	e0 a0 03 12 	rcall	80009f40 <fix16_add>
80009920:	18 9b       	mov	r11,r12
  add->val = OP_ADD(add->a, add->b);
  net_activate(add->outs[0], add->val);
}

static void op_add_in_b(op_add_t* add, const io_t* v) {
  add->b = *v;
80009922:	8f cc       	st.w	r7[0x30],r12
  add->val = OP_ADD(add->a, add->b);
80009924:	6e bc       	ld.w	r12,r7[0x2c]
80009926:	e0 a0 03 0d 	rcall	80009f40 <fix16_add>
8000992a:	8f ac       	st.w	r7[0x28],r12
  if(add->btrig) {
8000992c:	6e d8       	ld.w	r8,r7[0x34]
8000992e:	58 08       	cp.w	r8,0
80009930:	cd b0       	breq	800098e6 <op_add_inc_input+0x22>
    net_activate(add->outs[0], add->val);
80009932:	18 9b       	mov	r11,r12
80009934:	ef 0c 00 40 	ld.sh	r12,r7[64]
80009938:	fe b0 fb b2 	rcall	8000909c <net_activate>
8000993c:	cd 5b       	rjmp	800098e6 <op_add_inc_input+0x22>
8000993e:	d7 03       	nop

80009940 <op_enc_init>:
//----- external functions
// initialize
void op_enc_init(op_enc_t* enc) {
  enc->super.numInputs = 5;
  enc->super.numOutputs = 2;
  enc->outs[0] = -1;
80009940:	3f f8       	mov	r8,-1
  enc->outs[1] = -1;
80009942:	f9 58 00 56 	st.h	r12[86],r8
//----- external functions
// initialize
void op_enc_init(op_enc_t* enc) {
  enc->super.numInputs = 5;
  enc->super.numOutputs = 2;
  enc->outs[0] = -1;
80009946:	f9 58 00 54 	st.h	r12[84],r8
  enc->super.out = enc->outs;
  enc->super.opString = op_enc_opstring;
  enc->super.inString = op_enc_instring;
  enc->super.outString = op_enc_outstring;
  enc->super.type = eOpEnc;
  enc->super.status = eSysCtlOp;
8000994a:	30 18       	mov	r8,1
  enc->in_val[3] = &(enc->step);
  enc->in_val[4] = &(enc->wrap);
  
  enc->min = 0;
  enc->max = OP_ONE;
  enc->step = OP_MIN_INC;
8000994c:	99 c8       	st.w	r12[0x30],r8
  enc->super.out = enc->outs;
  enc->super.opString = op_enc_opstring;
  enc->super.inString = op_enc_instring;
  enc->super.outString = op_enc_outstring;
  enc->super.type = eOpEnc;
  enc->super.status = eSysCtlOp;
8000994e:	99 98       	st.w	r12[0x24],r8
  enc->in_val[1] = &(enc->min);
  enc->in_val[2] = &(enc->max);
  enc->in_val[3] = &(enc->step);
  enc->in_val[4] = &(enc->wrap);
  
  enc->min = 0;
80009950:	30 08       	mov	r8,0
  enc->max = OP_ONE;
  enc->step = OP_MIN_INC;
  enc->wrap = 0;
80009952:	99 f8       	st.w	r12[0x3c],r8
  enc->in_val[1] = &(enc->min);
  enc->in_val[2] = &(enc->max);
  enc->in_val[3] = &(enc->step);
  enc->in_val[4] = &(enc->wrap);
  
  enc->min = 0;
80009954:	99 d8       	st.w	r12[0x34],r8

//-------------------------------------------------
//----- external functions
// initialize
void op_enc_init(op_enc_t* enc) {
  enc->super.numInputs = 5;
80009956:	30 58       	mov	r8,5
80009958:	b8 88       	st.b	r12[0x0],r8
  enc->super.numOutputs = 2;
8000995a:	30 28       	mov	r8,2
8000995c:	b8 98       	st.b	r12[0x1],r8
  enc->outs[0] = -1;
  enc->outs[1] = -1;
  enc->super.inc_func = (op_inc_func)op_enc_inc_input;
8000995e:	fe c8 fe 86 	sub	r8,pc,-378
  enc->super.in_func = op_enc_in_func;
80009962:	99 18       	st.w	r12[0x4],r8
80009964:	33 88       	mov	r8,56
  enc->super.in_val = enc->in_val;
80009966:	99 28       	st.w	r12[0x8],r8
80009968:	f8 c8 ff c0 	sub	r8,r12,-64
  enc->super.out = enc->outs;
8000996c:	99 38       	st.w	r12[0xc],r8
8000996e:	f8 c8 ff ac 	sub	r8,r12,-84
  enc->super.opString = op_enc_opstring;
80009972:	99 48       	st.w	r12[0x10],r8
80009974:	49 28       	lddpc	r8,800099bc <op_enc_init+0x7c>
80009976:	70 08       	ld.w	r8,r8[0x0]
  enc->super.inString = op_enc_instring;
80009978:	99 58       	st.w	r12[0x14],r8
8000997a:	49 28       	lddpc	r8,800099c0 <op_enc_init+0x80>
8000997c:	70 08       	ld.w	r8,r8[0x0]
  enc->super.outString = op_enc_outstring;
8000997e:	99 68       	st.w	r12[0x18],r8
80009980:	49 18       	lddpc	r8,800099c4 <op_enc_init+0x84>
80009982:	70 08       	ld.w	r8,r8[0x0]
  enc->super.type = eOpEnc;
80009984:	99 78       	st.w	r12[0x1c],r8
80009986:	30 18       	mov	r8,1
80009988:	f9 68 00 20 	st.b	r12[32],r8
  enc->super.status = eSysCtlOp;

  enc->in_val[0] = &(enc->move);
8000998c:	f8 c8 ff d4 	sub	r8,r12,-44
80009990:	f9 48 00 40 	st.w	r12[64],r8
  enc->in_val[1] = &(enc->min);
80009994:	f8 c8 ff cc 	sub	r8,r12,-52
80009998:	f9 48 00 44 	st.w	r12[68],r8
  enc->in_val[2] = &(enc->max);
8000999c:	f8 c8 ff c8 	sub	r8,r12,-56
800099a0:	f9 48 00 48 	st.w	r12[72],r8
  enc->in_val[3] = &(enc->step);
800099a4:	f8 c8 ff d0 	sub	r8,r12,-48
800099a8:	f9 48 00 4c 	st.w	r12[76],r8
  enc->in_val[4] = &(enc->wrap);
800099ac:	f8 c8 ff c4 	sub	r8,r12,-60
800099b0:	f9 48 00 50 	st.w	r12[80],r8
  
  enc->min = 0;
  enc->max = OP_ONE;
800099b4:	e0 78 00 00 	mov	r8,65536
  enc->step = OP_MIN_INC;
  enc->wrap = 0;
}
800099b8:	99 e8       	st.w	r12[0x38],r8
800099ba:	5e fc       	retal	r12
800099bc:	80 01       	ld.sh	r1,r0[0x0]
800099be:	4a 6c       	lddpc	r12,80009a54 <op_enc_perform+0x70>
800099c0:	80 01       	ld.sh	r1,r0[0x0]
800099c2:	4a 68       	lddpc	r8,80009a58 <op_enc_perform+0x74>
800099c4:	80 01       	ld.sh	r1,r0[0x0]
800099c6:	4a 70       	lddpc	r0,80009a60 <op_enc_perform+0x7c>

800099c8 <op_enc_in_step>:
800099c8:	76 08       	ld.w	r8,r11[0x0]
800099ca:	99 c8       	st.w	r12[0x30],r8
800099cc:	5e fc       	retal	r12

800099ce <op_enc_in_wrap>:
800099ce:	76 08       	ld.w	r8,r11[0x0]
}

// wrap behavior
static void op_enc_in_wrap(op_enc_t* enc, const io_t* v) {
  //  enc->wrap = (*v > 0);
  if(*v > 0) { enc->wrap = OP_ONE; } else { enc->wrap = 0; }
800099d0:	58 08       	cp.w	r8,0
800099d2:	e0 8a 00 06 	brle	800099de <op_enc_in_wrap+0x10>
800099d6:	e0 78 00 00 	mov	r8,65536
800099da:	99 f8       	st.w	r12[0x3c],r8
800099dc:	5e fc       	retal	r12
800099de:	30 08       	mov	r8,0
800099e0:	99 f8       	st.w	r12[0x3c],r8
800099e2:	5e fc       	retal	r12

800099e4 <op_enc_perform>:
  //  op_enc_perform(enc);
}

// perform wrapping and output
static void op_enc_perform(op_enc_t* enc){ 
800099e4:	eb cd 40 fc 	pushm	r2-r7,lr
800099e8:	18 94       	mov	r4,r12
  io_t wrap = 0;
  io_t dif = 0;
  if (enc->wrap) { // wrapping...
800099ea:	78 f6       	ld.w	r6,r12[0x3c]
800099ec:	58 06       	cp.w	r6,0
800099ee:	c3 90       	breq	80009a60 <op_enc_perform+0x7c>
    // if value needs wrapping, output the applied difference
    while (enc->val > enc->max) { 
800099f0:	78 a7       	ld.w	r7,r12[0x28]
800099f2:	78 e3       	ld.w	r3,r12[0x38]
800099f4:	06 37       	cp.w	r7,r3
800099f6:	e0 8a 00 51 	brle	80009a98 <op_enc_perform+0xb4>
800099fa:	30 05       	mov	r5,0
800099fc:	78 d2       	ld.w	r2,r12[0x34]
      dif = OP_SUB(enc->min, enc->max);
800099fe:	06 9b       	mov	r11,r3
80009a00:	04 9c       	mov	r12,r2
80009a02:	e0 a0 02 ac 	rcall	80009f5a <fix16_sub>
      wrap = OP_ADD(wrap, dif);
80009a06:	18 9b       	mov	r11,r12
  io_t wrap = 0;
  io_t dif = 0;
  if (enc->wrap) { // wrapping...
    // if value needs wrapping, output the applied difference
    while (enc->val > enc->max) { 
      dif = OP_SUB(enc->min, enc->max);
80009a08:	18 96       	mov	r6,r12
      wrap = OP_ADD(wrap, dif);
80009a0a:	0a 9c       	mov	r12,r5
80009a0c:	e0 a0 02 9a 	rcall	80009f40 <fix16_add>
      enc->val = OP_ADD(enc->val, dif);
80009a10:	0c 9b       	mov	r11,r6
  io_t dif = 0;
  if (enc->wrap) { // wrapping...
    // if value needs wrapping, output the applied difference
    while (enc->val > enc->max) { 
      dif = OP_SUB(enc->min, enc->max);
      wrap = OP_ADD(wrap, dif);
80009a12:	18 95       	mov	r5,r12
      enc->val = OP_ADD(enc->val, dif);
80009a14:	0e 9c       	mov	r12,r7
80009a16:	e0 a0 02 95 	rcall	80009f40 <fix16_add>
80009a1a:	89 ac       	st.w	r4[0x28],r12
80009a1c:	18 97       	mov	r7,r12
static void op_enc_perform(op_enc_t* enc){ 
  io_t wrap = 0;
  io_t dif = 0;
  if (enc->wrap) { // wrapping...
    // if value needs wrapping, output the applied difference
    while (enc->val > enc->max) { 
80009a1e:	18 33       	cp.w	r3,r12
80009a20:	ce f5       	brlt	800099fe <op_enc_perform+0x1a>
      dif = OP_SUB(enc->min, enc->max);
      wrap = OP_ADD(wrap, dif);
      enc->val = OP_ADD(enc->val, dif);
    }
    while (enc->val < enc->min) { 
80009a22:	0e 32       	cp.w	r2,r7
80009a24:	e0 8a 00 15 	brle	80009a4e <op_enc_perform+0x6a>
      dif = OP_SUB(enc->max, enc->min);
80009a28:	04 9b       	mov	r11,r2
80009a2a:	06 9c       	mov	r12,r3
80009a2c:	e0 a0 02 97 	rcall	80009f5a <fix16_sub>
      wrap = OP_ADD(wrap, dif);
80009a30:	18 9b       	mov	r11,r12
      dif = OP_SUB(enc->min, enc->max);
      wrap = OP_ADD(wrap, dif);
      enc->val = OP_ADD(enc->val, dif);
    }
    while (enc->val < enc->min) { 
      dif = OP_SUB(enc->max, enc->min);
80009a32:	18 96       	mov	r6,r12
      wrap = OP_ADD(wrap, dif);
80009a34:	0a 9c       	mov	r12,r5
80009a36:	e0 a0 02 85 	rcall	80009f40 <fix16_add>
      enc->val = OP_ADD(enc->val, dif);
80009a3a:	0c 9b       	mov	r11,r6
      wrap = OP_ADD(wrap, dif);
      enc->val = OP_ADD(enc->val, dif);
    }
    while (enc->val < enc->min) { 
      dif = OP_SUB(enc->max, enc->min);
      wrap = OP_ADD(wrap, dif);
80009a3c:	18 95       	mov	r5,r12
      enc->val = OP_ADD(enc->val, dif);
80009a3e:	0e 9c       	mov	r12,r7
80009a40:	e0 a0 02 80 	rcall	80009f40 <fix16_add>
80009a44:	89 ac       	st.w	r4[0x28],r12
80009a46:	18 97       	mov	r7,r12
    while (enc->val > enc->max) { 
      dif = OP_SUB(enc->min, enc->max);
      wrap = OP_ADD(wrap, dif);
      enc->val = OP_ADD(enc->val, dif);
    }
    while (enc->val < enc->min) { 
80009a48:	18 32       	cp.w	r2,r12
80009a4a:	fe 99 ff ef 	brgt	80009a28 <op_enc_perform+0x44>
      enc->val = enc->min;
      dif = -1; // force wrap output
    }
  }
  // output the value
  net_activate(enc->outs[0], enc->val);
80009a4e:	0e 9b       	mov	r11,r7
80009a50:	e9 0c 00 54 	ld.sh	r12,r4[84]
80009a54:	fe b0 fb 24 	rcall	8000909c <net_activate>

  // output the wrap amount
  if (dif != 0) {
80009a58:	58 06       	cp.w	r6,0
80009a5a:	c1 61       	brne	80009a86 <op_enc_perform+0xa2>
80009a5c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
      dif = OP_SUB(enc->max, enc->min);
      wrap = OP_ADD(wrap, dif);
      enc->val = OP_ADD(enc->val, dif);
    }
  } else { // saturating...
    if (enc->val > enc->max) {
80009a60:	78 a8       	ld.w	r8,r12[0x28]
80009a62:	78 e7       	ld.w	r7,r12[0x38]
80009a64:	0e 38       	cp.w	r8,r7
80009a66:	f0 07 17 a0 	movle	r7,r8
      enc->val = enc->max;
80009a6a:	e9 f7 9a 0a 	st.wgt	r4[0x28],r7
80009a6e:	f9 b6 09 01 	movgt	r6,1
      dif = 1; // force wrap output
    }
    if (enc->val < enc->min) {
80009a72:	78 db       	ld.w	r11,r12[0x34]
80009a74:	0e 3b       	cp.w	r11,r7
80009a76:	e0 8a 00 0f 	brle	80009a94 <op_enc_perform+0xb0>
      enc->val = enc->min;
80009a7a:	99 ab       	st.w	r12[0x28],r11
      dif = -1; // force wrap output
    }
  }
  // output the value
  net_activate(enc->outs[0], enc->val);
80009a7c:	30 05       	mov	r5,0
80009a7e:	f9 0c 00 54 	ld.sh	r12,r12[84]
80009a82:	fe b0 fb 0d 	rcall	8000909c <net_activate>

  // output the wrap amount
  if (dif != 0) {
    net_activate(enc->outs[1], wrap);  
80009a86:	0a 9b       	mov	r11,r5
80009a88:	e9 0c 00 56 	ld.sh	r12,r4[86]
80009a8c:	fe b0 fb 08 	rcall	8000909c <net_activate>
80009a90:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
      enc->val = enc->min;
      dif = -1; // force wrap output
    }
  }
  // output the value
  net_activate(enc->outs[0], enc->val);
80009a94:	30 05       	mov	r5,0
80009a96:	cd cb       	rjmp	80009a4e <op_enc_perform+0x6a>
static void op_enc_perform(op_enc_t* enc){ 
  io_t wrap = 0;
  io_t dif = 0;
  if (enc->wrap) { // wrapping...
    // if value needs wrapping, output the applied difference
    while (enc->val > enc->max) { 
80009a98:	30 06       	mov	r6,0
80009a9a:	78 d2       	ld.w	r2,r12[0x34]
80009a9c:	0c 95       	mov	r5,r6
80009a9e:	cc 2b       	rjmp	80009a22 <op_enc_perform+0x3e>

80009aa0 <op_enc_in_max>:
80009aa0:	d4 01       	pushm	lr
80009aa2:	76 08       	ld.w	r8,r11[0x0]
80009aa4:	99 e8       	st.w	r12[0x38],r8
80009aa6:	c9 ff       	rcall	800099e4 <op_enc_perform>
80009aa8:	d8 02       	popm	pc
80009aaa:	d7 03       	nop

80009aac <op_enc_in_min>:

// max
static void op_enc_in_max(op_enc_t* enc, const io_t* v) {
  enc->max = *v;
  op_enc_perform(enc);
}
80009aac:	d4 01       	pushm	lr
80009aae:	76 08       	ld.w	r8,r11[0x0]
  op_enc_perform(enc);
}

// max
static void op_enc_in_min(op_enc_t* enc, const io_t* v) {
  enc->min = *v;
80009ab0:	99 d8       	st.w	r12[0x34],r8
  op_enc_perform(enc);
80009ab2:	c9 9f       	rcall	800099e4 <op_enc_perform>
80009ab4:	d8 02       	popm	pc
}
80009ab6:	d7 03       	nop

80009ab8 <op_enc_in_move>:
80009ab8:	eb cd 40 80 	pushm	r7,lr
  enc->step = *v;
  // op_enc_perform(enc);
}

// move
static void op_enc_in_move(op_enc_t* enc, const io_t* v) {
80009abc:	18 97       	mov	r7,r12
  //  enc->val += enc->step * (*v); 
  enc->val = OP_ADD(enc->val, OP_MUL(enc->step, *v));
80009abe:	76 0b       	ld.w	r11,r11[0x0]
80009ac0:	78 cc       	ld.w	r12,r12[0x30]
80009ac2:	e0 a0 02 5a 	rcall	80009f76 <fix16_mul>
80009ac6:	18 9b       	mov	r11,r12
80009ac8:	6e ac       	ld.w	r12,r7[0x28]
80009aca:	e0 a0 02 3b 	rcall	80009f40 <fix16_add>
80009ace:	8f ac       	st.w	r7[0x28],r12
  op_enc_perform(enc);
80009ad0:	0e 9c       	mov	r12,r7
80009ad2:	c8 9f       	rcall	800099e4 <op_enc_perform>
80009ad4:	e3 cd 80 80 	ldm	sp++,r7,pc

80009ad8 <op_enc_inc_input>:
}
80009ad8:	eb cd 40 80 	pushm	r7,lr
80009adc:	30 28       	mov	r8,2
80009ade:	18 97       	mov	r7,r12
80009ae0:	f0 0b 19 00 	cp.h	r11,r8
80009ae4:	c3 30       	breq	80009b4a <op_enc_inc_input+0x72>
80009ae6:	e0 8a 00 0c 	brle	80009afe <op_enc_inc_input+0x26>
}

//===== UI input
static void op_enc_inc_input(op_enc_t* enc, const s16 idx, const io_t inc) {
  io_t val;
  switch(idx) {
80009aea:	30 38       	mov	r8,3
80009aec:	f0 0b 19 00 	cp.h	r11,r8
80009af0:	c3 50       	breq	80009b5a <op_enc_inc_input+0x82>
80009af2:	30 48       	mov	r8,4
80009af4:	f0 0b 19 00 	cp.h	r11,r8
80009af8:	c1 40       	breq	80009b20 <op_enc_inc_input+0x48>
80009afa:	e3 cd 80 80 	ldm	sp++,r7,pc
80009afe:	30 08       	mov	r8,0
80009b00:	f0 0b 19 00 	cp.h	r11,r8
80009b04:	c1 60       	breq	80009b30 <op_enc_inc_input+0x58>
80009b06:	30 18       	mov	r8,1
80009b08:	f0 0b 19 00 	cp.h	r11,r8
80009b0c:	cf 71       	brne	80009afa <op_enc_inc_input+0x22>
  case 0:  // move
    op_enc_in_move(enc, &inc);
    break; 
  case 1:  // min
    val = OP_ADD(enc->min, inc);
80009b0e:	14 9b       	mov	r11,r10
80009b10:	78 dc       	ld.w	r12,r12[0x34]
80009b12:	e0 a0 02 17 	rcall	80009f40 <fix16_add>
  op_enc_perform(enc);
}

// max
static void op_enc_in_min(op_enc_t* enc, const io_t* v) {
  enc->min = *v;
80009b16:	8f dc       	st.w	r7[0x34],r12
  op_enc_perform(enc);
80009b18:	0e 9c       	mov	r12,r7
80009b1a:	c6 5f       	rcall	800099e4 <op_enc_perform>
80009b1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b20:	58 0a       	cp.w	r10,0
}

// wrap behavior
static void op_enc_in_wrap(op_enc_t* enc, const io_t* v) {
  //  enc->wrap = (*v > 0);
  if(*v > 0) { enc->wrap = OP_ONE; } else { enc->wrap = 0; }
80009b22:	e0 8a 00 22 	brle	80009b66 <op_enc_inc_input+0x8e>
80009b26:	e0 78 00 00 	mov	r8,65536
80009b2a:	99 f8       	st.w	r12[0x3c],r8
80009b2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b30:	14 9b       	mov	r11,r10
}

// move
static void op_enc_in_move(op_enc_t* enc, const io_t* v) {
  //  enc->val += enc->step * (*v); 
  enc->val = OP_ADD(enc->val, OP_MUL(enc->step, *v));
80009b32:	78 cc       	ld.w	r12,r12[0x30]
80009b34:	e0 a0 02 21 	rcall	80009f76 <fix16_mul>
80009b38:	18 9b       	mov	r11,r12
80009b3a:	6e ac       	ld.w	r12,r7[0x28]
80009b3c:	e0 a0 02 02 	rcall	80009f40 <fix16_add>
80009b40:	8f ac       	st.w	r7[0x28],r12
80009b42:	0e 9c       	mov	r12,r7
  op_enc_perform(enc);
80009b44:	c5 0f       	rcall	800099e4 <op_enc_perform>
80009b46:	e3 cd 80 80 	ldm	sp++,r7,pc
static void op_enc_inc_input(op_enc_t* enc, const s16 idx, const io_t inc) {
  io_t val;
  switch(idx) {
  case 0:  // move
    op_enc_in_move(enc, &inc);
    break; 
80009b4a:	14 9b       	mov	r11,r10
80009b4c:	78 ec       	ld.w	r12,r12[0x38]
  case 1:  // min
    val = OP_ADD(enc->min, inc);
    op_enc_in_min(enc, &val);
    break;
  case 2:  // max
    val = OP_ADD(enc->max, inc);
80009b4e:	cf 9d       	rcall	80009f40 <fix16_add>
80009b50:	8f ec       	st.w	r7[0x38],r12
80009b52:	0e 9c       	mov	r12,r7
80009b54:	c4 8f       	rcall	800099e4 <op_enc_perform>
  op_enc_perform(enc);
}

// max
static void op_enc_in_max(op_enc_t* enc, const io_t* v) {
  enc->max = *v;
80009b56:	e3 cd 80 80 	ldm	sp++,r7,pc
  op_enc_perform(enc);
80009b5a:	78 cc       	ld.w	r12,r12[0x30]
80009b5c:	14 9b       	mov	r11,r10
80009b5e:	cf 1d       	rcall	80009f40 <fix16_add>
80009b60:	8f cc       	st.w	r7[0x30],r12
  case 2:  // max
    val = OP_ADD(enc->max, inc);
    op_enc_in_max(enc, &val);
    break;
  case 3: // step
    val = OP_ADD(enc->step, inc);
80009b62:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b66:	30 08       	mov	r8,0
80009b68:	99 f8       	st.w	r12[0x3c],r8
//----- static function definitions

//======= operator input
// step
static void op_enc_in_step(op_enc_t* enc, const io_t* v) {
  enc->step = *v;
80009b6a:	cc 8b       	rjmp	80009afa <op_enc_inc_input+0x22>

80009b6c <op_gate_init>:
};

//-------------------------------------------------
//----- external function definitions
void op_gate_init(op_gate_t* gate) {
  gate->super.numInputs = 3;
80009b6c:	30 38       	mov	r8,3
80009b6e:	b8 88       	st.b	r12[0x0],r8
  gate->super.numOutputs = 1;
80009b70:	30 18       	mov	r8,1
80009b72:	b8 98       	st.b	r12[0x1],r8
  gate->outs[0] = -1;
80009b74:	3f f8       	mov	r8,-1
80009b76:	f9 58 00 40 	st.h	r12[64],r8
  gate->super.inc_func = (op_inc_func)op_gate_inc_input;
80009b7a:	fe c8 ff 5a 	sub	r8,pc,-166
  gate->super.in_func = op_gate_in_func;
80009b7e:	99 18       	st.w	r12[0x4],r8
80009b80:	34 c8       	mov	r8,76
  gate->super.in_val = gate->in_val;
80009b82:	99 28       	st.w	r12[0x8],r8
80009b84:	f8 c8 ff cc 	sub	r8,r12,-52
  gate->super.out = gate->outs;
80009b88:	99 38       	st.w	r12[0xc],r8
80009b8a:	f8 c8 ff c0 	sub	r8,r12,-64
  gate->super.opString = op_gate_opstring;
80009b8e:	99 48       	st.w	r12[0x10],r8
80009b90:	48 c8       	lddpc	r8,80009bc0 <op_gate_init+0x54>
80009b92:	70 08       	ld.w	r8,r8[0x0]
  gate->super.inString = op_gate_instring;
80009b94:	99 58       	st.w	r12[0x14],r8
80009b96:	48 c8       	lddpc	r8,80009bc4 <op_gate_init+0x58>
80009b98:	70 08       	ld.w	r8,r8[0x0]
  gate->super.outString = op_gate_outstring;
80009b9a:	99 68       	st.w	r12[0x18],r8
80009b9c:	48 b8       	lddpc	r8,80009bc8 <op_gate_init+0x5c>
80009b9e:	70 08       	ld.w	r8,r8[0x0]
  gate->super.type = eOpGate;  
80009ba0:	99 78       	st.w	r12[0x1c],r8
80009ba2:	30 48       	mov	r8,4
80009ba4:	f9 68 00 20 	st.b	r12[32],r8
  gate->super.status = eUserOp;
80009ba8:	30 08       	mov	r8,0

  gate->in_val[0] = &(gate->val);
80009baa:	99 98       	st.w	r12[0x24],r8
80009bac:	f8 c8 ff d8 	sub	r8,r12,-40
  gate->in_val[1] = &(gate->gate);
80009bb0:	99 d8       	st.w	r12[0x34],r8
80009bb2:	f8 c8 ff d4 	sub	r8,r12,-44
  gate->in_val[2] = &(gate->store);
80009bb6:	99 e8       	st.w	r12[0x38],r8
80009bb8:	f8 c8 ff d0 	sub	r8,r12,-48
}
80009bbc:	99 f8       	st.w	r12[0x3c],r8
80009bbe:	5e fc       	retal	r12
80009bc0:	80 01       	ld.sh	r1,r0[0x0]
80009bc2:	4a e4       	lddpc	r4,80009c78 <op_gate_inc_input+0x58>
80009bc4:	80 01       	ld.sh	r1,r0[0x0]
80009bc6:	4a e0       	lddpc	r0,80009c7c <op_gate_inc_input+0x5c>
80009bc8:	80 01       	ld.sh	r1,r0[0x0]
80009bca:	4a dc       	lddpc	r12,80009c7c <op_gate_inc_input+0x5c>

80009bcc <op_gate_in_store>:
80009bcc:	76 08       	ld.w	r8,r11[0x0]
80009bce:	58 08       	cp.w	r8,0
80009bd0:	e0 8a 00 05 	brle	80009bda <op_gate_in_store+0xe>
  }
}

static void op_gate_in_store(op_gate_t* gate, const io_t* v) {
  //  gate->store = (*v != 0);
  if(*v > 0) { gate->store = 1; } else { gate->store = 0; }
80009bd4:	30 18       	mov	r8,1
80009bd6:	99 c8       	st.w	r12[0x30],r8
80009bd8:	5e fc       	retal	r12
80009bda:	30 08       	mov	r8,0
80009bdc:	99 c8       	st.w	r12[0x30],r8
80009bde:	5e fc       	retal	r12

80009be0 <op_gate_in_gate>:
  if(gate->gate != 0) {
    net_activate(gate->outs[0], gate->val);
  }
}

static void op_gate_in_gate(op_gate_t* gate, const io_t* v) {
80009be0:	d4 01       	pushm	lr
80009be2:	18 98       	mov	r8,r12
  //  gate->gate = (io_t)(*v != 0);
  if(*v > 0) { gate->gate = 1; } else { gate->gate = 0; }
80009be4:	76 09       	ld.w	r9,r11[0x0]
80009be6:	58 09       	cp.w	r9,0
80009be8:	e0 8a 00 0d 	brle	80009c02 <op_gate_in_gate+0x22>
80009bec:	30 19       	mov	r9,1
80009bee:	99 b9       	st.w	r12[0x2c],r9
  if (gate->store) {
80009bf0:	70 c9       	ld.w	r9,r8[0x30]
80009bf2:	58 09       	cp.w	r9,0
80009bf4:	c0 60       	breq	80009c00 <op_gate_in_gate+0x20>
    net_activate(gate->outs[0], gate->val);
80009bf6:	f1 0c 00 40 	ld.sh	r12,r8[64]
80009bfa:	70 ab       	ld.w	r11,r8[0x28]
80009bfc:	fe b0 fa 50 	rcall	8000909c <net_activate>
80009c00:	d8 02       	popm	pc
  }
}

static void op_gate_in_gate(op_gate_t* gate, const io_t* v) {
  //  gate->gate = (io_t)(*v != 0);
  if(*v > 0) { gate->gate = 1; } else { gate->gate = 0; }
80009c02:	30 09       	mov	r9,0
80009c04:	99 b9       	st.w	r12[0x2c],r9
80009c06:	cf 5b       	rjmp	80009bf0 <op_gate_in_gate+0x10>

80009c08 <op_gate_in_value>:
80009c08:	d4 01       	pushm	lr
80009c0a:	76 0b       	ld.w	r11,r11[0x0]
}

//-------------------------------------------------
//----- static function definitions
static void op_gate_in_value(op_gate_t* gate, const io_t* v) {
  gate->val = *v;
80009c0c:	99 ab       	st.w	r12[0x28],r11
  if(gate->gate != 0) {
80009c0e:	78 b8       	ld.w	r8,r12[0x2c]
80009c10:	58 08       	cp.w	r8,0
80009c12:	c0 50       	breq	80009c1c <op_gate_in_value+0x14>
    net_activate(gate->outs[0], gate->val);
80009c14:	f9 0c 00 40 	ld.sh	r12,r12[64]
80009c18:	fe b0 fa 42 	rcall	8000909c <net_activate>
80009c1c:	d8 02       	popm	pc
80009c1e:	d7 03       	nop

80009c20 <op_gate_inc_input>:
80009c20:	eb cd 40 80 	pushm	r7,lr
  if(*v > 0) { gate->store = 1; } else { gate->store = 0; }
}

static void op_gate_inc_input(op_gate_t* gate, const s16 idx, const io_t inc) {
  io_t val;
  switch(idx) {
80009c24:	30 18       	mov	r8,1
static void op_gate_in_store(op_gate_t* gate, const io_t* v) {
  //  gate->store = (*v != 0);
  if(*v > 0) { gate->store = 1; } else { gate->store = 0; }
}

static void op_gate_inc_input(op_gate_t* gate, const s16 idx, const io_t inc) {
80009c26:	18 97       	mov	r7,r12
  io_t val;
  switch(idx) {
80009c28:	f0 0b 19 00 	cp.h	r11,r8
80009c2c:	c2 00       	breq	80009c6c <op_gate_inc_input+0x4c>
80009c2e:	30 28       	mov	r8,2
80009c30:	f0 0b 19 00 	cp.h	r11,r8
80009c34:	c1 50       	breq	80009c5e <op_gate_inc_input+0x3e>
80009c36:	30 08       	mov	r8,0
80009c38:	f0 0b 19 00 	cp.h	r11,r8
80009c3c:	c0 30       	breq	80009c42 <op_gate_inc_input+0x22>
80009c3e:	e3 cd 80 80 	ldm	sp++,r7,pc
  case 0:  // value
      val = OP_ADD(gate->val, inc);
80009c42:	78 ac       	ld.w	r12,r12[0x28]
80009c44:	14 9b       	mov	r11,r10
80009c46:	c7 dd       	rcall	80009f40 <fix16_add>
80009c48:	8f ac       	st.w	r7[0x28],r12
}

//-------------------------------------------------
//----- static function definitions
static void op_gate_in_value(op_gate_t* gate, const io_t* v) {
  gate->val = *v;
80009c4a:	6e b8       	ld.w	r8,r7[0x2c]
  if(gate->gate != 0) {
80009c4c:	58 08       	cp.w	r8,0
80009c4e:	cf 80       	breq	80009c3e <op_gate_inc_input+0x1e>
80009c50:	18 9b       	mov	r11,r12
    net_activate(gate->outs[0], gate->val);
80009c52:	ef 0c 00 40 	ld.sh	r12,r7[64]
80009c56:	fe b0 fa 23 	rcall	8000909c <net_activate>
80009c5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009c5e:	58 0a       	cp.w	r10,0
  }
}

static void op_gate_in_store(op_gate_t* gate, const io_t* v) {
  //  gate->store = (*v != 0);
  if(*v > 0) { gate->store = 1; } else { gate->store = 0; }
80009c60:	e0 8a 00 19 	brle	80009c92 <op_gate_inc_input+0x72>
80009c64:	30 18       	mov	r8,1
80009c66:	99 c8       	st.w	r12[0x30],r8
80009c68:	e3 cd 80 80 	ldm	sp++,r7,pc
80009c6c:	58 0a       	cp.w	r10,0
  }
}

static void op_gate_in_gate(op_gate_t* gate, const io_t* v) {
  //  gate->gate = (io_t)(*v != 0);
  if(*v > 0) { gate->gate = 1; } else { gate->gate = 0; }
80009c6e:	f9 b8 09 01 	movgt	r8,1
80009c72:	f9 f8 9a 0b 	st.wgt	r12[0x2c],r8
80009c76:	f9 b8 0a 00 	movle	r8,0
80009c7a:	f9 f8 aa 0b 	st.wle	r12[0x2c],r8
80009c7e:	78 c8       	ld.w	r8,r12[0x30]
  if (gate->store) {
80009c80:	58 08       	cp.w	r8,0
80009c82:	cd e0       	breq	80009c3e <op_gate_inc_input+0x1e>
80009c84:	f9 0c 00 40 	ld.sh	r12,r12[64]
    net_activate(gate->outs[0], gate->val);
80009c88:	6e ab       	ld.w	r11,r7[0x28]
80009c8a:	fe b0 fa 09 	rcall	8000909c <net_activate>
80009c8e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009c92:	30 08       	mov	r8,0
  }
}

static void op_gate_in_store(op_gate_t* gate, const io_t* v) {
  //  gate->store = (*v != 0);
  if(*v > 0) { gate->store = 1; } else { gate->store = 0; }
80009c94:	99 c8       	st.w	r12[0x30],r8
80009c96:	cd 4b       	rjmp	80009c3e <op_gate_inc_input+0x1e>

80009c98 <op_mul_init>:
static const char* op_mul_opstring  = "MUL";

//-------------------------------------------------
//----- external function definitions
void op_mul_init(op_mul_t* mul) {
  mul->super.numInputs = 3;
80009c98:	30 38       	mov	r8,3
  mul->super.in_val = mul->in_val;
  mul->super.out = mul->outs;
  mul->super.opString = op_mul_opstring;
  mul->super.inString = op_mul_instring;
  mul->super.outString = op_mul_outstring;
  mul->super.type = eOpMul;  
80009c9a:	f9 68 00 20 	st.b	r12[32],r8
static const char* op_mul_opstring  = "MUL";

//-------------------------------------------------
//----- external function definitions
void op_mul_init(op_mul_t* mul) {
  mul->super.numInputs = 3;
80009c9e:	b8 88       	st.b	r12[0x0],r8
  mul->super.numOutputs = 1;
80009ca0:	30 18       	mov	r8,1
80009ca2:	b8 98       	st.b	r12[0x1],r8
  mul->outs[0] = -1;
  mul->super.inc_func = (op_inc_func)op_mul_inc_input;
80009ca4:	fe c8 ff 58 	sub	r8,pc,-168
  mul->super.in_func = op_mul_in_func;
80009ca8:	99 18       	st.w	r12[0x4],r8
80009caa:	35 88       	mov	r8,88
  mul->super.in_val = mul->in_val;
80009cac:	99 28       	st.w	r12[0x8],r8
80009cae:	f8 c8 ff c8 	sub	r8,r12,-56
  mul->super.out = mul->outs;
80009cb2:	99 38       	st.w	r12[0xc],r8
80009cb4:	f8 c8 ff c0 	sub	r8,r12,-64
  mul->super.opString = op_mul_opstring;
80009cb8:	99 48       	st.w	r12[0x10],r8
80009cba:	48 c8       	lddpc	r8,80009ce8 <op_mul_init+0x50>
80009cbc:	70 08       	ld.w	r8,r8[0x0]
  mul->super.inString = op_mul_instring;
80009cbe:	99 58       	st.w	r12[0x14],r8
80009cc0:	48 b8       	lddpc	r8,80009cec <op_mul_init+0x54>
80009cc2:	70 08       	ld.w	r8,r8[0x0]
  mul->super.outString = op_mul_outstring;
80009cc4:	99 68       	st.w	r12[0x18],r8
80009cc6:	48 b8       	lddpc	r8,80009cf0 <op_mul_init+0x58>
80009cc8:	70 08       	ld.w	r8,r8[0x0]
  mul->super.type = eOpMul;  
  mul->super.status = eUserOp;  
80009cca:	99 78       	st.w	r12[0x1c],r8
80009ccc:	30 08       	mov	r8,0
 
  mul->in_val[0] = &(mul->a);
80009cce:	99 98       	st.w	r12[0x24],r8
80009cd0:	f8 c8 ff d4 	sub	r8,r12,-44
  mul->in_val[1] = &(mul->b);
80009cd4:	99 e8       	st.w	r12[0x38],r8
80009cd6:	f8 c8 ff d0 	sub	r8,r12,-48
  mul->in_val[2] = &(mul->btrig);
80009cda:	99 f8       	st.w	r12[0x3c],r8
80009cdc:	f8 c8 ff cc 	sub	r8,r12,-52
80009ce0:	f9 48 00 40 	st.w	r12[64],r8
}
80009ce4:	5e fc       	retal	r12
80009ce6:	d7 03       	nop
80009ce8:	80 01       	ld.sh	r1,r0[0x0]
80009cea:	4a fc       	lddpc	r12,80009da4 <op_mul_inc_input+0x58>
80009cec:	80 01       	ld.sh	r1,r0[0x0]
80009cee:	4a f8       	lddpc	r8,80009da8 <op_mul_inc_input+0x5c>
80009cf0:	80 01       	ld.sh	r1,r0[0x0]
80009cf2:	4a f4       	lddpc	r4,80009dac <op_mul_inc_input+0x60>

80009cf4 <op_mul_in_btrig>:
80009cf4:	76 08       	ld.w	r8,r11[0x0]
80009cf6:	58 08       	cp.w	r8,0
}

// set b-trigger mode
static void op_mul_in_btrig(op_mul_t* mul, const io_t* v) {
  //printf("mul at %d received BTRIG %d\n", (int)mul, (int)*v);
  if(*v > 0) { mul->btrig = OP_ONE; } { mul->btrig = 0; }
80009cf8:	e0 8a 00 05 	brle	80009d02 <op_mul_in_btrig+0xe>
80009cfc:	e0 78 00 00 	mov	r8,65536
80009d00:	99 d8       	st.w	r12[0x34],r8
80009d02:	30 08       	mov	r8,0
80009d04:	99 d8       	st.w	r12[0x34],r8
}
80009d06:	5e fc       	retal	r12

80009d08 <op_mul_in_b>:
  mul->val = OP_MUL(mul->a, mul->b);
  net_activate(mul->outs[0], mul->val);
}

// set operand B
static void op_mul_in_b(op_mul_t* mul, const io_t* v) {
80009d08:	eb cd 40 80 	pushm	r7,lr
80009d0c:	18 97       	mov	r7,r12
  //printf("mul at %d received B %d\n", (int)mul, (int)*v);
  mul->b = *v;
80009d0e:	76 0b       	ld.w	r11,r11[0x0]
80009d10:	99 cb       	st.w	r12[0x30],r11
  mul->val = OP_MUL(mul->a, mul->b);
80009d12:	78 bc       	ld.w	r12,r12[0x2c]
80009d14:	c3 1d       	rcall	80009f76 <fix16_mul>
80009d16:	8f ac       	st.w	r7[0x28],r12
80009d18:	6e d8       	ld.w	r8,r7[0x34]
  if(mul->btrig) {
80009d1a:	58 08       	cp.w	r8,0
80009d1c:	c0 60       	breq	80009d28 <op_mul_in_b+0x20>
80009d1e:	18 9b       	mov	r11,r12
    net_activate(mul->outs[0], mul->val);
80009d20:	ef 0c 00 40 	ld.sh	r12,r7[64]
80009d24:	fe b0 f9 bc 	rcall	8000909c <net_activate>
80009d28:	e3 cd 80 80 	ldm	sp++,r7,pc

80009d2c <op_mul_in_a>:
80009d2c:	eb cd 40 80 	pushm	r7,lr
80009d30:	18 97       	mov	r7,r12
80009d32:	76 0c       	ld.w	r12,r11[0x0]
80009d34:	6e cb       	ld.w	r11,r7[0x30]
80009d36:	8f bc       	st.w	r7[0x2c],r12
//----- static function definitions
// set operand A
static void op_mul_in_a(op_mul_t* mul, const io_t* v) {
  // printf("mul at %d received A %d\n", (int)mul, (int)*v);
  mul->a = *v;
  mul->val = OP_MUL(mul->a, mul->b);
80009d38:	c1 fd       	rcall	80009f76 <fix16_mul>
80009d3a:	18 9b       	mov	r11,r12
80009d3c:	ef 0c 00 40 	ld.sh	r12,r7[64]
  net_activate(mul->outs[0], mul->val);
80009d40:	8f ab       	st.w	r7[0x28],r11
//----- static function definitions
// set operand A
static void op_mul_in_a(op_mul_t* mul, const io_t* v) {
  // printf("mul at %d received A %d\n", (int)mul, (int)*v);
  mul->a = *v;
  mul->val = OP_MUL(mul->a, mul->b);
80009d42:	fe b0 f9 ad 	rcall	8000909c <net_activate>
  net_activate(mul->outs[0], mul->val);
80009d46:	e3 cd 80 80 	ldm	sp++,r7,pc
}
80009d4a:	d7 03       	nop

80009d4c <op_mul_inc_input>:
80009d4c:	eb cd 40 80 	pushm	r7,lr
80009d50:	30 18       	mov	r8,1
80009d52:	18 97       	mov	r7,r12
}

//===== UI input
static void op_mul_inc_input(op_mul_t* mul, const s16 idx, const io_t inc) {
  io_t val;
  switch(idx) {
80009d54:	f0 0b 19 00 	cp.h	r11,r8
80009d58:	c2 30       	breq	80009d9e <op_mul_inc_input+0x52>
80009d5a:	30 28       	mov	r8,2
80009d5c:	f0 0b 19 00 	cp.h	r11,r8
80009d60:	c1 50       	breq	80009d8a <op_mul_inc_input+0x3e>
80009d62:	30 08       	mov	r8,0
80009d64:	f0 0b 19 00 	cp.h	r11,r8
80009d68:	c0 30       	breq	80009d6e <op_mul_inc_input+0x22>
80009d6a:	e3 cd 80 80 	ldm	sp++,r7,pc
  case 0:  // a
    val = OP_ADD(mul->a, inc);
80009d6e:	14 9b       	mov	r11,r10
80009d70:	78 bc       	ld.w	r12,r12[0x2c]
80009d72:	ce 7c       	rcall	80009f40 <fix16_add>
80009d74:	6e cb       	ld.w	r11,r7[0x30]
//----- static function definitions
// set operand A
static void op_mul_in_a(op_mul_t* mul, const io_t* v) {
  // printf("mul at %d received A %d\n", (int)mul, (int)*v);
  mul->a = *v;
  mul->val = OP_MUL(mul->a, mul->b);
80009d76:	8f bc       	st.w	r7[0x2c],r12
//-------------------------------------------------
//----- static function definitions
// set operand A
static void op_mul_in_a(op_mul_t* mul, const io_t* v) {
  // printf("mul at %d received A %d\n", (int)mul, (int)*v);
  mul->a = *v;
80009d78:	cf fc       	rcall	80009f76 <fix16_mul>
  mul->val = OP_MUL(mul->a, mul->b);
80009d7a:	18 9b       	mov	r11,r12
80009d7c:	ef 0c 00 40 	ld.sh	r12,r7[64]
  net_activate(mul->outs[0], mul->val);
80009d80:	8f ab       	st.w	r7[0x28],r11
80009d82:	fe b0 f9 8d 	rcall	8000909c <net_activate>
80009d86:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d8a:	58 0a       	cp.w	r10,0
80009d8c:	e0 8a 00 05 	brle	80009d96 <op_mul_inc_input+0x4a>
}

// set b-trigger mode
static void op_mul_in_btrig(op_mul_t* mul, const io_t* v) {
  //printf("mul at %d received BTRIG %d\n", (int)mul, (int)*v);
  if(*v > 0) { mul->btrig = OP_ONE; } { mul->btrig = 0; }
80009d90:	e0 78 00 00 	mov	r8,65536
80009d94:	99 d8       	st.w	r12[0x34],r8
80009d96:	30 08       	mov	r8,0
80009d98:	8f d8       	st.w	r7[0x34],r8
80009d9a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d9e:	14 9b       	mov	r11,r10
80009da0:	78 cc       	ld.w	r12,r12[0x30]
  case 0:  // a
    val = OP_ADD(mul->a, inc);
    op_mul_in_a(mul, &val);
    break; 
  case 1:  // b
    val = OP_ADD(mul->b, inc);
80009da2:	cc fc       	rcall	80009f40 <fix16_add>
80009da4:	18 9b       	mov	r11,r12
80009da6:	8f cc       	st.w	r7[0x30],r12
80009da8:	6e bc       	ld.w	r12,r7[0x2c]
80009daa:	ce 6c       	rcall	80009f76 <fix16_mul>
}

// set operand B
static void op_mul_in_b(op_mul_t* mul, const io_t* v) {
  //printf("mul at %d received B %d\n", (int)mul, (int)*v);
  mul->b = *v;
80009dac:	8f ac       	st.w	r7[0x28],r12
  mul->val = OP_MUL(mul->a, mul->b);
80009dae:	6e d8       	ld.w	r8,r7[0x34]
80009db0:	58 08       	cp.w	r8,0
80009db2:	cd c0       	breq	80009d6a <op_mul_inc_input+0x1e>
80009db4:	18 9b       	mov	r11,r12
  if(mul->btrig) {
80009db6:	ef 0c 00 40 	ld.sh	r12,r7[64]
80009dba:	fe b0 f9 71 	rcall	8000909c <net_activate>
    net_activate(mul->outs[0], mul->val);
80009dbe:	e3 cd 80 80 	ldm	sp++,r7,pc
80009dc2:	d7 03       	nop

80009dc4 <op_sw_init>:
  sw->super.opString = op_sw_opstring;
  sw->super.inString = op_sw_instring;
  sw->super.outString = op_sw_outstring;
  sw->super.type = eOpSwitch;
  sw->super.status = eSysCtlOp;
  sw->state = 0;
80009dc4:	30 08       	mov	r8,0
  sw->mul = OP_ONE;
  sw->tog = 0;
80009dc6:	99 c8       	st.w	r12[0x30],r8
  sw->super.opString = op_sw_opstring;
  sw->super.inString = op_sw_instring;
  sw->super.outString = op_sw_outstring;
  sw->super.type = eOpSwitch;
  sw->super.status = eSysCtlOp;
  sw->state = 0;
80009dc8:	99 a8       	st.w	r12[0x28],r8
//---------------------------------------------
//----- external function definition

/// initialize
void op_sw_init(op_sw_t* sw) {
  sw->super.numInputs = 3;
80009dca:	30 38       	mov	r8,3
80009dcc:	b8 88       	st.b	r12[0x0],r8
  sw->super.numOutputs = 1;
80009dce:	30 18       	mov	r8,1
80009dd0:	b8 98       	st.b	r12[0x1],r8
  sw->outs[0] = -1;
80009dd2:	3f f8       	mov	r8,-1
80009dd4:	f9 58 00 40 	st.h	r12[64],r8
  sw->super.inc_func = (op_inc_func)op_sw_inc_func;
80009dd8:	fe c8 ff 24 	sub	r8,pc,-220
  sw->super.in_func = op_sw_in_func;
80009ddc:	99 18       	st.w	r12[0x4],r8
80009dde:	36 48       	mov	r8,100
  sw->super.in_val = sw->in_val;
80009de0:	99 28       	st.w	r12[0x8],r8
80009de2:	f8 c8 ff cc 	sub	r8,r12,-52
  sw->in_val[0] = &(sw->state);
80009de6:	99 38       	st.w	r12[0xc],r8
80009de8:	f8 c8 ff d8 	sub	r8,r12,-40
  sw->in_val[1] = &(sw->tog);
80009dec:	99 d8       	st.w	r12[0x34],r8
80009dee:	f8 c8 ff d0 	sub	r8,r12,-48
  sw->in_val[2] = &(sw->mul);
80009df2:	99 e8       	st.w	r12[0x38],r8
80009df4:	f8 c8 ff d4 	sub	r8,r12,-44
  sw->super.out = sw->outs;
80009df8:	99 f8       	st.w	r12[0x3c],r8
80009dfa:	f8 c8 ff c0 	sub	r8,r12,-64
  sw->super.opString = op_sw_opstring;
80009dfe:	99 48       	st.w	r12[0x10],r8
80009e00:	48 98       	lddpc	r8,80009e24 <op_sw_init+0x60>
80009e02:	70 08       	ld.w	r8,r8[0x0]
  sw->super.inString = op_sw_instring;
80009e04:	99 58       	st.w	r12[0x14],r8
80009e06:	48 98       	lddpc	r8,80009e28 <op_sw_init+0x64>
80009e08:	70 08       	ld.w	r8,r8[0x0]
  sw->super.outString = op_sw_outstring;
80009e0a:	99 68       	st.w	r12[0x18],r8
80009e0c:	48 88       	lddpc	r8,80009e2c <op_sw_init+0x68>
80009e0e:	70 08       	ld.w	r8,r8[0x0]
  sw->super.type = eOpSwitch;
80009e10:	99 78       	st.w	r12[0x1c],r8
80009e12:	30 08       	mov	r8,0
80009e14:	f9 68 00 20 	st.b	r12[32],r8
  sw->super.status = eSysCtlOp;
80009e18:	30 18       	mov	r8,1
  sw->state = 0;
  sw->mul = OP_ONE;
80009e1a:	99 98       	st.w	r12[0x24],r8
80009e1c:	e0 78 00 00 	mov	r8,65536
  sw->tog = 0;
}
80009e20:	99 b8       	st.w	r12[0x2c],r8
80009e22:	5e fc       	retal	r12
80009e24:	80 01       	ld.sh	r1,r0[0x0]
80009e26:	4b 04       	lddpc	r4,80009ee4 <op_sw_inc_func+0x30>
80009e28:	80 01       	ld.sh	r1,r0[0x0]
80009e2a:	4b 00       	lddpc	r0,80009ee8 <op_sw_inc_func+0x34>
80009e2c:	80 01       	ld.sh	r1,r0[0x0]
80009e2e:	4b 08       	lddpc	r8,80009eec <op_sw_inc_func+0x38>

80009e30 <op_sw_in_tog>:
80009e30:	76 08       	ld.w	r8,r11[0x0]
80009e32:	58 08       	cp.w	r8,0
80009e34:	e0 8a 00 06 	brle	80009e40 <op_sw_in_tog+0x10>
}

// input toggle mode
static void op_sw_in_tog(op_sw_t* sw, const io_t* v) {
  //  sw->tog = (io_t)(*v > 0);
  if (*v > 0) { sw->tog = OP_ONE; } else  { sw->tog = 0; } 
80009e38:	e0 78 00 00 	mov	r8,65536
80009e3c:	99 c8       	st.w	r12[0x30],r8
80009e3e:	5e fc       	retal	r12
80009e40:	30 08       	mov	r8,0
80009e42:	99 c8       	st.w	r12[0x30],r8
80009e44:	5e fc       	retal	r12
80009e46:	d7 03       	nop

80009e48 <op_sw_in_mul>:
  net_activate(sw->outs[0], sw->state);
  */
}

// input multiplier
static void op_sw_in_mul(op_sw_t* sw, const io_t* v) {
80009e48:	d4 01       	pushm	lr
  sw->mul = *v;
80009e4a:	76 09       	ld.w	r9,r11[0x0]
80009e4c:	99 b9       	st.w	r12[0x2c],r9
  net_activate(sw->outs[0], sw->state);
  */
}

// input multiplier
static void op_sw_in_mul(op_sw_t* sw, const io_t* v) {
80009e4e:	18 98       	mov	r8,r12
  sw->mul = *v;
  if (sw->state > 0) {
80009e50:	78 a9       	ld.w	r9,r12[0x28]
80009e52:	58 09       	cp.w	r9,0
80009e54:	e0 8a 00 08 	brle	80009e64 <op_sw_in_mul+0x1c>
    sw->state = *v;
80009e58:	76 0b       	ld.w	r11,r11[0x0]
    net_activate(sw->outs[0], sw->state);
80009e5a:	f9 0c 00 40 	ld.sh	r12,r12[64]

// input multiplier
static void op_sw_in_mul(op_sw_t* sw, const io_t* v) {
  sw->mul = *v;
  if (sw->state > 0) {
    sw->state = *v;
80009e5e:	91 ab       	st.w	r8[0x28],r11
    net_activate(sw->outs[0], sw->state);
80009e60:	fe b0 f9 1e 	rcall	8000909c <net_activate>
80009e64:	d8 02       	popm	pc
80009e66:	d7 03       	nop

80009e68 <op_sw_in_state>:
80009e68:	d4 01       	pushm	lr
80009e6a:	78 c8       	ld.w	r8,r12[0x30]

//===== operator input

// input state
static void op_sw_in_state(op_sw_t* sw, const io_t* v) {
  if (sw->tog) {
80009e6c:	58 08       	cp.w	r8,0
80009e6e:	c1 40       	breq	80009e96 <op_sw_in_state+0x2e>
    // toggle mode, sw state toggles on positive input
    if ( *v > 0) {
80009e70:	76 08       	ld.w	r8,r11[0x0]
80009e72:	58 08       	cp.w	r8,0
80009e74:	e0 8a 00 1b 	brle	80009eaa <op_sw_in_state+0x42>
      if (sw->state != 0) { 
80009e78:	78 a8       	ld.w	r8,r12[0x28]
	sw->state = 0; 
80009e7a:	58 08       	cp.w	r8,0
80009e7c:	f9 bb 01 00 	movne	r11,0
80009e80:	f9 fb 1a 0a 	st.wne	r12[0x28],r11
      } else {
	sw->state = sw->mul;
80009e84:	f9 fb 00 0b 	ld.weq	r11,r12[0x2c]
80009e88:	f9 fb 0a 0a 	st.weq	r12[0x28],r11
      }
      net_activate(sw->outs[0], sw->state);
80009e8c:	f9 0c 00 40 	ld.sh	r12,r12[64]
80009e90:	fe b0 f9 06 	rcall	8000909c <net_activate>
80009e94:	d8 02       	popm	pc
    } 
  } else {
    // momentary mode, sw value takes input
    //    sw->state = (((*v) > 0) ? sw->mul : 0);
    if((*v) > 0) { sw->state = sw->mul; } else { sw->state = 0; }
80009e96:	76 09       	ld.w	r9,r11[0x0]
80009e98:	58 09       	cp.w	r9,0
80009e9a:	e0 8a 00 09 	brle	80009eac <op_sw_in_state+0x44>
80009e9e:	78 bb       	ld.w	r11,r12[0x2c]
80009ea0:	99 ab       	st.w	r12[0x28],r11
    net_activate(sw->outs[0], sw->state);
80009ea2:	f9 0c 00 40 	ld.sh	r12,r12[64]
80009ea6:	fe b0 f8 fb 	rcall	8000909c <net_activate>
80009eaa:	d8 02       	popm	pc
      net_activate(sw->outs[0], sw->state);
    } 
  } else {
    // momentary mode, sw value takes input
    //    sw->state = (((*v) > 0) ? sw->mul : 0);
    if((*v) > 0) { sw->state = sw->mul; } else { sw->state = 0; }
80009eac:	99 a8       	st.w	r12[0x28],r8
80009eae:	10 9b       	mov	r11,r8
80009eb0:	cf 9b       	rjmp	80009ea2 <op_sw_in_state+0x3a>
80009eb2:	d7 03       	nop

80009eb4 <op_sw_inc_func>:
80009eb4:	eb cd 40 80 	pushm	r7,lr
  io_t val;
  /* print_dbg("\r\n sw increment; idx: "); */
  /* print_dbg_hex(idx); */
  /* print_dbg(" , val: "); */
  /* print_dbg_hex(inc); */
  switch(idx) {
80009eb8:	30 18       	mov	r8,1
}

//===== UI input

// increment
static void op_sw_inc_func(op_sw_t* sw, const s16 idx, const io_t inc) {
80009eba:	18 97       	mov	r7,r12
  io_t val;
  /* print_dbg("\r\n sw increment; idx: "); */
  /* print_dbg_hex(idx); */
  /* print_dbg(" , val: "); */
  /* print_dbg_hex(inc); */
  switch(idx) {
80009ebc:	f0 0b 19 00 	cp.h	r11,r8
80009ec0:	c2 70       	breq	80009f0e <op_sw_inc_func+0x5a>
80009ec2:	30 28       	mov	r8,2
80009ec4:	f0 0b 19 00 	cp.h	r11,r8
80009ec8:	c1 30       	breq	80009eee <op_sw_inc_func+0x3a>
80009eca:	30 08       	mov	r8,0
80009ecc:	f0 0b 19 00 	cp.h	r11,r8
80009ed0:	c0 30       	breq	80009ed6 <op_sw_inc_func+0x22>
80009ed2:	e3 cd 80 80 	ldm	sp++,r7,pc

//===== operator input

// input state
static void op_sw_in_state(op_sw_t* sw, const io_t* v) {
  if (sw->tog) {
80009ed6:	78 cb       	ld.w	r11,r12[0x30]
80009ed8:	58 0b       	cp.w	r11,0
80009eda:	c2 20       	breq	80009f1e <op_sw_inc_func+0x6a>
    // toggle mode, sw state toggles on positive input
    if ( *v > 0) {
80009edc:	58 0a       	cp.w	r10,0
80009ede:	fe 9a ff fa 	brle	80009ed2 <op_sw_inc_func+0x1e>
      if (sw->state != 0) { 
80009ee2:	78 a8       	ld.w	r8,r12[0x28]
80009ee4:	58 08       	cp.w	r8,0
80009ee6:	c1 f0       	breq	80009f24 <op_sw_inc_func+0x70>
	sw->state = 0; 
80009ee8:	30 0b       	mov	r11,0
80009eea:	99 ab       	st.w	r12[0x28],r11
80009eec:	c1 e8       	rjmp	80009f28 <op_sw_inc_func+0x74>
    break;
  case 1: // toggle mode
    op_sw_in_tog(sw, &inc);
    break;
  case 2: // multiplier
    val = OP_ADD(sw->mul, inc);
80009eee:	78 bc       	ld.w	r12,r12[0x2c]
80009ef0:	14 9b       	mov	r11,r10
80009ef2:	c2 7c       	rcall	80009f40 <fix16_add>
80009ef4:	8f bc       	st.w	r7[0x2c],r12
  */
}

// input multiplier
static void op_sw_in_mul(op_sw_t* sw, const io_t* v) {
  sw->mul = *v;
80009ef6:	6e a8       	ld.w	r8,r7[0x28]
  if (sw->state > 0) {
80009ef8:	58 08       	cp.w	r8,0
80009efa:	fe 9a ff ec 	brle	80009ed2 <op_sw_inc_func+0x1e>
80009efe:	8f ac       	st.w	r7[0x28],r12
    sw->state = *v;
80009f00:	18 9b       	mov	r11,r12
    net_activate(sw->outs[0], sw->state);
80009f02:	ef 0c 00 40 	ld.sh	r12,r7[64]
80009f06:	fe b0 f8 cb 	rcall	8000909c <net_activate>
80009f0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f0e:	58 0a       	cp.w	r10,0
}

// input toggle mode
static void op_sw_in_tog(op_sw_t* sw, const io_t* v) {
  //  sw->tog = (io_t)(*v > 0);
  if (*v > 0) { sw->tog = OP_ONE; } else  { sw->tog = 0; } 
80009f10:	e0 8a 00 12 	brle	80009f34 <op_sw_inc_func+0x80>
80009f14:	e0 78 00 00 	mov	r8,65536
80009f18:	99 c8       	st.w	r12[0x30],r8
80009f1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f1e:	58 0a       	cp.w	r10,0
      net_activate(sw->outs[0], sw->state);
    } 
  } else {
    // momentary mode, sw value takes input
    //    sw->state = (((*v) > 0) ? sw->mul : 0);
    if((*v) > 0) { sw->state = sw->mul; } else { sw->state = 0; }
80009f20:	e0 8a 00 0e 	brle	80009f3c <op_sw_inc_func+0x88>
80009f24:	6e bb       	ld.w	r11,r7[0x2c]
80009f26:	8f ab       	st.w	r7[0x28],r11
80009f28:	ef 0c 00 40 	ld.sh	r12,r7[64]
    net_activate(sw->outs[0], sw->state);
80009f2c:	fe b0 f8 b8 	rcall	8000909c <net_activate>
80009f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f34:	30 08       	mov	r8,0
}

// input toggle mode
static void op_sw_in_tog(op_sw_t* sw, const io_t* v) {
  //  sw->tog = (io_t)(*v > 0);
  if (*v > 0) { sw->tog = OP_ONE; } else  { sw->tog = 0; } 
80009f36:	99 c8       	st.w	r12[0x30],r8
80009f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f3c:	99 ab       	st.w	r12[0x28],r11
      net_activate(sw->outs[0], sw->state);
    } 
  } else {
    // momentary mode, sw value takes input
    //    sw->state = (((*v) > 0) ? sw->mul : 0);
    if((*v) > 0) { sw->state = sw->mul; } else { sw->state = 0; }
80009f3e:	cf 5b       	rjmp	80009f28 <op_sw_inc_func+0x74>

80009f40 <fix16_add>:
  uint32_t _a = a, _b = b;
  uint32_t sum = _a + _b;

  // Overflow can only happen if sign of a == sibfin/commgn of b, and then
  // it causes sign of sum != sign of a.
  if (!((_a ^ _b) & 0x80000000) && ((_a ^ sum) & 0x80000000))
80009f40:	f7 ec 20 08 	eor	r8,r11,r12
fix16_t fix16_add(fix16_t a, fix16_t b)
{
  // Use unsigned integers because overflow with signed integers is
  // an undefined operation (http://www.airs.com/blog/archives/120).
  uint32_t _a = a, _b = b;
  uint32_t sum = _a + _b;
80009f44:	18 0b       	add	r11,r12

  // Overflow can only happen if sign of a == sibfin/commgn of b, and then
  // it causes sign of sum != sign of a.
  if (!((_a ^ _b) & 0x80000000) && ((_a ^ sum) & 0x80000000))
80009f46:	58 08       	cp.w	r8,0
80009f48:	c0 24       	brge	80009f4c <fix16_add+0xc>
    return fix16_overflow;
  
  return sum;
80009f4a:	5e fb       	retal	r11
  uint32_t _a = a, _b = b;
  uint32_t sum = _a + _b;

  // Overflow can only happen if sign of a == sibfin/commgn of b, and then
  // it causes sign of sum != sign of a.
  if (!((_a ^ _b) & 0x80000000) && ((_a ^ sum) & 0x80000000))
80009f4c:	f7 ec 20 0c 	eor	r12,r11,r12
80009f50:	58 0c       	cp.w	r12,0
80009f52:	cf c4       	brge	80009f4a <fix16_add+0xa>
80009f54:	fc 1c 80 00 	movh	r12,0x8000
80009f58:	5e fc       	retal	r12

80009f5a <fix16_sub>:
  uint32_t _a = a, _b = b;
  uint32_t diff = _a - _b;

  // Overflow can only happen if sign of a != sign of b, and then
  // it causes sign of diff != sign of a.
  if (((_a ^ _b) & 0x80000000) && ((_a ^ diff) & 0x80000000))
80009f5a:	f7 ec 20 08 	eor	r8,r11,r12
}

fix16_t fix16_sub(fix16_t a, fix16_t b)
{
  uint32_t _a = a, _b = b;
  uint32_t diff = _a - _b;
80009f5e:	f8 0b 01 0b 	sub	r11,r12,r11

  // Overflow can only happen if sign of a != sign of b, and then
  // it causes sign of diff != sign of a.
  if (((_a ^ _b) & 0x80000000) && ((_a ^ diff) & 0x80000000))
80009f62:	58 08       	cp.w	r8,0
80009f64:	c0 25       	brlt	80009f68 <fix16_sub+0xe>
    return fix16_overflow;
  
  return diff;
80009f66:	5e fb       	retal	r11
  uint32_t _a = a, _b = b;
  uint32_t diff = _a - _b;

  // Overflow can only happen if sign of a != sign of b, and then
  // it causes sign of diff != sign of a.
  if (((_a ^ _b) & 0x80000000) && ((_a ^ diff) & 0x80000000))
80009f68:	f7 ec 20 0c 	eor	r12,r11,r12
80009f6c:	58 0c       	cp.w	r12,0
80009f6e:	cf c4       	brge	80009f66 <fix16_sub+0xc>
80009f70:	fc 1c 80 00 	movh	r12,0x8000
80009f74:	5e fc       	retal	r12

80009f76 <fix16_mul>:
 * detection.
 */
 
#if !defined(FIXMATH_NO_64BIT) && !defined(FIXMATH_OPTIMIZE_8BIT)
fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
{
80009f76:	eb cd 00 c0 	pushm	r6-r7
  int64_t product = (int64_t)inArg0 * inArg1;
80009f7a:	f6 0c 04 4a 	muls.d	r10,r11,r12
  
  #ifndef FIXMATH_NO_OVERFLOW
  // The upper 17 bits should all be the same (the sign).
  uint32_t upper = (product >> 47);
80009f7e:	f6 08 14 0f 	asr	r8,r11,0xf
  #endif
  
  if (product < 0)
80009f82:	58 0a       	cp.w	r10,0
80009f84:	5c 2b       	cpc	r11
80009f86:	c1 65       	brlt	80009fb2 <fix16_mul+0x3c>
    #endif
  }
  else
  {
    #ifndef FIXMATH_NO_OVERFLOW
    if (upper)
80009f88:	58 08       	cp.w	r8,0
80009f8a:	c1 61       	brne	80009fb6 <fix16_mul+0x40>
  
  #ifdef FIXMATH_NO_ROUNDING
  return product >> 16;
  #else
  fix16_t result = product >> 16;
  result += (product & 0x8000) >> 15;
80009f8c:	e0 68 80 00 	mov	r8,32768
80009f90:	f4 0c 16 10 	lsr	r12,r10,0x10
80009f94:	30 09       	mov	r9,0
80009f96:	f9 eb 11 0c 	or	r12,r12,r11<<0x10
80009f9a:	f5 e8 00 06 	and	r6,r10,r8
80009f9e:	f7 e9 00 07 	and	r7,r11,r9
80009fa2:	0c 98       	mov	r8,r6
80009fa4:	af 98       	lsr	r8,0xf
80009fa6:	f1 e7 11 18 	or	r8,r8,r7<<0x11
80009faa:	10 0c       	add	r12,r8
  
  return result;
  #endif
}
80009fac:	e3 cd 00 c0 	ldm	sp++,r6-r7
80009fb0:	5e fc       	retal	r12
  #endif
  
  if (product < 0)
  {
    #ifndef FIXMATH_NO_OVERFLOW
    if (~upper)
80009fb2:	5b f8       	cp.w	r8,-1
80009fb4:	c0 60       	breq	80009fc0 <fix16_mul+0x4a>
  return product >> 16;
  #else
  fix16_t result = product >> 16;
  result += (product & 0x8000) >> 15;
  
  return result;
80009fb6:	fc 1c 80 00 	movh	r12,0x8000
  #endif
}
80009fba:	e3 cd 00 c0 	ldm	sp++,r6-r7
80009fbe:	5e fc       	retal	r12
        return fix16_overflow;
    #endif
    
    #ifndef FIXMATH_NO_ROUNDING
    // This adjustment is required in order to round -1/2 correctly
    product--;
80009fc0:	3f f8       	mov	r8,-1
80009fc2:	3f f9       	mov	r9,-1
80009fc4:	10 0a       	add	r10,r8
80009fc6:	f6 09 00 4b 	adc	r11,r11,r9
80009fca:	ce 1b       	rjmp	80009f8c <fix16_mul+0x16>

80009fcc <str_copy>:
#define SMPSTR_MAX_LEN 128

// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
80009fcc:	30 08       	mov	r8,0
80009fce:	f0 0a 18 00 	cp.b	r10,r8
80009fd2:	c0 d5       	brlt	80009fec <str_copy+0x20>
      }
      dst[i] = src[i];
      i++;
    }
  } else {
    while(i < len) {
80009fd4:	5c 6a       	casts.b	r10
80009fd6:	5e 0c       	reteq	r12

// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
80009fd8:	30 08       	mov	r8,0
      dst[i] = src[i];
      i++;
    }
  } else {
    while(i < len) {
      dst[i] = src[i];
80009fda:	f8 08 07 09 	ld.ub	r9,r12[r8]
80009fde:	f6 08 0b 09 	st.b	r11[r8],r9
      i++;
80009fe2:	2f f8       	sub	r8,-1
80009fe4:	5c 58       	castu.b	r8
      }
      dst[i] = src[i];
      i++;
    }
  } else {
    while(i < len) {
80009fe6:	14 38       	cp.w	r8,r10
80009fe8:	cf 95       	brlt	80009fda <str_copy+0xe>
80009fea:	5e fc       	retal	r12
// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
      if(src[i] == 0) {
80009fec:	19 88       	ld.ub	r8,r12[0x0]
80009fee:	58 08       	cp.w	r8,0
80009ff0:	5e 0c       	reteq	r12
	break;
      }
      dst[i] = src[i];
80009ff2:	16 c8       	st.b	r11++,r8
80009ff4:	2f fc       	sub	r12,-1
80009ff6:	30 18       	mov	r8,1

// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
80009ff8:	38 0a       	mov	r10,-128
      if(src[i] == 0) {
	break;
      }
      dst[i] = src[i];
      i++;
80009ffa:	2f f8       	sub	r8,-1
// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
      if(src[i] == 0) {
80009ffc:	19 89       	ld.ub	r9,r12[0x0]
	break;
      }
      dst[i] = src[i];
      i++;
80009ffe:	5c 58       	castu.b	r8
// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
      if(src[i] == 0) {
8000a000:	58 09       	cp.w	r9,0
8000a002:	5e 0c       	reteq	r12
	break;
      }
      dst[i] = src[i];
8000a004:	16 c9       	st.b	r11++,r9
      i++;
8000a006:	2f fc       	sub	r12,-1

// copy with length arg (-1 == until null terminator, no bounds check!)
void str_copy(const char* src, char * dst, s8 len) {
  u8 i=0;
  if(len < 0) {
    while(i < SMPSTR_MAX_LEN) {
8000a008:	f4 08 18 00 	cp.b	r8,r10
8000a00c:	cf 71       	brne	80009ffa <str_copy+0x2e>
8000a00e:	5e fc       	retal	r12

8000a010 <fatfs_lba_of_cluster>:
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8000a010:	78 c8       	ld.w	r8,r12[0x30]
8000a012:	58 08       	cp.w	r8,0
8000a014:	c0 80       	breq	8000a024 <fatfs_lba_of_cluster+0x14>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8000a016:	78 18       	ld.w	r8,r12[0x4]
8000a018:	20 2b       	sub	r11,2
8000a01a:	19 89       	ld.ub	r9,r12[0x0]
8000a01c:	f6 09 02 4c 	mul	r12,r11,r9
8000a020:	10 0c       	add	r12,r8
}
8000a022:	5e fc       	retal	r12
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8000a024:	19 88       	ld.ub	r8,r12[0x0]
8000a026:	f9 19 00 28 	ld.uh	r9,r12[40]
8000a02a:	20 2b       	sub	r11,2
8000a02c:	a5 49       	asr	r9,0x4
8000a02e:	b1 3b       	mul	r11,r8
8000a030:	78 18       	ld.w	r8,r12[0x4]
8000a032:	f2 08 00 0c 	add	r12,r9,r8
8000a036:	16 0c       	add	r12,r11
8000a038:	5e fc       	retal	r12

8000a03a <fatfs_sector_read>:
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8000a03a:	d4 01       	pushm	lr
8000a03c:	16 9e       	mov	lr,r11
    return fs->disk_io.read_media(lba, target, count);
8000a03e:	78 d8       	ld.w	r8,r12[0x34]
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8000a040:	14 9b       	mov	r11,r10
    return fs->disk_io.read_media(lba, target, count);
8000a042:	1c 9c       	mov	r12,lr
8000a044:	12 9a       	mov	r10,r9
8000a046:	5d 18       	icall	r8
}
8000a048:	d8 02       	popm	pc

8000a04a <fatfs_sector_write>:
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8000a04a:	d4 01       	pushm	lr
8000a04c:	16 9e       	mov	lr,r11
    return fs->disk_io.write_media(lba, target, count);
8000a04e:	78 e8       	ld.w	r8,r12[0x38]
}
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8000a050:	14 9b       	mov	r11,r10
    return fs->disk_io.write_media(lba, target, count);
8000a052:	1c 9c       	mov	r12,lr
8000a054:	12 9a       	mov	r10,r9
8000a056:	5d 18       	icall	r8
}
8000a058:	d8 02       	popm	pc

8000a05a <fatfs_get_root_cluster>:
//-----------------------------------------------------------------------------
uint32 fatfs_get_root_cluster(struct fatfs *fs)
{
    // NOTE: On FAT16 this will be 0 which has a special meaning...
    return fs->rootdir_first_cluster;
}
8000a05a:	78 2c       	ld.w	r12,r12[0x8]
8000a05c:	5e fc       	retal	r12

8000a05e <fatfs_list_directory_start>:
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
void fatfs_list_directory_start(struct fatfs *fs, struct fs_dir_list_status *dirls, uint32 StartCluster)
{
    dirls->cluster = StartCluster;
    dirls->sector = 0;
8000a05e:	30 08       	mov	r8,0
// fatfs_list_directory_start: Initialise a directory listing procedure
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
void fatfs_list_directory_start(struct fatfs *fs, struct fs_dir_list_status *dirls, uint32 StartCluster)
{
    dirls->cluster = StartCluster;
8000a060:	97 1a       	st.w	r11[0x4],r10
    dirls->sector = 0;
    dirls->offset = 0;
8000a062:	f7 68 00 08 	st.b	r11[8],r8
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
void fatfs_list_directory_start(struct fatfs *fs, struct fs_dir_list_status *dirls, uint32 StartCluster)
{
    dirls->cluster = StartCluster;
    dirls->sector = 0;
8000a066:	97 08       	st.w	r11[0x0],r8
    dirls->offset = 0;
}
8000a068:	5e fc       	retal	r12
8000a06a:	d7 03       	nop

8000a06c <fatfs_init>:

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
8000a06c:	eb cd 40 f8 	pushm	r3-r7,lr
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
8000a070:	3f f8       	mov	r8,-1

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
8000a072:	18 97       	mov	r7,r12
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
    fs->currentsector.dirty = 0;
8000a074:	30 06       	mov	r6,0
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
8000a076:	f9 48 02 44 	st.w	r12[580],r8
    fs->currentsector.dirty = 0;
8000a07a:	f9 46 02 48 	st.w	r12[584],r6

    fs->next_free_cluster = 0; // Invalid
8000a07e:	99 96       	st.w	r12[0x24],r6

    fatfs_fat_init(fs);
8000a080:	e0 a0 15 5c 	rcall	8000cb38 <fatfs_fat_init>

    // Make sure we have a read function (write function is optional)
    if (!fs->disk_io.read_media)
8000a084:	6e d8       	ld.w	r8,r7[0x34]
8000a086:	58 08       	cp.w	r8,0
8000a088:	c0 31       	brne	8000a08e <fatfs_init+0x22>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8000a08a:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1

    // MBR: Sector 0 on the disk
    // NOTE: Some removeable media does not have this.

    // Load MBR (LBA 0) into the 512 byte buffer
    if (!fs->disk_io.read_media(0, fs->currentsector.sector, 1))
8000a08e:	0c 9c       	mov	r12,r6
8000a090:	30 1a       	mov	r10,1
8000a092:	ee c6 ff bc 	sub	r6,r7,-68
8000a096:	0c 9b       	mov	r11,r6
8000a098:	5d 18       	icall	r8
8000a09a:	cf 80       	breq	8000a08a <fatfs_init+0x1e>
    ///////////////////


    // Make Sure 0x55 and 0xAA are at end of sector
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
8000a09c:	ef 18 02 42 	ld.uh	r8,r7[578]
8000a0a0:	e0 48 55 aa 	cp.w	r8,21930
8000a0a4:	c0 40       	breq	8000a0ac <fatfs_init+0x40>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8000a0a6:	3f dc       	mov	r12,-3
8000a0a8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
        return FAT_INIT_INVALID_SIGNATURE;

    // Now check again using the access function to prove endian conversion function
    if (GET_16BIT_WORD(fs->currentsector.sector, SIGNATURE_POSITION) != SIGNATURE_VALUE) 
8000a0ac:	ef 39 02 43 	ld.ub	r9,r7[579]
8000a0b0:	ef 38 02 42 	ld.ub	r8,r7[578]
8000a0b4:	a9 69       	lsl	r9,0x8
8000a0b6:	f2 08 00 08 	add	r8,r9,r8
8000a0ba:	e0 48 aa 55 	cp.w	r8,43605
8000a0be:	c0 40       	breq	8000a0c6 <fatfs_init+0x5a>
8000a0c0:	3f cc       	mov	r12,-4
8000a0c2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    	   
    if (sizeof(struct fat_dir_entry) != FAT_DIR_ENTRY_SIZE)
        return FAT_INIT_STRUCT_PACKING;

    // Check the partition type code
    switch(fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION])
8000a0c6:	ef 38 02 06 	ld.ub	r8,r7[518]
8000a0ca:	30 f9       	mov	r9,15
8000a0cc:	f2 08 18 00 	cp.b	r8,r9
8000a0d0:	e0 8b 00 0c 	brhi	8000a0e8 <fatfs_init+0x7c>
8000a0d4:	30 19       	mov	r9,1
8000a0d6:	f2 08 09 49 	lsl	r9,r9,r8
8000a0da:	12 9a       	mov	r10,r9
8000a0dc:	e2 1a d8 60 	andl	r10,0xd860,COH
8000a0e0:	c0 91       	brne	8000a0f2 <fatfs_init+0x86>
8000a0e2:	ed b9 00 00 	bld	r9,0x0
8000a0e6:	c2 70       	breq	8000a134 <fatfs_init+0xc8>
        break;
        case 0x00:
            valid_partition = 0;
            break;
        default:
            if (fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION] <= 0x06)
8000a0e8:	30 69       	mov	r9,6
8000a0ea:	f2 08 18 00 	cp.b	r8,r9
8000a0ee:	e0 8b 00 23 	brhi	8000a134 <fatfs_init+0xc8>
        break;
    }

    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
8000a0f2:	ef 38 02 0c 	ld.ub	r8,r7[524]
8000a0f6:	b1 68       	lsl	r8,0x10
8000a0f8:	ef 3c 02 0d 	ld.ub	r12,r7[525]
8000a0fc:	b9 6c       	lsl	r12,0x18
8000a0fe:	10 0c       	add	r12,r8
8000a100:	ef 38 02 0a 	ld.ub	r8,r7[522]
8000a104:	10 0c       	add	r12,r8
8000a106:	ef 38 02 0b 	ld.ub	r8,r7[523]
8000a10a:	a9 68       	lsl	r8,0x8
8000a10c:	10 0c       	add	r12,r8
8000a10e:	8f 7c       	st.w	r7[0x1c],r12
    else
        fs->lba_begin = 0;

    // Load Volume 1 table into sector buffer
    // (We may already have this in the buffer if MBR less drive!)
    if (!fs->disk_io.read_media(fs->lba_begin, fs->currentsector.sector, 1))
8000a110:	0c 9b       	mov	r11,r6
8000a112:	6e d8       	ld.w	r8,r7[0x34]
8000a114:	30 1a       	mov	r10,1
8000a116:	5d 18       	icall	r8
8000a118:	cb 90       	breq	8000a08a <fatfs_init+0x1e>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
8000a11a:	ef 36 00 50 	ld.ub	r6,r7[80]
8000a11e:	ef 3a 00 4f 	ld.ub	r10,r7[79]
8000a122:	ec 08 15 08 	lsl	r8,r6,0x8
8000a126:	14 08       	add	r8,r10
8000a128:	e0 48 02 00 	cp.w	r8,512
8000a12c:	c0 70       	breq	8000a13a <fatfs_init+0xce>
8000a12e:	3f ec       	mov	r12,-2
8000a130:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
    // Else possibly MBR less disk
    else
        fs->lba_begin = 0;
8000a134:	30 0c       	mov	r12,0
8000a136:	8f 7c       	st.w	r7[0x1c],r12
8000a138:	ce cb       	rjmp	8000a110 <fatfs_init+0xa4>
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
8000a13a:	ef 38 00 51 	ld.ub	r8,r7[81]
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
8000a13e:	ef 39 00 55 	ld.ub	r9,r7[85]
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
8000a142:	ae 88       	st.b	r7[0x0],r8
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
8000a144:	ef 38 00 56 	ld.ub	r8,r7[86]
8000a148:	a9 68       	lsl	r8,0x8
8000a14a:	f2 08 00 08 	add	r8,r9,r8
8000a14e:	ef 58 00 28 	st.h	r7[40],r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a152:	ef 39 00 5b 	ld.ub	r9,r7[91]
8000a156:	ef 38 00 5a 	ld.ub	r8,r7[90]
8000a15a:	f2 05 15 08 	lsl	r5,r9,0x8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
8000a15e:	ef 3c 00 53 	ld.ub	r12,r7[83]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a162:	10 05       	add	r5,r8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
8000a164:	ef 3b 00 52 	ld.ub	r11,r7[82]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
8000a168:	ef 3e 00 54 	ld.ub	lr,r7[84]
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a16c:	c1 01       	brne	8000a18c <fatfs_init+0x120>
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
8000a16e:	ef 35 00 6a 	ld.ub	r5,r7[106]
8000a172:	b1 65       	lsl	r5,0x10
8000a174:	ef 34 00 6b 	ld.ub	r4,r7[107]
8000a178:	b9 64       	lsl	r4,0x18
8000a17a:	0a 04       	add	r4,r5
8000a17c:	ef 35 00 68 	ld.ub	r5,r7[104]
8000a180:	0a 04       	add	r4,r5
8000a182:	ef 35 00 69 	ld.ub	r5,r7[105]
8000a186:	a9 65       	lsl	r5,0x8
8000a188:	e8 05 00 05 	add	r5,r4,r5
8000a18c:	8f 85       	st.w	r7[0x20],r5
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
8000a18e:	ef 35 00 72 	ld.ub	r5,r7[114]
8000a192:	b1 65       	lsl	r5,0x10
8000a194:	ef 34 00 73 	ld.ub	r4,r7[115]
8000a198:	b9 64       	lsl	r4,0x18
8000a19a:	0a 04       	add	r4,r5
8000a19c:	ef 35 00 70 	ld.ub	r5,r7[112]
8000a1a0:	0a 04       	add	r4,r5
8000a1a2:	ef 35 00 71 	ld.ub	r5,r7[113]
8000a1a6:	a9 65       	lsl	r5,0x8
8000a1a8:	e8 05 00 05 	add	r5,r4,r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000a1ac:	ef 13 00 28 	ld.uh	r3,r7[40]
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000a1b0:	ef 34 00 74 	ld.ub	r4,r7[116]
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
8000a1b4:	8f 25       	st.w	r7[0x8],r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000a1b6:	a5 73       	lsl	r3,0x5
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000a1b8:	ef 35 00 75 	ld.ub	r5,r7[117]

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000a1bc:	e6 c3 fe 01 	sub	r3,r3,-511
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000a1c0:	a9 65       	lsl	r5,0x8

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000a1c2:	a9 53       	asr	r3,0x9
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000a1c4:	e8 05 00 05 	add	r5,r4,r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000a1c8:	8f 43       	st.w	r7[0x10],r3
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000a1ca:	ef 55 00 18 	st.h	r7[24],r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
8000a1ce:	6e 84       	ld.w	r4,r7[0x20]
8000a1d0:	f8 05 15 08 	lsl	r5,r12,0x8
8000a1d4:	fc 04 02 44 	mul	r4,lr,r4
8000a1d8:	16 05       	add	r5,r11
8000a1da:	5c 75       	castu.h	r5
8000a1dc:	ea 04 00 03 	add	r3,r5,r4
8000a1e0:	8f 33       	st.w	r7[0xc],r3
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
8000a1e2:	6e 73       	ld.w	r3,r7[0x1c]
8000a1e4:	06 05       	add	r5,r3

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
8000a1e6:	ea 04 00 04 	add	r4,r5,r4
    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
8000a1ea:	8f 55       	st.w	r7[0x14],r5

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
8000a1ec:	8f 14       	st.w	r7[0x4],r4

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
8000a1ee:	ef 35 02 42 	ld.ub	r5,r7[578]
8000a1f2:	ef 34 02 43 	ld.ub	r4,r7[579]
8000a1f6:	a9 64       	lsl	r4,0x8
8000a1f8:	e8 05 00 05 	add	r5,r4,r5
8000a1fc:	e0 45 aa 55 	cp.w	r5,43605
8000a200:	fe 91 ff 53 	brne	8000a0a6 <fatfs_init+0x3a>
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a204:	a9 69       	lsl	r9,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8000a206:	ef 33 00 56 	ld.ub	r3,r7[86]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a20a:	f2 08 00 05 	add	r5,r9,r8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8000a20e:	ef 34 00 55 	ld.ub	r4,r7[85]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000a212:	c0 f1       	brne	8000a230 <fatfs_init+0x1c4>
        FATSz = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);  
8000a214:	ef 38 00 6a 	ld.ub	r8,r7[106]
8000a218:	b1 68       	lsl	r8,0x10
8000a21a:	ef 35 00 6b 	ld.ub	r5,r7[107]
8000a21e:	b9 65       	lsl	r5,0x18
8000a220:	10 05       	add	r5,r8
8000a222:	ef 38 00 68 	ld.ub	r8,r7[104]
8000a226:	10 05       	add	r5,r8
8000a228:	ef 38 00 69 	ld.ub	r8,r7[105]
8000a22c:	a9 68       	lsl	r8,0x8
8000a22e:	10 05       	add	r5,r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16) != 0)
8000a230:	ef 39 00 58 	ld.ub	r9,r7[88]
8000a234:	ef 38 00 57 	ld.ub	r8,r7[87]
8000a238:	a9 69       	lsl	r9,0x8
8000a23a:	10 09       	add	r9,r8
8000a23c:	c0 f1       	brne	8000a25a <fatfs_init+0x1ee>
        total_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16);
    else
        total_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_TOTSEC32);
8000a23e:	ef 38 00 66 	ld.ub	r8,r7[102]
8000a242:	b1 68       	lsl	r8,0x10
8000a244:	ef 39 00 67 	ld.ub	r9,r7[103]
8000a248:	b9 69       	lsl	r9,0x18
8000a24a:	10 09       	add	r9,r8
8000a24c:	ef 38 00 64 	ld.ub	r8,r7[100]
8000a250:	10 09       	add	r9,r8
8000a252:	ef 38 00 65 	ld.ub	r8,r7[101]
8000a256:	a9 68       	lsl	r8,0x8
8000a258:	10 09       	add	r9,r8

    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
8000a25a:	0f 88       	ld.ub	r8,r7[0x0]
8000a25c:	58 08       	cp.w	r8,0
8000a25e:	c0 41       	brne	8000a266 <fatfs_init+0x1fa>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8000a260:	3f bc       	mov	r12,-5
        }
    }
    else
        return FAT_INIT_WRONG_FILESYS_TYPE;    
}
8000a262:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8000a266:	a9 6c       	lsl	r12,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8000a268:	a9 66       	lsl	r6,0x8
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8000a26a:	a9 63       	lsl	r3,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8000a26c:	ec 0a 00 0a 	add	r10,r6,r10
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8000a270:	e6 04 00 04 	add	r4,r3,r4
8000a274:	ea 0e 02 4e 	mul	lr,r5,lr
8000a278:	f8 0b 00 0b 	add	r11,r12,r11
8000a27c:	f4 c5 00 01 	sub	r5,r10,1
8000a280:	e8 0c 15 05 	lsl	r12,r4,0x5
8000a284:	18 05       	add	r5,r12
8000a286:	ea 0a 0c 04 	divs	r4,r5,r10
8000a28a:	e8 0a 11 00 	rsub	r10,r4,0
8000a28e:	16 1a       	sub	r10,r11
8000a290:	1c 1a       	sub	r10,lr
8000a292:	f4 09 00 09 	add	r9,r10,r9
8000a296:	f2 08 0d 08 	divu	r8,r9,r8

        if(count_of_clusters < 4085) 
8000a29a:	e0 48 0f f4 	cp.w	r8,4084
8000a29e:	fe 98 ff e1 	brls	8000a260 <fatfs_init+0x1f4>
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
8000a2a2:	e0 48 ff f4 	cp.w	r8,65524
8000a2a6:	f9 bc 08 00 	movls	r12,0

            // Volume is FAT16
            fs->fat_type = FAT_TYPE_16;
8000a2aa:	ef fc 8a 0c 	st.wls	r7[0x30],r12
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
8000a2ae:	ef fc 8a 02 	st.wls	r7[0x8],r12
            return FAT_INIT_OK;
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
8000a2b2:	f9 b8 0b 01 	movhi	r8,1
8000a2b6:	ef f8 ba 0c 	st.whi	r7[0x30],r8
8000a2ba:	f9 bc 0b 00 	movhi	r12,0
            return FAT_INIT_OK;
8000a2be:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000a2c2:	d7 03       	nop

8000a2c4 <T.41>:
8000a2c4:	eb cd 40 f8 	pushm	r3-r7,lr
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000a2c8:	58 0b       	cp.w	r11,0
8000a2ca:	5f 09       	sreq	r9
8000a2cc:	78 c8       	ld.w	r8,r12[0x30]
}
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
8000a2ce:	18 97       	mov	r7,r12
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000a2d0:	58 08       	cp.w	r8,0
8000a2d2:	5f 08       	sreq	r8
}
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
8000a2d4:	14 94       	mov	r4,r10
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000a2d6:	f3 e8 00 08 	and	r8,r9,r8
8000a2da:	c0 f0       	breq	8000a2f8 <T.41+0x34>
    {
        if (offset < fs->rootdir_sectors)
8000a2dc:	78 48       	ld.w	r8,r12[0x10]
8000a2de:	14 38       	cp.w	r8,r10
8000a2e0:	e0 88 00 1d 	brls	8000a31a <T.41+0x56>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8000a2e4:	6e 78       	ld.w	r8,r7[0x1c]
8000a2e6:	78 3c       	ld.w	r12,r12[0xc]
8000a2e8:	10 0c       	add	r12,r8

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000a2ea:	ee f8 02 44 	ld.w	r8,r7[580]

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
    {
        if (offset < fs->rootdir_sectors)
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8000a2ee:	14 0c       	add	r12,r10

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000a2f0:	10 3c       	cp.w	r12,r8
8000a2f2:	c2 01       	brne	8000a332 <T.41+0x6e>
8000a2f4:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
8000a2f8:	19 83       	ld.ub	r3,r12[0x0]
8000a2fa:	f4 03 0d 08 	divu	r8,r10,r3
8000a2fe:	10 95       	mov	r5,r8
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000a300:	58 08       	cp.w	r8,0
8000a302:	c0 a0       	breq	8000a316 <T.41+0x52>
8000a304:	30 06       	mov	r6,0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8000a306:	0e 9c       	mov	r12,r7
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000a308:	2f f6       	sub	r6,-1
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8000a30a:	e0 a0 14 61 	rcall	8000cbcc <fatfs_find_next_cluster>
8000a30e:	18 9b       	mov	r11,r12
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000a310:	0c 35       	cp.w	r5,r6
8000a312:	fe 9b ff fa 	brhi	8000a306 <T.41+0x42>
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
8000a316:	5b fb       	cp.w	r11,-1
8000a318:	c0 31       	brne	8000a31e <T.41+0x5a>
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
    {
        fs->currentsector.address = lba;
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000a31a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8000a31e:	0e 9c       	mov	r12,r7
8000a320:	c7 8e       	rcall	8000a010 <fatfs_lba_of_cluster>
8000a322:	a7 35       	mul	r5,r3
8000a324:	ee f8 02 44 	ld.w	r8,r7[580]

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000a328:	0a 14       	sub	r4,r5
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8000a32a:	e8 0c 00 0c 	add	r12,r4,r12
8000a32e:	10 3c       	cp.w	r12,r8

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000a330:	ce 20       	breq	8000a2f4 <T.41+0x30>
8000a332:	ef 4c 02 44 	st.w	r7[580],r12
    {
        fs->currentsector.address = lba;
8000a336:	ee cb ff bc 	sub	r11,r7,-68
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000a33a:	6e d8       	ld.w	r8,r7[0x34]
8000a33c:	30 1a       	mov	r10,1
8000a33e:	5d 18       	icall	r8
8000a340:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000a344 <fatfs_get_file_entry>:
8000a344:	d4 31       	pushm	r0-r7,lr
8000a346:	fa cd 01 28 	sub	sp,sp,296
8000a34a:	18 97       	mov	r7,r12
8000a34c:	50 1b       	stdsp	sp[0x4],r11
8000a34e:	14 96       	mov	r6,r10
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
8000a350:	30 1b       	mov	r11,1
}
//-------------------------------------------------------------
// fatfs_get_file_entry: Find the file entry for a filename
//-------------------------------------------------------------
uint32 fatfs_get_file_entry(struct fatfs *fs, uint32 Cluster, char *name_to_find, struct fat_dir_entry *sfEntry)
{
8000a352:	50 39       	stdsp	sp[0xc],r9
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
8000a354:	fa c5 ff ee 	sub	r5,sp,-18
8000a358:	0a 9c       	mov	r12,r5
8000a35a:	e0 a0 0e 50 	rcall	8000bffa <fatfs_lfn_cache_init>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a35e:	ee cb ff bc 	sub	r11,r7,-68
8000a362:	30 04       	mov	r4,0
8000a364:	50 2b       	stdsp	sp[0x8],r11
8000a366:	08 9a       	mov	r10,r4

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8000a368:	40 1b       	lddsp	r11,sp[0x4]
8000a36a:	2f f4       	sub	r4,-1
8000a36c:	0e 9c       	mov	r12,r7
8000a36e:	ca bf       	rcall	8000a2c4 <T.41>
8000a370:	e0 80 00 90 	breq	8000a490 <fatfs_get_file_entry+0x14c>
8000a374:	40 23       	lddsp	r3,sp[0x8]
8000a376:	30 02       	mov	r2,0
8000a378:	32 01       	mov	r1,32
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
8000a37a:	32 e0       	mov	r0,46

                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
8000a37c:	c0 d8       	rjmp	8000a396 <fatfs_get_file_entry+0x52>
8000a37e:	e4 cb ff bc 	sub	r11,r2,-68
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
8000a382:	0a 9c       	mov	r12,r5
8000a384:	ee 0b 00 0b 	add	r11,r7,r11
8000a388:	e0 a0 0c 6c 	rcall	8000bc60 <fatfs_lfn_cache_entry>
8000a38c:	2e 03       	sub	r3,-32
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8000a38e:	2e 02       	sub	r2,-32
8000a390:	e0 42 02 00 	cp.w	r2,512
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000a394:	ce 90       	breq	8000a366 <fatfs_get_file_entry+0x22>
8000a396:	06 9c       	mov	r12,r3
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a398:	e0 a0 0d 4b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a39c:	18 9b       	mov	r11,r12
8000a39e:	cf 01       	brne	8000a37e <fatfs_get_file_entry+0x3a>
8000a3a0:	50 0b       	stdsp	sp[0x0],r11
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a3a2:	06 9c       	mov	r12,r3
8000a3a4:	e0 a0 0d 4c 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a3a8:	40 0b       	lddsp	r11,sp[0x0]
8000a3aa:	c6 01       	brne	8000a46a <fatfs_get_file_entry+0x126>
8000a3ac:	06 9b       	mov	r11,r3
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists 
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) ) 
8000a3ae:	0a 9c       	mov	r12,r5
8000a3b0:	e0 a0 0d 5f 	rcall	8000be6e <fatfs_entry_lfn_exists>
8000a3b4:	18 98       	mov	r8,r12
8000a3b6:	c0 d0       	breq	8000a3d0 <fatfs_get_file_entry+0x8c>
8000a3b8:	0a 9c       	mov	r12,r5
                {
                    long_filename = fatfs_lfn_cache_get(&lfn);
8000a3ba:	e0 a0 0d 23 	rcall	8000be00 <fatfs_lfn_cache_get>
8000a3be:	0c 9b       	mov	r11,r6

                    // Compare names to see if they match
                    if (fatfs_compare_names(long_filename, name_to_find)) 
8000a3c0:	e0 a0 11 7a 	rcall	8000c6b4 <fatfs_compare_names>
8000a3c4:	c6 01       	brne	8000a484 <fatfs_get_file_entry+0x140>
8000a3c6:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8000a3c8:	0a 9c       	mov	r12,r5
8000a3ca:	e0 a0 0e 18 	rcall	8000bffa <fatfs_lfn_cache_init>
8000a3ce:	cd fb       	rjmp	8000a38c <fatfs_get_file_entry+0x48>
8000a3d0:	50 08       	stdsp	sp[0x0],r8
                }                 
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a3d2:	06 9c       	mov	r12,r3
8000a3d4:	e0 a0 0d 68 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a3d8:	40 08       	lddsp	r8,sp[0x0]
8000a3da:	cd 90       	breq	8000a38c <fatfs_get_file_entry+0x48>
8000a3dc:	30 0a       	mov	r10,0
                {
                    memset(short_filename, 0, sizeof(short_filename));
8000a3de:	30 0b       	mov	r11,0
8000a3e0:	fa eb 01 18 	st.d	sp[280],r10
8000a3e4:	54 88       	stdsp	sp[0x120],r8
8000a3e6:	fb 68 01 24 	st.b	sp[292],r8
8000a3ea:	07 88       	ld.ub	r8,r3[0x0]

                    // Copy name to string
                    for (i=0; i<8; i++) 
                        short_filename[i] = directoryEntry->Name[i];
8000a3ec:	fb 68 01 18 	st.b	sp[280],r8
8000a3f0:	07 99       	ld.ub	r9,r3[0x1]
8000a3f2:	fb 69 01 19 	st.b	sp[281],r9
8000a3f6:	07 a9       	ld.ub	r9,r3[0x2]
8000a3f8:	fb 69 01 1a 	st.b	sp[282],r9
8000a3fc:	07 b9       	ld.ub	r9,r3[0x3]
8000a3fe:	fb 69 01 1b 	st.b	sp[283],r9
8000a402:	07 c9       	ld.ub	r9,r3[0x4]
8000a404:	fb 69 01 1c 	st.b	sp[284],r9
8000a408:	07 d9       	ld.ub	r9,r3[0x5]
8000a40a:	fb 69 01 1d 	st.b	sp[285],r9
8000a40e:	07 e9       	ld.ub	r9,r3[0x6]
8000a410:	fb 69 01 1e 	st.b	sp[286],r9
8000a414:	07 f9       	ld.ub	r9,r3[0x7]
8000a416:	fb 69 01 1f 	st.b	sp[287],r9
8000a41a:	e7 39 00 08 	ld.ub	r9,r3[8]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8000a41e:	fb 69 01 21 	st.b	sp[289],r9
8000a422:	e7 39 00 09 	ld.ub	r9,r3[9]
8000a426:	e7 3a 00 08 	ld.ub	r10,r3[8]
                        if (directoryEntry->Name[i] != ' ')
8000a42a:	fb 69 01 22 	st.b	sp[290],r9

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8000a42e:	e7 39 00 09 	ld.ub	r9,r3[9]
                        if (directoryEntry->Name[i] != ' ')
8000a432:	e2 09 18 00 	cp.b	r9,r1
8000a436:	c1 e0       	breq	8000a472 <fatfs_get_file_entry+0x12e>
8000a438:	30 1b       	mov	r11,1
8000a43a:	e7 39 00 0a 	ld.ub	r9,r3[10]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8000a43e:	fb 69 01 23 	st.b	sp[291],r9
8000a442:	e7 39 00 0a 	ld.ub	r9,r3[10]
                        if (directoryEntry->Name[i] != ' ')
8000a446:	e2 09 18 00 	cp.b	r9,r1
8000a44a:	c1 80       	breq	8000a47a <fatfs_get_file_entry+0x136>
8000a44c:	f0 00 18 00 	cp.b	r0,r8
                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
                            short_filename[8] = '.';
8000a450:	e2 09 17 00 	moveq	r9,r1
8000a454:	e0 09 17 10 	movne	r9,r0
8000a458:	fb 69 01 20 	st.b	sp[288],r9
8000a45c:	0c 9b       	mov	r11,r6
                    }
                    else
                        short_filename[8] = ' ';
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
8000a45e:	fa cc fe e8 	sub	r12,sp,-280
8000a462:	e0 a0 11 29 	rcall	8000c6b4 <fatfs_compare_names>
8000a466:	c0 f1       	brne	8000a484 <fatfs_get_file_entry+0x140>
8000a468:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8000a46a:	0a 9c       	mov	r12,r5
8000a46c:	e0 a0 0d c7 	rcall	8000bffa <fatfs_lfn_cache_init>
8000a470:	c8 eb       	rjmp	8000a38c <fatfs_get_file_entry+0x48>
8000a472:	e2 0a 18 00 	cp.b	r10,r1
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
8000a476:	5f 1b       	srne	r11
8000a478:	ce 1b       	rjmp	8000a43a <fatfs_get_file_entry+0xf6>
8000a47a:	58 0b       	cp.w	r11,0
                            dotRequired = 1;
                    }

                    // Dot only required if extension present
                    if (dotRequired)
8000a47c:	ce 81       	brne	8000a44c <fatfs_get_file_entry+0x108>
8000a47e:	fb 69 01 20 	st.b	sp[288],r9
                            short_filename[8] = '.';
                        else
                            short_filename[8] = ' ';
                    }
                    else
                        short_filename[8] = ' ';
8000a482:	ce db       	rjmp	8000a45c <fatfs_get_file_entry+0x118>
8000a484:	06 9b       	mov	r11,r3
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
8000a486:	40 3c       	lddsp	r12,sp[0xc]
8000a488:	32 0a       	mov	r10,32
8000a48a:	e0 a0 23 9d 	rcall	8000ebc4 <memcpy>
8000a48e:	30 1c       	mov	r12,1
8000a490:	2b 6d       	sub	sp,-296
        else
            break;
    } // End of while loop

    return 0;
}
8000a492:	d8 32       	popm	r0-r7,pc

8000a494 <fatfs_sfn_exists>:
8000a494:	d4 31       	pushm	r0-r7,lr
8000a496:	20 6d       	sub	sp,24
8000a498:	f8 c8 fe fc 	sub	r8,r12,-260
8000a49c:	50 18       	stdsp	sp[0x4],r8
8000a49e:	f8 c8 fe dc 	sub	r8,r12,-292
8000a4a2:	18 95       	mov	r5,r12
8000a4a4:	50 28       	stdsp	sp[0x8],r8
8000a4a6:	50 4b       	stdsp	sp[0x10],r11
8000a4a8:	f8 c8 fe bc 	sub	r8,r12,-324
8000a4ac:	50 5a       	stdsp	sp[0x14],r10
8000a4ae:	f8 c7 ff bc 	sub	r7,r12,-68
8000a4b2:	30 06       	mov	r6,0
8000a4b4:	f8 c2 ff 9c 	sub	r2,r12,-100
8000a4b8:	f8 c3 ff 7c 	sub	r3,r12,-132
8000a4bc:	f8 c4 ff 5c 	sub	r4,r12,-164
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a4c0:	f8 c1 ff 3c 	sub	r1,r12,-196
8000a4c4:	f8 c0 ff 1c 	sub	r0,r12,-228
8000a4c8:	50 38       	stdsp	sp[0xc],r8
8000a4ca:	0c 9a       	mov	r10,r6

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8000a4cc:	40 4b       	lddsp	r11,sp[0x10]
8000a4ce:	2f f6       	sub	r6,-1
8000a4d0:	0a 9c       	mov	r12,r5
8000a4d2:	cf 9e       	rcall	8000a2c4 <T.41>
8000a4d4:	c7 10       	breq	8000a5b6 <fatfs_sfn_exists+0x122>
8000a4d6:	0e 9c       	mov	r12,r7
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a4d8:	e0 a0 0c ab 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a4dc:	e0 80 00 fd 	breq	8000a6d6 <fatfs_sfn_exists+0x242>
8000a4e0:	04 9c       	mov	r12,r2
8000a4e2:	e0 a0 0c a6 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a4e6:	e0 80 00 e5 	breq	8000a6b0 <fatfs_sfn_exists+0x21c>
8000a4ea:	06 9c       	mov	r12,r3
8000a4ec:	e0 a0 0c a1 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a4f0:	e0 80 00 cd 	breq	8000a68a <fatfs_sfn_exists+0x1f6>
8000a4f4:	08 9c       	mov	r12,r4
8000a4f6:	e0 a0 0c 9c 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a4fa:	e0 80 00 b5 	breq	8000a664 <fatfs_sfn_exists+0x1d0>
8000a4fe:	02 9c       	mov	r12,r1
8000a500:	e0 a0 0c 97 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a504:	e0 80 00 9d 	breq	8000a63e <fatfs_sfn_exists+0x1aa>
8000a508:	00 9c       	mov	r12,r0
8000a50a:	e0 a0 0c 92 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a50e:	e0 80 00 85 	breq	8000a618 <fatfs_sfn_exists+0x184>
8000a512:	40 1c       	lddsp	r12,sp[0x4]
8000a514:	e0 a0 0c 8d 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a518:	c7 00       	breq	8000a5f8 <fatfs_sfn_exists+0x164>
8000a51a:	40 2c       	lddsp	r12,sp[0x8]
8000a51c:	e0 a0 0c 89 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a520:	c5 c0       	breq	8000a5d8 <fatfs_sfn_exists+0x144>
8000a522:	40 3c       	lddsp	r12,sp[0xc]
8000a524:	e0 a0 0c 85 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a528:	c4 90       	breq	8000a5ba <fatfs_sfn_exists+0x126>
8000a52a:	ee c8 fe e0 	sub	r8,r7,-288
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a52e:	50 08       	stdsp	sp[0x0],r8
8000a530:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a532:	e0 a0 0c 7e 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a536:	e0 80 00 f5 	breq	8000a720 <fatfs_sfn_exists+0x28c>
8000a53a:	ee c8 fe c0 	sub	r8,r7,-320
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a53e:	50 08       	stdsp	sp[0x0],r8
8000a540:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a542:	e0 a0 0c 76 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a546:	e0 80 00 db 	breq	8000a6fc <fatfs_sfn_exists+0x268>
8000a54a:	ee c8 fe a0 	sub	r8,r7,-352
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a54e:	50 08       	stdsp	sp[0x0],r8
8000a550:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a552:	e0 a0 0c 6e 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a556:	e0 80 01 31 	breq	8000a7b8 <fatfs_sfn_exists+0x324>
8000a55a:	ee c8 fe 80 	sub	r8,r7,-384
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a55e:	50 08       	stdsp	sp[0x0],r8
8000a560:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a562:	e0 a0 0c 66 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a566:	e0 80 01 16 	breq	8000a792 <fatfs_sfn_exists+0x2fe>
8000a56a:	ee c8 fe 60 	sub	r8,r7,-416
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a56e:	50 08       	stdsp	sp[0x0],r8
8000a570:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a572:	e0 a0 0c 5e 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a576:	e0 80 00 fb 	breq	8000a76c <fatfs_sfn_exists+0x2d8>
8000a57a:	ee c8 fe 40 	sub	r8,r7,-448
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a57e:	50 08       	stdsp	sp[0x0],r8
8000a580:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a582:	e0 a0 0c 56 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a586:	e0 80 00 e0 	breq	8000a746 <fatfs_sfn_exists+0x2b2>
8000a58a:	ee c8 fe 20 	sub	r8,r7,-480
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a58e:	50 08       	stdsp	sp[0x0],r8
8000a590:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a592:	e0 a0 0c 4e 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a596:	c9 a1       	brne	8000a4ca <fatfs_sfn_exists+0x36>
8000a598:	40 0c       	lddsp	r12,sp[0x0]
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a59a:	e0 a0 0c 51 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a59e:	c9 61       	brne	8000a4ca <fatfs_sfn_exists+0x36>
8000a5a0:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a5a2:	e0 a0 0c 81 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a5a6:	c9 20       	breq	8000a4ca <fatfs_sfn_exists+0x36>
8000a5a8:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a5aa:	30 ba       	mov	r10,11
8000a5ac:	40 5b       	lddsp	r11,sp[0x14]
8000a5ae:	e0 a0 24 a0 	rcall	8000eeee <strncmp>
8000a5b2:	c8 c1       	brne	8000a4ca <fatfs_sfn_exists+0x36>
8000a5b4:	30 1c       	mov	r12,1
8000a5b6:	2f ad       	sub	sp,-24
        else
            break;
    } // End of while loop

    return 0;
}
8000a5b8:	d8 32       	popm	r0-r7,pc
8000a5ba:	40 3c       	lddsp	r12,sp[0xc]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a5bc:	e0 a0 0c 40 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a5c0:	cb 51       	brne	8000a52a <fatfs_sfn_exists+0x96>
8000a5c2:	40 3c       	lddsp	r12,sp[0xc]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a5c4:	e0 a0 0c 70 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a5c8:	cb 10       	breq	8000a52a <fatfs_sfn_exists+0x96>
8000a5ca:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a5cc:	40 5b       	lddsp	r11,sp[0x14]
8000a5ce:	40 3c       	lddsp	r12,sp[0xc]
8000a5d0:	e0 a0 24 8f 	rcall	8000eeee <strncmp>
8000a5d4:	ca b1       	brne	8000a52a <fatfs_sfn_exists+0x96>
8000a5d6:	ce fb       	rjmp	8000a5b4 <fatfs_sfn_exists+0x120>
8000a5d8:	40 2c       	lddsp	r12,sp[0x8]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a5da:	e0 a0 0c 31 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a5de:	ca 21       	brne	8000a522 <fatfs_sfn_exists+0x8e>
8000a5e0:	40 2c       	lddsp	r12,sp[0x8]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a5e2:	e0 a0 0c 61 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a5e6:	c9 e0       	breq	8000a522 <fatfs_sfn_exists+0x8e>
8000a5e8:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a5ea:	40 5b       	lddsp	r11,sp[0x14]
8000a5ec:	40 2c       	lddsp	r12,sp[0x8]
8000a5ee:	e0 a0 24 80 	rcall	8000eeee <strncmp>
8000a5f2:	c9 81       	brne	8000a522 <fatfs_sfn_exists+0x8e>
8000a5f4:	30 1c       	mov	r12,1
8000a5f6:	ce 0b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a5f8:	40 1c       	lddsp	r12,sp[0x4]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a5fa:	e0 a0 0c 21 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a5fe:	c8 e1       	brne	8000a51a <fatfs_sfn_exists+0x86>
8000a600:	40 1c       	lddsp	r12,sp[0x4]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a602:	e0 a0 0c 51 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a606:	c8 a0       	breq	8000a51a <fatfs_sfn_exists+0x86>
8000a608:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a60a:	40 5b       	lddsp	r11,sp[0x14]
8000a60c:	40 1c       	lddsp	r12,sp[0x4]
8000a60e:	e0 a0 24 70 	rcall	8000eeee <strncmp>
8000a612:	c8 41       	brne	8000a51a <fatfs_sfn_exists+0x86>
8000a614:	30 1c       	mov	r12,1
8000a616:	cd 0b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a618:	00 9c       	mov	r12,r0
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a61a:	e0 a0 0c 11 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a61e:	fe 91 ff 7a 	brne	8000a512 <fatfs_sfn_exists+0x7e>
8000a622:	00 9c       	mov	r12,r0
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a624:	e0 a0 0c 40 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a628:	fe 90 ff 75 	breq	8000a512 <fatfs_sfn_exists+0x7e>
8000a62c:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a62e:	40 5b       	lddsp	r11,sp[0x14]
8000a630:	00 9c       	mov	r12,r0
8000a632:	e0 a0 24 5e 	rcall	8000eeee <strncmp>
8000a636:	fe 91 ff 6e 	brne	8000a512 <fatfs_sfn_exists+0x7e>
8000a63a:	30 1c       	mov	r12,1
8000a63c:	cb db       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a63e:	02 9c       	mov	r12,r1
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a640:	e0 a0 0b fe 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a644:	fe 91 ff 62 	brne	8000a508 <fatfs_sfn_exists+0x74>
8000a648:	02 9c       	mov	r12,r1
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a64a:	e0 a0 0c 2d 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a64e:	fe 90 ff 5d 	breq	8000a508 <fatfs_sfn_exists+0x74>
8000a652:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a654:	40 5b       	lddsp	r11,sp[0x14]
8000a656:	02 9c       	mov	r12,r1
8000a658:	e0 a0 24 4b 	rcall	8000eeee <strncmp>
8000a65c:	fe 91 ff 56 	brne	8000a508 <fatfs_sfn_exists+0x74>
8000a660:	30 1c       	mov	r12,1
8000a662:	ca ab       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a664:	08 9c       	mov	r12,r4
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a666:	e0 a0 0b eb 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a66a:	fe 91 ff 4a 	brne	8000a4fe <fatfs_sfn_exists+0x6a>
8000a66e:	08 9c       	mov	r12,r4
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a670:	e0 a0 0c 1a 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a674:	fe 90 ff 45 	breq	8000a4fe <fatfs_sfn_exists+0x6a>
8000a678:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a67a:	40 5b       	lddsp	r11,sp[0x14]
8000a67c:	08 9c       	mov	r12,r4
8000a67e:	e0 a0 24 38 	rcall	8000eeee <strncmp>
8000a682:	fe 91 ff 3e 	brne	8000a4fe <fatfs_sfn_exists+0x6a>
8000a686:	30 1c       	mov	r12,1
8000a688:	c9 7b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a68a:	06 9c       	mov	r12,r3
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a68c:	e0 a0 0b d8 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a690:	fe 91 ff 32 	brne	8000a4f4 <fatfs_sfn_exists+0x60>
8000a694:	06 9c       	mov	r12,r3
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a696:	e0 a0 0c 07 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a69a:	fe 90 ff 2d 	breq	8000a4f4 <fatfs_sfn_exists+0x60>
8000a69e:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a6a0:	40 5b       	lddsp	r11,sp[0x14]
8000a6a2:	06 9c       	mov	r12,r3
8000a6a4:	e0 a0 24 25 	rcall	8000eeee <strncmp>
8000a6a8:	fe 91 ff 26 	brne	8000a4f4 <fatfs_sfn_exists+0x60>
8000a6ac:	30 1c       	mov	r12,1
8000a6ae:	c8 4b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a6b0:	04 9c       	mov	r12,r2
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a6b2:	e0 a0 0b c5 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a6b6:	fe 91 ff 1a 	brne	8000a4ea <fatfs_sfn_exists+0x56>
8000a6ba:	04 9c       	mov	r12,r2
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a6bc:	e0 a0 0b f4 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a6c0:	fe 90 ff 15 	breq	8000a4ea <fatfs_sfn_exists+0x56>
8000a6c4:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a6c6:	40 5b       	lddsp	r11,sp[0x14]
8000a6c8:	04 9c       	mov	r12,r2
8000a6ca:	e0 a0 24 12 	rcall	8000eeee <strncmp>
8000a6ce:	fe 91 ff 0e 	brne	8000a4ea <fatfs_sfn_exists+0x56>
8000a6d2:	30 1c       	mov	r12,1
8000a6d4:	c7 1b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a6d6:	0e 9c       	mov	r12,r7
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a6d8:	e0 a0 0b b2 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a6dc:	fe 91 ff 02 	brne	8000a4e0 <fatfs_sfn_exists+0x4c>
8000a6e0:	0e 9c       	mov	r12,r7
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a6e2:	e0 a0 0b e1 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a6e6:	fe 90 fe fd 	breq	8000a4e0 <fatfs_sfn_exists+0x4c>
8000a6ea:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a6ec:	40 5b       	lddsp	r11,sp[0x14]
8000a6ee:	0e 9c       	mov	r12,r7
8000a6f0:	e0 a0 23 ff 	rcall	8000eeee <strncmp>
8000a6f4:	fe 91 fe f6 	brne	8000a4e0 <fatfs_sfn_exists+0x4c>
8000a6f8:	30 1c       	mov	r12,1
8000a6fa:	c5 eb       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a6fc:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a6fe:	e0 a0 0b 9f 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a702:	fe 91 ff 24 	brne	8000a54a <fatfs_sfn_exists+0xb6>
8000a706:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a708:	e0 a0 0b ce 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a70c:	fe 90 ff 1f 	breq	8000a54a <fatfs_sfn_exists+0xb6>
8000a710:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a712:	30 ba       	mov	r10,11
8000a714:	40 5b       	lddsp	r11,sp[0x14]
8000a716:	e0 a0 23 ec 	rcall	8000eeee <strncmp>
8000a71a:	fe 91 ff 18 	brne	8000a54a <fatfs_sfn_exists+0xb6>
8000a71e:	c4 bb       	rjmp	8000a5b4 <fatfs_sfn_exists+0x120>
8000a720:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a722:	e0 a0 0b 8d 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a726:	fe 91 ff 0a 	brne	8000a53a <fatfs_sfn_exists+0xa6>
8000a72a:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a72c:	e0 a0 0b bc 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a730:	fe 90 ff 05 	breq	8000a53a <fatfs_sfn_exists+0xa6>
8000a734:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a736:	30 ba       	mov	r10,11
8000a738:	40 5b       	lddsp	r11,sp[0x14]
8000a73a:	e0 a0 23 da 	rcall	8000eeee <strncmp>
8000a73e:	fe 91 fe fe 	brne	8000a53a <fatfs_sfn_exists+0xa6>
8000a742:	30 1c       	mov	r12,1
8000a744:	c3 9b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a746:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a748:	e0 a0 0b 7a 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a74c:	fe 91 ff 1f 	brne	8000a58a <fatfs_sfn_exists+0xf6>
8000a750:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a752:	e0 a0 0b a9 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a756:	fe 90 ff 1a 	breq	8000a58a <fatfs_sfn_exists+0xf6>
8000a75a:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a75c:	30 ba       	mov	r10,11
8000a75e:	40 5b       	lddsp	r11,sp[0x14]
8000a760:	e0 a0 23 c7 	rcall	8000eeee <strncmp>
8000a764:	fe 91 ff 13 	brne	8000a58a <fatfs_sfn_exists+0xf6>
8000a768:	30 1c       	mov	r12,1
8000a76a:	c2 6b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a76c:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a76e:	e0 a0 0b 67 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a772:	fe 91 ff 04 	brne	8000a57a <fatfs_sfn_exists+0xe6>
8000a776:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a778:	e0 a0 0b 96 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a77c:	fe 90 fe ff 	breq	8000a57a <fatfs_sfn_exists+0xe6>
8000a780:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a782:	30 ba       	mov	r10,11
8000a784:	40 5b       	lddsp	r11,sp[0x14]
8000a786:	e0 a0 23 b4 	rcall	8000eeee <strncmp>
8000a78a:	fe 91 fe f8 	brne	8000a57a <fatfs_sfn_exists+0xe6>
8000a78e:	30 1c       	mov	r12,1
8000a790:	c1 3b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a792:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a794:	e0 a0 0b 54 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a798:	fe 91 fe e9 	brne	8000a56a <fatfs_sfn_exists+0xd6>
8000a79c:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a79e:	e0 a0 0b 83 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a7a2:	fe 90 fe e4 	breq	8000a56a <fatfs_sfn_exists+0xd6>
8000a7a6:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a7a8:	30 ba       	mov	r10,11
8000a7aa:	40 5b       	lddsp	r11,sp[0x14]
8000a7ac:	e0 a0 23 a1 	rcall	8000eeee <strncmp>
8000a7b0:	fe 91 fe dd 	brne	8000a56a <fatfs_sfn_exists+0xd6>
8000a7b4:	30 1c       	mov	r12,1
8000a7b6:	c0 0b       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a7b8:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a7ba:	e0 a0 0b 41 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a7be:	fe 91 fe ce 	brne	8000a55a <fatfs_sfn_exists+0xc6>
8000a7c2:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a7c4:	e0 a0 0b 70 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a7c8:	fe 90 fe c9 	breq	8000a55a <fatfs_sfn_exists+0xc6>
8000a7cc:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a7ce:	30 ba       	mov	r10,11
8000a7d0:	40 5b       	lddsp	r11,sp[0x14]
8000a7d2:	e0 a0 23 8e 	rcall	8000eeee <strncmp>
8000a7d6:	fe 91 fe c2 	brne	8000a55a <fatfs_sfn_exists+0xc6>
8000a7da:	30 1c       	mov	r12,1
8000a7dc:	ce da       	rjmp	8000a5b6 <fatfs_sfn_exists+0x122>
8000a7de:	d7 03       	nop

8000a7e0 <fatfs_update_file_length>:
8000a7e0:	d4 31       	pushm	r0-r7,lr
8000a7e2:	20 8d       	sub	sp,32
8000a7e4:	50 4b       	stdsp	sp[0x10],r11
8000a7e6:	50 5a       	stdsp	sp[0x14],r10
8000a7e8:	50 79       	stdsp	sp[0x1c],r9
8000a7ea:	18 97       	mov	r7,r12
8000a7ec:	78 e8       	ld.w	r8,r12[0x38]
8000a7ee:	58 08       	cp.w	r8,0
8000a7f0:	e0 80 01 f4 	breq	8000abd8 <fatfs_update_file_length+0x3f8>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a7f4:	f8 ce ff 1c 	sub	lr,r12,-228
8000a7f8:	f8 c6 ff bc 	sub	r6,r12,-68
8000a7fc:	50 0e       	stdsp	sp[0x0],lr
8000a7fe:	f8 c9 fe fc 	sub	r9,r12,-260
8000a802:	f8 c8 fe dc 	sub	r8,r12,-292
8000a806:	f8 ce fe bc 	sub	lr,r12,-324
8000a80a:	30 05       	mov	r5,0
8000a80c:	50 66       	stdsp	sp[0x18],r6
8000a80e:	f8 c2 ff 9c 	sub	r2,r12,-100
8000a812:	f8 c3 ff 7c 	sub	r3,r12,-132
8000a816:	f8 c1 ff 5c 	sub	r1,r12,-164
8000a81a:	f8 c0 ff 3c 	sub	r0,r12,-196
8000a81e:	50 19       	stdsp	sp[0x4],r9
8000a820:	50 28       	stdsp	sp[0x8],r8
8000a822:	50 3e       	stdsp	sp[0xc],lr
8000a824:	0a 9a       	mov	r10,r5

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8000a826:	40 4b       	lddsp	r11,sp[0x10]
8000a828:	2f f5       	sub	r5,-1
8000a82a:	0e 9c       	mov	r12,r7
8000a82c:	fe b0 fd 4c 	rcall	8000a2c4 <T.41>
8000a830:	e0 80 01 d4 	breq	8000abd8 <fatfs_update_file_length+0x3f8>
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a834:	0c 9c       	mov	r12,r6
8000a836:	e0 a0 0a fc 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a83a:	e0 80 01 3c 	breq	8000aab2 <fatfs_update_file_length+0x2d2>
8000a83e:	04 9c       	mov	r12,r2
8000a840:	e0 a0 0a f7 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a844:	e0 80 01 23 	breq	8000aa8a <fatfs_update_file_length+0x2aa>
8000a848:	06 9c       	mov	r12,r3
8000a84a:	e0 a0 0a f2 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a84e:	e0 80 01 0a 	breq	8000aa62 <fatfs_update_file_length+0x282>
8000a852:	02 9c       	mov	r12,r1
8000a854:	e0 a0 0a ed 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a858:	e0 80 00 f1 	breq	8000aa3a <fatfs_update_file_length+0x25a>
8000a85c:	00 9c       	mov	r12,r0
8000a85e:	e0 a0 0a e8 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a862:	e0 80 00 d7 	breq	8000aa10 <fatfs_update_file_length+0x230>
8000a866:	40 0c       	lddsp	r12,sp[0x0]
8000a868:	e0 a0 0a e3 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a86c:	e0 80 00 bc 	breq	8000a9e4 <fatfs_update_file_length+0x204>
8000a870:	40 1c       	lddsp	r12,sp[0x4]
8000a872:	e0 a0 0a de 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a876:	e0 80 00 a1 	breq	8000a9b8 <fatfs_update_file_length+0x1d8>
8000a87a:	40 2c       	lddsp	r12,sp[0x8]
8000a87c:	e0 a0 0a d9 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a880:	e0 80 00 86 	breq	8000a98c <fatfs_update_file_length+0x1ac>
8000a884:	40 3c       	lddsp	r12,sp[0xc]
8000a886:	e0 a0 0a d4 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a88a:	c6 e0       	breq	8000a966 <fatfs_update_file_length+0x186>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a88c:	ec c4 fe e0 	sub	r4,r6,-288

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a890:	08 9c       	mov	r12,r4
8000a892:	e0 a0 0a ce 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a896:	e0 80 01 35 	breq	8000ab00 <fatfs_update_file_length+0x320>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a89a:	ec c4 fe c0 	sub	r4,r6,-320

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a89e:	08 9c       	mov	r12,r4
8000a8a0:	e0 a0 0a c7 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8a4:	e0 80 01 19 	breq	8000aad6 <fatfs_update_file_length+0x2f6>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a8a8:	ec c4 fe a0 	sub	r4,r6,-352

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a8ac:	08 9c       	mov	r12,r4
8000a8ae:	e0 a0 0a c0 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8b2:	e0 80 01 7d 	breq	8000abac <fatfs_update_file_length+0x3cc>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a8b6:	ec c4 fe 80 	sub	r4,r6,-384

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a8ba:	08 9c       	mov	r12,r4
8000a8bc:	e0 a0 0a b9 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8c0:	e0 80 01 60 	breq	8000ab80 <fatfs_update_file_length+0x3a0>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a8c4:	ec c4 fe 60 	sub	r4,r6,-416

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a8c8:	08 9c       	mov	r12,r4
8000a8ca:	e0 a0 0a b2 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8ce:	e0 80 01 43 	breq	8000ab54 <fatfs_update_file_length+0x374>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a8d2:	ec c4 fe 40 	sub	r4,r6,-448

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a8d6:	08 9c       	mov	r12,r4
8000a8d8:	e0 a0 0a ab 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8dc:	e0 80 01 27 	breq	8000ab2a <fatfs_update_file_length+0x34a>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000a8e0:	ec c4 fe 20 	sub	r4,r6,-480

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8000a8e4:	08 9c       	mov	r12,r4
8000a8e6:	e0 a0 0a a4 	rcall	8000be2e <fatfs_entry_lfn_text>
8000a8ea:	c9 d1       	brne	8000a824 <fatfs_update_file_length+0x44>
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a8ec:	08 9c       	mov	r12,r4
8000a8ee:	e0 a0 0a a7 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a8f2:	c9 91       	brne	8000a824 <fatfs_update_file_length+0x44>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a8f4:	08 9c       	mov	r12,r4
8000a8f6:	e0 a0 0a d7 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a8fa:	c9 50       	breq	8000a824 <fatfs_update_file_length+0x44>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a8fc:	30 ba       	mov	r10,11
8000a8fe:	40 5b       	lddsp	r11,sp[0x14]
8000a900:	08 9c       	mov	r12,r4
8000a902:	e0 a0 22 f6 	rcall	8000eeee <strncmp>
8000a906:	c8 f1       	brne	8000a824 <fatfs_update_file_length+0x44>
8000a908:	50 64       	stdsp	sp[0x18],r4
8000a90a:	e0 6c 01 e0 	mov	r12,480
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000a90e:	40 79       	lddsp	r9,sp[0x1c]
8000a910:	e6 19 00 ff 	andh	r9,0xff,COH
8000a914:	40 7e       	lddsp	lr,sp[0x1c]
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8000a916:	40 6b       	lddsp	r11,sp[0x18]
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000a918:	40 78       	lddsp	r8,sp[0x1c]
8000a91a:	1c 95       	mov	r5,lr
8000a91c:	b9 68       	lsl	r8,0x18
8000a91e:	e2 15 ff 00 	andl	r5,0xff00,COH
8000a922:	f1 ee 13 88 	or	r8,r8,lr>>0x18
8000a926:	f1 e5 10 88 	or	r8,r8,r5<<0x8
8000a92a:	f1 e9 12 88 	or	r8,r8,r9>>0x8
8000a92e:	f7 68 00 1f 	st.b	r11[31],r8
8000a932:	f0 09 16 18 	lsr	r9,r8,0x18
8000a936:	40 6e       	lddsp	lr,sp[0x18]
8000a938:	fd 69 00 1c 	st.b	lr[28],r9
8000a93c:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
8000a940:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8000a944:	ec 0c 00 0c 	add	r12,r6,r12
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000a948:	fd 68 00 1e 	st.b	lr[30],r8
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8000a94c:	32 0a       	mov	r10,32
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000a94e:	fd 69 00 1d 	st.b	lr[29],r9
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8000a952:	e0 a0 21 39 	rcall	8000ebc4 <memcpy>

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000a956:	0c 9b       	mov	r11,r6
8000a958:	ee fc 02 44 	ld.w	r12,r7[580]
8000a95c:	6e e8       	ld.w	r8,r7[0x38]
8000a95e:	30 1a       	mov	r10,1
8000a960:	5d 18       	icall	r8
        else
            break;
    } // End of while loop

    return 0;
}
8000a962:	2f 8d       	sub	sp,-32
8000a964:	d8 32       	popm	r0-r7,pc
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a966:	40 3c       	lddsp	r12,sp[0xc]
8000a968:	e0 a0 0a 6a 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a96c:	c9 01       	brne	8000a88c <fatfs_update_file_length+0xac>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a96e:	40 3c       	lddsp	r12,sp[0xc]
8000a970:	e0 a0 0a 9a 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a974:	c8 c0       	breq	8000a88c <fatfs_update_file_length+0xac>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a976:	30 ba       	mov	r10,11
8000a978:	40 5b       	lddsp	r11,sp[0x14]
8000a97a:	40 3c       	lddsp	r12,sp[0xc]
8000a97c:	e0 a0 22 b9 	rcall	8000eeee <strncmp>
8000a980:	c8 61       	brne	8000a88c <fatfs_update_file_length+0xac>
8000a982:	40 39       	lddsp	r9,sp[0xc]
8000a984:	e0 6c 01 00 	mov	r12,256
8000a988:	50 69       	stdsp	sp[0x18],r9
8000a98a:	cc 2b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a98c:	40 2c       	lddsp	r12,sp[0x8]
8000a98e:	e0 a0 0a 57 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a992:	fe 91 ff 79 	brne	8000a884 <fatfs_update_file_length+0xa4>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a996:	40 2c       	lddsp	r12,sp[0x8]
8000a998:	e0 a0 0a 86 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a99c:	fe 90 ff 74 	breq	8000a884 <fatfs_update_file_length+0xa4>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a9a0:	30 ba       	mov	r10,11
8000a9a2:	40 5b       	lddsp	r11,sp[0x14]
8000a9a4:	40 2c       	lddsp	r12,sp[0x8]
8000a9a6:	e0 a0 22 a4 	rcall	8000eeee <strncmp>
8000a9aa:	fe 91 ff 6d 	brne	8000a884 <fatfs_update_file_length+0xa4>
8000a9ae:	40 2e       	lddsp	lr,sp[0x8]
8000a9b0:	e0 6c 00 e0 	mov	r12,224
8000a9b4:	50 6e       	stdsp	sp[0x18],lr
8000a9b6:	ca cb       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a9b8:	40 1c       	lddsp	r12,sp[0x4]
8000a9ba:	e0 a0 0a 41 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a9be:	fe 91 ff 5e 	brne	8000a87a <fatfs_update_file_length+0x9a>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a9c2:	40 1c       	lddsp	r12,sp[0x4]
8000a9c4:	e0 a0 0a 70 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a9c8:	fe 90 ff 59 	breq	8000a87a <fatfs_update_file_length+0x9a>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a9cc:	30 ba       	mov	r10,11
8000a9ce:	40 5b       	lddsp	r11,sp[0x14]
8000a9d0:	40 1c       	lddsp	r12,sp[0x4]
8000a9d2:	e0 a0 22 8e 	rcall	8000eeee <strncmp>
8000a9d6:	fe 91 ff 52 	brne	8000a87a <fatfs_update_file_length+0x9a>
8000a9da:	40 18       	lddsp	r8,sp[0x4]
8000a9dc:	e0 6c 00 c0 	mov	r12,192
8000a9e0:	50 68       	stdsp	sp[0x18],r8
8000a9e2:	c9 6b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000a9e4:	40 0c       	lddsp	r12,sp[0x0]
8000a9e6:	e0 a0 0a 2b 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000a9ea:	fe 91 ff 43 	brne	8000a870 <fatfs_update_file_length+0x90>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000a9ee:	40 0c       	lddsp	r12,sp[0x0]
8000a9f0:	e0 a0 0a 5a 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000a9f4:	fe 90 ff 3e 	breq	8000a870 <fatfs_update_file_length+0x90>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000a9f8:	30 ba       	mov	r10,11
8000a9fa:	40 5b       	lddsp	r11,sp[0x14]
8000a9fc:	40 0c       	lddsp	r12,sp[0x0]
8000a9fe:	e0 a0 22 78 	rcall	8000eeee <strncmp>
8000aa02:	fe 91 ff 37 	brne	8000a870 <fatfs_update_file_length+0x90>
8000aa06:	40 09       	lddsp	r9,sp[0x0]
8000aa08:	e0 6c 00 a0 	mov	r12,160
8000aa0c:	50 69       	stdsp	sp[0x18],r9
8000aa0e:	c8 0b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aa10:	00 9c       	mov	r12,r0
8000aa12:	e0 a0 0a 15 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aa16:	fe 91 ff 28 	brne	8000a866 <fatfs_update_file_length+0x86>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aa1a:	00 9c       	mov	r12,r0
8000aa1c:	e0 a0 0a 44 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aa20:	fe 90 ff 23 	breq	8000a866 <fatfs_update_file_length+0x86>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aa24:	30 ba       	mov	r10,11
8000aa26:	40 5b       	lddsp	r11,sp[0x14]
8000aa28:	00 9c       	mov	r12,r0
8000aa2a:	e0 a0 22 62 	rcall	8000eeee <strncmp>
8000aa2e:	fe 91 ff 1c 	brne	8000a866 <fatfs_update_file_length+0x86>
8000aa32:	50 60       	stdsp	sp[0x18],r0
8000aa34:	e0 6c 00 80 	mov	r12,128
8000aa38:	c6 bb       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aa3a:	02 9c       	mov	r12,r1
8000aa3c:	e0 a0 0a 00 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aa40:	fe 91 ff 0e 	brne	8000a85c <fatfs_update_file_length+0x7c>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aa44:	02 9c       	mov	r12,r1
8000aa46:	e0 a0 0a 2f 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aa4a:	fe 90 ff 09 	breq	8000a85c <fatfs_update_file_length+0x7c>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aa4e:	30 ba       	mov	r10,11
8000aa50:	40 5b       	lddsp	r11,sp[0x14]
8000aa52:	02 9c       	mov	r12,r1
8000aa54:	e0 a0 22 4d 	rcall	8000eeee <strncmp>
8000aa58:	fe 91 ff 02 	brne	8000a85c <fatfs_update_file_length+0x7c>
8000aa5c:	50 61       	stdsp	sp[0x18],r1
8000aa5e:	36 0c       	mov	r12,96
8000aa60:	c5 7b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aa62:	06 9c       	mov	r12,r3
8000aa64:	e0 a0 09 ec 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aa68:	fe 91 fe f5 	brne	8000a852 <fatfs_update_file_length+0x72>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aa6c:	06 9c       	mov	r12,r3
8000aa6e:	e0 a0 0a 1b 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aa72:	fe 90 fe f0 	breq	8000a852 <fatfs_update_file_length+0x72>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aa76:	30 ba       	mov	r10,11
8000aa78:	40 5b       	lddsp	r11,sp[0x14]
8000aa7a:	06 9c       	mov	r12,r3
8000aa7c:	e0 a0 22 39 	rcall	8000eeee <strncmp>
8000aa80:	fe 91 fe e9 	brne	8000a852 <fatfs_update_file_length+0x72>
8000aa84:	50 63       	stdsp	sp[0x18],r3
8000aa86:	34 0c       	mov	r12,64
8000aa88:	c4 3b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aa8a:	04 9c       	mov	r12,r2
8000aa8c:	e0 a0 09 d8 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aa90:	fe 91 fe dc 	brne	8000a848 <fatfs_update_file_length+0x68>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aa94:	04 9c       	mov	r12,r2
8000aa96:	e0 a0 0a 07 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aa9a:	fe 90 fe d7 	breq	8000a848 <fatfs_update_file_length+0x68>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aa9e:	30 ba       	mov	r10,11
8000aaa0:	40 5b       	lddsp	r11,sp[0x14]
8000aaa2:	04 9c       	mov	r12,r2
8000aaa4:	e0 a0 22 25 	rcall	8000eeee <strncmp>
8000aaa8:	fe 91 fe d0 	brne	8000a848 <fatfs_update_file_length+0x68>
8000aaac:	50 62       	stdsp	sp[0x18],r2
8000aaae:	32 0c       	mov	r12,32
8000aab0:	c2 fb       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aab2:	0c 9c       	mov	r12,r6
8000aab4:	e0 a0 09 c4 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aab8:	fe 91 fe c3 	brne	8000a83e <fatfs_update_file_length+0x5e>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aabc:	0c 9c       	mov	r12,r6
8000aabe:	e0 a0 09 f3 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aac2:	fe 90 fe be 	breq	8000a83e <fatfs_update_file_length+0x5e>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aac6:	30 ba       	mov	r10,11
8000aac8:	40 5b       	lddsp	r11,sp[0x14]
8000aaca:	0c 9c       	mov	r12,r6
8000aacc:	e0 a0 22 11 	rcall	8000eeee <strncmp>
8000aad0:	fe 91 fe b7 	brne	8000a83e <fatfs_update_file_length+0x5e>
8000aad4:	c1 db       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000aad6:	08 9c       	mov	r12,r4
8000aad8:	e0 a0 09 b2 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000aadc:	fe 91 fe e6 	brne	8000a8a8 <fatfs_update_file_length+0xc8>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000aae0:	08 9c       	mov	r12,r4
8000aae2:	e0 a0 09 e1 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000aae6:	fe 90 fe e1 	breq	8000a8a8 <fatfs_update_file_length+0xc8>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000aaea:	30 ba       	mov	r10,11
8000aaec:	40 5b       	lddsp	r11,sp[0x14]
8000aaee:	08 9c       	mov	r12,r4
8000aaf0:	e0 a0 21 ff 	rcall	8000eeee <strncmp>
8000aaf4:	fe 91 fe da 	brne	8000a8a8 <fatfs_update_file_length+0xc8>
8000aaf8:	50 64       	stdsp	sp[0x18],r4
8000aafa:	e0 6c 01 40 	mov	r12,320
8000aafe:	c0 8b       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000ab00:	08 9c       	mov	r12,r4
8000ab02:	e0 a0 09 9d 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000ab06:	fe 91 fe ca 	brne	8000a89a <fatfs_update_file_length+0xba>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000ab0a:	08 9c       	mov	r12,r4
8000ab0c:	e0 a0 09 cc 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000ab10:	fe 90 fe c5 	breq	8000a89a <fatfs_update_file_length+0xba>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000ab14:	30 ba       	mov	r10,11
8000ab16:	40 5b       	lddsp	r11,sp[0x14]
8000ab18:	08 9c       	mov	r12,r4
8000ab1a:	e0 a0 21 ea 	rcall	8000eeee <strncmp>
8000ab1e:	fe 91 fe be 	brne	8000a89a <fatfs_update_file_length+0xba>
8000ab22:	50 64       	stdsp	sp[0x18],r4
8000ab24:	e0 6c 01 20 	mov	r12,288
8000ab28:	cf 3a       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000ab2a:	08 9c       	mov	r12,r4
8000ab2c:	e0 a0 09 88 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000ab30:	fe 91 fe d8 	brne	8000a8e0 <fatfs_update_file_length+0x100>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000ab34:	08 9c       	mov	r12,r4
8000ab36:	e0 a0 09 b7 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000ab3a:	fe 90 fe d3 	breq	8000a8e0 <fatfs_update_file_length+0x100>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000ab3e:	30 ba       	mov	r10,11
8000ab40:	40 5b       	lddsp	r11,sp[0x14]
8000ab42:	08 9c       	mov	r12,r4
8000ab44:	e0 a0 21 d5 	rcall	8000eeee <strncmp>
8000ab48:	fe 91 fe cc 	brne	8000a8e0 <fatfs_update_file_length+0x100>
8000ab4c:	50 64       	stdsp	sp[0x18],r4
8000ab4e:	e0 6c 01 c0 	mov	r12,448
8000ab52:	cd ea       	rjmp	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000ab54:	08 9c       	mov	r12,r4
8000ab56:	e0 a0 09 73 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000ab5a:	fe 91 fe bc 	brne	8000a8d2 <fatfs_update_file_length+0xf2>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000ab5e:	08 9c       	mov	r12,r4
8000ab60:	e0 a0 09 a2 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000ab64:	fe 90 fe b7 	breq	8000a8d2 <fatfs_update_file_length+0xf2>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000ab68:	30 ba       	mov	r10,11
8000ab6a:	40 5b       	lddsp	r11,sp[0x14]
8000ab6c:	08 9c       	mov	r12,r4
8000ab6e:	e0 a0 21 c0 	rcall	8000eeee <strncmp>
8000ab72:	fe 91 fe b0 	brne	8000a8d2 <fatfs_update_file_length+0xf2>
8000ab76:	50 64       	stdsp	sp[0x18],r4
8000ab78:	e0 6c 01 a0 	mov	r12,416
8000ab7c:	fe 9f fe c9 	bral	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000ab80:	08 9c       	mov	r12,r4
8000ab82:	e0 a0 09 5d 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000ab86:	fe 91 fe 9f 	brne	8000a8c4 <fatfs_update_file_length+0xe4>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000ab8a:	08 9c       	mov	r12,r4
8000ab8c:	e0 a0 09 8c 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000ab90:	fe 90 fe 9a 	breq	8000a8c4 <fatfs_update_file_length+0xe4>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000ab94:	30 ba       	mov	r10,11
8000ab96:	40 5b       	lddsp	r11,sp[0x14]
8000ab98:	08 9c       	mov	r12,r4
8000ab9a:	e0 a0 21 aa 	rcall	8000eeee <strncmp>
8000ab9e:	fe 91 fe 93 	brne	8000a8c4 <fatfs_update_file_length+0xe4>
8000aba2:	50 64       	stdsp	sp[0x18],r4
8000aba4:	e0 6c 01 80 	mov	r12,384
8000aba8:	fe 9f fe b3 	bral	8000a90e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000abac:	08 9c       	mov	r12,r4
8000abae:	e0 a0 09 47 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000abb2:	fe 91 fe 82 	brne	8000a8b6 <fatfs_update_file_length+0xd6>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8000abb6:	08 9c       	mov	r12,r4
8000abb8:	e0 a0 09 76 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000abbc:	fe 90 fe 7d 	breq	8000a8b6 <fatfs_update_file_length+0xd6>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000abc0:	30 ba       	mov	r10,11
8000abc2:	40 5b       	lddsp	r11,sp[0x14]
8000abc4:	08 9c       	mov	r12,r4
8000abc6:	e0 a0 21 94 	rcall	8000eeee <strncmp>
8000abca:	fe 91 fe 76 	brne	8000a8b6 <fatfs_update_file_length+0xd6>
8000abce:	50 64       	stdsp	sp[0x18],r4
8000abd0:	e0 6c 01 60 	mov	r12,352
8000abd4:	fe 9f fe 9d 	bral	8000a90e <fatfs_update_file_length+0x12e>

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000abd8:	2f 8d       	sub	sp,-32
8000abda:	d8 3a       	popm	r0-r7,pc,r12=0

8000abdc <fatfs_list_directory_next>:
8000abdc:	d4 31       	pushm	r0-r7,lr
8000abde:	fa cd 01 20 	sub	sp,sp,288
8000abe2:	18 92       	mov	r2,r12
8000abe4:	16 91       	mov	r1,r11
8000abe6:	50 1a       	stdsp	sp[0x4],r10
8000abe8:	fa c4 ff f6 	sub	r4,sp,-10
8000abec:	30 0b       	mov	r11,0
8000abee:	08 9c       	mov	r12,r4
8000abf0:	e0 a0 0a 05 	rcall	8000bffa <fatfs_lfn_cache_init>
            {
                // Increase directory offset 
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000abf4:	e4 c3 ff bc 	sub	r3,r2,-68
    struct lfn_cache lfn;
    int dotRequired = 0;
    int result = 0;
 
    // Initialise LFN cache first
    fatfs_lfn_cache_init(&lfn, 0);
8000abf8:	62 0a       	ld.w	r10,r1[0x0]
    {
        // If data read OK
        if (fatfs_sector_reader(fs, dirls->cluster, dirls->sector, 0))
        {
            // Maximum of 16 directory entries
            for (item = dirls->offset; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000abfa:	30 f5       	mov	r5,15
    fatfs_lfn_cache_init(&lfn, 0);

    while (1)
    {
        // If data read OK
        if (fatfs_sector_reader(fs, dirls->cluster, dirls->sector, 0))
8000abfc:	62 1b       	ld.w	r11,r1[0x4]
8000abfe:	04 9c       	mov	r12,r2
8000ac00:	fe b0 fb 62 	rcall	8000a2c4 <T.41>
8000ac04:	e0 80 00 ba 	breq	8000ad78 <fatfs_list_directory_next+0x19c>
        {
            // Maximum of 16 directory entries
            for (item = dirls->offset; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000ac08:	e3 37 00 08 	ld.ub	r7,r1[8]
8000ac0c:	ea 07 18 00 	cp.b	r7,r5
8000ac10:	e0 88 00 10 	brls	8000ac30 <fatfs_list_directory_next+0x54>
8000ac14:	c2 68       	rjmp	8000ac60 <fatfs_list_directory_next+0x84>
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if ( fatfs_entry_lfn_text(directoryEntry) )   
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
8000ac16:	e0 cb ff bc 	sub	r11,r0,-68
8000ac1a:	08 9c       	mov	r12,r4
8000ac1c:	e4 0b 00 0b 	add	r11,r2,r11
8000ac20:	e0 a0 08 20 	rcall	8000bc60 <fatfs_lfn_cache_entry>
    {
        // If data read OK
        if (fatfs_sector_reader(fs, dirls->cluster, dirls->sector, 0))
        {
            // Maximum of 16 directory entries
            for (item = dirls->offset; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000ac24:	2f f7       	sub	r7,-1
8000ac26:	5c 57       	castu.b	r7
8000ac28:	ea 07 18 00 	cp.b	r7,r5
8000ac2c:	e0 8b 00 1a 	brhi	8000ac60 <fatfs_list_directory_next+0x84>
            {
                // Increase directory offset 
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000ac30:	ee 00 15 05 	lsl	r0,r7,0x5
8000ac34:	e6 00 00 06 	add	r6,r3,r0

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if ( fatfs_entry_lfn_text(directoryEntry) )   
8000ac38:	0c 9c       	mov	r12,r6
8000ac3a:	e0 a0 08 fa 	rcall	8000be2e <fatfs_entry_lfn_text>
8000ac3e:	18 9b       	mov	r11,r12
8000ac40:	ce b1       	brne	8000ac16 <fatfs_list_directory_next+0x3a>
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
                     
                // If Invalid record found delete any long file name information collated
                else if ( fatfs_entry_lfn_invalid(directoryEntry) )     
8000ac42:	50 0b       	stdsp	sp[0x0],r11
8000ac44:	0c 9c       	mov	r12,r6
8000ac46:	e0 a0 08 fb 	rcall	8000be3c <fatfs_entry_lfn_invalid>
8000ac4a:	40 0b       	lddsp	r11,sp[0x0]
8000ac4c:	c1 10       	breq	8000ac6e <fatfs_list_directory_next+0x92>
                    fatfs_lfn_cache_init(&lfn, 0);
8000ac4e:	08 9c       	mov	r12,r4
8000ac50:	e0 a0 09 d5 	rcall	8000bffa <fatfs_lfn_cache_init>
    {
        // If data read OK
        if (fatfs_sector_reader(fs, dirls->cluster, dirls->sector, 0))
        {
            // Maximum of 16 directory entries
            for (item = dirls->offset; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000ac54:	2f f7       	sub	r7,-1
8000ac56:	5c 57       	castu.b	r7
8000ac58:	ea 07 18 00 	cp.b	r7,r5
8000ac5c:	fe 98 ff ea 	brls	8000ac30 <fatfs_list_directory_next+0x54>
                    return 1;            
                }
            }// end of for

            // If reached end of the dir move onto next sector
            dirls->sector++;
8000ac60:	62 0a       	ld.w	r10,r1[0x0]
            dirls->offset = 0;
8000ac62:	30 09       	mov	r9,0
                    return 1;            
                }
            }// end of for

            // If reached end of the dir move onto next sector
            dirls->sector++;
8000ac64:	2f fa       	sub	r10,-1
            dirls->offset = 0;
8000ac66:	e3 69 00 08 	st.b	r1[8],r9
                    return 1;            
                }
            }// end of for

            // If reached end of the dir move onto next sector
            dirls->sector++;
8000ac6a:	83 0a       	st.w	r1[0x0],r10
            dirls->offset = 0;
        }
        else
            break;
    }
8000ac6c:	cc 8b       	rjmp	8000abfc <fatfs_list_directory_next+0x20>
                // If Invalid record found delete any long file name information collated
                else if ( fatfs_entry_lfn_invalid(directoryEntry) )     
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists 
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) ) 
8000ac6e:	0c 9b       	mov	r11,r6
8000ac70:	08 9c       	mov	r12,r4
8000ac72:	e0 a0 08 fe 	rcall	8000be6e <fatfs_entry_lfn_exists>
8000ac76:	18 90       	mov	r0,r12
8000ac78:	e0 81 00 82 	brne	8000ad7c <fatfs_list_directory_next+0x1a0>
                    return 1;
                }            
                // Normal Entry, only 8.3 Text         
                else 
#endif        
                if ( fatfs_entry_sfn_only(directoryEntry) )
8000ac7c:	0c 9c       	mov	r12,r6
8000ac7e:	e0 a0 09 13 	rcall	8000bea4 <fatfs_entry_sfn_only>
8000ac82:	cd 10       	breq	8000ac24 <fatfs_list_directory_next+0x48>
                {
                    fatfs_lfn_cache_init(&lfn, 0);
8000ac84:	08 9c       	mov	r12,r4
8000ac86:	00 9b       	mov	r11,r0
8000ac88:	e0 a0 09 b9 	rcall	8000bffa <fatfs_lfn_cache_init>
                    
                    memset(short_filename, 0, sizeof(short_filename));
8000ac8c:	fa cb fe f0 	sub	r11,sp,-272
//-----------------------------------------------------------------------------
// fatfs_list_directory_next: Get the next entry in the directory.
// Returns: 1 = found, 0 = end of listing
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
int fatfs_list_directory_next(struct fatfs *fs, struct fs_dir_list_status *dirls, struct fs_dir_ent *entry)
8000ac90:	ec c9 ff fc 	sub	r9,r6,-4
#endif        
                if ( fatfs_entry_sfn_only(directoryEntry) )
                {
                    fatfs_lfn_cache_init(&lfn, 0);
                    
                    memset(short_filename, 0, sizeof(short_filename));
8000ac94:	fb 60 01 1c 	st.b	sp[284],r0
//-----------------------------------------------------------------------------
// fatfs_list_directory_next: Get the next entry in the directory.
// Returns: 1 = found, 0 = end of listing
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
int fatfs_list_directory_next(struct fatfs *fs, struct fs_dir_list_status *dirls, struct fs_dir_ent *entry)
8000ac98:	16 39       	cp.w	r9,r11
8000ac9a:	5f 3c       	srlo	r12
8000ac9c:	fa c8 fe ec 	sub	r8,sp,-276
8000aca0:	10 36       	cp.w	r6,r8
8000aca2:	5f ba       	srhi	r10
8000aca4:	f9 ea 10 0a 	or	r10,r12,r10
8000aca8:	f9 d6 c0 02 	bfextu	r12,r6,0x0,0x2
8000acac:	5f 0c       	sreq	r12
8000acae:	f9 ea 00 0a 	and	r10,r12,r10
8000acb2:	e0 0a 18 00 	cp.b	r10,r0
8000acb6:	c7 f0       	breq	8000adb4 <fatfs_list_directory_next+0x1d8>
                    
                    memset(short_filename, 0, sizeof(short_filename));

                    // Copy name to string
                    for (i=0; i<8; i++) 
                        short_filename[i] = directoryEntry->Name[i];
8000acb8:	72 09       	ld.w	r9,r9[0x0]
8000acba:	91 09       	st.w	r8[0x0],r9
8000acbc:	6c 08       	ld.w	r8,r6[0x0]
8000acbe:	97 08       	st.w	r11[0x0],r8

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8000acc0:	ed 38 00 09 	ld.ub	r8,r6[9]
8000acc4:	fb 68 01 1a 	st.b	sp[282],r8
8000acc8:	ed 39 00 08 	ld.ub	r9,r6[8]
8000accc:	fb 69 01 19 	st.b	sp[281],r9
                        if (directoryEntry->Name[i] != ' ')
8000acd0:	32 0a       	mov	r10,32
8000acd2:	f4 08 18 00 	cp.b	r8,r10
8000acd6:	c6 b0       	breq	8000adac <fatfs_list_directory_next+0x1d0>
8000acd8:	30 1c       	mov	r12,1

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8000acda:	ed 38 00 0a 	ld.ub	r8,r6[10]
8000acde:	fb 68 01 1b 	st.b	sp[283],r8
                        if (directoryEntry->Name[i] != ' ')
8000ace2:	32 09       	mov	r9,32
8000ace4:	f2 08 18 00 	cp.b	r8,r9
8000ace8:	c5 f0       	breq	8000ada6 <fatfs_list_directory_next+0x1ca>

                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
8000acea:	32 e8       	mov	r8,46
8000acec:	fb 39 01 10 	ld.ub	r9,sp[272]
8000acf0:	f0 09 18 00 	cp.b	r9,r8
8000acf4:	c5 50       	breq	8000ad9e <fatfs_list_directory_next+0x1c2>
                            short_filename[8] = '.';
                        else
                            short_filename[8] = ' ';
                    }
                    else
                        short_filename[8] = ' ';
8000acf6:	fb 68 01 18 	st.b	sp[280],r8
                    
                    fatfs_get_sfn_display_name(entry->filename, short_filename);
8000acfa:	40 1c       	lddsp	r12,sp[0x4]
8000acfc:	e0 a0 0c b6 	rcall	8000c668 <fatfs_get_sfn_display_name>

                    if (fatfs_entry_is_dir(directoryEntry)) 
8000ad00:	0c 9c       	mov	r12,r6
8000ad02:	e0 a0 08 e7 	rcall	8000bed0 <fatfs_entry_is_dir>
8000ad06:	c4 80       	breq	8000ad96 <fatfs_list_directory_next+0x1ba>
                        entry->is_dir = 1; 
8000ad08:	30 18       	mov	r8,1
8000ad0a:	40 19       	lddsp	r9,sp[0x4]
8000ad0c:	f3 68 01 04 	st.b	r9[260],r8
                    else
                        entry->is_dir = 0;

                    entry->size = FAT_HTONL(directoryEntry->FileSize);
8000ad10:	ed 39 00 1c 	ld.ub	r9,r6[28]
8000ad14:	ed 38 00 1d 	ld.ub	r8,r6[29]
8000ad18:	b1 68       	lsl	r8,0x10
8000ad1a:	f1 e9 11 88 	or	r8,r8,r9<<0x18
8000ad1e:	ed 39 00 1e 	ld.ub	r9,r6[30]
8000ad22:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000ad26:	ed 39 00 1f 	ld.ub	r9,r6[31]
8000ad2a:	f3 e8 10 08 	or	r8,r9,r8
8000ad2e:	10 99       	mov	r9,r8
8000ad30:	e6 19 00 ff 	andh	r9,0xff,COH
8000ad34:	f0 0a 15 18 	lsl	r10,r8,0x18
8000ad38:	f5 e8 13 8a 	or	r10,r10,r8>>0x18
8000ad3c:	e2 18 ff 00 	andl	r8,0xff00,COH
8000ad40:	f5 e8 10 88 	or	r8,r10,r8<<0x8
8000ad44:	f1 e9 12 88 	or	r8,r8,r9>>0x8
8000ad48:	40 19       	lddsp	r9,sp[0x4]
8000ad4a:	f3 48 01 0c 	st.w	r9[268],r8
                    entry->cluster = (FAT_HTONS(directoryEntry->FstClusHI)<<16) | FAT_HTONS(directoryEntry->FstClusLO);
8000ad4e:	ed 38 00 14 	ld.ub	r8,r6[20]
8000ad52:	ed 39 00 15 	ld.ub	r9,r6[21]
8000ad56:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000ad5a:	ed 3a 00 1b 	ld.ub	r10,r6[27]
8000ad5e:	ed 38 00 1a 	ld.ub	r8,r6[26]
8000ad62:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000ad66:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ad6a:	40 19       	lddsp	r9,sp[0x4]
8000ad6c:	f3 48 01 08 	st.w	r9[264],r8

                    // Next starting position
                    dirls->offset = item + 1;
8000ad70:	2f f7       	sub	r7,-1
8000ad72:	30 1c       	mov	r12,1
8000ad74:	e3 67 00 08 	st.b	r1[8],r7
        else
            break;
    }

    return result;
} 
8000ad78:	2b 8d       	sub	sp,-288
8000ad7a:	d8 32       	popm	r0-r7,pc

                // Normal SFN Entry and Long text exists 
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) ) 
                {
                    // Get text
                    long_filename = fatfs_lfn_cache_get(&lfn);
8000ad7c:	08 9c       	mov	r12,r4
8000ad7e:	e0 a0 08 41 	rcall	8000be00 <fatfs_lfn_cache_get>
                    strncpy(entry->filename, long_filename, FATFS_MAX_LONG_FILENAME-1);
8000ad82:	e0 6a 01 03 	mov	r10,259
8000ad86:	18 9b       	mov	r11,r12
8000ad88:	40 1c       	lddsp	r12,sp[0x4]
8000ad8a:	e0 a0 20 c5 	rcall	8000ef14 <strncpy>

                    if (fatfs_entry_is_dir(directoryEntry)) 
8000ad8e:	0c 9c       	mov	r12,r6
8000ad90:	e0 a0 08 a0 	rcall	8000bed0 <fatfs_entry_is_dir>
8000ad94:	cb a1       	brne	8000ad08 <fatfs_list_directory_next+0x12c>
                    fatfs_get_sfn_display_name(entry->filename, short_filename);

                    if (fatfs_entry_is_dir(directoryEntry)) 
                        entry->is_dir = 1; 
                    else
                        entry->is_dir = 0;
8000ad96:	40 18       	lddsp	r8,sp[0x4]
8000ad98:	f1 6c 01 04 	st.b	r8[260],r12
8000ad9c:	cb ab       	rjmp	8000ad10 <fatfs_list_directory_next+0x134>
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
                            short_filename[8] = '.';
                        else
                            short_filename[8] = ' ';
8000ad9e:	32 08       	mov	r8,32
8000ada0:	fb 68 01 18 	st.b	sp[280],r8
8000ada4:	ca bb       	rjmp	8000acfa <fatfs_list_directory_next+0x11e>
                        if (directoryEntry->Name[i] != ' ')
                            dotRequired = 1;
                    }

                    // Dot only required if extension present
                    if (dotRequired)
8000ada6:	58 0c       	cp.w	r12,0
8000ada8:	ca 70       	breq	8000acf6 <fatfs_list_directory_next+0x11a>
8000adaa:	ca 0b       	rjmp	8000acea <fatfs_list_directory_next+0x10e>
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
8000adac:	f0 09 18 00 	cp.b	r9,r8
8000adb0:	5f 1c       	srne	r12
8000adb2:	c9 4b       	rjmp	8000acda <fatfs_list_directory_next+0xfe>
                    
                    memset(short_filename, 0, sizeof(short_filename));

                    // Copy name to string
                    for (i=0; i<8; i++) 
                        short_filename[i] = directoryEntry->Name[i];
8000adb4:	0d 88       	ld.ub	r8,r6[0x0]
8000adb6:	fb 68 01 10 	st.b	sp[272],r8
8000adba:	0d 98       	ld.ub	r8,r6[0x1]
8000adbc:	fb 68 01 11 	st.b	sp[273],r8
8000adc0:	0d a8       	ld.ub	r8,r6[0x2]
8000adc2:	fb 68 01 12 	st.b	sp[274],r8
8000adc6:	0d b8       	ld.ub	r8,r6[0x3]
8000adc8:	fb 68 01 13 	st.b	sp[275],r8
8000adcc:	0d c8       	ld.ub	r8,r6[0x4]
8000adce:	fb 68 01 14 	st.b	sp[276],r8
8000add2:	0d d8       	ld.ub	r8,r6[0x5]
8000add4:	fb 68 01 15 	st.b	sp[277],r8
8000add8:	0d e8       	ld.ub	r8,r6[0x6]
8000adda:	fb 68 01 16 	st.b	sp[278],r8
8000adde:	0d f8       	ld.ub	r8,r6[0x7]
8000ade0:	fb 68 01 17 	st.b	sp[279],r8
8000ade4:	c6 eb       	rjmp	8000acc0 <fatfs_list_directory_next+0xe4>
8000ade6:	d7 03       	nop

8000ade8 <fatfs_write_sector>:
8000ade8:	eb cd 40 e0 	pushm	r5-r7,lr
8000adec:	20 1d       	sub	sp,4
8000adee:	18 96       	mov	r6,r12
8000adf0:	16 98       	mov	r8,r11
8000adf2:	78 e7       	ld.w	r7,r12[0x38]
8000adf4:	58 07       	cp.w	r7,0
8000adf6:	c2 50       	breq	8000ae40 <fatfs_write_sector+0x58>
8000adf8:	58 0b       	cp.w	r11,0
8000adfa:	5f 05       	sreq	r5
8000adfc:	78 ce       	ld.w	lr,r12[0x30]
8000adfe:	58 0e       	cp.w	lr,0
8000ae00:	5f 0e       	sreq	lr
8000ae02:	fd e5 00 05 	and	r5,lr,r5
8000ae06:	c1 10       	breq	8000ae28 <fatfs_write_sector+0x40>
8000ae08:	78 48       	ld.w	r8,r12[0x10]
8000ae0a:	14 38       	cp.w	r8,r10
8000ae0c:	e0 88 00 1a 	brls	8000ae40 <fatfs_write_sector+0x58>
8000ae10:	78 3c       	ld.w	r12,r12[0xc]
8000ae12:	6c 78       	ld.w	r8,r6[0x1c]
    {
        uint32 lba;

        // In FAT16 we cannot extend the root dir!
        if (sector < fs->rootdir_sectors)
            lba = fs->lba_begin + fs->rootdir_first_sector + sector;
8000ae14:	10 0c       	add	r12,r8
8000ae16:	14 0c       	add	r12,r10
        else
            return 0;

        // User target buffer passed in
        if (target)
8000ae18:	58 09       	cp.w	r9,0
8000ae1a:	c2 d0       	breq	8000ae74 <fatfs_write_sector+0x8c>
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8000ae1c:	12 9b       	mov	r11,r9
8000ae1e:	30 1a       	mov	r10,1
8000ae20:	5d 17       	icall	r7

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
        }
    }
}
8000ae22:	2f fd       	sub	sp,-4
8000ae24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    }
    // FAT16/32 Other
    else
    {
        // User target buffer passed in
        if (target)
8000ae28:	58 09       	cp.w	r9,0
8000ae2a:	c1 90       	breq	8000ae5c <fatfs_write_sector+0x74>
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8000ae2c:	58 0e       	cp.w	lr,0
8000ae2e:	c0 c1       	brne	8000ae46 <fatfs_write_sector+0x5e>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8000ae30:	78 1b       	ld.w	r11,r12[0x4]
8000ae32:	20 28       	sub	r8,2
8000ae34:	19 8c       	ld.ub	r12,r12[0x0]
8000ae36:	f0 0c 02 4c 	mul	r12,r8,r12
8000ae3a:	16 0c       	add	r12,r11
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8000ae3c:	14 0c       	add	r12,r10
8000ae3e:	ce fb       	rjmp	8000ae1c <fatfs_write_sector+0x34>
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000ae40:	2f fd       	sub	sp,-4
8000ae42:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8000ae46:	19 8b       	ld.ub	r11,r12[0x0]
8000ae48:	20 28       	sub	r8,2
8000ae4a:	f9 1c 00 28 	ld.uh	r12,r12[40]
8000ae4e:	b7 38       	mul	r8,r11
8000ae50:	a5 4c       	asr	r12,0x4
8000ae52:	6c 1b       	ld.w	r11,r6[0x4]
8000ae54:	16 0c       	add	r12,r11
8000ae56:	10 0c       	add	r12,r8
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8000ae58:	14 0c       	add	r12,r10
8000ae5a:	ce 1b       	rjmp	8000ae1c <fatfs_write_sector+0x34>
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8000ae5c:	50 0a       	stdsp	sp[0x0],r10
8000ae5e:	fe b0 f8 d9 	rcall	8000a010 <fatfs_lba_of_cluster>
8000ae62:	40 0a       	lddsp	r10,sp[0x0]

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000ae64:	ec cb ff bc 	sub	r11,r6,-68
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8000ae68:	14 0c       	add	r12,r10

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000ae6a:	30 1a       	mov	r10,1
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8000ae6c:	ed 4c 02 44 	st.w	r6[580],r12

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000ae70:	5d 17       	icall	r7
8000ae72:	cd 8b       	rjmp	8000ae22 <fatfs_write_sector+0x3a>
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = lba;
8000ae74:	ed 4c 02 44 	st.w	r6[580],r12

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000ae78:	ec cb ff bc 	sub	r11,r6,-68
8000ae7c:	30 1a       	mov	r10,1
8000ae7e:	5d 17       	icall	r7
8000ae80:	cd 1b       	rjmp	8000ae22 <fatfs_write_sector+0x3a>
8000ae82:	d7 03       	nop

8000ae84 <fatfs_sector_reader>:
8000ae84:	eb cd 40 fc 	pushm	r2-r7,lr
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000ae88:	58 0b       	cp.w	r11,0
8000ae8a:	5f 08       	sreq	r8
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
8000ae8c:	12 93       	mov	r3,r9
8000ae8e:	18 97       	mov	r7,r12
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000ae90:	78 c9       	ld.w	r9,r12[0x30]
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
8000ae92:	14 96       	mov	r6,r10
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8000ae94:	58 09       	cp.w	r9,0
8000ae96:	5f 09       	sreq	r9
8000ae98:	12 68       	and	r8,r9
8000ae9a:	c1 10       	breq	8000aebc <fatfs_sector_reader+0x38>
    {
        if (offset < fs->rootdir_sectors)
8000ae9c:	78 48       	ld.w	r8,r12[0x10]
8000ae9e:	14 38       	cp.w	r8,r10
8000aea0:	e0 88 00 3b 	brls	8000af16 <fatfs_sector_reader+0x92>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8000aea4:	78 3c       	ld.w	r12,r12[0xc]
8000aea6:	6e 78       	ld.w	r8,r7[0x1c]
8000aea8:	10 0c       	add	r12,r8
8000aeaa:	14 0c       	add	r12,r10
        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
    }

    // User provided target array
    if (target)
8000aeac:	58 03       	cp.w	r3,0
8000aeae:	c2 70       	breq	8000aefc <fatfs_sector_reader+0x78>
        return fs->disk_io.read_media(lba, target, 1);
8000aeb0:	6e d8       	ld.w	r8,r7[0x34]
8000aeb2:	06 9b       	mov	r11,r3
8000aeb4:	30 1a       	mov	r10,1
8000aeb6:	5d 18       	icall	r8
8000aeb8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
8000aebc:	19 82       	ld.ub	r2,r12[0x0]
8000aebe:	f4 02 0d 08 	divu	r8,r10,r2
8000aec2:	10 94       	mov	r4,r8
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000aec4:	58 08       	cp.w	r8,0
8000aec6:	c0 a0       	breq	8000aeda <fatfs_sector_reader+0x56>
8000aec8:	30 05       	mov	r5,0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8000aeca:	0e 9c       	mov	r12,r7
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000aecc:	2f f5       	sub	r5,-1
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8000aece:	e0 a0 0e 7f 	rcall	8000cbcc <fatfs_find_next_cluster>
8000aed2:	18 9b       	mov	r11,r12
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8000aed4:	0a 34       	cp.w	r4,r5
8000aed6:	fe 9b ff fa 	brhi	8000aeca <fatfs_sector_reader+0x46>
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
8000aeda:	5b fb       	cp.w	r11,-1
8000aedc:	c1 d0       	breq	8000af16 <fatfs_sector_reader+0x92>
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8000aede:	6e c8       	ld.w	r8,r7[0x30]
8000aee0:	58 08       	cp.w	r8,0
8000aee2:	c1 c0       	breq	8000af1a <fatfs_sector_reader+0x96>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8000aee4:	0f 88       	ld.ub	r8,r7[0x0]
8000aee6:	20 2b       	sub	r11,2
8000aee8:	b1 3b       	mul	r11,r8
8000aeea:	6e 18       	ld.w	r8,r7[0x4]
8000aeec:	f6 08 00 08 	add	r8,r11,r8
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8000aef0:	a5 34       	mul	r4,r2
8000aef2:	08 16       	sub	r6,r4
8000aef4:	ec 08 00 0c 	add	r12,r6,r8
    }

    // User provided target array
    if (target)
8000aef8:	58 03       	cp.w	r3,0
8000aefa:	cd b1       	brne	8000aeb0 <fatfs_sector_reader+0x2c>
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000aefc:	ee f8 02 44 	ld.w	r8,r7[580]
8000af00:	18 38       	cp.w	r8,r12
8000af02:	c1 70       	breq	8000af30 <fatfs_sector_reader+0xac>
    {
        fs->currentsector.address = lba;
8000af04:	ef 4c 02 44 	st.w	r7[580],r12
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000af08:	ee cb ff bc 	sub	r11,r7,-68
8000af0c:	6e d8       	ld.w	r8,r7[0x34]
8000af0e:	30 1a       	mov	r10,1
8000af10:	5d 18       	icall	r8
8000af12:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000af16:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8000af1a:	ef 19 00 28 	ld.uh	r9,r7[40]
8000af1e:	a5 49       	asr	r9,0x4
8000af20:	20 2b       	sub	r11,2
8000af22:	6e 18       	ld.w	r8,r7[0x4]
8000af24:	f2 08 00 08 	add	r8,r9,r8
8000af28:	0f 89       	ld.ub	r9,r7[0x0]
8000af2a:	f6 09 03 48 	mac	r8,r11,r9
8000af2e:	ce 1b       	rjmp	8000aef0 <fatfs_sector_reader+0x6c>

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8000af30:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

8000af34 <fatfs_cache_init>:
        file->cluster_cache_data[i] = 0; 
    }
#endif
    
    return 1;
}
8000af34:	5e ff       	retal	1

8000af36 <fatfs_cache_get_next_cluster>:
        return 1;
    }
#endif
    
    return 0;
}
8000af36:	5e fd       	retal	0

8000af38 <fatfs_cache_set_next_cluster>:
        file->cluster_cache_data[slot] = nextCluster;
    }
#endif

    return 1;
}
8000af38:	5e ff       	retal	1
8000af3a:	d7 03       	nop

8000af3c <_free_file>:
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8000af3c:	f8 f8 04 3c 	ld.w	r8,r12[1084]
8000af40:	58 08       	cp.w	r8,0
8000af42:	c1 f0       	breq	8000af80 <_free_file+0x44>
        list->head = node->next;
    else
        node->previous->next = node->next;
8000af44:	f8 f9 04 40 	ld.w	r9,r12[1088]
8000af48:	91 19       	st.w	r8[0x4],r9
8000af4a:	f8 f8 04 40 	ld.w	r8,r12[1088]
8000af4e:	f8 f9 04 3c 	ld.w	r9,r12[1084]

    if(!node->next)
8000af52:	58 08       	cp.w	r8,0
8000af54:	c1 e0       	breq	8000af90 <_free_file+0x54>
        list->tail = node->previous;
    else
        node->next->previous = node->previous;
8000af56:	91 09       	st.w	r8[0x0],r9
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8000af58:	e0 6b 26 54 	mov	r11,9812
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8000af5c:	f8 c9 fb c4 	sub	r9,r12,-1084
8000af60:	76 18       	ld.w	r8,r11[0x4]
8000af62:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000af64:	c1 a0       	breq	8000af98 <_free_file+0x5c>
8000af66:	f9 48 04 3c 	st.w	r12[1084],r8
    new_node->next = node->next;
8000af6a:	70 1a       	ld.w	r10,r8[0x4]
8000af6c:	f9 4a 04 40 	st.w	r12[1088],r10
    if (!node->next)
        list->tail = new_node;
8000af70:	70 1a       	ld.w	r10,r8[0x4]
8000af72:	58 0a       	cp.w	r10,0
8000af74:	f7 f9 0a 01 	st.weq	r11[0x4],r9
    else
        node->next->previous = new_node;
8000af78:	f5 f9 1a 00 	st.wne	r10[0x0],r9
    node->next = new_node;
8000af7c:	91 19       	st.w	r8[0x4],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8000af7e:	5e fc       	retal	r12
8000af80:	10 99       	mov	r9,r8
8000af82:	e0 6a 19 54 	mov	r10,6484
8000af86:	f8 f8 04 40 	ld.w	r8,r12[1088]
    else
        node->previous->next = node->next;

    if(!node->next)
8000af8a:	95 08       	st.w	r10[0x0],r8
        list->tail = node->previous;
8000af8c:	58 08       	cp.w	r8,0
8000af8e:	ce 41       	brne	8000af56 <_free_file+0x1a>
8000af90:	e0 68 19 54 	mov	r8,6484
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000af94:	91 19       	st.w	r8[0x4],r9
8000af96:	ce 1b       	rjmp	8000af58 <_free_file+0x1c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000af98:	76 08       	ld.w	r8,r11[0x0]
    new_node->next = node;
8000af9a:	58 08       	cp.w	r8,0
8000af9c:	c0 e0       	breq	8000afb8 <_free_file+0x7c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000af9e:	70 0a       	ld.w	r10,r8[0x0]
8000afa0:	f9 48 04 40 	st.w	r12[1088],r8
    new_node->next = node;
    if (!node->previous)
        list->head = new_node;
8000afa4:	f9 4a 04 3c 	st.w	r12[1084],r10
8000afa8:	70 0a       	ld.w	r10,r8[0x0]
    else
        node->previous->next = new_node;
8000afaa:	58 0a       	cp.w	r10,0
8000afac:	f7 f9 0a 00 	st.weq	r11[0x0],r9
    node->previous = new_node;
8000afb0:	f5 f9 1a 01 	st.wne	r10[0x4],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000afb4:	91 09       	st.w	r8[0x0],r9
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8000afb6:	5e fc       	retal	r12
8000afb8:	97 19       	st.w	r11[0x4],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000afba:	97 09       	st.w	r11[0x0],r9
8000afbc:	f9 48 04 40 	st.w	r12[1088],r8
8000afc0:	f9 48 04 3c 	st.w	r12[1084],r8
8000afc4:	5e fc       	retal	r12
8000afc6:	d7 03       	nop

8000afc8 <fl_init>:
8000afc8:	e0 68 1d c8 	mov	r8,7624
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000afcc:	30 09       	mov	r9,0
8000afce:	f1 49 08 84 	st.w	r8[2180],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000afd2:	f1 49 04 3c 	st.w	r8[1084],r9
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000afd6:	e0 6a 19 54 	mov	r10,6484
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000afda:	95 09       	st.w	r10[0x0],r9
8000afdc:	95 19       	st.w	r10[0x4],r9
    new_node->next = node->next;
    if (!node->next)
8000afde:	f0 c9 fb c4 	sub	r9,r8,-1084
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000afe2:	f0 ca f7 80 	sub	r10,r8,-2176
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000afe6:	f1 49 08 80 	st.w	r8[2176],r9
8000afea:	f1 4a 04 40 	st.w	r8[1088],r10
8000afee:	e0 68 26 54 	mov	r8,9812

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000aff2:	91 09       	st.w	r8[0x0],r9
8000aff4:	91 1a       	st.w	r8[0x4],r10
}
8000aff6:	30 19       	mov	r9,1
8000aff8:	e0 68 26 50 	mov	r8,9808
8000affc:	91 09       	st.w	r8[0x0],r9
8000affe:	5e fc       	retal	r12

8000b000 <_open_directory>:
8000b000:	eb cd 40 fe 	pushm	r1-r7,lr
8000b004:	fa cd 01 24 	sub	sp,sp,292
//-----------------------------------------------------------------------------
// _open_directory: Cycle through path string to find the start cluster
// address of the highest subdir.
//-----------------------------------------------------------------------------
static int _open_directory(char *path, uint32 *pathCluster)
{
8000b008:	18 93       	mov	r3,r12
8000b00a:	16 91       	mov	r1,r11
    char currentfolder[FATFS_MAX_LONG_FILENAME];
    struct fat_dir_entry sfEntry;
    uint32 startcluster;

    // Set starting cluster to root cluster
    startcluster = fatfs_get_root_cluster(&_fs);
8000b00c:	e0 6c 19 60 	mov	r12,6496
8000b010:	fe b0 f8 25 	rcall	8000a05a <fatfs_get_root_cluster>

    // Find number of levels
    levels = fatfs_total_path_levels(path);
8000b014:	18 95       	mov	r5,r12
8000b016:	06 9c       	mov	r12,r3
8000b018:	e0 a0 0a fa 	rcall	8000c60c <fatfs_total_path_levels>

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8000b01c:	18 92       	mov	r2,r12
8000b01e:	c3 35       	brlt	8000b084 <_open_directory+0x84>
8000b020:	30 07       	mov	r7,0
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
            return 0;

        // Find clusteraddress for folder (currentfolder) 
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
8000b022:	1a 96       	mov	r6,sp
8000b024:	fa c4 fe fc 	sub	r4,sp,-260
8000b028:	c2 18       	rjmp	8000b06a <_open_directory+0x6a>
8000b02a:	0a 9b       	mov	r11,r5
8000b02c:	08 99       	mov	r9,r4
8000b02e:	1a 9a       	mov	r10,sp
8000b030:	e0 6c 19 60 	mov	r12,6496
8000b034:	fe b0 f9 88 	rcall	8000a344 <fatfs_get_file_entry>
        {
            // Check entry is folder
            if (fatfs_entry_is_dir(&sfEntry))
8000b038:	c2 30       	breq	8000b07e <_open_directory+0x7e>
8000b03a:	08 9c       	mov	r12,r4
8000b03c:	e0 a0 07 4a 	rcall	8000bed0 <fatfs_entry_is_dir>
                startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8000b040:	c1 f0       	breq	8000b07e <_open_directory+0x7e>
8000b042:	fb 19 01 18 	ld.uh	r9,sp[280]
8000b046:	fb 18 01 1e 	ld.uh	r8,sp[286]
8000b04a:	f2 05 15 08 	lsl	r5,r9,0x8
8000b04e:	eb d5 c0 10 	bfextu	r5,r5,0x0,0x10
8000b052:	eb e9 12 85 	or	r5,r5,r9>>0x8
8000b056:	f0 09 15 08 	lsl	r9,r8,0x8
8000b05a:	b1 65       	lsl	r5,0x10
8000b05c:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b060:	f3 e8 12 88 	or	r8,r9,r8>>0x8

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8000b064:	10 05       	add	r5,r8
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
8000b066:	0e 32       	cp.w	r2,r7
8000b068:	c0 e5       	brlt	8000b084 <_open_directory+0x84>
8000b06a:	0e 9b       	mov	r11,r7

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8000b06c:	e0 69 01 04 	mov	r9,260
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
8000b070:	2f f7       	sub	r7,-1
8000b072:	1a 9a       	mov	r10,sp
8000b074:	06 9c       	mov	r12,r3
8000b076:	e0 a0 0c 17 	rcall	8000c8a4 <fatfs_get_substring>
        else
            return 0;
    }

    *pathCluster = startcluster;
    return 1;
8000b07a:	5b fc       	cp.w	r12,-1
8000b07c:	cd 71       	brne	8000b02a <_open_directory+0x2a>
8000b07e:	2b 7d       	sub	sp,-292
        }
        else
            return 0;
    }

    *pathCluster = startcluster;
8000b080:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000b084:	83 05       	st.w	r1[0x0],r5
8000b086:	2b 7d       	sub	sp,-292
8000b088:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1

8000b08c <_write_sectors>:
8000b08c:	d4 31       	pushm	r0-r7,lr
8000b08e:	20 3d       	sub	sp,12
8000b090:	3f f8       	mov	r8,-1
8000b092:	12 90       	mov	r0,r9
8000b094:	50 28       	stdsp	sp[0x8],r8
8000b096:	e0 69 19 60 	mov	r9,6496
8000b09a:	50 0a       	stdsp	sp[0x0],r10
8000b09c:	13 88       	ld.ub	r8,r9[0x0]
8000b09e:	f6 08 0d 06 	divu	r6,r11,r8
    uint32 lba;
    uint32 TotalWriteCount = count;

    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);
8000b0a2:	18 95       	mov	r5,r12
8000b0a4:	ec 08 02 42 	mul	r2,r6,r8
8000b0a8:	0c 94       	mov	r4,r6
8000b0aa:	f6 02 01 02 	sub	r2,r11,r2
    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000b0ae:	f8 f7 02 28 	ld.w	r7,r12[552]
    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);

    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
8000b0b2:	e4 00 00 09 	add	r9,r2,r0
8000b0b6:	12 38       	cp.w	r8,r9
8000b0b8:	e0 01 17 20 	movhs	r1,r0
        count = _fs.sectors_per_cluster - SectorNumber;
8000b0bc:	f1 d2 e3 11 	subcs	r1,r8,r2

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000b0c0:	0c 37       	cp.w	r7,r6
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b0c2:	c5 b0       	breq	8000b178 <_write_sectors+0xec>
8000b0c4:	58 06       	cp.w	r6,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;
8000b0c6:	c4 e1       	brne	8000b162 <_write_sectors+0xd6>
8000b0c8:	6a 16       	ld.w	r6,r5[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b0ca:	30 07       	mov	r7,0
8000b0cc:	0e 34       	cp.w	r4,r7
8000b0ce:	e0 88 00 58 	brls	8000b17e <_write_sectors+0xf2>
8000b0d2:	fa c3 ff fc 	sub	r3,sp,-4

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
8000b0d6:	c0 98       	rjmp	8000b0e8 <_write_sectors+0x5c>
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b0d8:	50 26       	stdsp	sp[0x8],r6
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
8000b0da:	2f f7       	sub	r7,-1

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
8000b0dc:	40 16       	lddsp	r6,sp[0x4]
8000b0de:	5b f6       	cp.w	r6,-1
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b0e0:	c1 c0       	breq	8000b118 <_write_sectors+0x8c>
8000b0e2:	0e 34       	cp.w	r4,r7
8000b0e4:	e0 88 00 2a 	brls	8000b138 <_write_sectors+0xac>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
8000b0e8:	0e 9a       	mov	r10,r7
8000b0ea:	06 99       	mov	r9,r3
8000b0ec:	0a 9b       	mov	r11,r5
8000b0ee:	e0 6c 19 60 	mov	r12,6496
8000b0f2:	c2 2f       	rcall	8000af36 <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000b0f4:	cf 21       	brne	8000b0d8 <_write_sectors+0x4c>
8000b0f6:	0c 9b       	mov	r11,r6
8000b0f8:	e0 6c 19 60 	mov	r12,6496

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8000b0fc:	e0 a0 0d 68 	rcall	8000cbcc <fatfs_find_next_cluster>
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000b100:	0e 9a       	mov	r10,r7

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8000b102:	18 99       	mov	r9,r12
8000b104:	50 1c       	stdsp	sp[0x4],r12
8000b106:	0a 9b       	mov	r11,r5
8000b108:	e0 6c 19 60 	mov	r12,6496
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b10c:	c1 6f       	rcall	8000af38 <fatfs_cache_set_next_cluster>
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
8000b10e:	50 26       	stdsp	sp[0x8],r6

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
8000b110:	2f f7       	sub	r7,-1
8000b112:	40 16       	lddsp	r6,sp[0x4]
8000b114:	5b f6       	cp.w	r6,-1
8000b116:	ce 61       	brne	8000b0e2 <_write_sectors+0x56>

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
        {
            // Add some more cluster(s) to the last good cluster chain
            if (!fatfs_add_free_space(&_fs, &LastCluster,  (TotalWriteCount + _fs.sectors_per_cluster -1) / _fs.sectors_per_cluster))
8000b118:	e0 69 19 60 	mov	r9,6496
8000b11c:	13 88       	ld.ub	r8,r9[0x0]
8000b11e:	e0 cb 00 01 	sub	r11,r0,1
8000b122:	10 0b       	add	r11,r8
8000b124:	f6 08 0d 0a 	divu	r10,r11,r8
8000b128:	fa cb ff f8 	sub	r11,sp,-8
8000b12c:	e0 6c 19 60 	mov	r12,6496
            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
8000b130:	e0 a0 15 ec 	rcall	8000dd08 <fatfs_add_free_space>

            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
8000b134:	c1 e0       	breq	8000b170 <_write_sectors+0xe4>
8000b136:	40 26       	lddsp	r6,sp[0x8]
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
    }

    // Calculate write address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + SectorNumber;
8000b138:	eb 44 02 28 	st.w	r5[552],r4
8000b13c:	eb 46 02 2c 	st.w	r5[556],r6

    if (fatfs_sector_write(&_fs, lba, buf, count))
8000b140:	0c 9b       	mov	r11,r6
8000b142:	e0 6c 19 60 	mov	r12,6496
8000b146:	fe b0 f7 65 	rcall	8000a010 <fatfs_lba_of_cluster>
8000b14a:	02 99       	mov	r9,r1
8000b14c:	f8 02 00 0b 	add	r11,r12,r2
        return count;
    else
        return 0;
}
8000b150:	40 0a       	lddsp	r10,sp[0x0]
8000b152:	e0 6c 19 60 	mov	r12,6496
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b156:	fe b0 f7 7a 	rcall	8000a04a <fatfs_sector_write>
8000b15a:	c0 b0       	breq	8000b170 <_write_sectors+0xe4>
8000b15c:	02 9c       	mov	r12,r1
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
8000b15e:	2f dd       	sub	sp,-12
8000b160:	d8 32       	popm	r0-r7,pc
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b162:	ee c9 ff ff 	sub	r9,r7,-1

    if (fatfs_sector_write(&_fs, lba, buf, count))
        return count;
    else
        return 0;
}
8000b166:	0c 39       	cp.w	r9,r6
8000b168:	cb 01       	brne	8000b0c8 <_write_sectors+0x3c>
8000b16a:	f8 f6 02 2c 	ld.w	r6,r12[556]
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
8000b16e:	ca fb       	rjmp	8000b0cc <_write_sectors+0x40>
8000b170:	30 01       	mov	r1,0
            if (Cluster == FAT32_LAST_CLUSTER)
                break;
        }

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
8000b172:	02 9c       	mov	r12,r1
8000b174:	2f dd       	sub	sp,-12
8000b176:	d8 32       	popm	r0-r7,pc
8000b178:	f8 f6 02 2c 	ld.w	r6,r12[556]
8000b17c:	ce 2b       	rjmp	8000b140 <_write_sectors+0xb4>
8000b17e:	5b f6       	cp.w	r6,-1
8000b180:	cd c1       	brne	8000b138 <_write_sectors+0xac>
8000b182:	cc eb       	rjmp	8000b11e <_write_sectors+0x92>

8000b184 <_read_sectors>:
8000b184:	d4 31       	pushm	r0-r7,lr
8000b186:	20 1d       	sub	sp,4
8000b188:	12 92       	mov	r2,r9
8000b18a:	e0 68 19 60 	mov	r8,6496
8000b18e:	18 96       	mov	r6,r12
8000b190:	11 88       	ld.ub	r8,r8[0x0]
8000b192:	14 90       	mov	r0,r10
    uint32 Cluster = 0;
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
8000b194:	f6 08 0d 04 	divu	r4,r11,r8
    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000b198:	f8 f7 02 28 	ld.w	r7,r12[552]
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    Sector = offset - (ClusterIdx * _fs.sectors_per_cluster);
8000b19c:	e8 08 02 41 	mul	r1,r4,r8
8000b1a0:	08 95       	mov	r5,r4
8000b1a2:	f6 01 01 01 	sub	r1,r11,r1

    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
8000b1a6:	e2 09 00 09 	add	r9,r1,r9
        count = _fs.sectors_per_cluster - Sector;
8000b1aa:	12 38       	cp.w	r8,r9
8000b1ac:	f1 d1 e3 12 	subcs	r2,r8,r1

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000b1b0:	08 37       	cp.w	r7,r4
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b1b2:	c3 e0       	breq	8000b22e <_read_sectors+0xaa>
8000b1b4:	58 04       	cp.w	r4,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;                    
8000b1b6:	c4 41       	brne	8000b23e <_read_sectors+0xba>
8000b1b8:	6c 14       	ld.w	r4,r6[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b1ba:	30 07       	mov	r7,0
8000b1bc:	0e 35       	cp.w	r5,r7
8000b1be:	e0 88 00 21 	brls	8000b200 <_read_sectors+0x7c>
8000b1c2:	1a 93       	mov	r3,sp
8000b1c4:	c0 68       	rjmp	8000b1d0 <_read_sectors+0x4c>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            Cluster = nextCluster;
8000b1c6:	2f f7       	sub	r7,-1
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b1c8:	40 04       	lddsp	r4,sp[0x0]
8000b1ca:	0e 35       	cp.w	r5,r7
8000b1cc:	e0 88 00 1a 	brls	8000b200 <_read_sectors+0x7c>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
8000b1d0:	0e 9a       	mov	r10,r7
8000b1d2:	1a 99       	mov	r9,sp
8000b1d4:	0c 9b       	mov	r11,r6
8000b1d6:	e0 6c 19 60 	mov	r12,6496
8000b1da:	ca ee       	rcall	8000af36 <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000b1dc:	cf 51       	brne	8000b1c6 <_read_sectors+0x42>
8000b1de:	08 9b       	mov	r11,r4
8000b1e0:	e0 6c 19 60 	mov	r12,6496

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8000b1e4:	e0 a0 0c f4 	rcall	8000cbcc <fatfs_find_next_cluster>
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000b1e8:	0e 9a       	mov	r10,r7

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8000b1ea:	18 99       	mov	r9,r12
8000b1ec:	50 0c       	stdsp	sp[0x0],r12
8000b1ee:	0c 9b       	mov	r11,r6
8000b1f0:	e0 6c 19 60 	mov	r12,6496
            }            

            Cluster = nextCluster;
8000b1f4:	ca 2e       	rcall	8000af38 <fatfs_cache_set_next_cluster>
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000b1f6:	2f f7       	sub	r7,-1
8000b1f8:	40 04       	lddsp	r4,sp[0x0]
8000b1fa:	0e 35       	cp.w	r5,r7

            Cluster = nextCluster;
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
8000b1fc:	fe 9b ff ea 	brhi	8000b1d0 <_read_sectors+0x4c>
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
8000b200:	5b f4       	cp.w	r4,-1
8000b202:	c1 a0       	breq	8000b236 <_read_sectors+0xb2>
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
8000b204:	ed 45 02 28 	st.w	r6[552],r5
    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
        return 0;

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;
8000b208:	ed 44 02 2c 	st.w	r6[556],r4
8000b20c:	08 9b       	mov	r11,r4
8000b20e:	e0 6c 19 60 	mov	r12,6496

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
8000b212:	fe b0 f6 ff 	rcall	8000a010 <fatfs_lba_of_cluster>
8000b216:	04 99       	mov	r9,r2
8000b218:	f8 01 00 0b 	add	r11,r12,r1
8000b21c:	00 9a       	mov	r10,r0
8000b21e:	e0 6c 19 60 	mov	r12,6496
        return count;
    else
        return 0;
}
8000b222:	fe b0 f7 0c 	rcall	8000a03a <fatfs_sector_read>
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
8000b226:	c0 80       	breq	8000b236 <_read_sectors+0xb2>
8000b228:	04 9c       	mov	r12,r2
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
        }
    }

    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
8000b22a:	2f fd       	sub	sp,-4
8000b22c:	d8 32       	popm	r0-r7,pc

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
8000b22e:	f8 f4 02 2c 	ld.w	r4,r12[556]
        return count;
    else
        return 0;
}
8000b232:	5b f4       	cp.w	r4,-1
8000b234:	ce c1       	brne	8000b20c <_read_sectors+0x88>
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b236:	30 02       	mov	r2,0
8000b238:	04 9c       	mov	r12,r2
8000b23a:	2f fd       	sub	sp,-4
8000b23c:	d8 32       	popm	r0-r7,pc
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
8000b23e:	ee c8 ff ff 	sub	r8,r7,-1
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000b242:	08 38       	cp.w	r8,r4
8000b244:	cb a1       	brne	8000b1b8 <_read_sectors+0x34>
8000b246:	f8 f4 02 2c 	ld.w	r4,r12[556]
8000b24a:	cb 9b       	rjmp	8000b1bc <_read_sectors+0x38>

8000b24c <_create_file>:
8000b24c:	eb cd 40 fc 	pushm	r2-r7,lr
8000b250:	20 bd       	sub	sp,44
8000b252:	e0 68 19 60 	mov	r8,6496
8000b256:	18 93       	mov	r3,r12
8000b258:	70 e8       	ld.w	r8,r8[0x38]
8000b25a:	58 08       	cp.w	r8,0
    struct fat_dir_entry sfEntry;
    char shortFilename[FAT_SFN_SIZE_FULL];
    int tailNum = 0;

    // No write access?
    if (!_fs.disk_io.write_media)
8000b25c:	c0 61       	brne	8000b268 <_create_file+0x1c>

    fatfs_cache_init(&_fs, file);
    
    fatfs_fat_purge(&_fs);

    return file;
8000b25e:	30 07       	mov	r7,0
}
8000b260:	0e 9c       	mov	r12,r7
8000b262:	2f 5d       	sub	sp,-44
8000b264:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
{
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
8000b268:	e0 69 26 54 	mov	r9,9812
    if (node)
8000b26c:	72 05       	ld.w	r5,r9[0x0]
8000b26e:	58 05       	cp.w	r5,0
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8000b270:	cf 70       	breq	8000b25e <_create_file+0x12>
        list->head = node->next;
8000b272:	6a 08       	ld.w	r8,r5[0x0]
8000b274:	58 08       	cp.w	r8,0
8000b276:	f0 0a 17 00 	moveq	r10,r8
8000b27a:	eb f8 00 01 	ld.weq	r8,r5[0x4]
8000b27e:	f3 f8 0a 00 	st.weq	r9[0x0],r8
    else
        node->previous->next = node->next;
8000b282:	eb fa 10 01 	ld.wne	r10,r5[0x4]
8000b286:	f1 fa 1a 01 	st.wne	r8[0x4],r10
8000b28a:	eb f8 10 01 	ld.wne	r8,r5[0x4]
8000b28e:	eb fa 10 00 	ld.wne	r10,r5[0x0]

    if(!node->next)
        list->tail = node->previous;
8000b292:	f3 fa 0a 01 	st.weq	r9[0x4],r10
    else
        node->next->previous = node->previous;
8000b296:	f1 fa 1a 00 	st.wne	r8[0x0],r10
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8000b29a:	e0 64 19 54 	mov	r4,6484
8000b29e:	68 18       	ld.w	r8,r4[0x4]
8000b2a0:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b2a2:	e0 80 00 b9 	breq	8000b414 <_create_file+0x1c8>
    new_node->next = node->next;
8000b2a6:	8b 08       	st.w	r5[0x0],r8
    if (!node->next)
8000b2a8:	70 19       	ld.w	r9,r8[0x4]
        list->tail = new_node;
8000b2aa:	8b 19       	st.w	r5[0x4],r9
8000b2ac:	70 19       	ld.w	r9,r8[0x4]
8000b2ae:	58 09       	cp.w	r9,0
    else
        node->next->previous = new_node;
8000b2b0:	e9 f5 0a 01 	st.weq	r4[0x4],r5
    node->next = new_node;
8000b2b4:	f3 f5 1a 00 	st.wne	r9[0x0],r5

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
8000b2b8:	91 15       	st.w	r8[0x4],r5
    if (!_fs.disk_io.write_media)
        return NULL;

    // Allocate a new file handle
    file = _allocate_file();
    if (!file)
8000b2ba:	ea c7 04 3c 	sub	r7,r5,1084
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
8000b2be:	cd 10       	breq	8000b260 <_create_file+0x14>
8000b2c0:	ea c6 04 28 	sub	r6,r5,1064
8000b2c4:	e0 6a 01 04 	mov	r10,260
8000b2c8:	30 0b       	mov	r11,0
8000b2ca:	0c 9c       	mov	r12,r6
    memset(file->filename, '\0', sizeof(file->filename));
8000b2cc:	e0 a0 1d 20 	rcall	8000ed0c <memset>
8000b2d0:	ea c5 03 24 	sub	r5,r5,804
8000b2d4:	e0 6a 01 04 	mov	r10,260
8000b2d8:	30 0b       	mov	r11,0
8000b2da:	0a 9c       	mov	r12,r5

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)filename, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
8000b2dc:	e0 a0 1d 18 	rcall	8000ed0c <memset>
8000b2e0:	e0 68 01 04 	mov	r8,260
8000b2e4:	06 9c       	mov	r12,r3
8000b2e6:	0a 99       	mov	r9,r5
8000b2e8:	10 9a       	mov	r10,r8
8000b2ea:	0c 9b       	mov	r11,r6
8000b2ec:	e0 a0 0b 34 	rcall	8000c954 <fatfs_split_path>
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
8000b2f0:	5b fc       	cp.w	r12,-1
8000b2f2:	c1 80       	breq	8000b322 <_create_file+0xd6>
8000b2f4:	68 04       	ld.w	r4,r4[0x0]
8000b2f6:	58 04       	cp.w	r4,0
8000b2f8:	c0 51       	brne	8000b302 <_create_file+0xb6>
8000b2fa:	c1 88       	rjmp	8000b32a <_create_file+0xde>
8000b2fc:	68 14       	ld.w	r4,r4[0x4]
    {
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
8000b2fe:	58 04       	cp.w	r4,0
8000b300:	c1 50       	breq	8000b32a <_create_file+0xde>

        // If not the current file 
        if (openFile != file)
8000b302:	e8 c8 04 3c 	sub	r8,r4,1084
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
8000b306:	10 37       	cp.w	r7,r8
8000b308:	cf a0       	breq	8000b2fc <_create_file+0xb0>
8000b30a:	0c 9b       	mov	r11,r6
8000b30c:	e8 cc 04 28 	sub	r12,r4,1064
8000b310:	e0 a0 09 d2 	rcall	8000c6b4 <fatfs_compare_names>
8000b314:	cf 40       	breq	8000b2fc <_create_file+0xb0>
8000b316:	e8 cc 03 24 	sub	r12,r4,804
8000b31a:	0a 9b       	mov	r11,r5
8000b31c:	e0 a0 09 cc 	rcall	8000c6b4 <fatfs_compare_names>
    if (tailNum == 9999)
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);

        _free_file(file);
8000b320:	ce e0       	breq	8000b2fc <_create_file+0xb0>
8000b322:	0e 9c       	mov	r12,r7
8000b324:	c0 ce       	rcall	8000af3c <_free_file>
        return NULL;
8000b326:	30 07       	mov	r7,0
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0] == 0)
8000b328:	c9 cb       	rjmp	8000b260 <_create_file+0x14>
8000b32a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000b32e:	30 08       	mov	r8,0
8000b330:	f0 09 18 00 	cp.b	r9,r8
        file->parentcluster = fatfs_get_root_cluster(&_fs);
8000b334:	c6 81       	brne	8000b404 <_create_file+0x1b8>
8000b336:	e0 6c 19 60 	mov	r12,6496
8000b33a:	fe b0 f6 90 	rcall	8000a05a <fatfs_get_root_cluster>
            return NULL;
        }
    }

    // Check if same filename exists in directory
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry) == 1)
8000b33e:	18 9b       	mov	r11,r12
8000b340:	8f 0c       	st.w	r7[0x0],r12
8000b342:	1a 99       	mov	r9,sp
8000b344:	0a 9a       	mov	r10,r5
8000b346:	e0 6c 19 60 	mov	r12,6496
8000b34a:	fe b0 f7 fd 	rcall	8000a344 <fatfs_get_file_entry>
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
8000b34e:	58 1c       	cp.w	r12,1

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
8000b350:	ce 90       	breq	8000b322 <_create_file+0xd6>
8000b352:	30 19       	mov	r9,1
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
8000b354:	30 06       	mov	r6,0

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
8000b356:	ee ca ff fc 	sub	r10,r7,-4
8000b35a:	8f 16       	st.w	r7[0x4],r6
8000b35c:	12 9b       	mov	r11,r9
8000b35e:	e0 6c 19 60 	mov	r12,6496
        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
8000b362:	e0 a0 15 07 	rcall	8000dd70 <fatfs_allocate_free_space>
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
8000b366:	18 98       	mov	r8,r12
8000b368:	c6 e0       	breq	8000b444 <_create_file+0x1f8>
8000b36a:	0c 94       	mov	r4,r6
8000b36c:	ee c3 fd e4 	sub	r3,r7,-540
8000b370:	fa c2 ff e0 	sub	r2,sp,-32
8000b374:	c1 28       	rjmp	8000b398 <_create_file+0x14c>
8000b376:	08 9a       	mov	r10,r4
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);

        // Check if entry exists already or not
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
8000b378:	04 9b       	mov	r11,r2
8000b37a:	06 9c       	mov	r12,r3
8000b37c:	e0 a0 06 5a 	rcall	8000c030 <fatfs_lfn_generate_tail>
8000b380:	06 9a       	mov	r10,r3
8000b382:	6e 0b       	ld.w	r11,r7[0x0]
8000b384:	e0 6c 19 60 	mov	r12,6496
            break;

        tailNum++;
    }
    while (tailNum < 9999);
8000b388:	fe b0 f8 86 	rcall	8000a494 <fatfs_sfn_exists>
8000b38c:	18 96       	mov	r6,r12
    // Generate a short filename & tail
    tailNum = 0;
    do 
    {
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);
8000b38e:	c1 10       	breq	8000b3b0 <_create_file+0x164>
8000b390:	2f f4       	sub	r4,-1
8000b392:	e0 44 27 0f 	cp.w	r4,9999

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
8000b396:	c5 c0       	breq	8000b44e <_create_file+0x202>
8000b398:	0a 9b       	mov	r11,r5
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
8000b39a:	04 9c       	mov	r12,r2
8000b39c:	e0 a0 06 ac 	rcall	8000c0f4 <fatfs_lfn_create_sfn>
8000b3a0:	58 04       	cp.w	r4,0
8000b3a2:	ce a1       	brne	8000b376 <_create_file+0x12a>
8000b3a4:	30 ba       	mov	r10,11
        tailNum++;
    }
    while (tailNum < 9999);

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
8000b3a6:	04 9b       	mov	r11,r2
8000b3a8:	06 9c       	mov	r12,r3
8000b3aa:	e0 a0 1c 0d 	rcall	8000ebc4 <memcpy>
        return NULL;
    }
#endif

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
8000b3ae:	ce 9b       	rjmp	8000b380 <_create_file+0x134>
8000b3b0:	e0 44 27 0f 	cp.w	r4,9999
8000b3b4:	c4 d0       	breq	8000b44e <_create_file+0x202>
8000b3b6:	1a dc       	st.w	--sp,r12
8000b3b8:	0a 9a       	mov	r10,r5
8000b3ba:	1a dc       	st.w	--sp,r12
8000b3bc:	06 99       	mov	r9,r3
8000b3be:	6e 18       	ld.w	r8,r7[0x4]
8000b3c0:	6e 0b       	ld.w	r11,r7[0x0]
8000b3c2:	e0 6c 19 60 	mov	r12,6496
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
8000b3c6:	e0 a0 0f e9 	rcall	8000d398 <fatfs_add_file_entry>
    file->file_data_dirty = 0;
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
8000b3ca:	2f ed       	sub	sp,-8
8000b3cc:	18 95       	mov	r5,r12
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
8000b3ce:	58 0c       	cp.w	r12,0
8000b3d0:	c3 00       	breq	8000b430 <_create_file+0x1e4>
    file->file_data_dirty = 0;
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
8000b3d2:	3f f8       	mov	r8,-1
8000b3d4:	0e 9b       	mov	r11,r7
    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
    file->file_data_dirty = 0;
    file->filelength_changed = 0;
8000b3d6:	ef 48 02 2c 	st.w	r7[556],r8
        return NULL;
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
8000b3da:	ef 48 04 30 	st.w	r7[1072],r8
    file->file_data_address = 0xFFFFFFFF;
    file->file_data_dirty = 0;
8000b3de:	ef 48 02 28 	st.w	r7[552],r8

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

    fatfs_cache_init(&_fs, file);
8000b3e2:	8f 46       	st.w	r7[0x10],r6
8000b3e4:	8f 36       	st.w	r7[0xc],r6
    
    fatfs_fat_purge(&_fs);
8000b3e6:	8f 26       	st.w	r7[0x8],r6
8000b3e8:	ef 46 04 34 	st.w	r7[1076],r6

    return file;
}
8000b3ec:	e0 6c 19 60 	mov	r12,6496
8000b3f0:	fe b0 fd a2 	rcall	8000af34 <fatfs_cache_init>
    if (file->path[0] == 0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
8000b3f4:	e0 6c 19 60 	mov	r12,6496
8000b3f8:	e0 a0 0b be 	rcall	8000cb74 <fatfs_fat_purge>
8000b3fc:	0e 9c       	mov	r12,r7
8000b3fe:	2f 5d       	sub	sp,-44
        {
            _free_file(file);
            return NULL;
8000b400:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000b404:	0c 9c       	mov	r12,r6
8000b406:	0e 9b       	mov	r11,r7
8000b408:	fe b0 fd fc 	rcall	8000b000 <_open_directory>
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
    new_node->next = node;
8000b40c:	18 98       	mov	r8,r12
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000b40e:	c1 b0       	breq	8000b444 <_create_file+0x1f8>
    new_node->next = node;
    if (!node->previous)
8000b410:	6e 0b       	ld.w	r11,r7[0x0]
        list->head = new_node;
8000b412:	c9 8b       	rjmp	8000b342 <_create_file+0xf6>
8000b414:	68 08       	ld.w	r8,r4[0x0]
8000b416:	58 08       	cp.w	r8,0
    else
        node->previous->next = new_node;
8000b418:	c2 10       	breq	8000b45a <_create_file+0x20e>
8000b41a:	70 09       	ld.w	r9,r8[0x0]
    node->previous = new_node;
8000b41c:	8b 18       	st.w	r5[0x4],r8
8000b41e:	8b 09       	st.w	r5[0x0],r9

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
8000b420:	70 09       	ld.w	r9,r8[0x0]
8000b422:	58 09       	cp.w	r9,0
8000b424:	e9 f5 0a 00 	st.weq	r4[0x0],r5

        _free_file(file);
8000b428:	f3 f5 1a 01 	st.wne	r9[0x4],r5
8000b42c:	91 05       	st.w	r8[0x0],r5
8000b42e:	c4 6b       	rjmp	8000b2ba <_create_file+0x6e>
        return NULL;
8000b430:	6e 1b       	ld.w	r11,r7[0x4]
    file->startcluster = 0;

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
    {
        _free_file(file);
8000b432:	e0 6c 19 60 	mov	r12,6496
8000b436:	e0 a0 0d a5 	rcall	8000cf80 <fatfs_free_cluster_chain>
        return NULL;
8000b43a:	0e 9c       	mov	r12,r7

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
8000b43c:	0a 97       	mov	r7,r5
8000b43e:	fe b0 fd 7f 	rcall	8000af3c <_free_file>
8000b442:	c0 fb       	rjmp	8000b260 <_create_file+0x14>
8000b444:	0e 9c       	mov	r12,r7
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000b446:	10 97       	mov	r7,r8
        list->tail = node;
8000b448:	fe b0 fd 7a 	rcall	8000af3c <_free_file>
        node->previous = 0;
8000b44c:	c0 ab       	rjmp	8000b260 <_create_file+0x14>
8000b44e:	6e 1b       	ld.w	r11,r7[0x4]
8000b450:	e0 6c 19 60 	mov	r12,6496
8000b454:	e0 a0 0d 96 	rcall	8000cf80 <fatfs_free_cluster_chain>
8000b458:	c6 5b       	rjmp	8000b322 <_create_file+0xd6>
8000b45a:	89 05       	st.w	r4[0x0],r5
8000b45c:	89 15       	st.w	r4[0x4],r5
8000b45e:	8b 18       	st.w	r5[0x4],r8
8000b460:	8b 08       	st.w	r5[0x0],r8
8000b462:	c2 cb       	rjmp	8000b2ba <_create_file+0x6e>

8000b464 <fl_readdir>:
8000b464:	eb cd 40 e0 	pushm	r5-r7,lr
8000b468:	20 1d       	sub	sp,4
8000b46a:	e0 69 26 50 	mov	r9,9808
8000b46e:	18 96       	mov	r6,r12
8000b470:	16 95       	mov	r5,r11
8000b472:	72 08       	ld.w	r8,r9[0x0]
8000b474:	58 08       	cp.w	r8,0
8000b476:	c1 b0       	breq	8000b4ac <fl_readdir+0x48>
8000b478:	e0 67 19 60 	mov	r7,6496
8000b47c:	6e f8       	ld.w	r8,r7[0x3c]
8000b47e:	58 08       	cp.w	r8,0
8000b480:	c0 20       	breq	8000b484 <fl_readdir+0x20>
8000b482:	5d 18       	icall	r8
8000b484:	0a 9a       	mov	r10,r5
8000b486:	0c 9b       	mov	r11,r6
8000b488:	e0 6c 19 60 	mov	r12,6496
8000b48c:	fe b0 fb a8 	rcall	8000abdc <fatfs_list_directory_next>
8000b490:	6f 08       	ld.w	r8,r7[0x40]
8000b492:	58 08       	cp.w	r8,0
8000b494:	c0 40       	breq	8000b49c <fl_readdir+0x38>
8000b496:	50 0c       	stdsp	sp[0x0],r12
8000b498:	5d 18       	icall	r8
8000b49a:	40 0c       	lddsp	r12,sp[0x0]
    res = fatfs_list_directory_next(&_fs, dirls, entry);

    FL_UNLOCK(&_fs);

    return res ? 0 : -1;
}
8000b49c:	58 0c       	cp.w	r12,0
8000b49e:	f9 bc 00 ff 	moveq	r12,-1
8000b4a2:	f9 bc 01 00 	movne	r12,0
8000b4a6:	2f fd       	sub	sp,-4
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000b4a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b4ac:	e0 6a 1d c8 	mov	r10,7624
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000b4b0:	f5 48 08 84 	st.w	r10[2180],r8
8000b4b4:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8000b4b8:	e0 6b 19 54 	mov	r11,6484
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b4bc:	97 08       	st.w	r11[0x0],r8
8000b4be:	97 18       	st.w	r11[0x4],r8
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b4c0:	f4 cc f7 80 	sub	r12,r10,-2176
8000b4c4:	e0 68 26 54 	mov	r8,9812
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b4c8:	f5 4c 04 40 	st.w	r10[1088],r12

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000b4cc:	f4 cb fb c4 	sub	r11,r10,-1084
8000b4d0:	f5 4b 08 80 	st.w	r10[2176],r11
8000b4d4:	91 1c       	st.w	r8[0x4],r12
8000b4d6:	91 0b       	st.w	r8[0x0],r11
8000b4d8:	30 18       	mov	r8,1
8000b4da:	93 08       	st.w	r9[0x0],r8
8000b4dc:	cc eb       	rjmp	8000b478 <fl_readdir+0x14>
8000b4de:	d7 03       	nop

8000b4e0 <fl_opendir>:
8000b4e0:	eb cd 40 e0 	pushm	r5-r7,lr
8000b4e4:	20 1d       	sub	sp,4
8000b4e6:	3f f8       	mov	r8,-1
8000b4e8:	50 08       	stdsp	sp[0x0],r8
8000b4ea:	e0 69 26 50 	mov	r9,9808
//-----------------------------------------------------------------------------
// fl_opendir: Opens a directory for listing
//-----------------------------------------------------------------------------
#if FATFS_DIR_LIST_SUPPORT
FL_DIR* fl_opendir(const char* path, FL_DIR *dir)
{
8000b4ee:	18 95       	mov	r5,r12
    int levels;
    int res = 1;
    uint32 cluster = FAT32_INVALID_CLUSTER;

    // If first call to library, initialise
    CHECK_FL_INIT();
8000b4f0:	16 96       	mov	r6,r11
8000b4f2:	72 08       	ld.w	r8,r9[0x0]
8000b4f4:	58 08       	cp.w	r8,0

    FL_LOCK(&_fs);
8000b4f6:	c1 e0       	breq	8000b532 <fl_opendir+0x52>
8000b4f8:	e0 67 19 60 	mov	r7,6496
8000b4fc:	6e f8       	ld.w	r8,r7[0x3c]
8000b4fe:	58 08       	cp.w	r8,0

    levels = fatfs_total_path_levels((char*)path) + 1;
8000b500:	c0 20       	breq	8000b504 <fl_opendir+0x24>
8000b502:	5d 18       	icall	r8
8000b504:	0a 9c       	mov	r12,r5

    // If path is in the root dir
    if (levels == 0)
8000b506:	e0 a0 08 83 	rcall	8000c60c <fatfs_total_path_levels>
        cluster = fatfs_get_root_cluster(&_fs);
    // Find parent directory start cluster
    else
        res = _open_directory((char*)path, &cluster);
8000b50a:	5b fc       	cp.w	r12,-1
8000b50c:	c2 c0       	breq	8000b564 <fl_opendir+0x84>
8000b50e:	0a 9c       	mov	r12,r5
8000b510:	1a 9b       	mov	r11,sp

    if (res)
8000b512:	fe b0 fd 77 	rcall	8000b000 <_open_directory>
        fatfs_list_directory_start(&_fs, dir, cluster);

    FL_UNLOCK(&_fs);
8000b516:	c3 31       	brne	8000b57c <fl_opendir+0x9c>
8000b518:	6f 08       	ld.w	r8,r7[0x40]
8000b51a:	58 08       	cp.w	r8,0

    return cluster != FAT32_INVALID_CLUSTER ? dir : 0;
8000b51c:	c0 20       	breq	8000b520 <fl_opendir+0x40>
}
8000b51e:	5d 18       	icall	r8
8000b520:	40 0c       	lddsp	r12,sp[0x0]
8000b522:	5b fc       	cp.w	r12,-1
8000b524:	ec 0c 17 10 	movne	r12,r6
8000b528:	f9 bc 00 00 	moveq	r12,0
8000b52c:	2f fd       	sub	sp,-4

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b52e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000b532:	e0 6a 1d c8 	mov	r10,7624

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b536:	f5 48 08 84 	st.w	r10[2180],r8
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000b53a:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8000b53e:	e0 6b 19 54 	mov	r11,6484
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b542:	97 08       	st.w	r11[0x0],r8
8000b544:	97 18       	st.w	r11[0x4],r8
8000b546:	f4 cc f7 80 	sub	r12,r10,-2176
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b54a:	e0 68 26 54 	mov	r8,9812
8000b54e:	f5 4c 04 40 	st.w	r10[1088],r12
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b552:	f4 cb fb c4 	sub	r11,r10,-1084

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000b556:	f5 4b 08 80 	st.w	r10[2176],r11

    levels = fatfs_total_path_levels((char*)path) + 1;

    // If path is in the root dir
    if (levels == 0)
        cluster = fatfs_get_root_cluster(&_fs);
8000b55a:	91 1c       	st.w	r8[0x4],r12
8000b55c:	91 0b       	st.w	r8[0x0],r11
8000b55e:	30 18       	mov	r8,1
8000b560:	93 08       	st.w	r9[0x0],r8
8000b562:	cc bb       	rjmp	8000b4f8 <fl_opendir+0x18>
    // Find parent directory start cluster
    else
        res = _open_directory((char*)path, &cluster);

    if (res)
        fatfs_list_directory_start(&_fs, dir, cluster);
8000b564:	e0 6c 19 60 	mov	r12,6496
8000b568:	fe b0 f5 79 	rcall	8000a05a <fatfs_get_root_cluster>
8000b56c:	18 9a       	mov	r10,r12
        cluster = fatfs_get_root_cluster(&_fs);
    // Find parent directory start cluster
    else
        res = _open_directory((char*)path, &cluster);

    if (res)
8000b56e:	50 0c       	stdsp	sp[0x0],r12
8000b570:	0c 9b       	mov	r11,r6
8000b572:	e0 6c 19 60 	mov	r12,6496
8000b576:	fe b0 f5 74 	rcall	8000a05e <fatfs_list_directory_start>
8000b57a:	cc fb       	rjmp	8000b518 <fl_opendir+0x38>
8000b57c:	40 0a       	lddsp	r10,sp[0x0]
8000b57e:	cf 9b       	rjmp	8000b570 <fl_opendir+0x90>

8000b580 <fl_fflush>:
8000b580:	eb cd 40 c0 	pushm	r6-r7,lr
8000b584:	e0 69 26 50 	mov	r9,9808
8000b588:	18 97       	mov	r7,r12
8000b58a:	72 08       	ld.w	r8,r9[0x0]
8000b58c:	58 08       	cp.w	r8,0
8000b58e:	c1 30       	breq	8000b5b4 <fl_fflush+0x34>
8000b590:	58 07       	cp.w	r7,0
8000b592:	c0 f0       	breq	8000b5b0 <fl_fflush+0x30>
8000b594:	e0 66 19 60 	mov	r6,6496
    // If first call to library, initialise
    CHECK_FL_INIT();

    if (file)
    {
        FL_LOCK(&_fs);
8000b598:	6c f8       	ld.w	r8,r6[0x3c]
8000b59a:	58 08       	cp.w	r8,0

        // If some write data still in buffer
        if (file->file_data_dirty)
8000b59c:	c0 20       	breq	8000b5a0 <fl_fflush+0x20>
8000b59e:	5d 18       	icall	r8
8000b5a0:	ee f8 04 34 	ld.w	r8,r7[1076]
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
                file->file_data_dirty = 0;
        }

        FL_UNLOCK(&_fs);
8000b5a4:	58 08       	cp.w	r8,0
8000b5a6:	c2 01       	brne	8000b5e6 <fl_fflush+0x66>
8000b5a8:	6d 08       	ld.w	r8,r6[0x40]
8000b5aa:	58 08       	cp.w	r8,0
    }
#endif
    return 0;
}
8000b5ac:	c0 20       	breq	8000b5b0 <fl_fflush+0x30>
8000b5ae:	5d 18       	icall	r8

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b5b0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000b5b4:	e0 6a 1d c8 	mov	r10,7624

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b5b8:	f5 48 08 84 	st.w	r10[2180],r8
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000b5bc:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8000b5c0:	e0 6b 19 54 	mov	r11,6484
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b5c4:	97 08       	st.w	r11[0x0],r8
8000b5c6:	97 18       	st.w	r11[0x4],r8
8000b5c8:	f4 cc f7 80 	sub	r12,r10,-2176
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b5cc:	e0 68 26 54 	mov	r8,9812
8000b5d0:	f5 4c 04 40 	st.w	r10[1088],r12
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b5d4:	f4 cb fb c4 	sub	r11,r10,-1084

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000b5d8:	f5 4b 08 80 	st.w	r10[2176],r11

        // If some write data still in buffer
        if (file->file_data_dirty)
        {
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
8000b5dc:	91 1c       	st.w	r8[0x4],r12
8000b5de:	91 0b       	st.w	r8[0x0],r11
8000b5e0:	30 18       	mov	r8,1
8000b5e2:	93 08       	st.w	r9[0x0],r8
8000b5e4:	cd 6b       	rjmp	8000b590 <fl_fflush+0x10>
8000b5e6:	30 19       	mov	r9,1
8000b5e8:	ee ca fd d0 	sub	r10,r7,-560
                file->file_data_dirty = 0;
8000b5ec:	ee fb 04 30 	ld.w	r11,r7[1072]
8000b5f0:	0e 9c       	mov	r12,r7
8000b5f2:	fe b0 fd 4d 	rcall	8000b08c <_write_sectors>
8000b5f6:	f9 b8 01 00 	movne	r8,0
8000b5fa:	ef f8 1b 0d 	st.wne	r7[0x434],r8
8000b5fe:	cd 5b       	rjmp	8000b5a8 <fl_fflush+0x28>

8000b600 <T.96>:
8000b600:	eb cd 40 fe 	pushm	r1-r7,lr
8000b604:	e0 68 26 50 	mov	r8,9808
8000b608:	18 95       	mov	r5,r12
8000b60a:	16 97       	mov	r7,r11
8000b60c:	70 08       	ld.w	r8,r8[0x0]
8000b60e:	58 08       	cp.w	r8,0
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (buffer==NULL || file==NULL)
8000b610:	c0 c0       	breq	8000b628 <T.96+0x28>
8000b612:	58 07       	cp.w	r7,0
8000b614:	5f 09       	sreq	r9
8000b616:	58 05       	cp.w	r5,0
8000b618:	5f 08       	sreq	r8
8000b61a:	f3 e8 10 08 	or	r8,r9,r8
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8000b61e:	c0 80       	breq	8000b62e <T.96+0x2e>
        // Increment file pointer
        file->bytenum += copyCount;
    }    

    return bytesRead;
}
8000b620:	3f f6       	mov	r6,-1
8000b622:	0c 9c       	mov	r12,r6
8000b624:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
    int bytesRead = 0;    

    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
8000b628:	fe b0 fc d0 	rcall	8000afc8 <fl_init>

    if (buffer==NULL || file==NULL)
        return -1;

    // No read permissions
    if (!(file->flags & FILE_READ))
8000b62c:	cf 3b       	rjmp	8000b612 <T.96+0x12>
8000b62e:	ef 38 04 38 	ld.ub	r8,r7[1080]
8000b632:	ed b8 00 00 	bld	r8,0x0
    // Nothing to be done
    if (!count)
        return 0;

    // Check if read starts past end of file
    if (file->bytenum >= file->filelength)
8000b636:	cf 51       	brne	8000b620 <T.96+0x20>
8000b638:	6e 24       	ld.w	r4,r7[0x8]
8000b63a:	6e 32       	ld.w	r2,r7[0xc]
8000b63c:	04 34       	cp.w	r4,r2
        return -1;

    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
8000b63e:	cf 12       	brcc	8000b620 <T.96+0x20>
8000b640:	e8 c8 ff ff 	sub	r8,r4,-1
8000b644:	10 32       	cp.w	r2,r8
        count = file->filelength - file->bytenum;
8000b646:	c4 e2       	brcc	8000b6e2 <T.96+0xe2>
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8000b648:	08 12       	sub	r2,r4
8000b64a:	58 02       	cp.w	r2,0
8000b64c:	e0 8a 00 50 	brle	8000b6ec <T.96+0xec>

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
8000b650:	e7 d4 c0 09 	bfextu	r3,r4,0x0,0x9
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
8000b654:	a9 94       	lsr	r4,0x9
8000b656:	ee c1 fd d0 	sub	r1,r7,-560
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
8000b65a:	30 06       	mov	r6,0
8000b65c:	58 03       	cp.w	r3,0
8000b65e:	c2 b1       	brne	8000b6b4 <T.96+0xb4>
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
8000b660:	c2 48       	rjmp	8000b6a8 <T.96+0xa8>
8000b662:	30 19       	mov	r9,1
8000b664:	02 9a       	mov	r10,r1
8000b666:	08 9b       	mov	r11,r4
8000b668:	0e 9c       	mov	r12,r7
8000b66a:	fe b0 fd 8d 	rcall	8000b184 <_read_sectors>
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
                file->file_data_dirty = 0;
8000b66e:	cd a0       	breq	8000b622 <T.96+0x22>
                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
8000b670:	30 08       	mov	r8,0
8000b672:	ef 44 04 30 	st.w	r7[1072],r4
                file->file_data_dirty = 0;
8000b676:	ef 48 04 34 	st.w	r7[1076],r8
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
8000b67a:	e0 68 02 00 	mov	r8,512
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
8000b67e:	e2 03 00 0b 	add	r11,r1,r3
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
8000b682:	f0 03 01 03 	sub	r3,r8,r3
8000b686:	e4 06 01 08 	sub	r8,r2,r6
8000b68a:	2f f4       	sub	r4,-1
8000b68c:	e6 08 0d 43 	min	r3,r3,r8
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
8000b690:	ea 06 00 0c 	add	r12,r5,r6
8000b694:	06 9a       	mov	r10,r3
8000b696:	e0 a0 1a 97 	rcall	8000ebc4 <memcpy>
    
        // Increase total read count 
        bytesRead += copyCount;

        // Increment file pointer
        file->bytenum += copyCount;
8000b69a:	6e 28       	ld.w	r8,r7[0x8]
8000b69c:	06 08       	add	r8,r3
            sector++;
            offset = 0;
        }
    
        // Increase total read count 
        bytesRead += copyCount;
8000b69e:	8f 28       	st.w	r7[0x8],r8

        // Increment file pointer
        file->bytenum += copyCount;
8000b6a0:	06 06       	add	r6,r3
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8000b6a2:	30 03       	mov	r3,0
8000b6a4:	04 36       	cp.w	r6,r2
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
8000b6a6:	cb e4       	brge	8000b622 <T.96+0x22>
8000b6a8:	e4 06 01 09 	sub	r9,r2,r6
8000b6ac:	e0 49 01 ff 	cp.w	r9,511
8000b6b0:	e0 89 00 0d 	brgt	8000b6ca <T.96+0xca>
                break;
        }
        else
        {
            // Do we need to re-read the sector?
            if (file->file_data_address != sector)
8000b6b4:	ee f8 04 30 	ld.w	r8,r7[1072]
8000b6b8:	10 34       	cp.w	r4,r8
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
8000b6ba:	ce 00       	breq	8000b67a <T.96+0x7a>
8000b6bc:	ee f8 04 34 	ld.w	r8,r7[1076]
8000b6c0:	58 08       	cp.w	r8,0
                    fl_fflush(file);
8000b6c2:	cd 00       	breq	8000b662 <T.96+0x62>
8000b6c4:	0e 9c       	mov	r12,r7
8000b6c6:	c5 df       	rcall	8000b580 <fl_fflush>
8000b6c8:	cc db       	rjmp	8000b662 <T.96+0x62>
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
        {
            // Read as many sectors as possible into target buffer
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);        
8000b6ca:	a9 59       	asr	r9,0x9
8000b6cc:	ea 06 00 0a 	add	r10,r5,r6
8000b6d0:	08 9b       	mov	r11,r4
8000b6d2:	0e 9c       	mov	r12,r7
8000b6d4:	fe b0 fd 58 	rcall	8000b184 <_read_sectors>
            if (sectorsRead)
8000b6d8:	ca 50       	breq	8000b622 <T.96+0x22>
            {
                // We have upto one sector to copy
                copyCount = FAT_SECTOR_SIZE * sectorsRead;

                // Move onto next sector and reset copy offset
                sector+= sectorsRead;
8000b6da:	18 04       	add	r4,r12
            // Read as many sectors as possible into target buffer
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);        
            if (sectorsRead)
            {
                // We have upto one sector to copy
                copyCount = FAT_SECTOR_SIZE * sectorsRead;
8000b6dc:	f8 03 15 09 	lsl	r3,r12,0x9
8000b6e0:	cd db       	rjmp	8000b69a <T.96+0x9a>

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
8000b6e2:	e7 d4 c0 09 	bfextu	r3,r4,0x0,0x9
8000b6e6:	30 12       	mov	r2,1
    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
        count = file->filelength - file->bytenum;

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
8000b6e8:	a9 94       	lsr	r4,0x9
8000b6ea:	cb 6b       	rjmp	8000b656 <T.96+0x56>

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8000b6ec:	30 06       	mov	r6,0
8000b6ee:	c9 ab       	rjmp	8000b622 <T.96+0x22>

8000b6f0 <fl_fgetc>:
8000b6f0:	d4 01       	pushm	lr
8000b6f2:	20 1d       	sub	sp,4
8000b6f4:	30 08       	mov	r8,0
8000b6f6:	18 9b       	mov	r11,r12
8000b6f8:	fa cc ff fc 	sub	r12,sp,-4
8000b6fc:	18 f8       	st.b	--r12,r8
8000b6fe:	c8 1f       	rcall	8000b600 <T.96>
8000b700:	58 1c       	cp.w	r12,1
8000b702:	fb fc 08 03 	ld.ubeq	r12,sp[0x3]
    int res;
    uint8 data = 0;
    
    res = fl_fread(&data, 1, 1, f);
    if (res == 1)
        return (int)data;
8000b706:	2f fd       	sub	sp,-4
    else
        return res;
}
8000b708:	d8 02       	popm	pc
8000b70a:	d7 03       	nop

8000b70c <fl_fclose>:
8000b70c:	eb cd 40 c0 	pushm	r6-r7,lr
void fl_fclose(void *f)
{
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
8000b710:	e0 69 26 50 	mov	r9,9808
8000b714:	18 97       	mov	r7,r12
8000b716:	72 08       	ld.w	r8,r9[0x0]
8000b718:	58 08       	cp.w	r8,0

    if (file)
8000b71a:	c4 30       	breq	8000b7a0 <fl_fclose+0x94>
8000b71c:	58 07       	cp.w	r7,0
    {
        FL_LOCK(&_fs);
8000b71e:	c3 f0       	breq	8000b79c <fl_fclose+0x90>
8000b720:	e0 66 19 60 	mov	r6,6496
8000b724:	6c f8       	ld.w	r8,r6[0x3c]
8000b726:	58 08       	cp.w	r8,0

        // Flush un-written data to file
        fl_fflush(f);
8000b728:	c0 20       	breq	8000b72c <fl_fclose+0x20>
8000b72a:	5d 18       	icall	r8
8000b72c:	0e 9c       	mov	r12,r7

        // File size changed?
        if (file->filelength_changed)
8000b72e:	c2 9f       	rcall	8000b580 <fl_fflush>
8000b730:	6e 48       	ld.w	r8,r7[0x10]
8000b732:	58 08       	cp.w	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
8000b734:	c4 f1       	brne	8000b7d2 <fl_fclose+0xc6>
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
        file->filelength_changed = 0;
8000b736:	30 08       	mov	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
8000b738:	8f 48       	st.w	r7[0x10],r8
        file->filelength = 0;
8000b73a:	8f 28       	st.w	r7[0x8],r8
        file->startcluster = 0;
8000b73c:	8f 38       	st.w	r7[0xc],r8
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
8000b73e:	8f 18       	st.w	r7[0x4],r8
8000b740:	ef 48 04 34 	st.w	r7[1076],r8
        }

        file->bytenum = 0;
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
8000b744:	3f f8       	mov	r8,-1
8000b746:	ef 48 04 30 	st.w	r7[1072],r8
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8000b74a:	ee f8 04 3c 	ld.w	r8,r7[1084]
8000b74e:	58 08       	cp.w	r8,0
        list->head = node->next;
    else
        node->previous->next = node->next;
8000b750:	c4 c0       	breq	8000b7e8 <fl_fclose+0xdc>
8000b752:	ee f9 04 40 	ld.w	r9,r7[1088]
8000b756:	91 19       	st.w	r8[0x4],r9
8000b758:	ee f9 04 40 	ld.w	r9,r7[1088]
8000b75c:	ee f8 04 3c 	ld.w	r8,r7[1084]

    if(!node->next)
8000b760:	58 09       	cp.w	r9,0
        list->tail = node->previous;
    else
        node->next->previous = node->previous;
8000b762:	c4 a0       	breq	8000b7f6 <fl_fclose+0xea>
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8000b764:	93 08       	st.w	r9[0x0],r8
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8000b766:	e0 6b 26 54 	mov	r11,9812
8000b76a:	ee c9 fb c4 	sub	r9,r7,-1084
8000b76e:	76 18       	ld.w	r8,r11[0x4]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b770:	58 08       	cp.w	r8,0
8000b772:	c4 60       	breq	8000b7fe <fl_fclose+0xf2>
    new_node->next = node->next;
8000b774:	ef 48 04 3c 	st.w	r7[1084],r8
8000b778:	70 1a       	ld.w	r10,r8[0x4]
    if (!node->next)
8000b77a:	ef 4a 04 40 	st.w	r7[1088],r10
        list->tail = new_node;
8000b77e:	70 1a       	ld.w	r10,r8[0x4]
8000b780:	58 0a       	cp.w	r10,0
    else
        node->next->previous = new_node;
8000b782:	f7 f9 0a 01 	st.weq	r11[0x4],r9
    node->next = new_node;
8000b786:	f5 f9 1a 00 	st.wne	r10[0x0],r9
        file->filelength_changed = 0;

        // Free file handle
        _free_file(file);

        fatfs_fat_purge(&_fs);
8000b78a:	91 19       	st.w	r8[0x4],r9
8000b78c:	e0 6c 19 60 	mov	r12,6496

        FL_UNLOCK(&_fs);
8000b790:	e0 a0 09 f2 	rcall	8000cb74 <fatfs_fat_purge>
8000b794:	6d 08       	ld.w	r8,r6[0x40]
8000b796:	58 08       	cp.w	r8,0
8000b798:	c0 20       	breq	8000b79c <fl_fclose+0x90>

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b79a:	5d 18       	icall	r8
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000b79c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b7a0:	e0 6a 1d c8 	mov	r10,7624
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000b7a4:	f5 48 08 84 	st.w	r10[2180],r8
8000b7a8:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8000b7ac:	e0 6b 19 54 	mov	r11,6484
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b7b0:	97 08       	st.w	r11[0x0],r8
8000b7b2:	97 18       	st.w	r11[0x4],r8
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b7b4:	f4 cc f7 80 	sub	r12,r10,-2176
8000b7b8:	e0 68 26 54 	mov	r8,9812
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b7bc:	f5 4c 04 40 	st.w	r10[1088],r12

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000b7c0:	f4 cb fb c4 	sub	r11,r10,-1084
8000b7c4:	f5 4b 08 80 	st.w	r10[2176],r11
        // File size changed?
        if (file->filelength_changed)
        {
#if FATFS_INC_WRITE_SUPPORT
            // Update filesize in directory
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
8000b7c8:	91 1c       	st.w	r8[0x4],r12
8000b7ca:	91 0b       	st.w	r8[0x0],r11
8000b7cc:	30 18       	mov	r8,1
8000b7ce:	93 08       	st.w	r9[0x0],r8
8000b7d0:	ca 6b       	rjmp	8000b71c <fl_fclose+0x10>
8000b7d2:	6e 39       	ld.w	r9,r7[0xc]
#endif
            file->filelength_changed = 0;
8000b7d4:	ee ca fd e4 	sub	r10,r7,-540
8000b7d8:	6e 0b       	ld.w	r11,r7[0x0]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8000b7da:	e0 6c 19 60 	mov	r12,6496
8000b7de:	fe b0 f8 01 	rcall	8000a7e0 <fatfs_update_file_length>
    else
        node->previous->next = node->next;

    if(!node->next)
8000b7e2:	30 08       	mov	r8,0
8000b7e4:	8f 48       	st.w	r7[0x10],r8
        list->tail = node->previous;
8000b7e6:	ca 8b       	rjmp	8000b736 <fl_fclose+0x2a>
8000b7e8:	ee f9 04 40 	ld.w	r9,r7[1088]
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000b7ec:	e0 6a 19 54 	mov	r10,6484
8000b7f0:	95 09       	st.w	r10[0x0],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000b7f2:	58 09       	cp.w	r9,0
    new_node->next = node;
8000b7f4:	cb 81       	brne	8000b764 <fl_fclose+0x58>
8000b7f6:	e0 69 19 54 	mov	r9,6484
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000b7fa:	93 18       	st.w	r9[0x4],r8
    new_node->next = node;
    if (!node->previous)
8000b7fc:	cb 5b       	rjmp	8000b766 <fl_fclose+0x5a>
        list->head = new_node;
8000b7fe:	76 08       	ld.w	r8,r11[0x0]
8000b800:	58 08       	cp.w	r8,0
8000b802:	c0 e0       	breq	8000b81e <fl_fclose+0x112>
    else
        node->previous->next = new_node;
8000b804:	70 0a       	ld.w	r10,r8[0x0]
8000b806:	ef 48 04 40 	st.w	r7[1088],r8
    node->previous = new_node;
8000b80a:	ef 4a 04 3c 	st.w	r7[1084],r10
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000b80e:	70 0a       	ld.w	r10,r8[0x0]
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8000b810:	58 0a       	cp.w	r10,0
8000b812:	f7 f9 0a 00 	st.weq	r11[0x0],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b816:	f5 f9 1a 01 	st.wne	r10[0x4],r9
8000b81a:	91 09       	st.w	r8[0x0],r9
8000b81c:	cb 8b       	rjmp	8000b78c <fl_fclose+0x80>
8000b81e:	97 19       	st.w	r11[0x4],r9
8000b820:	97 09       	st.w	r11[0x0],r9
8000b822:	ef 48 04 40 	st.w	r7[1088],r8
8000b826:	ef 48 04 3c 	st.w	r7[1084],r8
8000b82a:	cb 1b       	rjmp	8000b78c <fl_fclose+0x80>

8000b82c <fl_attach_media>:
8000b82c:	eb cd 40 80 	pushm	r7,lr
8000b830:	e0 6a 26 50 	mov	r10,9808
8000b834:	18 98       	mov	r8,r12
8000b836:	74 09       	ld.w	r9,r10[0x0]
8000b838:	58 09       	cp.w	r9,0
8000b83a:	c1 00       	breq	8000b85a <fl_attach_media+0x2e>
    int res;

    // If first call to library, initialise
    CHECK_FL_INIT();

    _fs.disk_io.read_media = rd;
8000b83c:	e0 6c 19 60 	mov	r12,6496
    _fs.disk_io.write_media = wr;

    // Initialise FAT parameters
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
8000b840:	99 d8       	st.w	r12[0x34],r8
8000b842:	99 eb       	st.w	r12[0x38],r11
8000b844:	fe b0 f4 14 	rcall	8000a06c <fatfs_init>
	    print_dbg_hex(res);
	    print_dbg("\r\n");
        return res;
    }

    _filelib_valid = 1;
8000b848:	18 97       	mov	r7,r12
8000b84a:	c2 11       	brne	8000b88c <fl_attach_media+0x60>
    return FAT_INIT_OK;
}
8000b84c:	30 19       	mov	r9,1
	    print_dbg_hex(res);
	    print_dbg("\r\n");
        return res;
    }

    _filelib_valid = 1;
8000b84e:	e0 68 19 5c 	mov	r8,6492
    return FAT_INIT_OK;
}
8000b852:	0e 9c       	mov	r12,r7
8000b854:	91 09       	st.w	r8[0x0],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8000b856:	e3 cd 80 80 	ldm	sp++,r7,pc

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000b85a:	e0 6c 1d c8 	mov	r12,7624
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8000b85e:	f9 49 08 84 	st.w	r12[2180],r9
8000b862:	f9 49 04 3c 	st.w	r12[1084],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b866:	e0 6e 19 54 	mov	lr,6484
8000b86a:	9d 09       	st.w	lr[0x0],r9
8000b86c:	9d 19       	st.w	lr[0x4],r9
    new_node->next = node->next;
    if (!node->next)
8000b86e:	f8 c7 fb c4 	sub	r7,r12,-1084
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000b872:	e0 69 26 54 	mov	r9,9812
8000b876:	f9 47 08 80 	st.w	r12[2176],r7

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000b87a:	f8 ce f7 80 	sub	lr,r12,-2176
8000b87e:	f9 4e 04 40 	st.w	r12[1088],lr

    // Initialise FAT parameters
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
    {
      //        FAT_PRINTF(("FAT_FS: Error could not load FAT details (%d)!\r\n", res));
            print_dbg("FAT_FS: Error could not load FAT details!\r\n");
8000b882:	93 1e       	st.w	r9[0x4],lr
8000b884:	93 07       	st.w	r9[0x0],r7
	    print_dbg("error number: ");
8000b886:	30 19       	mov	r9,1
8000b888:	95 09       	st.w	r10[0x0],r9
8000b88a:	cd 9b       	rjmp	8000b83c <fl_attach_media+0x10>
	    print_dbg_hex(res);
8000b88c:	48 8c       	lddpc	r12,8000b8ac <fl_attach_media+0x80>
8000b88e:	fe b0 b8 e9 	rcall	80002a60 <print_dbg>
	    print_dbg("\r\n");
8000b892:	48 8c       	lddpc	r12,8000b8b0 <fl_attach_media+0x84>
8000b894:	fe b0 b8 e6 	rcall	80002a60 <print_dbg>
        return res;
    }

    _filelib_valid = 1;
    return FAT_INIT_OK;
}
8000b898:	0e 9c       	mov	r12,r7
8000b89a:	fe b0 b8 8b 	rcall	800029b0 <print_dbg_hex>
8000b89e:	48 6c       	lddpc	r12,8000b8b4 <fl_attach_media+0x88>
8000b8a0:	fe b0 b8 e0 	rcall	80002a60 <print_dbg>
8000b8a4:	0e 9c       	mov	r12,r7
8000b8a6:	e3 cd 80 80 	ldm	sp++,r7,pc
8000b8aa:	d7 03       	nop
8000b8ac:	80 01       	ld.sh	r1,r0[0x0]
8000b8ae:	4f 54       	lddpc	r4,8000ba80 <_open_file+0x1c8>
8000b8b0:	80 01       	ld.sh	r1,r0[0x0]
8000b8b2:	4f 80       	lddpc	r0,8000ba90 <_open_file+0x1d8>
8000b8b4:	80 01       	ld.sh	r1,r0[0x0]
8000b8b6:	41 88       	lddsp	r8,sp[0x60]

8000b8b8 <_open_file>:
8000b8b8:	eb cd 40 fe 	pushm	r1-r7,lr
8000b8bc:	20 8d       	sub	sp,32
8000b8be:	e0 61 26 54 	mov	r1,9812
8000b8c2:	18 92       	mov	r2,r12
8000b8c4:	62 06       	ld.w	r6,r1[0x0]
8000b8c6:	58 06       	cp.w	r6,0
8000b8c8:	e0 80 00 f0 	breq	8000baa8 <_open_file+0x1f0>
8000b8cc:	6c 08       	ld.w	r8,r6[0x0]
8000b8ce:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8000b8d0:	f0 09 17 00 	moveq	r9,r8
8000b8d4:	ed f8 00 01 	ld.weq	r8,r6[0x4]
8000b8d8:	e3 f8 0a 00 	st.weq	r1[0x0],r8
    else
        node->previous->next = node->next;
8000b8dc:	ed f9 10 01 	ld.wne	r9,r6[0x4]
8000b8e0:	f1 f9 1a 01 	st.wne	r8[0x4],r9
8000b8e4:	ed f8 10 01 	ld.wne	r8,r6[0x4]
8000b8e8:	ed f9 10 00 	ld.wne	r9,r6[0x0]

    if(!node->next)
        list->tail = node->previous;
8000b8ec:	e3 f9 0a 01 	st.weq	r1[0x4],r9
    else
        node->next->previous = node->previous;
8000b8f0:	f1 f9 1a 00 	st.wne	r8[0x0],r9
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8000b8f4:	e0 63 19 54 	mov	r3,6484
8000b8f8:	66 18       	ld.w	r8,r3[0x4]
8000b8fa:	58 08       	cp.w	r8,0
8000b8fc:	e0 80 00 db 	breq	8000bab2 <_open_file+0x1fa>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000b900:	8d 08       	st.w	r6[0x0],r8
    new_node->next = node->next;
8000b902:	70 19       	ld.w	r9,r8[0x4]
8000b904:	8d 19       	st.w	r6[0x4],r9
    if (!node->next)
8000b906:	70 19       	ld.w	r9,r8[0x4]
        list->tail = new_node;
8000b908:	58 09       	cp.w	r9,0
8000b90a:	e7 f6 0a 01 	st.weq	r3[0x4],r6
    else
        node->next->previous = new_node;
8000b90e:	f3 f6 1a 00 	st.wne	r9[0x0],r6
    node->next = new_node;
8000b912:	91 16       	st.w	r8[0x4],r6

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
8000b914:	ec c7 04 3c 	sub	r7,r6,1084
    FL_FILE* file; 
    struct fat_dir_entry sfEntry;

    // Allocate a new file handle
    file = _allocate_file();
    if (!file)
8000b918:	c3 60       	breq	8000b984 <_open_file+0xcc>
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
8000b91a:	ec c5 04 28 	sub	r5,r6,1064
8000b91e:	e0 6a 01 04 	mov	r10,260
8000b922:	30 0b       	mov	r11,0
8000b924:	0a 9c       	mov	r12,r5
8000b926:	e0 a0 19 f3 	rcall	8000ed0c <memset>
    memset(file->filename, '\0', sizeof(file->filename));
8000b92a:	ec c4 03 24 	sub	r4,r6,804
8000b92e:	e0 6a 01 04 	mov	r10,260
8000b932:	30 0b       	mov	r11,0
8000b934:	08 9c       	mov	r12,r4
8000b936:	e0 a0 19 eb 	rcall	8000ed0c <memset>

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)path, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
8000b93a:	e0 68 01 04 	mov	r8,260
8000b93e:	04 9c       	mov	r12,r2
8000b940:	08 99       	mov	r9,r4
8000b942:	10 9a       	mov	r10,r8
8000b944:	0a 9b       	mov	r11,r5
8000b946:	e0 a0 08 07 	rcall	8000c954 <fatfs_split_path>
8000b94a:	5b fc       	cp.w	r12,-1
8000b94c:	c1 80       	breq	8000b97c <_open_file+0xc4>
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
8000b94e:	66 02       	ld.w	r2,r3[0x0]
8000b950:	58 02       	cp.w	r2,0
8000b952:	c0 51       	brne	8000b95c <_open_file+0xa4>
8000b954:	c1 c8       	rjmp	8000b98c <_open_file+0xd4>
8000b956:	64 12       	ld.w	r2,r2[0x4]
8000b958:	58 02       	cp.w	r2,0
8000b95a:	c1 90       	breq	8000b98c <_open_file+0xd4>
    {
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
8000b95c:	e4 c8 04 3c 	sub	r8,r2,1084

        // If not the current file 
        if (openFile != file)
8000b960:	10 37       	cp.w	r7,r8
8000b962:	cf a0       	breq	8000b956 <_open_file+0x9e>
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
8000b964:	0a 9b       	mov	r11,r5
8000b966:	e4 cc 04 28 	sub	r12,r2,1064
8000b96a:	e0 a0 06 a5 	rcall	8000c6b4 <fatfs_compare_names>
8000b96e:	cf 40       	breq	8000b956 <_open_file+0x9e>
8000b970:	e4 cc 03 24 	sub	r12,r2,804
8000b974:	08 9b       	mov	r11,r4
8000b976:	e0 a0 06 9f 	rcall	8000c6b4 <fatfs_compare_names>
8000b97a:	ce e0       	breq	8000b956 <_open_file+0x9e>
    }

    // Check if file already open
    if (_check_file_open(file))
    {
        _free_file(file);
8000b97c:	0e 9c       	mov	r12,r7
8000b97e:	fe b0 fa df 	rcall	8000af3c <_free_file>
8000b982:	30 07       	mov	r7,0
            return file;
        }

    _free_file(file);
    return NULL;
}
8000b984:	0e 9c       	mov	r12,r7
8000b986:	2f 8d       	sub	sp,-32
8000b988:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
8000b98c:	ef 39 00 14 	ld.ub	r9,r7[20]
8000b990:	30 08       	mov	r8,0
8000b992:	f0 09 18 00 	cp.b	r9,r8
8000b996:	c5 70       	breq	8000ba44 <_open_file+0x18c>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
8000b998:	0a 9c       	mov	r12,r5
8000b99a:	0e 9b       	mov	r11,r7
8000b99c:	fe b0 fb 32 	rcall	8000b000 <_open_directory>
8000b9a0:	18 98       	mov	r8,r12
8000b9a2:	e0 80 00 ab 	breq	8000baf8 <_open_file+0x240>
        {
            _free_file(file);
            return NULL;
8000b9a6:	6e 0b       	ld.w	r11,r7[0x0]
        }
    }

    // Using dir cluster address search for filename
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry))
8000b9a8:	08 9a       	mov	r10,r4
8000b9aa:	1a 95       	mov	r5,sp
8000b9ac:	e0 6c 19 60 	mov	r12,6496
8000b9b0:	1a 99       	mov	r9,sp
8000b9b2:	fe b0 f4 c9 	rcall	8000a344 <fatfs_get_file_entry>
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
8000b9b6:	c4 e0       	breq	8000ba52 <_open_file+0x19a>
8000b9b8:	1a 9c       	mov	r12,sp
8000b9ba:	e0 a0 02 90 	rcall	8000beda <fatfs_entry_is_file>
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
8000b9be:	c4 a0       	breq	8000ba52 <_open_file+0x19a>
8000b9c0:	1a 9b       	mov	r11,sp
8000b9c2:	30 ba       	mov	r10,11
8000b9c4:	ee cc fd e4 	sub	r12,r7,-540
8000b9c8:	e0 a0 18 fe 	rcall	8000ebc4 <memcpy>
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
8000b9cc:	40 7a       	lddsp	r10,sp[0x1c]
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
8000b9ce:	3f f8       	mov	r8,-1
8000b9d0:	14 9c       	mov	r12,r10
8000b9d2:	f4 06 15 18 	lsl	r6,r10,0x18
8000b9d6:	e6 1c 00 ff 	andh	r12,0xff,COH
8000b9da:	ed ea 13 86 	or	r6,r6,r10>>0x18
8000b9de:	e2 1a ff 00 	andl	r10,0xff00,COH
8000b9e2:	ed ea 10 8a 	or	r10,r6,r10<<0x8
8000b9e6:	f5 ec 12 8a 	or	r10,r10,r12>>0x8
8000b9ea:	30 09       	mov	r9,0
            file->bytenum = 0;
8000b9ec:	8f 3a       	st.w	r7[0xc],r10
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8000b9ee:	8f 29       	st.w	r7[0x8],r9
8000b9f0:	fb 16 00 14 	ld.uh	r6,sp[20]
8000b9f4:	fb 1a 00 1a 	ld.uh	r10,sp[26]
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
8000b9f8:	ef 48 02 2c 	st.w	r7[556],r8
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
8000b9fc:	ef 48 04 30 	st.w	r7[1072],r8
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
8000ba00:	ef 48 02 28 	st.w	r7[552],r8
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8000ba04:	ec 08 15 08 	lsl	r8,r6,0x8
8000ba08:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba0c:	f1 e6 12 86 	or	r6,r8,r6>>0x8
8000ba10:	f4 08 15 08 	lsl	r8,r10,0x8
8000ba14:	b1 66       	lsl	r6,0x10
8000ba16:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba1a:	f1 ea 12 8a 	or	r10,r8,r10>>0x8
8000ba1e:	ec 0a 00 0a 	add	r10,r6,r10
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
            file->filelength_changed = 0;
8000ba22:	0e 9b       	mov	r11,r7
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
8000ba24:	8f 49       	st.w	r7[0x10],r9
8000ba26:	ef 49 04 34 	st.w	r7[1076],r9

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

            fatfs_cache_init(&_fs, file);
8000ba2a:	8f 1a       	st.w	r7[0x4],r10
8000ba2c:	e0 6c 19 60 	mov	r12,6496

            fatfs_fat_purge(&_fs);
8000ba30:	fe b0 fa 82 	rcall	8000af34 <fatfs_cache_init>
8000ba34:	e0 6c 19 60 	mov	r12,6496
            return file;
        }

    _free_file(file);
    return NULL;
}
8000ba38:	e0 a0 08 9e 	rcall	8000cb74 <fatfs_fat_purge>
8000ba3c:	0e 9c       	mov	r12,r7
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
8000ba3e:	2f 8d       	sub	sp,-32
8000ba40:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000ba44:	e0 6c 19 60 	mov	r12,6496
8000ba48:	fe b0 f3 09 	rcall	8000a05a <fatfs_get_root_cluster>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8000ba4c:	18 9b       	mov	r11,r12
8000ba4e:	8f 0c       	st.w	r7[0x0],r12
8000ba50:	ca cb       	rjmp	8000b9a8 <_open_file+0xf0>
8000ba52:	6c 08       	ld.w	r8,r6[0x0]
8000ba54:	58 08       	cp.w	r8,0
8000ba56:	f0 09 17 00 	moveq	r9,r8
    else
        node->previous->next = node->next;
8000ba5a:	ef f8 01 10 	ld.weq	r8,r7[0x440]
8000ba5e:	e7 f8 0a 00 	st.weq	r3[0x0],r8
8000ba62:	ef f9 11 10 	ld.wne	r9,r7[0x440]
8000ba66:	f1 f9 1a 01 	st.wne	r8[0x4],r9

    if(!node->next)
        list->tail = node->previous;
8000ba6a:	ef f8 11 10 	ld.wne	r8,r7[0x440]
    else
        node->next->previous = node->previous;
8000ba6e:	ed f9 10 00 	ld.wne	r9,r6[0x0]
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8000ba72:	e7 f9 0a 01 	st.weq	r3[0x4],r9
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8000ba76:	f1 f9 1a 00 	st.wne	r8[0x0],r9
8000ba7a:	e0 6b 26 54 	mov	r11,9812
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000ba7e:	62 18       	ld.w	r8,r1[0x4]
    new_node->next = node->next;
8000ba80:	ee c9 fb c4 	sub	r9,r7,-1084
8000ba84:	58 08       	cp.w	r8,0
    if (!node->next)
8000ba86:	c2 40       	breq	8000bace <_open_file+0x216>
        list->tail = new_node;
8000ba88:	8d 08       	st.w	r6[0x0],r8
8000ba8a:	70 1a       	ld.w	r10,r8[0x4]
8000ba8c:	ef 4a 04 40 	st.w	r7[1088],r10
    else
        node->next->previous = new_node;
8000ba90:	70 1a       	ld.w	r10,r8[0x4]
    node->next = new_node;
8000ba92:	58 0a       	cp.w	r10,0
8000ba94:	f7 f9 0a 01 	st.weq	r11[0x4],r9
            return file;
        }

    _free_file(file);
    return NULL;
}
8000ba98:	f5 f9 1a 00 	st.wne	r10[0x0],r9
8000ba9c:	30 07       	mov	r7,0
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
    if (node)
8000ba9e:	91 19       	st.w	r8[0x4],r9
8000baa0:	0e 9c       	mov	r12,r7
8000baa2:	2f 8d       	sub	sp,-32
8000baa4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000baa8:	0c 97       	mov	r7,r6
8000baaa:	0e 9c       	mov	r12,r7
8000baac:	2f 8d       	sub	sp,-32
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000baae:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000bab2:	66 08       	ld.w	r8,r3[0x0]
    new_node->next = node;
    if (!node->previous)
8000bab4:	58 08       	cp.w	r8,0
        list->head = new_node;
8000bab6:	c1 c0       	breq	8000baee <_open_file+0x236>
8000bab8:	70 09       	ld.w	r9,r8[0x0]
8000baba:	8d 18       	st.w	r6[0x4],r8
    else
        node->previous->next = new_node;
8000babc:	8d 09       	st.w	r6[0x0],r9
8000babe:	70 09       	ld.w	r9,r8[0x0]
    node->previous = new_node;
8000bac0:	58 09       	cp.w	r9,0
8000bac2:	e7 f6 0a 00 	st.weq	r3[0x0],r6
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000bac6:	f3 f6 1a 01 	st.wne	r9[0x4],r6
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8000baca:	91 06       	st.w	r8[0x0],r6
8000bacc:	c2 4b       	rjmp	8000b914 <_open_file+0x5c>
    new_node->next = node;
8000bace:	76 08       	ld.w	r8,r11[0x0]
8000bad0:	58 08       	cp.w	r8,0
    if (!node->previous)
8000bad2:	c1 80       	breq	8000bb02 <_open_file+0x24a>
        list->head = new_node;
8000bad4:	70 0a       	ld.w	r10,r8[0x0]
8000bad6:	8d 0a       	st.w	r6[0x0],r10
8000bad8:	ef 48 04 40 	st.w	r7[1088],r8
    else
        node->previous->next = new_node;
8000badc:	70 0a       	ld.w	r10,r8[0x0]
    node->previous = new_node;
8000bade:	58 0a       	cp.w	r10,0
8000bae0:	f7 f9 0a 00 	st.weq	r11[0x0],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000bae4:	f5 f9 1a 01 	st.wne	r10[0x4],r9
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8000bae8:	91 09       	st.w	r8[0x0],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8000baea:	30 07       	mov	r7,0
8000baec:	c4 cb       	rjmp	8000b984 <_open_file+0xcc>
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
        {
            _free_file(file);
8000baee:	87 06       	st.w	r3[0x0],r6
8000baf0:	87 16       	st.w	r3[0x4],r6
8000baf2:	8d 18       	st.w	r6[0x4],r8
8000baf4:	8d 08       	st.w	r6[0x0],r8
            return NULL;
8000baf6:	c0 fb       	rjmp	8000b914 <_open_file+0x5c>
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
8000baf8:	0e 9c       	mov	r12,r7
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000bafa:	10 97       	mov	r7,r8
        list->tail = node;
        node->previous = 0;
8000bafc:	fe b0 fa 20 	rcall	8000af3c <_free_file>
        node->next = 0;
8000bb00:	c4 2b       	rjmp	8000b984 <_open_file+0xcc>
8000bb02:	97 19       	st.w	r11[0x4],r9
8000bb04:	97 09       	st.w	r11[0x0],r9
8000bb06:	8d 08       	st.w	r6[0x0],r8
8000bb08:	ef 48 04 40 	st.w	r7[1088],r8
8000bb0c:	10 97       	mov	r7,r8
8000bb0e:	c3 bb       	rjmp	8000b984 <_open_file+0xcc>

8000bb10 <fl_fopen>:
8000bb10:	eb cd 40 fc 	pushm	r2-r7,lr
8000bb14:	20 1d       	sub	sp,4
8000bb16:	e0 69 26 50 	mov	r9,9808
8000bb1a:	18 97       	mov	r7,r12
8000bb1c:	72 08       	ld.w	r8,r9[0x0]
8000bb1e:	58 08       	cp.w	r8,0
8000bb20:	c0 a0       	breq	8000bb34 <fl_fopen+0x24>
8000bb22:	e0 68 19 5c 	mov	r8,6492
8000bb26:	70 08       	ld.w	r8,r8[0x0]
8000bb28:	58 08       	cp.w	r8,0
8000bb2a:	c2 21       	brne	8000bb6e <fl_fopen+0x5e>
8000bb2c:	30 0c       	mov	r12,0
8000bb2e:	2f fd       	sub	sp,-4
8000bb30:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000bb34:	e0 6a 1d c8 	mov	r10,7624
8000bb38:	f5 48 08 84 	st.w	r10[2180],r8
8000bb3c:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8000bb40:	e0 6c 19 54 	mov	r12,6484
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000bb44:	99 08       	st.w	r12[0x0],r8
8000bb46:	99 18       	st.w	r12[0x4],r8
8000bb48:	f4 c6 f7 80 	sub	r6,r10,-2176
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000bb4c:	e0 68 26 54 	mov	r8,9812
8000bb50:	f5 46 04 40 	st.w	r10[1088],r6
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8000bb54:	f4 cc fb c4 	sub	r12,r10,-1084

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000bb58:	f5 4c 08 80 	st.w	r10[2176],r12
    uint8 flags = 0;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (!_filelib_valid)
8000bb5c:	91 16       	st.w	r8[0x4],r6
8000bb5e:	91 0c       	st.w	r8[0x0],r12
8000bb60:	30 18       	mov	r8,1
        return NULL;

    if (!path || !mode)
8000bb62:	93 08       	st.w	r9[0x0],r8
8000bb64:	e0 68 19 5c 	mov	r8,6492
8000bb68:	70 08       	ld.w	r8,r8[0x0]
8000bb6a:	58 08       	cp.w	r8,0
8000bb6c:	ce 00       	breq	8000bb2c <fl_fopen+0x1c>
8000bb6e:	58 0b       	cp.w	r11,0
    FL_UNLOCK(&_fs);
}
//-----------------------------------------------------------------------------
// fopen: Open or Create a file for reading or writing
//-----------------------------------------------------------------------------
void* fl_fopen(const char *path, const char *mode)
8000bb70:	5f 09       	sreq	r9
8000bb72:	58 07       	cp.w	r7,0
8000bb74:	5f 08       	sreq	r8
8000bb76:	f3 e8 10 08 	or	r8,r9,r8
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
    {
        switch (mode[i])
8000bb7a:	cd 91       	brne	8000bb2c <fl_fopen+0x1c>
    FL_UNLOCK(&_fs);
}
//-----------------------------------------------------------------------------
// fopen: Open or Create a file for reading or writing
//-----------------------------------------------------------------------------
void* fl_fopen(const char *path, const char *mode)
8000bb7c:	16 9c       	mov	r12,r11
8000bb7e:	50 0b       	stdsp	sp[0x0],r11
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bb80:	e0 a0 19 95 	rcall	8000eeaa <strlen>
    {
        switch (mode[i])
8000bb84:	30 06       	mov	r6,0
8000bb86:	4b 6a       	lddpc	r10,8000bc5c <fl_fopen+0x14c>
8000bb88:	0c 98       	mov	r8,r6
8000bb8a:	40 0b       	lddsp	r11,sp[0x0]
8000bb8c:	18 38       	cp.w	r8,r12
8000bb8e:	c1 e4       	brge	8000bbca <fl_fopen+0xba>
8000bb90:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000bb94:	22 b9       	sub	r9,43
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
8000bb96:	e0 49 00 4c 	cp.w	r9,76
8000bb9a:	e0 8b 00 08 	brhi	8000bbaa <fl_fopen+0x9a>
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bb9e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
            break;
        case 'w':
        case 'W':
            flags |= FILE_WRITE;
            flags |= FILE_ERASE;
            flags |= FILE_CREATE;
8000bba2:	ed b6 00 00 	bld	r6,0x0
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bba6:	c3 81       	brne	8000bc16 <fl_fopen+0x106>
8000bba8:	a1 b6       	sbr	r6,0x1
    {
        switch (mode[i])
        {
        case 'r':
        case 'R':
            flags |= FILE_READ;
8000bbaa:	2f f8       	sub	r8,-1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bbac:	cf 0b       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bbae:	e8 16 00 32 	orl	r6,0x32
8000bbb2:	2f f8       	sub	r8,-1
8000bbb4:	ce cb       	rjmp	8000bb8c <fl_fopen+0x7c>
            break;
        case 'a':
        case 'A':
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
8000bbb6:	a1 a6       	sbr	r6,0x0
8000bbb8:	2f f8       	sub	r8,-1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bbba:	ce 9b       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bbbc:	a3 b6       	sbr	r6,0x3
    // No write support!
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
8000bbbe:	2f f8       	sub	r8,-1
8000bbc0:	ce 6b       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bbc2:	e8 16 00 26 	orl	r6,0x26
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);

    FL_LOCK(&_fs);
8000bbc6:	2f f8       	sub	r8,-1
8000bbc8:	ce 2b       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bbca:	e0 65 19 60 	mov	r5,6496

    // Read
    if (flags & FILE_READ)
8000bbce:	6a e8       	ld.w	r8,r5[0x38]
8000bbd0:	58 08       	cp.w	r8,0
8000bbd2:	c3 d0       	breq	8000bc4c <fl_fopen+0x13c>
        file = _open_file(path);

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
8000bbd4:	6a f8       	ld.w	r8,r5[0x3c]
8000bbd6:	58 08       	cp.w	r8,0
8000bbd8:	c0 20       	breq	8000bbdc <fl_fopen+0xcc>
8000bbda:	5d 18       	icall	r8
8000bbdc:	e9 d6 c0 01 	bfextu	r4,r6,0x0,0x1
        file = _create_file(path);
#endif

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
8000bbe0:	c2 91       	brne	8000bc32 <fl_fopen+0x122>
        if ((flags & FILE_CREATE) && !file)
8000bbe2:	0c 93       	mov	r3,r6
8000bbe4:	e2 13 00 20 	andl	r3,0x20,COH
8000bbe8:	c3 51       	brne	8000bc52 <fl_fopen+0x142>
8000bbea:	06 92       	mov	r2,r3
8000bbec:	58 04       	cp.w	r4,0
8000bbee:	c2 c1       	brne	8000bc46 <fl_fopen+0x136>
8000bbf0:	58 03       	cp.w	r3,0
            if (flags & (FILE_WRITE | FILE_APPEND))
8000bbf2:	5f 18       	srne	r8
8000bbf4:	58 02       	cp.w	r2,0
8000bbf6:	5f 09       	sreq	r9
8000bbf8:	10 69       	and	r9,r8
8000bbfa:	e8 09 18 00 	cp.b	r9,r4
                file = _open_file(path);

    if (file)
        file->flags = flags;

    FL_UNLOCK(&_fs);
8000bbfe:	c2 40       	breq	8000bc46 <fl_fopen+0x136>
8000bc00:	0c 98       	mov	r8,r6
8000bc02:	e2 18 00 06 	andl	r8,0x6,COH
8000bc06:	c1 d1       	brne	8000bc40 <fl_fopen+0x130>
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
8000bc08:	08 92       	mov	r2,r4
8000bc0a:	6b 08       	ld.w	r8,r5[0x40]
8000bc0c:	58 08       	cp.w	r8,0
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
            }
            else if (flags & FILE_APPEND)
8000bc0e:	c0 20       	breq	8000bc12 <fl_fopen+0x102>
8000bc10:	5d 18       	icall	r8
8000bc12:	04 9c       	mov	r12,r2
            {
                flags |= FILE_READ;
                flags |= FILE_WRITE;
                flags |= FILE_APPEND;
                flags |= FILE_CREATE;
8000bc14:	c8 db       	rjmp	8000bb2e <fl_fopen+0x1e>
8000bc16:	ed b6 00 01 	bld	r6,0x1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bc1a:	c0 80       	breq	8000bc2a <fl_fopen+0x11a>
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
8000bc1c:	ed b6 00 02 	bld	r6,0x2
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8000bc20:	cc 51       	brne	8000bbaa <fl_fopen+0x9a>
8000bc22:	e8 16 00 27 	orl	r6,0x27

    FL_LOCK(&_fs);

    // Read
    if (flags & FILE_READ)
        file = _open_file(path);
8000bc26:	2f f8       	sub	r8,-1
8000bc28:	cb 2b       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bc2a:	e8 16 00 31 	orl	r6,0x31
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);

    if (file)
        file->flags = flags;
8000bc2e:	2f f8       	sub	r8,-1
8000bc30:	ca eb       	rjmp	8000bb8c <fl_fopen+0x7c>
8000bc32:	0e 9c       	mov	r12,r7

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);
8000bc34:	c4 2e       	rcall	8000b8b8 <_open_file>
8000bc36:	18 92       	mov	r2,r12
8000bc38:	cd 50       	breq	8000bbe2 <fl_fopen+0xd2>
8000bc3a:	e5 66 04 38 	st.b	r2[1080],r6

    if (file)
8000bc3e:	ce 6b       	rjmp	8000bc0a <fl_fopen+0xfa>
8000bc40:	0e 9c       	mov	r12,r7
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
8000bc42:	c3 be       	rcall	8000b8b8 <_open_file>
8000bc44:	18 92       	mov	r2,r12
8000bc46:	58 02       	cp.w	r2,0
        file = _open_file(path);

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
        file = _create_file(path);
8000bc48:	cf 91       	brne	8000bc3a <fl_fopen+0x12a>
8000bc4a:	ce 0b       	rjmp	8000bc0a <fl_fopen+0xfa>
8000bc4c:	e2 16 00 d9 	andl	r6,0xd9,COH
8000bc50:	cc 2b       	rjmp	8000bbd4 <fl_fopen+0xc4>
8000bc52:	0e 9c       	mov	r12,r7
8000bc54:	fe b0 fa fc 	rcall	8000b24c <_create_file>
8000bc58:	18 92       	mov	r2,r12
8000bc5a:	cc 9b       	rjmp	8000bbec <fl_fopen+0xdc>
8000bc5c:	80 01       	ld.sh	r1,r0[0x0]
8000bc5e:	4e 20       	lddpc	r0,8000bde4 <fatfs_lfn_cache_entry+0x184>

8000bc60 <fatfs_lfn_cache_entry>:
// fatfs_lfn_cache_entry - Function extracts long file name text from sector 
// at a specific offset
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
8000bc60:	d4 01       	pushm	lr
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
8000bc62:	31 48       	mov	r8,20
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;
8000bc64:	17 89       	ld.ub	r9,r11[0x0]
8000bc66:	f3 d9 c0 05 	bfextu	r9,r9,0x0,0x5

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
8000bc6a:	f0 09 18 00 	cp.b	r9,r8
8000bc6e:	e0 8b 00 c8 	brhi	8000bdfe <fatfs_lfn_cache_entry+0x19e>
        return ;

    // This is an error condition
    if (LFNIndex == 0)
8000bc72:	58 09       	cp.w	r9,0
8000bc74:	e0 80 00 c5 	breq	8000bdfe <fatfs_lfn_cache_entry+0x19e>
        return ;

    if (lfn->no_of_strings == 0) 
8000bc78:	30 08       	mov	r8,0
8000bc7a:	f9 3a 01 05 	ld.ub	r10,r12[261]
        lfn->no_of_strings = LFNIndex;
8000bc7e:	f0 0a 18 00 	cp.b	r10,r8
8000bc82:	f9 f9 0f 05 	st.beq	r12[0x105],r9

    lfn->String[LFNIndex-1][0] = entryBuffer[1];
8000bc86:	20 19       	sub	r9,1
8000bc88:	f2 09 00 18 	add	r8,r9,r9<<0x1
8000bc8c:	17 9e       	ld.ub	lr,r11[0x1]
8000bc8e:	f2 08 00 29 	add	r9,r9,r8<<0x2
8000bc92:	f8 09 00 08 	add	r8,r12,r9
8000bc96:	10 9a       	mov	r10,r8
8000bc98:	14 ce       	st.b	r10++,lr
    lfn->String[LFNIndex-1][1] = entryBuffer[3];
8000bc9a:	17 be       	ld.ub	lr,r11[0x3]
8000bc9c:	b4 8e       	st.b	r10[0x0],lr
    lfn->String[LFNIndex-1][2] = entryBuffer[5];
8000bc9e:	17 da       	ld.ub	r10,r11[0x5]
8000bca0:	b0 aa       	st.b	r8[0x2],r10
    lfn->String[LFNIndex-1][3] = entryBuffer[7];
8000bca2:	17 fa       	ld.ub	r10,r11[0x7]
8000bca4:	b0 ba       	st.b	r8[0x3],r10
    lfn->String[LFNIndex-1][4] = entryBuffer[9];
8000bca6:	f7 3a 00 09 	ld.ub	r10,r11[9]
8000bcaa:	b0 ca       	st.b	r8[0x4],r10
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
8000bcac:	f7 3a 00 0e 	ld.ub	r10,r11[14]
8000bcb0:	b0 da       	st.b	r8[0x5],r10
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
8000bcb2:	f7 3a 00 10 	ld.ub	r10,r11[16]
8000bcb6:	b0 ea       	st.b	r8[0x6],r10
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
8000bcb8:	f7 3a 00 12 	ld.ub	r10,r11[18]
8000bcbc:	b0 fa       	st.b	r8[0x7],r10
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
8000bcbe:	f7 3a 00 14 	ld.ub	r10,r11[20]
8000bcc2:	f1 6a 00 08 	st.b	r8[8],r10
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
8000bcc6:	f7 3a 00 16 	ld.ub	r10,r11[22]
8000bcca:	f1 6a 00 09 	st.b	r8[9],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
8000bcce:	f7 3a 00 18 	ld.ub	r10,r11[24]
8000bcd2:	f1 6a 00 0a 	st.b	r8[10],r10
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
8000bcd6:	f7 3a 00 1c 	ld.ub	r10,r11[28]
8000bcda:	f1 6a 00 0b 	st.b	r8[11],r10
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
8000bcde:	f7 3a 00 1e 	ld.ub	r10,r11[30]

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bce2:	11 8b       	ld.ub	r11,r8[0x0]
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
8000bce4:	f1 6a 00 0c 	st.b	r8[12],r10

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bce8:	3f fa       	mov	r10,-1
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bcea:	f4 0b 18 00 	cp.b	r11,r10
8000bcee:	f9 ba 00 20 	moveq	r10,32
8000bcf2:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bcf6:	f8 09 00 08 	add	r8,r12,r9
8000bcfa:	3f fa       	mov	r10,-1
8000bcfc:	2f f8       	sub	r8,-1
8000bcfe:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd00:	f4 0b 18 00 	cp.b	r11,r10
8000bd04:	f9 ba 00 20 	moveq	r10,32
8000bd08:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd0c:	f8 09 00 08 	add	r8,r12,r9
8000bd10:	3f fa       	mov	r10,-1
8000bd12:	2f e8       	sub	r8,-2
8000bd14:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd16:	f4 0b 18 00 	cp.b	r11,r10
8000bd1a:	f9 ba 00 20 	moveq	r10,32
8000bd1e:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd22:	f8 09 00 08 	add	r8,r12,r9
8000bd26:	3f fa       	mov	r10,-1
8000bd28:	2f d8       	sub	r8,-3
8000bd2a:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd2c:	f4 0b 18 00 	cp.b	r11,r10
8000bd30:	f9 ba 00 20 	moveq	r10,32
8000bd34:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd38:	f8 09 00 08 	add	r8,r12,r9
8000bd3c:	3f fa       	mov	r10,-1
8000bd3e:	2f c8       	sub	r8,-4
8000bd40:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd42:	f4 0b 18 00 	cp.b	r11,r10
8000bd46:	f9 ba 00 20 	moveq	r10,32
8000bd4a:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd4e:	f8 09 00 08 	add	r8,r12,r9
8000bd52:	3f fa       	mov	r10,-1
8000bd54:	2f b8       	sub	r8,-5
8000bd56:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd58:	f4 0b 18 00 	cp.b	r11,r10
8000bd5c:	f9 ba 00 20 	moveq	r10,32
8000bd60:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd64:	f8 09 00 08 	add	r8,r12,r9
8000bd68:	3f fa       	mov	r10,-1
8000bd6a:	2f a8       	sub	r8,-6
8000bd6c:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd6e:	f4 0b 18 00 	cp.b	r11,r10
8000bd72:	f9 ba 00 20 	moveq	r10,32
8000bd76:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd7a:	f8 09 00 08 	add	r8,r12,r9
8000bd7e:	3f fa       	mov	r10,-1
8000bd80:	2f 98       	sub	r8,-7
8000bd82:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd84:	f4 0b 18 00 	cp.b	r11,r10
8000bd88:	f9 ba 00 20 	moveq	r10,32
8000bd8c:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bd90:	f8 09 00 08 	add	r8,r12,r9
8000bd94:	3f fa       	mov	r10,-1
8000bd96:	2f 88       	sub	r8,-8
8000bd98:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bd9a:	f4 0b 18 00 	cp.b	r11,r10
8000bd9e:	f9 ba 00 20 	moveq	r10,32
8000bda2:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bda6:	f8 09 00 08 	add	r8,r12,r9
8000bdaa:	3f fa       	mov	r10,-1
8000bdac:	2f 78       	sub	r8,-9
8000bdae:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bdb0:	f4 0b 18 00 	cp.b	r11,r10
8000bdb4:	f9 ba 00 20 	moveq	r10,32
8000bdb8:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bdbc:	f8 09 00 08 	add	r8,r12,r9
8000bdc0:	3f fa       	mov	r10,-1
8000bdc2:	2f 68       	sub	r8,-10
8000bdc4:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bdc6:	f4 0b 18 00 	cp.b	r11,r10
8000bdca:	f9 ba 00 20 	moveq	r10,32
8000bdce:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bdd2:	f8 09 00 08 	add	r8,r12,r9
8000bdd6:	3f fa       	mov	r10,-1
8000bdd8:	2f 58       	sub	r8,-11
8000bdda:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bddc:	f4 0b 18 00 	cp.b	r11,r10
8000bde0:	f9 ba 00 20 	moveq	r10,32
8000bde4:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8000bde8:	f8 09 00 09 	add	r9,r12,r9
8000bdec:	3f f8       	mov	r8,-1
8000bdee:	2f 49       	sub	r9,-12
8000bdf0:	13 8a       	ld.ub	r10,r9[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8000bdf2:	f0 0a 18 00 	cp.b	r10,r8
8000bdf6:	f9 b8 00 20 	moveq	r8,32
8000bdfa:	f3 f8 0e 00 	st.beq	r9[0x0],r8
8000bdfe:	d8 02       	popm	pc

8000be00 <fatfs_lfn_cache_get>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
8000be00:	f9 38 01 05 	ld.ub	r8,r12[261]
8000be04:	31 49       	mov	r9,20
8000be06:	f2 08 18 00 	cp.b	r8,r9
8000be0a:	c0 e0       	breq	8000be26 <fatfs_lfn_cache_get+0x26>
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
8000be0c:	58 08       	cp.w	r8,0
8000be0e:	c0 31       	brne	8000be14 <fatfs_lfn_cache_get+0x14>
        lfn->String[lfn->no_of_strings][0] = '\0';
    else
        lfn->String[0][0] = '\0';
8000be10:	b8 88       	st.b	r12[0x0],r8

    return (char*)&lfn->String[0][0];
}
8000be12:	5e fc       	retal	r12
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
        lfn->String[lfn->no_of_strings][0] = '\0';
8000be14:	f0 08 00 19 	add	r9,r8,r8<<0x1
8000be18:	f0 09 00 28 	add	r8,r8,r9<<0x2
8000be1c:	30 09       	mov	r9,0
8000be1e:	f8 08 00 08 	add	r8,r12,r8
8000be22:	b0 89       	st.b	r8[0x0],r9
8000be24:	5e fc       	retal	r12
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
8000be26:	30 08       	mov	r8,0
8000be28:	f9 68 01 04 	st.b	r12[260],r8
8000be2c:	5e fc       	retal	r12

8000be2e <fatfs_entry_lfn_text>:
//-----------------------------------------------------------------------------
// fatfs_entry_lfn_text: If LFN text entry found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_text(struct fat_dir_entry *entry)
{
8000be2e:	f9 38 00 0b 	ld.ub	r8,r12[11]
8000be32:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000be36:	58 f8       	cp.w	r8,15
    if ((entry->Attr & FILE_ATTR_LFN_TEXT) == FILE_ATTR_LFN_TEXT) 
        return 1;
    else 
        return 0;
}
8000be38:	5f 0c       	sreq	r12
8000be3a:	5e fc       	retal	r12

8000be3c <fatfs_entry_lfn_invalid>:
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8000be3c:	3e 58       	mov	r8,-27
8000be3e:	19 89       	ld.ub	r9,r12[0x0]
8000be40:	f0 09 18 00 	cp.b	r9,r8
8000be44:	5f 0a       	sreq	r10
8000be46:	30 08       	mov	r8,0
8000be48:	f0 09 18 00 	cp.b	r9,r8
8000be4c:	5f 09       	sreq	r9
8000be4e:	f5 e9 10 09 	or	r9,r10,r9
8000be52:	f0 09 18 00 	cp.b	r9,r8
8000be56:	c0 b1       	brne	8000be6c <fatfs_entry_lfn_invalid+0x30>
         (entry->Name[0]==FILE_HEADER_DELETED)||
         (entry->Attr==FILE_ATTR_VOLUME_ID) || 
8000be58:	f9 38 00 0b 	ld.ub	r8,r12[11]
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8000be5c:	30 89       	mov	r9,8
8000be5e:	f2 08 18 00 	cp.b	r8,r9
8000be62:	c0 50       	breq	8000be6c <fatfs_entry_lfn_invalid+0x30>
8000be64:	e2 18 00 06 	andl	r8,0x6,COH
8000be68:	5f 1c       	srne	r12
8000be6a:	5e fc       	retal	r12
8000be6c:	5e ff       	retal	1

8000be6e <fatfs_entry_lfn_exists>:
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8000be6e:	f7 38 00 0b 	ld.ub	r8,r11[11]
8000be72:	30 f9       	mov	r9,15
8000be74:	f2 08 18 00 	cp.b	r8,r9
8000be78:	c1 50       	breq	8000bea2 <fatfs_entry_lfn_exists+0x34>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
8000be7a:	17 89       	ld.ub	r9,r11[0x0]
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8000be7c:	58 09       	cp.w	r9,0
8000be7e:	c1 20       	breq	8000bea2 <fatfs_entry_lfn_exists+0x34>
8000be80:	3e 5a       	mov	r10,-27
8000be82:	f4 09 18 00 	cp.b	r9,r10
8000be86:	c0 e0       	breq	8000bea2 <fatfs_entry_lfn_exists+0x34>
8000be88:	30 89       	mov	r9,8
8000be8a:	f2 08 18 00 	cp.b	r8,r9
8000be8e:	c0 a0       	breq	8000bea2 <fatfs_entry_lfn_exists+0x34>
8000be90:	e2 18 00 06 	andl	r8,0x6,COH
8000be94:	c0 71       	brne	8000bea2 <fatfs_entry_lfn_exists+0x34>
8000be96:	f9 39 01 05 	ld.ub	r9,r12[261]
8000be9a:	f0 09 18 00 	cp.b	r9,r8
8000be9e:	5f 1c       	srne	r12
8000bea0:	5e fc       	retal	r12
8000bea2:	5e fd       	retal	0

8000bea4 <fatfs_entry_sfn_only>:
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8000bea4:	f9 38 00 0b 	ld.ub	r8,r12[11]
8000bea8:	30 f9       	mov	r9,15
8000beaa:	f2 08 18 00 	cp.b	r8,r9
8000beae:	c1 00       	breq	8000bece <fatfs_entry_sfn_only+0x2a>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
8000beb0:	19 89       	ld.ub	r9,r12[0x0]
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8000beb2:	58 09       	cp.w	r9,0
8000beb4:	c0 d0       	breq	8000bece <fatfs_entry_sfn_only+0x2a>
8000beb6:	3e 5a       	mov	r10,-27
8000beb8:	f4 09 18 00 	cp.b	r9,r10
8000bebc:	c0 90       	breq	8000bece <fatfs_entry_sfn_only+0x2a>
8000bebe:	30 89       	mov	r9,8
8000bec0:	f2 08 18 00 	cp.b	r8,r9
8000bec4:	c0 50       	breq	8000bece <fatfs_entry_sfn_only+0x2a>
8000bec6:	e2 18 00 06 	andl	r8,0x6,COH
8000beca:	5f 0c       	sreq	r12
8000becc:	5e fc       	retal	r12
8000bece:	5e fd       	retal	0

8000bed0 <fatfs_entry_is_dir>:
// TODO: FILE_ATTR_SYSHID ?!?!??!
//-----------------------------------------------------------------------------
// fatfs_entry_is_dir: Returns 1 if a directory
//-----------------------------------------------------------------------------
int fatfs_entry_is_dir(struct fat_dir_entry *entry)
{
8000bed0:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_DIR) 
        return 1;
    else 
        return 0;
}
8000bed4:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000bed8:	5e fc       	retal	r12

8000beda <fatfs_entry_is_file>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_file: Returns 1 is a file entry
//-----------------------------------------------------------------------------
int fatfs_entry_is_file(struct fat_dir_entry *entry)
{
8000beda:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_FILE) 
        return 1;
    else 
        return 0;
}
8000bede:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
8000bee2:	5e fc       	retal	r12

8000bee4 <fatfs_sfn_create_entry>:
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
8000bee4:	eb cd 40 e0 	pushm	r5-r7,lr
#endif
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
8000bee8:	f8 c7 ff fc 	sub	r7,r12,-4
8000beec:	0e 39       	cp.w	r9,r7
8000beee:	5f b5       	srhi	r5
8000bef0:	f2 ce ff fc 	sub	lr,r9,-4
8000bef4:	1c 3c       	cp.w	r12,lr
8000bef6:	5f b6       	srhi	r6
8000bef8:	eb e6 10 06 	or	r6,r5,r6
8000befc:	f3 ec 10 05 	or	r5,r9,r12
8000bf00:	eb d5 c0 02 	bfextu	r5,r5,0x0,0x2
8000bf04:	5f 05       	sreq	r5
8000bf06:	eb e6 00 06 	and	r6,r5,r6
8000bf0a:	c6 70       	breq	8000bfd8 <fatfs_sfn_create_entry+0xf4>
{
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
8000bf0c:	78 06       	ld.w	r6,r12[0x0]
8000bf0e:	93 06       	st.w	r9[0x0],r6
8000bf10:	6e 07       	ld.w	r7,r7[0x0]
8000bf12:	9d 07       	st.w	lr[0x0],r7
8000bf14:	f9 3e 00 08 	ld.ub	lr,r12[8]
8000bf18:	f3 6e 00 08 	st.b	r9[8],lr
8000bf1c:	f9 3e 00 09 	ld.ub	lr,r12[9]
8000bf20:	f3 6e 00 09 	st.b	r9[9],lr
8000bf24:	f9 3c 00 0a 	ld.ub	r12,r12[10]
8000bf28:	f3 6c 00 0a 	st.b	r9[10],r12

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
8000bf2c:	30 0c       	mov	r12,0
    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;
8000bf2e:	30 0e       	mov	lr,0
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
8000bf30:	f3 6c 00 19 	st.b	r9[25],r12
    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
8000bf34:	f3 6c 00 0d 	st.b	r9[13],r12
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
8000bf38:	f3 6c 00 0e 	st.b	r9[14],r12
8000bf3c:	f3 6c 00 0f 	st.b	r9[15],r12
    entry->CrtDate[1] = 0x00;
8000bf40:	f3 6c 00 11 	st.b	r9[17],r12
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
8000bf44:	f3 6c 00 13 	st.b	r9[19],r12
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
8000bf48:	f3 6c 00 16 	st.b	r9[22],r12
8000bf4c:	f3 6c 00 17 	st.b	r9[23],r12

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
8000bf50:	32 0c       	mov	r12,32
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    

    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
8000bf52:	58 08       	cp.w	r8,0
8000bf54:	f3 fc 0e 0b 	st.beq	r9[0xb],r12
    else
        entry->Attr = FILE_TYPE_DIR;
8000bf58:	f9 b8 01 10 	movne	r8,16
8000bf5c:	f3 f8 1e 0b 	st.bne	r9[0xb],r8

    entry->NTRes = 0x00;
8000bf60:	f3 6e 00 0c 	st.b	r9[12],lr

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
8000bf64:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
8000bf68:	b1 8a       	lsr	r10,0x10
8000bf6a:	f4 0e 16 08 	lsr	lr,r10,0x8
8000bf6e:	fd ea 10 8a 	or	r10,lr,r10<<0x8
8000bf72:	5c 7a       	castu.h	r10
8000bf74:	f3 6a 00 15 	st.b	r9[21],r10
8000bf78:	a9 8a       	lsr	r10,0x8
8000bf7a:	f3 6a 00 14 	st.b	r9[20],r10
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
8000bf7e:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bf82:	f5 e8 10 88 	or	r8,r10,r8<<0x8
8000bf86:	5c 78       	castu.h	r8
8000bf88:	f3 68 00 1b 	st.b	r9[27],r8
8000bf8c:	a9 88       	lsr	r8,0x8
8000bf8e:	f3 68 00 1a 	st.b	r9[26],r8
    entry->FileSize = FAT_HTONL(size);
8000bf92:	f6 08 15 18 	lsl	r8,r11,0x18
8000bf96:	f1 eb 13 88 	or	r8,r8,r11>>0x18

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
8000bf9a:	f3 6c 00 10 	st.b	r9[16],r12
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
8000bf9e:	f3 6c 00 12 	st.b	r9[18],r12
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    
8000bfa2:	f3 6c 00 18 	st.b	r9[24],r12

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
    entry->FileSize = FAT_HTONL(size);
8000bfa6:	16 9c       	mov	r12,r11
8000bfa8:	e2 1b ff 00 	andl	r11,0xff00,COH
8000bfac:	e6 1c 00 ff 	andh	r12,0xff,COH
8000bfb0:	f1 eb 10 8b 	or	r11,r8,r11<<0x8
8000bfb4:	f7 ec 12 8b 	or	r11,r11,r12>>0x8
8000bfb8:	f6 08 16 18 	lsr	r8,r11,0x18
8000bfbc:	f3 6b 00 1f 	st.b	r9[31],r11
8000bfc0:	f3 68 00 1c 	st.b	r9[28],r8
8000bfc4:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
8000bfc8:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
8000bfcc:	f3 68 00 1d 	st.b	r9[29],r8
8000bfd0:	f3 6b 00 1e 	st.b	r9[30],r11
}
8000bfd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
8000bfd8:	19 8e       	ld.ub	lr,r12[0x0]
8000bfda:	b2 8e       	st.b	r9[0x0],lr
8000bfdc:	19 9e       	ld.ub	lr,r12[0x1]
8000bfde:	b2 9e       	st.b	r9[0x1],lr
8000bfe0:	19 ae       	ld.ub	lr,r12[0x2]
8000bfe2:	b2 ae       	st.b	r9[0x2],lr
8000bfe4:	19 be       	ld.ub	lr,r12[0x3]
8000bfe6:	b2 be       	st.b	r9[0x3],lr
8000bfe8:	19 ce       	ld.ub	lr,r12[0x4]
8000bfea:	b2 ce       	st.b	r9[0x4],lr
8000bfec:	19 de       	ld.ub	lr,r12[0x5]
8000bfee:	b2 de       	st.b	r9[0x5],lr
8000bff0:	19 ee       	ld.ub	lr,r12[0x6]
8000bff2:	b2 ee       	st.b	r9[0x6],lr
8000bff4:	19 fe       	ld.ub	lr,r12[0x7]
8000bff6:	b2 fe       	st.b	r9[0x7],lr
8000bff8:	c8 eb       	rjmp	8000bf14 <fatfs_sfn_create_entry+0x30>

8000bffa <fatfs_lfn_cache_init>:
//-----------------------------------------------------------------------------
void fatfs_lfn_cache_init(struct lfn_cache *lfn, int wipeTable)
{
    int i = 0;

    lfn->no_of_strings = 0;
8000bffa:	30 08       	mov	r8,0
8000bffc:	f9 68 01 05 	st.b	r12[261],r8

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
8000c000:	58 0b       	cp.w	r11,0
8000c002:	5e 0c       	reteq	r12
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
            memset(lfn->String[i], 0x00, MAX_LFN_ENTRY_LENGTH);
8000c004:	30 0a       	mov	r10,0
8000c006:	14 99       	mov	r9,r10
8000c008:	f8 0a 00 08 	add	r8,r12,r10
8000c00c:	10 c9       	st.b	r8++,r9
8000c00e:	10 c9       	st.b	r8++,r9
8000c010:	10 c9       	st.b	r8++,r9
8000c012:	10 c9       	st.b	r8++,r9
8000c014:	10 c9       	st.b	r8++,r9
8000c016:	10 c9       	st.b	r8++,r9
8000c018:	10 c9       	st.b	r8++,r9
8000c01a:	10 c9       	st.b	r8++,r9
8000c01c:	10 c9       	st.b	r8++,r9
8000c01e:	10 c9       	st.b	r8++,r9
8000c020:	10 c9       	st.b	r8++,r9
8000c022:	10 c9       	st.b	r8++,r9
8000c024:	b0 89       	st.b	r8[0x0],r9
8000c026:	2f 3a       	sub	r10,-13

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
8000c028:	e0 4a 01 04 	cp.w	r10,260
8000c02c:	ce e1       	brne	8000c008 <fatfs_lfn_cache_init+0xe>
8000c02e:	5e fc       	retal	r12

8000c030 <fatfs_lfn_generate_tail>:
// sfn_output = Output short filename with tail
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_generate_tail(char *sfn_output, char *sfn_input, uint32 tailNum)
{
8000c030:	eb cd 40 fc 	pushm	r2-r7,lr
8000c034:	20 bd       	sub	sp,44
8000c036:	18 96       	mov	r6,r12
    int tail_chars;
    char tail_str[12];

    if (tailNum > 99999)
8000c038:	e0 5a 86 9f 	cp.w	r10,99999
8000c03c:	e0 88 00 05 	brls	8000c046 <fatfs_lfn_generate_tail+0x16>
8000c040:	2f 5d       	sub	sp,-44
8000c042:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
8000c046:	30 09       	mov	r9,0
8000c048:	fa c7 ff e0 	sub	r7,sp,-32
8000c04c:	30 08       	mov	r8,0
8000c04e:	ee e9 00 00 	st.d	r7[0],r8
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8000c052:	4a 89       	lddpc	r9,8000c0f0 <fatfs_lfn_generate_tail+0xc0>
8000c054:	f3 3c 00 10 	ld.ub	r12,r9[16]
8000c058:	fb 6c 00 10 	st.b	sp[16],r12

    if (tailNum > 99999)
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
8000c05c:	30 0c       	mov	r12,0
8000c05e:	8f 2c       	st.w	r7[0x8],r12
    tail_str[0] = '~';
8000c060:	37 ec       	mov	r12,126
8000c062:	fb 6c 00 20 	st.b	sp[32],r12
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8000c066:	f2 e4 00 00 	ld.d	r4,r9[0]
8000c06a:	fa e5 00 00 	st.d	sp[0],r4
8000c06e:	f2 e4 00 08 	ld.d	r4,r9[8]
8000c072:	fa e5 00 08 	st.d	sp[8],r4
8000c076:	fa c5 ff ec 	sub	r5,sp,-20
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
8000c07a:	e0 64 cc cd 	mov	r4,52429
8000c07e:	ea 14 cc cc 	orh	r4,0xcccc
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8000c082:	0a 99       	mov	r9,r5
8000c084:	c0 28       	rjmp	8000c088 <fatfs_lfn_generate_tail+0x58>
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
    } 
    while ((num /= 10) > 0);
8000c086:	10 99       	mov	r9,r8
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
8000c088:	f4 04 06 42 	mulu.d	r2,r10,r4
8000c08c:	e6 0c 16 03 	lsr	r12,r3,0x3
8000c090:	f8 0c 00 2e 	add	lr,r12,r12<<0x2
8000c094:	12 98       	mov	r8,r9
8000c096:	f4 0e 01 1a 	sub	r10,r10,lr<<0x1
8000c09a:	fa ce ff d4 	sub	lr,sp,-44
8000c09e:	fc 0a 00 0a 	add	r10,lr,r10
8000c0a2:	f5 3a ff d4 	ld.ub	r10,r10[-44]
8000c0a6:	10 ca       	st.b	r8++,r10
    } 
    while ((num /= 10) > 0);
8000c0a8:	18 9a       	mov	r10,r12
8000c0aa:	58 0c       	cp.w	r12,0
8000c0ac:	ce d1       	brne	8000c086 <fatfs_lfn_generate_tail+0x56>
    
    *cp-- = 0;
8000c0ae:	b0 8c       	st.b	r8[0x0],r12

    // Copy in forwards
    while (cp >= outbuf)
8000c0b0:	0a 39       	cp.w	r9,r5
8000c0b2:	c1 c3       	brcs	8000c0ea <fatfs_lfn_generate_tail+0xba>
8000c0b4:	fa c8 ff df 	sub	r8,sp,-33
        *s++ = *cp--;
8000c0b8:	13 8a       	ld.ub	r10,r9[0x0]
8000c0ba:	10 ca       	st.b	r8++,r10
8000c0bc:	20 19       	sub	r9,1
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
8000c0be:	0a 39       	cp.w	r9,r5
8000c0c0:	cf c2       	brcc	8000c0b8 <fatfs_lfn_generate_tail+0x88>
        *s++ = *cp--;

    *s = 0;
8000c0c2:	30 09       	mov	r9,0
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
8000c0c4:	30 ba       	mov	r10,11

    // Copy in forwards
    while (cp >= outbuf)
        *s++ = *cp--;

    *s = 0;
8000c0c6:	b0 89       	st.b	r8[0x0],r9
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
8000c0c8:	0c 9c       	mov	r12,r6
8000c0ca:	e0 a0 15 7d 	rcall	8000ebc4 <memcpy>
       
    // Overwrite with tail
    tail_chars = (int)strlen(tail_str);
8000c0ce:	0e 9c       	mov	r12,r7
8000c0d0:	e0 a0 16 ed 	rcall	8000eeaa <strlen>
    memcpy(sfn_output+(FAT_SFN_SIZE_PARTIAL-tail_chars), tail_str, tail_chars);
8000c0d4:	0e 9b       	mov	r11,r7
8000c0d6:	18 9a       	mov	r10,r12
8000c0d8:	f8 0c 11 08 	rsub	r12,r12,8
8000c0dc:	ec 0c 00 0c 	add	r12,r6,r12
8000c0e0:	e0 a0 15 72 	rcall	8000ebc4 <memcpy>
8000c0e4:	2f 5d       	sub	sp,-44
8000c0e6:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
8000c0ea:	fa c8 ff df 	sub	r8,sp,-33
8000c0ee:	ce ab       	rjmp	8000c0c2 <fatfs_lfn_generate_tail+0x92>
8000c0f0:	80 01       	ld.sh	r1,r0[0x0]
8000c0f2:	4f 90       	lddpc	r0,8000c2d4 <fatfs_filename_to_lfn+0x6c>

8000c0f4 <fatfs_lfn_create_sfn>:
8000c0f4:	eb cd 40 fc 	pushm	r2-r7,lr
8000c0f8:	20 1d       	sub	sp,4
8000c0fa:	16 97       	mov	r7,r11
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
{
8000c0fc:	18 94       	mov	r4,r12
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8000c0fe:	16 9c       	mov	r12,r11
8000c100:	e0 a0 16 d5 	rcall	8000eeaa <strlen>

    // Invalid to start with .
    if (filename[0]=='.')
8000c104:	32 e3       	mov	r3,46
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8000c106:	18 96       	mov	r6,r12

    // Invalid to start with .
    if (filename[0]=='.')
8000c108:	0f 88       	ld.ub	r8,r7[0x0]
8000c10a:	e6 08 18 00 	cp.b	r8,r3
8000c10e:	e0 80 00 98 	breq	8000c23e <fatfs_lfn_create_sfn+0x14a>
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
8000c112:	30 ba       	mov	r10,11
8000c114:	32 0b       	mov	r11,32
8000c116:	08 9c       	mov	r12,r4
8000c118:	e0 a0 15 fa 	rcall	8000ed0c <memset>
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8000c11c:	0c 95       	mov	r5,r6
    // Invalid to start with .
    if (filename[0]=='.')
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    memset(ext, ' ', 3);
8000c11e:	30 3a       	mov	r10,3
8000c120:	32 0b       	mov	r11,32
8000c122:	1a 9c       	mov	r12,sp
8000c124:	e0 a0 15 f4 	rcall	8000ed0c <memset>

    // Find dot seperator
    for (i = 0; i< len; i++)
8000c128:	58 06       	cp.w	r6,0
8000c12a:	e0 8a 00 62 	brle	8000c1ee <fatfs_lfn_create_sfn+0xfa>
8000c12e:	3f f9       	mov	r9,-1
8000c130:	30 08       	mov	r8,0
8000c132:	ee 08 07 0a 	ld.ub	r10,r7[r8]
8000c136:	e6 0a 18 00 	cp.b	r10,r3
8000c13a:	f0 09 17 00 	moveq	r9,r8
8000c13e:	2f f8       	sub	r8,-1
8000c140:	10 36       	cp.w	r6,r8
8000c142:	cf 81       	brne	8000c132 <fatfs_lfn_create_sfn+0x3e>
        if (filename[i]=='.')
            dotPos = i;
    }

    // Extract extensions
    if (dotPos!=-1)
8000c144:	5b f9       	cp.w	r9,-1
8000c146:	c2 b0       	breq	8000c19c <fatfs_lfn_create_sfn+0xa8>
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8000c148:	f2 c8 ff ff 	sub	r8,r9,-1
            if (i<len)
8000c14c:	10 36       	cp.w	r6,r8
8000c14e:	e0 8a 00 0a 	brle	8000c162 <fatfs_lfn_create_sfn+0x6e>
                ext[i-(dotPos+1)] = filename[i];
8000c152:	fa ca ff fc 	sub	r10,sp,-4
8000c156:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000c15a:	10 0a       	add	r10,r8
8000c15c:	12 1a       	sub	r10,r9
8000c15e:	f5 6b ff fb 	st.b	r10[-5],r11

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8000c162:	2f f8       	sub	r8,-1
            if (i<len)
8000c164:	10 36       	cp.w	r6,r8
8000c166:	e0 8a 00 0a 	brle	8000c17a <fatfs_lfn_create_sfn+0x86>
                ext[i-(dotPos+1)] = filename[i];
8000c16a:	fa ca ff fc 	sub	r10,sp,-4
8000c16e:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000c172:	10 0a       	add	r10,r8
8000c174:	12 1a       	sub	r10,r9
8000c176:	f5 6b ff fb 	st.b	r10[-5],r11

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8000c17a:	2f f8       	sub	r8,-1
            if (i<len)
8000c17c:	10 36       	cp.w	r6,r8
8000c17e:	e0 8a 00 0b 	brle	8000c194 <fatfs_lfn_create_sfn+0xa0>
                ext[i-(dotPos+1)] = filename[i];
8000c182:	ee 08 07 0a 	ld.ub	r10,r7[r8]
8000c186:	fa cb ff fc 	sub	r11,sp,-4
8000c18a:	f6 08 00 08 	add	r8,r11,r8
8000c18e:	12 18       	sub	r8,r9
8000c190:	f1 6a ff fb 	st.b	r8[-5],r10
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8000c194:	58 09       	cp.w	r9,0
8000c196:	e0 8a 00 2c 	brle	8000c1ee <fatfs_lfn_create_sfn+0xfa>
8000c19a:	12 95       	mov	r5,r9
8000c19c:	30 0a       	mov	r10,0
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8000c19e:	32 ee       	mov	lr,46
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8000c1a0:	14 99       	mov	r9,r10
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8000c1a2:	32 03       	mov	r3,32
8000c1a4:	14 96       	mov	r6,r10
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
8000c1a6:	31 92       	mov	r2,25
8000c1a8:	c0 98       	rjmp	8000c1ba <fatfs_lfn_create_sfn+0xc6>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
8000c1aa:	e8 0a 0b 0c 	st.b	r4[r10],r12
8000c1ae:	2f fa       	sub	r10,-1
            else
                sfn_output[pos++] = filename[i];
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
8000c1b0:	58 8a       	cp.w	r10,8
8000c1b2:	c1 e0       	breq	8000c1ee <fatfs_lfn_create_sfn+0xfa>
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8000c1b4:	2f f9       	sub	r9,-1
8000c1b6:	0a 39       	cp.w	r9,r5
8000c1b8:	c1 b4       	brge	8000c1ee <fatfs_lfn_create_sfn+0xfa>
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8000c1ba:	ee 09 07 08 	ld.ub	r8,r7[r9]
8000c1be:	fc 08 18 00 	cp.b	r8,lr
8000c1c2:	5f 1c       	srne	r12
8000c1c4:	e6 08 18 00 	cp.b	r8,r3
8000c1c8:	5f 1b       	srne	r11
8000c1ca:	f9 eb 00 0b 	and	r11,r12,r11
8000c1ce:	ec 0b 18 00 	cp.b	r11,r6
8000c1d2:	ce f0       	breq	8000c1b0 <fatfs_lfn_create_sfn+0xbc>
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
                sfn_output[pos++] = filename[i] - 'a' + 'A';
8000c1d4:	f0 cc 00 20 	sub	r12,r8,32
    pos = 0; 
    for (i=0;i<len;i++)
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
8000c1d8:	f0 cb 00 61 	sub	r11,r8,97
8000c1dc:	e4 0b 18 00 	cp.b	r11,r2
8000c1e0:	fe 98 ff e5 	brls	8000c1aa <fatfs_lfn_create_sfn+0xb6>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
            else
                sfn_output[pos++] = filename[i];
8000c1e4:	e8 0a 0b 08 	st.b	r4[r10],r8
8000c1e8:	2f fa       	sub	r10,-1
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
8000c1ea:	58 8a       	cp.w	r10,8
8000c1ec:	ce 41       	brne	8000c1b4 <fatfs_lfn_create_sfn+0xc0>
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8000c1ee:	1b 88       	ld.ub	r8,sp[0x0]
8000c1f0:	31 99       	mov	r9,25
8000c1f2:	f0 ca 00 61 	sub	r10,r8,97
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8000c1f6:	f2 0a 18 00 	cp.b	r10,r9
8000c1fa:	f7 b8 08 20 	subls	r8,32
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8000c1fe:	31 99       	mov	r9,25
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8000c200:	e9 68 00 08 	st.b	r4[8],r8
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8000c204:	1b 98       	ld.ub	r8,sp[0x1]
8000c206:	f0 ca 00 61 	sub	r10,r8,97
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8000c20a:	f2 0a 18 00 	cp.b	r10,r9
8000c20e:	f7 b8 08 20 	subls	r8,32
8000c212:	e9 68 00 09 	st.b	r4[9],r8
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8000c216:	31 99       	mov	r9,25
8000c218:	1b a8       	ld.ub	r8,sp[0x2]
8000c21a:	f0 ca 00 61 	sub	r10,r8,97
8000c21e:	f2 0a 18 00 	cp.b	r10,r9
8000c222:	e0 88 00 07 	brls	8000c230 <fatfs_lfn_create_sfn+0x13c>
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
8000c226:	e9 68 00 0a 	st.b	r4[10],r8
8000c22a:	2f fd       	sub	sp,-4
8000c22c:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8000c230:	22 08       	sub	r8,32
8000c232:	30 1c       	mov	r12,1
8000c234:	e9 68 00 0a 	st.b	r4[10],r8
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
    }

    return 1;
}
8000c238:	2f fd       	sub	sp,-4
8000c23a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    char ext[3];
    int pos;
    int len = (int)strlen(filename);

    // Invalid to start with .
    if (filename[0]=='.')
8000c23e:	2f fd       	sub	sp,-4
8000c240:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

8000c244 <fatfs_lfn_entries_required>:
8000c244:	d4 01       	pushm	lr
8000c246:	e0 a0 16 32 	rcall	8000eeaa <strlen>
8000c24a:	c0 e0       	breq	8000c266 <fatfs_lfn_entries_required+0x22>
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
        return (length + MAX_LFN_ENTRY_LENGTH - 1) / MAX_LFN_ENTRY_LENGTH;    
8000c24c:	f8 c8 ff f4 	sub	r8,r12,-12
8000c250:	e0 6b ec 4f 	mov	r11,60495
8000c254:	ea 1b 4e c4 	orh	r11,0x4ec4
8000c258:	f0 09 14 1f 	asr	r9,r8,0x1f
8000c25c:	f0 0b 04 4a 	muls.d	r10,r8,r11
8000c260:	f6 0c 14 02 	asr	r12,r11,0x2
8000c264:	12 1c       	sub	r12,r9
    else
        return 0;
}
8000c266:	d8 02       	popm	pc

8000c268 <fatfs_filename_to_lfn>:
8000c268:	eb cd 40 fe 	pushm	r1-r7,lr
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8000c26c:	20 dd       	sub	sp,52
8000c26e:	14 96       	mov	r6,r10
8000c270:	12 91       	mov	r1,r9
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8000c272:	fe f9 03 96 	ld.w	r9,pc[918]
8000c276:	72 ca       	ld.w	r10,r9[0x30]
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8000c278:	16 97       	mov	r7,r11
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8000c27a:	50 ca       	stdsp	sp[0x30],r10
8000c27c:	f2 ea 00 00 	ld.d	r10,r9[0]
8000c280:	fa eb 00 00 	st.d	sp[0],r10
8000c284:	f2 ea 00 08 	ld.d	r10,r9[8]
8000c288:	fa eb 00 08 	st.d	sp[8],r10
8000c28c:	f2 ea 00 10 	ld.d	r10,r9[16]
8000c290:	fa eb 00 10 	st.d	sp[16],r10
8000c294:	f2 ea 00 18 	ld.d	r10,r9[24]
8000c298:	fa eb 00 18 	st.d	sp[24],r10
8000c29c:	f2 ea 00 20 	ld.d	r10,r9[32]
8000c2a0:	fa eb 00 20 	st.d	sp[32],r10
8000c2a4:	f2 ea 00 28 	ld.d	r10,r9[40]
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8000c2a8:	18 93       	mov	r3,r12
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8000c2aa:	fa eb 00 28 	st.d	sp[40],r10

    // 13 characters entries
    int length = (int)strlen(filename);
8000c2ae:	e0 a0 15 fe 	rcall	8000eeaa <strlen>
8000c2b2:	18 95       	mov	r5,r12
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
8000c2b4:	e0 80 01 60 	breq	8000c574 <fatfs_filename_to_lfn+0x30c>
8000c2b8:	f8 c8 ff f4 	sub	r8,r12,-12
8000c2bc:	e0 6b ec 4f 	mov	r11,60495
8000c2c0:	ea 1b 4e c4 	orh	r11,0x4ec4
8000c2c4:	f0 09 14 1f 	asr	r9,r8,0x1f
8000c2c8:	f0 0b 04 4a 	muls.d	r10,r8,r11
8000c2cc:	f6 02 14 02 	asr	r2,r11,0x2
8000c2d0:	12 12       	sub	r2,r9
8000c2d2:	20 12       	sub	r2,1
    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
8000c2d4:	ec 06 00 14 	add	r4,r6,r6<<0x1

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
8000c2d8:	32 0a       	mov	r10,32
    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
8000c2da:	ec 04 00 24 	add	r4,r6,r4<<0x2

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
8000c2de:	30 0b       	mov	r11,0
8000c2e0:	0e 9c       	mov	r12,r7
8000c2e2:	e0 a0 15 15 	rcall	8000ed0c <memset>

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8000c2e6:	0c 32       	cp.w	r2,r6
8000c2e8:	e0 80 01 48 	breq	8000c578 <fatfs_filename_to_lfn+0x310>
8000c2ec:	2f f6       	sub	r6,-1
8000c2ee:	5c 56       	castu.b	r6

    // LFN flag
    buffer[11] = 0x0F;
8000c2f0:	30 f8       	mov	r8,15

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8000c2f2:	ae 86       	st.b	r7[0x0],r6

    // LFN flag
    buffer[11] = 0x0F;

    // Checksum of short filename
    buffer[13] = sfnChk;
8000c2f4:	ef 61 00 0d 	st.b	r7[13],r1

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));

    // LFN flag
    buffer[11] = 0x0F;
8000c2f8:	ef 68 00 0b 	st.b	r7[11],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c2fc:	08 35       	cp.w	r5,r4
8000c2fe:	e0 89 00 9e 	brgt	8000c43a <fatfs_filename_to_lfn+0x1d2>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c302:	e0 80 01 40 	breq	8000c582 <fatfs_filename_to_lfn+0x31a>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c306:	40 09       	lddsp	r9,sp[0x0]
8000c308:	3f f8       	mov	r8,-1
8000c30a:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c30e:	ee 09 00 09 	add	r9,r7,r9
8000c312:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c314:	e8 c8 ff ff 	sub	r8,r4,-1
8000c318:	10 35       	cp.w	r5,r8
8000c31a:	e0 8a 00 9a 	brle	8000c44e <fatfs_filename_to_lfn+0x1e6>
            buffer[nameIndexes[i]] = filename[start+i];
8000c31e:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c322:	40 18       	lddsp	r8,sp[0x4]
8000c324:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c328:	e8 c8 ff fe 	sub	r8,r4,-2
8000c32c:	10 35       	cp.w	r5,r8
8000c32e:	e0 89 00 9f 	brgt	8000c46c <fatfs_filename_to_lfn+0x204>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c332:	10 35       	cp.w	r5,r8
8000c334:	e0 80 01 65 	breq	8000c5fe <fatfs_filename_to_lfn+0x396>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c338:	40 29       	lddsp	r9,sp[0x8]
8000c33a:	3f f8       	mov	r8,-1
8000c33c:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c340:	ee 09 00 09 	add	r9,r7,r9
8000c344:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c346:	e8 c8 ff fd 	sub	r8,r4,-3
8000c34a:	10 35       	cp.w	r5,r8
8000c34c:	e0 8a 00 9a 	brle	8000c480 <fatfs_filename_to_lfn+0x218>
            buffer[nameIndexes[i]] = filename[start+i];
8000c350:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c354:	40 38       	lddsp	r8,sp[0xc]
8000c356:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c35a:	e8 c8 ff fc 	sub	r8,r4,-4
8000c35e:	10 35       	cp.w	r5,r8
8000c360:	e0 89 00 9f 	brgt	8000c49e <fatfs_filename_to_lfn+0x236>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c364:	10 35       	cp.w	r5,r8
8000c366:	e0 80 01 42 	breq	8000c5ea <fatfs_filename_to_lfn+0x382>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c36a:	40 49       	lddsp	r9,sp[0x10]
8000c36c:	3f f8       	mov	r8,-1
8000c36e:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c372:	ee 09 00 09 	add	r9,r7,r9
8000c376:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c378:	e8 c8 ff fb 	sub	r8,r4,-5
8000c37c:	10 35       	cp.w	r5,r8
8000c37e:	e0 8a 00 9a 	brle	8000c4b2 <fatfs_filename_to_lfn+0x24a>
            buffer[nameIndexes[i]] = filename[start+i];
8000c382:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c386:	40 58       	lddsp	r8,sp[0x14]
8000c388:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c38c:	e8 c8 ff fa 	sub	r8,r4,-6
8000c390:	10 35       	cp.w	r5,r8
8000c392:	e0 89 00 9e 	brgt	8000c4ce <fatfs_filename_to_lfn+0x266>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c396:	10 35       	cp.w	r5,r8
8000c398:	e0 80 01 09 	breq	8000c5aa <fatfs_filename_to_lfn+0x342>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c39c:	40 69       	lddsp	r9,sp[0x18]
8000c39e:	3f f8       	mov	r8,-1
8000c3a0:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c3a4:	ee 09 00 09 	add	r9,r7,r9
8000c3a8:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c3aa:	e8 c8 ff f9 	sub	r8,r4,-7
8000c3ae:	10 35       	cp.w	r5,r8
8000c3b0:	e0 8a 00 99 	brle	8000c4e2 <fatfs_filename_to_lfn+0x27a>
            buffer[nameIndexes[i]] = filename[start+i];
8000c3b4:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c3b8:	40 78       	lddsp	r8,sp[0x1c]
8000c3ba:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c3be:	e8 c8 ff f8 	sub	r8,r4,-8
8000c3c2:	10 35       	cp.w	r5,r8
8000c3c4:	e0 89 00 9d 	brgt	8000c4fe <fatfs_filename_to_lfn+0x296>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c3c8:	10 35       	cp.w	r5,r8
8000c3ca:	e0 80 00 e6 	breq	8000c596 <fatfs_filename_to_lfn+0x32e>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c3ce:	40 89       	lddsp	r9,sp[0x20]
8000c3d0:	3f f8       	mov	r8,-1
8000c3d2:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c3d6:	ee 09 00 09 	add	r9,r7,r9
8000c3da:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c3dc:	e8 c8 ff f7 	sub	r8,r4,-9
8000c3e0:	10 35       	cp.w	r5,r8
8000c3e2:	e0 8a 00 98 	brle	8000c512 <fatfs_filename_to_lfn+0x2aa>
            buffer[nameIndexes[i]] = filename[start+i];
8000c3e6:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c3ea:	40 98       	lddsp	r8,sp[0x24]
8000c3ec:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c3f0:	e8 c8 ff f6 	sub	r8,r4,-10
8000c3f4:	10 35       	cp.w	r5,r8
8000c3f6:	e0 89 00 9c 	brgt	8000c52e <fatfs_filename_to_lfn+0x2c6>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c3fa:	10 35       	cp.w	r5,r8
8000c3fc:	e0 80 00 ed 	breq	8000c5d6 <fatfs_filename_to_lfn+0x36e>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c400:	40 a9       	lddsp	r9,sp[0x28]
8000c402:	3f f8       	mov	r8,-1
8000c404:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c408:	ee 09 00 09 	add	r9,r7,r9
8000c40c:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c40e:	e8 c8 ff f5 	sub	r8,r4,-11
8000c412:	10 35       	cp.w	r5,r8
8000c414:	e0 8a 00 97 	brle	8000c542 <fatfs_filename_to_lfn+0x2da>
            buffer[nameIndexes[i]] = filename[start+i];
8000c418:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c41c:	40 b8       	lddsp	r8,sp[0x2c]
8000c41e:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c422:	2f 44       	sub	r4,-12
8000c424:	08 35       	cp.w	r5,r4
8000c426:	e0 8a 00 9b 	brle	8000c55c <fatfs_filename_to_lfn+0x2f4>
            buffer[nameIndexes[i]] = filename[start+i];
8000c42a:	e6 04 07 09 	ld.ub	r9,r3[r4]
8000c42e:	40 c8       	lddsp	r8,sp[0x30]
8000c430:	ee 08 0b 09 	st.b	r7[r8],r9
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
        }
    }
}
8000c434:	2f 3d       	sub	sp,-52
8000c436:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
8000c43a:	e6 04 07 09 	ld.ub	r9,r3[r4]
8000c43e:	40 08       	lddsp	r8,sp[0x0]
8000c440:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c444:	e8 c8 ff ff 	sub	r8,r4,-1
8000c448:	10 35       	cp.w	r5,r8
8000c44a:	fe 99 ff 6a 	brgt	8000c31e <fatfs_filename_to_lfn+0xb6>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c44e:	10 35       	cp.w	r5,r8
8000c450:	e0 80 00 d2 	breq	8000c5f4 <fatfs_filename_to_lfn+0x38c>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c454:	40 19       	lddsp	r9,sp[0x4]
8000c456:	3f f8       	mov	r8,-1
8000c458:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c45c:	ee 09 00 09 	add	r9,r7,r9
8000c460:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c462:	e8 c8 ff fe 	sub	r8,r4,-2
8000c466:	10 35       	cp.w	r5,r8
8000c468:	fe 9a ff 65 	brle	8000c332 <fatfs_filename_to_lfn+0xca>
            buffer[nameIndexes[i]] = filename[start+i];
8000c46c:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c470:	40 28       	lddsp	r8,sp[0x8]
8000c472:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c476:	e8 c8 ff fd 	sub	r8,r4,-3
8000c47a:	10 35       	cp.w	r5,r8
8000c47c:	fe 99 ff 6a 	brgt	8000c350 <fatfs_filename_to_lfn+0xe8>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c480:	10 35       	cp.w	r5,r8
8000c482:	e0 80 00 af 	breq	8000c5e0 <fatfs_filename_to_lfn+0x378>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c486:	40 39       	lddsp	r9,sp[0xc]
8000c488:	3f f8       	mov	r8,-1
8000c48a:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c48e:	ee 09 00 09 	add	r9,r7,r9
8000c492:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c494:	e8 c8 ff fc 	sub	r8,r4,-4
8000c498:	10 35       	cp.w	r5,r8
8000c49a:	fe 9a ff 65 	brle	8000c364 <fatfs_filename_to_lfn+0xfc>
            buffer[nameIndexes[i]] = filename[start+i];
8000c49e:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c4a2:	40 48       	lddsp	r8,sp[0x10]
8000c4a4:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c4a8:	e8 c8 ff fb 	sub	r8,r4,-5
8000c4ac:	10 35       	cp.w	r5,r8
8000c4ae:	fe 99 ff 6a 	brgt	8000c382 <fatfs_filename_to_lfn+0x11a>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c4b2:	10 35       	cp.w	r5,r8
8000c4b4:	c7 60       	breq	8000c5a0 <fatfs_filename_to_lfn+0x338>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c4b6:	40 59       	lddsp	r9,sp[0x14]
8000c4b8:	3f f8       	mov	r8,-1
8000c4ba:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c4be:	ee 09 00 09 	add	r9,r7,r9
8000c4c2:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c4c4:	e8 c8 ff fa 	sub	r8,r4,-6
8000c4c8:	10 35       	cp.w	r5,r8
8000c4ca:	fe 9a ff 66 	brle	8000c396 <fatfs_filename_to_lfn+0x12e>
            buffer[nameIndexes[i]] = filename[start+i];
8000c4ce:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c4d2:	40 68       	lddsp	r8,sp[0x18]
8000c4d4:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c4d8:	e8 c8 ff f9 	sub	r8,r4,-7
8000c4dc:	10 35       	cp.w	r5,r8
8000c4de:	fe 99 ff 6b 	brgt	8000c3b4 <fatfs_filename_to_lfn+0x14c>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c4e2:	10 35       	cp.w	r5,r8
8000c4e4:	c5 40       	breq	8000c58c <fatfs_filename_to_lfn+0x324>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c4e6:	40 79       	lddsp	r9,sp[0x1c]
8000c4e8:	3f f8       	mov	r8,-1
8000c4ea:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c4ee:	ee 09 00 09 	add	r9,r7,r9
8000c4f2:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c4f4:	e8 c8 ff f8 	sub	r8,r4,-8
8000c4f8:	10 35       	cp.w	r5,r8
8000c4fa:	fe 9a ff 67 	brle	8000c3c8 <fatfs_filename_to_lfn+0x160>
            buffer[nameIndexes[i]] = filename[start+i];
8000c4fe:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c502:	40 88       	lddsp	r8,sp[0x20]
8000c504:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c508:	e8 c8 ff f7 	sub	r8,r4,-9
8000c50c:	10 35       	cp.w	r5,r8
8000c50e:	fe 99 ff 6c 	brgt	8000c3e6 <fatfs_filename_to_lfn+0x17e>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c512:	10 35       	cp.w	r5,r8
8000c514:	c5 c0       	breq	8000c5cc <fatfs_filename_to_lfn+0x364>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c516:	40 99       	lddsp	r9,sp[0x24]
8000c518:	3f f8       	mov	r8,-1
8000c51a:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c51e:	ee 09 00 09 	add	r9,r7,r9
8000c522:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c524:	e8 c8 ff f6 	sub	r8,r4,-10
8000c528:	10 35       	cp.w	r5,r8
8000c52a:	fe 9a ff 68 	brle	8000c3fa <fatfs_filename_to_lfn+0x192>
            buffer[nameIndexes[i]] = filename[start+i];
8000c52e:	e6 08 07 09 	ld.ub	r9,r3[r8]
8000c532:	40 a8       	lddsp	r8,sp[0x28]
8000c534:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c538:	e8 c8 ff f5 	sub	r8,r4,-11
8000c53c:	10 35       	cp.w	r5,r8
8000c53e:	fe 99 ff 6d 	brgt	8000c418 <fatfs_filename_to_lfn+0x1b0>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c542:	10 35       	cp.w	r5,r8
8000c544:	c3 80       	breq	8000c5b4 <fatfs_filename_to_lfn+0x34c>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c546:	40 b9       	lddsp	r9,sp[0x2c]
8000c548:	3f f8       	mov	r8,-1
8000c54a:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c54e:	ee 09 00 09 	add	r9,r7,r9
8000c552:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8000c554:	2f 44       	sub	r4,-12
8000c556:	08 35       	cp.w	r5,r4
8000c558:	fe 99 ff 69 	brgt	8000c42a <fatfs_filename_to_lfn+0x1c2>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8000c55c:	08 35       	cp.w	r5,r4
8000c55e:	c3 00       	breq	8000c5be <fatfs_filename_to_lfn+0x356>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8000c560:	40 c9       	lddsp	r9,sp[0x30]
8000c562:	3f f8       	mov	r8,-1
8000c564:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8000c568:	ee 09 00 09 	add	r9,r7,r9
8000c56c:	b2 98       	st.b	r9[0x1],r8
        }
    }
}
8000c56e:	2f 3d       	sub	sp,-52
8000c570:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
8000c574:	3f f2       	mov	r2,-1
8000c576:	ca fa       	rjmp	8000c2d4 <fatfs_filename_to_lfn+0x6c>

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8000c578:	e4 c6 ff ff 	sub	r6,r2,-1
8000c57c:	a7 a6       	sbr	r6,0x6
8000c57e:	5c 56       	castu.b	r6
8000c580:	cb 8a       	rjmp	8000c2f0 <fatfs_filename_to_lfn+0x88>
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
8000c582:	30 09       	mov	r9,0
8000c584:	40 08       	lddsp	r8,sp[0x0]
8000c586:	ee 08 0b 09 	st.b	r7[r8],r9
8000c58a:	c5 db       	rjmp	8000c444 <fatfs_filename_to_lfn+0x1dc>
8000c58c:	30 09       	mov	r9,0
8000c58e:	40 78       	lddsp	r8,sp[0x1c]
8000c590:	ee 08 0b 09 	st.b	r7[r8],r9
8000c594:	c1 5b       	rjmp	8000c3be <fatfs_filename_to_lfn+0x156>
8000c596:	30 09       	mov	r9,0
8000c598:	40 88       	lddsp	r8,sp[0x20]
8000c59a:	ee 08 0b 09 	st.b	r7[r8],r9
8000c59e:	cb 5b       	rjmp	8000c508 <fatfs_filename_to_lfn+0x2a0>
8000c5a0:	30 09       	mov	r9,0
8000c5a2:	40 58       	lddsp	r8,sp[0x14]
8000c5a4:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5a8:	cf 2a       	rjmp	8000c38c <fatfs_filename_to_lfn+0x124>
8000c5aa:	30 09       	mov	r9,0
8000c5ac:	40 68       	lddsp	r8,sp[0x18]
8000c5ae:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5b2:	c9 3b       	rjmp	8000c4d8 <fatfs_filename_to_lfn+0x270>
8000c5b4:	30 09       	mov	r9,0
8000c5b6:	40 b8       	lddsp	r8,sp[0x2c]
8000c5b8:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5bc:	c3 3b       	rjmp	8000c422 <fatfs_filename_to_lfn+0x1ba>
8000c5be:	30 09       	mov	r9,0
8000c5c0:	40 c8       	lddsp	r8,sp[0x30]
8000c5c2:	ee 08 0b 09 	st.b	r7[r8],r9
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
        }
    }
}
8000c5c6:	2f 3d       	sub	sp,-52
8000c5c8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
8000c5cc:	30 09       	mov	r9,0
8000c5ce:	40 98       	lddsp	r8,sp[0x24]
8000c5d0:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5d4:	c0 eb       	rjmp	8000c3f0 <fatfs_filename_to_lfn+0x188>
8000c5d6:	30 09       	mov	r9,0
8000c5d8:	40 a8       	lddsp	r8,sp[0x28]
8000c5da:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5de:	ca db       	rjmp	8000c538 <fatfs_filename_to_lfn+0x2d0>
8000c5e0:	30 09       	mov	r9,0
8000c5e2:	40 38       	lddsp	r8,sp[0xc]
8000c5e4:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5e8:	cb 9a       	rjmp	8000c35a <fatfs_filename_to_lfn+0xf2>
8000c5ea:	30 09       	mov	r9,0
8000c5ec:	40 48       	lddsp	r8,sp[0x10]
8000c5ee:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5f2:	c5 bb       	rjmp	8000c4a8 <fatfs_filename_to_lfn+0x240>
8000c5f4:	30 09       	mov	r9,0
8000c5f6:	40 18       	lddsp	r8,sp[0x4]
8000c5f8:	ee 08 0b 09 	st.b	r7[r8],r9
8000c5fc:	c9 6a       	rjmp	8000c328 <fatfs_filename_to_lfn+0xc0>
8000c5fe:	30 09       	mov	r9,0
8000c600:	40 28       	lddsp	r8,sp[0x8]
8000c602:	ee 08 0b 09 	st.b	r7[r8],r9
8000c606:	c3 8b       	rjmp	8000c476 <fatfs_filename_to_lfn+0x20e>
8000c608:	80 01       	ld.sh	r1,r0[0x0]
8000c60a:	4f a4       	lddpc	r4,8000c7f0 <fatfs_compare_names+0x13c>

8000c60c <fatfs_total_path_levels>:
int fatfs_total_path_levels(char *path)
{
    int levels = 0;
    char expectedchar;

    if (!path)
8000c60c:	58 0c       	cp.w	r12,0
8000c60e:	c2 b0       	breq	8000c664 <fatfs_total_path_levels+0x58>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8000c610:	19 89       	ld.ub	r9,r12[0x0]
8000c612:	32 f8       	mov	r8,47
8000c614:	f0 09 18 00 	cp.b	r9,r8
8000c618:	c1 d0       	breq	8000c652 <fatfs_total_path_levels+0x46>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c61a:	19 99       	ld.ub	r9,r12[0x1]
8000c61c:	33 a8       	mov	r8,58
8000c61e:	f0 09 18 00 	cp.b	r9,r8
8000c622:	c1 c1       	brne	8000c65a <fatfs_total_path_levels+0x4e>
    {
        expectedchar = '\\';
        path += 3;
8000c624:	f8 c8 ff fd 	sub	r8,r12,-3
8000c628:	35 ca       	mov	r10,92
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8000c62a:	11 89       	ld.ub	r9,r8[0x0]
8000c62c:	58 09       	cp.w	r9,0
8000c62e:	c1 c0       	breq	8000c666 <fatfs_total_path_levels+0x5a>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8000c630:	30 0c       	mov	r12,0
8000c632:	c0 58       	rjmp	8000c63c <fatfs_total_path_levels+0x30>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
            path++;
8000c634:	2f f8       	sub	r8,-1

    // Count levels in path string
    while (*path)
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8000c636:	11 89       	ld.ub	r9,r8[0x0]
8000c638:	58 09       	cp.w	r9,0
8000c63a:	c0 b0       	breq	8000c650 <fatfs_total_path_levels+0x44>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8000c63c:	f2 0a 18 00 	cp.b	r10,r9
8000c640:	cf a1       	brne	8000c634 <fatfs_total_path_levels+0x28>
8000c642:	2f f8       	sub	r8,-1
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8000c644:	2f fc       	sub	r12,-1
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8000c646:	11 89       	ld.ub	r9,r8[0x0]
8000c648:	58 09       	cp.w	r9,0
8000c64a:	cf 91       	brne	8000c63c <fatfs_total_path_levels+0x30>
8000c64c:	20 1c       	sub	r12,1
8000c64e:	5e fc       	retal	r12
8000c650:	5e fc       	retal	r12
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8000c652:	f8 c8 ff ff 	sub	r8,r12,-1
8000c656:	32 fa       	mov	r10,47
8000c658:	ce 9b       	rjmp	8000c62a <fatfs_total_path_levels+0x1e>
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c65a:	19 a9       	ld.ub	r9,r12[0x2]
8000c65c:	35 c8       	mov	r8,92
8000c65e:	f0 09 18 00 	cp.b	r9,r8
8000c662:	ce 10       	breq	8000c624 <fatfs_total_path_levels+0x18>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8000c664:	5e fe       	retal	-1
8000c666:	5e fe       	retal	-1

8000c668 <fatfs_get_sfn_display_name>:
}
//-----------------------------------------------------------------------------
// fatfs_get_sfn_display_name: Get display name for SFN entry
//-----------------------------------------------------------------------------
int fatfs_get_sfn_display_name(char* out, char* in)
{
8000c668:	eb cd 40 e0 	pushm	r5-r7,lr
8000c66c:	30 09       	mov	r9,0
    int len = 0;
    while (*in && len <= 11)
    {
        char a = *in++;

        if (a == ' ')
8000c66e:	32 06       	mov	r6,32
// fatfs_get_sfn_display_name: Get display name for SFN entry
//-----------------------------------------------------------------------------
int fatfs_get_sfn_display_name(char* out, char* in)
{
    int len = 0;
    while (*in && len <= 11)
8000c670:	12 9e       	mov	lr,r9
        char a = *in++;

        if (a == ' ')
            continue;
        // Make lower case if uppercase
        else if ((a>='A') && (a<='Z'))
8000c672:	31 95       	mov	r5,25
// fatfs_get_sfn_display_name: Get display name for SFN entry
//-----------------------------------------------------------------------------
int fatfs_get_sfn_display_name(char* out, char* in)
{
    int len = 0;
    while (*in && len <= 11)
8000c674:	58 b9       	cp.w	r9,11
8000c676:	5f a7       	srle	r7
8000c678:	17 88       	ld.ub	r8,r11[0x0]
    {
        char a = *in++;
8000c67a:	2f fb       	sub	r11,-1
// fatfs_get_sfn_display_name: Get display name for SFN entry
//-----------------------------------------------------------------------------
int fatfs_get_sfn_display_name(char* out, char* in)
{
    int len = 0;
    while (*in && len <= 11)
8000c67c:	fc 08 18 00 	cp.b	r8,lr
8000c680:	5f 1a       	srne	r10
8000c682:	ef ea 00 0a 	and	r10,r7,r10
8000c686:	14 97       	mov	r7,r10
8000c688:	fc 0a 18 00 	cp.b	r10,lr
8000c68c:	c1 10       	breq	8000c6ae <fatfs_get_sfn_display_name+0x46>
    {
        char a = *in++;

        if (a == ' ')
8000c68e:	ec 08 18 00 	cp.b	r8,r6
8000c692:	cf 10       	breq	8000c674 <fatfs_get_sfn_display_name+0xc>
        // Make lower case if uppercase
        else if ((a>='A') && (a<='Z'))
            a+= 32;

        *out++ = a;
        len++;
8000c694:	2f f9       	sub	r9,-1

        if (a == ' ')
            continue;
        // Make lower case if uppercase
        else if ((a>='A') && (a<='Z'))
            a+= 32;
8000c696:	f0 c7 ff e0 	sub	r7,r8,-32
        char a = *in++;

        if (a == ' ')
            continue;
        // Make lower case if uppercase
        else if ((a>='A') && (a<='Z'))
8000c69a:	f0 ca 00 41 	sub	r10,r8,65
8000c69e:	ea 0a 18 00 	cp.b	r10,r5
8000c6a2:	e0 8b 00 04 	brhi	8000c6aa <fatfs_get_sfn_display_name+0x42>
            a+= 32;
8000c6a6:	f1 d7 c0 08 	bfextu	r8,r7,0x0,0x8

        *out++ = a;
8000c6aa:	18 c8       	st.b	r12++,r8
8000c6ac:	ce 4b       	rjmp	8000c674 <fatfs_get_sfn_display_name+0xc>
        len++;
    }

    *out = '\0';
8000c6ae:	b8 8a       	st.b	r12[0x0],r10
    return 1;
}
8000c6b0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1

8000c6b4 <fatfs_compare_names>:
//-----------------------------------------------------------------------------
// fatfs_compare_names: Compare two filenames (without copying or changing origonals)
// Returns 1 if match, 0 if not
//-----------------------------------------------------------------------------
int fatfs_compare_names(char* strA, char* strB)
{
8000c6b4:	d4 31       	pushm	r0-r7,lr
8000c6b6:	20 4d       	sub	sp,16
8000c6b8:	18 97       	mov	r7,r12
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8000c6ba:	19 84       	ld.ub	r4,r12[0x0]
8000c6bc:	58 04       	cp.w	r4,0
8000c6be:	e0 80 00 e9 	breq	8000c890 <fatfs_compare_names+0x1dc>
8000c6c2:	18 99       	mov	r9,r12
8000c6c4:	08 9a       	mov	r10,r4
8000c6c6:	30 08       	mov	r8,0
8000c6c8:	3f f6       	mov	r6,-1
    {
        if (*strSrc=='.')
8000c6ca:	32 ec       	mov	r12,46
8000c6cc:	f4 0c 18 00 	cp.b	r12,r10
8000c6d0:	f0 06 17 00 	moveq	r6,r8
            dotPos = (int)(strSrc-str);

        strSrc++;
8000c6d4:	2f f9       	sub	r9,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8000c6d6:	2f f8       	sub	r8,-1
8000c6d8:	13 8a       	ld.ub	r10,r9[0x0]
8000c6da:	58 0a       	cp.w	r10,0
8000c6dc:	cf 81       	brne	8000c6cc <fatfs_compare_names+0x18>
8000c6de:	17 83       	ld.ub	r3,r11[0x0]
8000c6e0:	58 03       	cp.w	r3,0
8000c6e2:	e0 80 00 d9 	breq	8000c894 <fatfs_compare_names+0x1e0>
8000c6e6:	06 98       	mov	r8,r3
8000c6e8:	16 9a       	mov	r10,r11
8000c6ea:	30 09       	mov	r9,0
8000c6ec:	3f f5       	mov	r5,-1
    {
        if (*strSrc=='.')
8000c6ee:	32 ec       	mov	r12,46
8000c6f0:	f0 0c 18 00 	cp.b	r12,r8
8000c6f4:	f2 05 17 00 	moveq	r5,r9
            dotPos = (int)(strSrc-str);

        strSrc++;
8000c6f8:	2f fa       	sub	r10,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8000c6fa:	2f f9       	sub	r9,-1
8000c6fc:	15 88       	ld.ub	r8,r10[0x0]
8000c6fe:	58 08       	cp.w	r8,0
8000c700:	cf 81       	brne	8000c6f0 <fatfs_compare_names+0x3c>
    ext2Pos = FileString_GetExtension(strB);

    // NOTE: Extension position can be different for matching 
    // filename if trailing space are present before it!
    // Check that if one has an extension, so does the other
    if ((ext1Pos==-1) && (ext2Pos!=-1))
8000c702:	5b f5       	cp.w	r5,-1
8000c704:	5f 1a       	srne	r10
8000c706:	5b f6       	cp.w	r6,-1
8000c708:	5f 09       	sreq	r9
8000c70a:	f5 e9 00 09 	and	r9,r10,r9
8000c70e:	f0 09 18 00 	cp.b	r9,r8
8000c712:	c1 e1       	brne	8000c74e <fatfs_compare_names+0x9a>
8000c714:	5b f5       	cp.w	r5,-1
8000c716:	5f 09       	sreq	r9
        return 0;
    if ((ext2Pos==-1) && (ext1Pos!=-1))
8000c718:	5b f6       	cp.w	r6,-1
8000c71a:	5f 18       	srne	r8
8000c71c:	10 69       	and	r9,r8
8000c71e:	c1 81       	brne	8000c74e <fatfs_compare_names+0x9a>
        return 0;

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
8000c720:	58 08       	cp.w	r8,0
8000c722:	c4 c0       	breq	8000c7ba <fatfs_compare_names+0x106>
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
8000c724:	ea c8 ff ff 	sub	r8,r5,-1

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
8000c728:	50 0b       	stdsp	sp[0x0],r11
    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
8000c72a:	f6 08 00 00 	add	r0,r11,r8

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
8000c72e:	ec c1 ff ff 	sub	r1,r6,-1
8000c732:	50 26       	stdsp	sp[0x8],r6
8000c734:	ee 01 00 01 	add	r1,r7,r1
        ext2 = strB+ext2Pos+1;
8000c738:	50 15       	stdsp	sp[0x4],r5

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
8000c73a:	02 9c       	mov	r12,r1
8000c73c:	e0 a0 13 b7 	rcall	8000eeaa <strlen>
8000c740:	18 92       	mov	r2,r12
8000c742:	00 9c       	mov	r12,r0
8000c744:	e0 a0 13 b3 	rcall	8000eeaa <strlen>
8000c748:	40 0b       	lddsp	r11,sp[0x0]
8000c74a:	18 32       	cp.w	r2,r12
8000c74c:	c0 40       	breq	8000c754 <fatfs_compare_names+0xa0>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c74e:	30 0c       	mov	r12,0
    // Compare main part of filenames
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
        return 0;
    else
        return 1;
}
8000c750:	2f cd       	sub	sp,-16
8000c752:	d8 32       	popm	r0-r7,pc
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c754:	58 02       	cp.w	r2,0
8000c756:	e0 80 00 a3 	breq	8000c89c <fatfs_compare_names+0x1e8>
8000c75a:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8000c75c:	31 9c       	mov	r12,25
8000c75e:	50 34       	stdsp	sp[0xc],r4
8000c760:	c1 68       	rjmp	8000c78c <fatfs_compare_names+0xd8>
8000c762:	12 94       	mov	r4,r9
            a+= 32;
        if ((b>='A') && (b<='Z'))
8000c764:	f4 ce 00 41 	sub	lr,r10,65
8000c768:	f8 0e 18 00 	cp.b	lr,r12
8000c76c:	e0 88 00 23 	brls	8000c7b2 <fatfs_compare_names+0xfe>
8000c770:	14 9e       	mov	lr,r10
            b+= 32;

        diff = a - b;
8000c772:	e8 0e 01 0e 	sub	lr,r4,lr

        // If different
        if (diff)
8000c776:	ce c1       	brne	8000c74e <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
8000c778:	58 09       	cp.w	r9,0
8000c77a:	e0 80 00 90 	breq	8000c89a <fatfs_compare_names+0x1e6>
8000c77e:	58 0a       	cp.w	r10,0
8000c780:	e0 80 00 8d 	breq	8000c89a <fatfs_compare_names+0x1e6>
8000c784:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c786:	10 32       	cp.w	r2,r8
8000c788:	e0 80 00 89 	breq	8000c89a <fatfs_compare_names+0x1e6>
    {
        a = *s1;
8000c78c:	e2 08 07 09 	ld.ub	r9,r1[r8]
        b = *s2;
8000c790:	e0 08 07 0a 	ld.ub	r10,r0[r8]

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8000c794:	f2 ce 00 41 	sub	lr,r9,65
8000c798:	f8 0e 18 00 	cp.b	lr,r12
8000c79c:	fe 9b ff e3 	brhi	8000c762 <fatfs_compare_names+0xae>
            a+= 32;
8000c7a0:	f2 c4 ff e0 	sub	r4,r9,-32
        if ((b>='A') && (b<='Z'))
8000c7a4:	f4 ce 00 41 	sub	lr,r10,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
8000c7a8:	5c 54       	castu.b	r4
        if ((b>='A') && (b<='Z'))
8000c7aa:	f8 0e 18 00 	cp.b	lr,r12
8000c7ae:	fe 9b ff e1 	brhi	8000c770 <fatfs_compare_names+0xbc>
            b+= 32;
8000c7b2:	f4 ce ff e0 	sub	lr,r10,-32
8000c7b6:	5c 5e       	castu.b	lr
8000c7b8:	cd db       	rjmp	8000c772 <fatfs_compare_names+0xbe>
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
8000c7ba:	50 0b       	stdsp	sp[0x0],r11
8000c7bc:	0e 9c       	mov	r12,r7
8000c7be:	e0 a0 13 76 	rcall	8000eeaa <strlen>
        file2Len = (int)strlen(strB);
8000c7c2:	40 0b       	lddsp	r11,sp[0x0]
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
8000c7c4:	18 96       	mov	r6,r12
        file2Len = (int)strlen(strB);
8000c7c6:	16 9c       	mov	r12,r11
8000c7c8:	50 26       	stdsp	sp[0x8],r6
8000c7ca:	e0 a0 13 70 	rcall	8000eeaa <strlen>
8000c7ce:	40 0b       	lddsp	r11,sp[0x0]
8000c7d0:	50 1c       	stdsp	sp[0x4],r12
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8000c7d2:	58 06       	cp.w	r6,0
8000c7d4:	c1 60       	breq	8000c800 <fatfs_compare_names+0x14c>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8000c7d6:	40 29       	lddsp	r9,sp[0x8]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c7d8:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8000c7da:	20 19       	sub	r9,1
8000c7dc:	ee 09 00 09 	add	r9,r7,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c7e0:	13 85       	ld.ub	r5,r9[0x0]
8000c7e2:	f0 05 18 00 	cp.b	r5,r8
8000c7e6:	c0 d1       	brne	8000c800 <fatfs_compare_names+0x14c>
8000c7e8:	f2 07 01 08 	sub	r8,r9,r7
8000c7ec:	c0 68       	rjmp	8000c7f8 <fatfs_compare_names+0x144>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
8000c7ee:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c7f0:	13 7a       	ld.ub	r10,--r9
8000c7f2:	ea 0a 18 00 	cp.b	r10,r5
8000c7f6:	c0 41       	brne	8000c7fe <fatfs_compare_names+0x14a>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
8000c7f8:	20 16       	sub	r6,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c7fa:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8000c7fc:	cf 91       	brne	8000c7ee <fatfs_compare_names+0x13a>
8000c7fe:	1c 96       	mov	r6,lr
8000c800:	58 0c       	cp.w	r12,0
8000c802:	c1 60       	breq	8000c82e <fatfs_compare_names+0x17a>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8000c804:	40 19       	lddsp	r9,sp[0x4]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c806:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8000c808:	20 19       	sub	r9,1
8000c80a:	f6 09 00 09 	add	r9,r11,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c80e:	13 85       	ld.ub	r5,r9[0x0]
8000c810:	f0 05 18 00 	cp.b	r5,r8
8000c814:	c0 d1       	brne	8000c82e <fatfs_compare_names+0x17a>
8000c816:	f2 0b 01 08 	sub	r8,r9,r11
8000c81a:	c0 68       	rjmp	8000c826 <fatfs_compare_names+0x172>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
8000c81c:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c81e:	13 7a       	ld.ub	r10,--r9
8000c820:	ea 0a 18 00 	cp.b	r10,r5
8000c824:	c0 41       	brne	8000c82c <fatfs_compare_names+0x178>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
8000c826:	20 1c       	sub	r12,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000c828:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8000c82a:	cf 91       	brne	8000c81c <fatfs_compare_names+0x168>
8000c82c:	1c 9c       	mov	r12,lr
    // Find length without trailing spaces (before ext)
    file1Len = FileString_TrimLength(strA, file1Len);
    file2Len = FileString_TrimLength(strB, file2Len);

    // Check the file lengths match
    if (file1Len!=file2Len)
8000c82e:	18 36       	cp.w	r6,r12
8000c830:	c8 f1       	brne	8000c74e <fatfs_compare_names+0x9a>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c832:	58 06       	cp.w	r6,0
8000c834:	c3 60       	breq	8000c8a0 <fatfs_compare_names+0x1ec>
8000c836:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8000c838:	31 99       	mov	r9,25
8000c83a:	c1 88       	rjmp	8000c86a <fatfs_compare_names+0x1b6>
8000c83c:	08 9c       	mov	r12,r4
            a+= 32;
        if ((b>='A') && (b<='Z'))
8000c83e:	e6 ca 00 41 	sub	r10,r3,65
8000c842:	f2 0a 18 00 	cp.b	r10,r9
8000c846:	e0 88 00 21 	brls	8000c888 <fatfs_compare_names+0x1d4>
8000c84a:	06 9a       	mov	r10,r3
            b+= 32;

        diff = a - b;

        // If different
        if (diff)
8000c84c:	f4 0c 18 00 	cp.b	r12,r10
8000c850:	fe 91 ff 7f 	brne	8000c74e <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
8000c854:	58 04       	cp.w	r4,0
8000c856:	c2 50       	breq	8000c8a0 <fatfs_compare_names+0x1ec>
8000c858:	58 03       	cp.w	r3,0
8000c85a:	c2 30       	breq	8000c8a0 <fatfs_compare_names+0x1ec>
8000c85c:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c85e:	10 36       	cp.w	r6,r8
8000c860:	c2 00       	breq	8000c8a0 <fatfs_compare_names+0x1ec>
8000c862:	ee 08 07 04 	ld.ub	r4,r7[r8]
8000c866:	f6 08 07 03 	ld.ub	r3,r11[r8]
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8000c86a:	08 9a       	mov	r10,r4
8000c86c:	24 1a       	sub	r10,65
8000c86e:	f2 0a 18 00 	cp.b	r10,r9
8000c872:	fe 9b ff e5 	brhi	8000c83c <fatfs_compare_names+0x188>
            a+= 32;
8000c876:	08 9c       	mov	r12,r4
        if ((b>='A') && (b<='Z'))
8000c878:	e6 ca 00 41 	sub	r10,r3,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
8000c87c:	2e 0c       	sub	r12,-32
8000c87e:	5c 5c       	castu.b	r12
        if ((b>='A') && (b<='Z'))
8000c880:	f2 0a 18 00 	cp.b	r10,r9
8000c884:	fe 9b ff e3 	brhi	8000c84a <fatfs_compare_names+0x196>
            b+= 32;
8000c888:	e6 ca ff e0 	sub	r10,r3,-32
8000c88c:	5c 5a       	castu.b	r10
8000c88e:	cd fb       	rjmp	8000c84c <fatfs_compare_names+0x198>
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8000c890:	3f f6       	mov	r6,-1
8000c892:	c2 6b       	rjmp	8000c6de <fatfs_compare_names+0x2a>
8000c894:	30 19       	mov	r9,1
8000c896:	3f f5       	mov	r5,-1
8000c898:	c4 0b       	rjmp	8000c718 <fatfs_compare_names+0x64>
8000c89a:	40 34       	lddsp	r4,sp[0xc]
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
        file2Len = (int)strlen(strB);
8000c89c:	0a 9c       	mov	r12,r5
8000c89e:	c9 ab       	rjmp	8000c7d2 <fatfs_compare_names+0x11e>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000c8a0:	30 1c       	mov	r12,1
8000c8a2:	c5 7b       	rjmp	8000c750 <fatfs_compare_names+0x9c>

8000c8a4 <fatfs_get_substring>:
8000c8a4:	eb cd 40 f8 	pushm	r3-r7,lr
// (or file) at the specified level.
// E.g. C:\folder\file.zip : Level 0 = C:\folder, Level 1 = file.zip
// Returns: -1 = Error, 0 = Ok
//-----------------------------------------------------------------------------
int fatfs_get_substring(char *path, int levelreq, char *output, int max_len)
{
8000c8a8:	20 3d       	sub	sp,12
    int pathlen=0;
    int levels=0;
    int copypnt=0;
    char expectedchar;

    if (!path || max_len <= 0)
8000c8aa:	58 0c       	cp.w	r12,0
8000c8ac:	5f 08       	sreq	r8
8000c8ae:	58 09       	cp.w	r9,0
8000c8b0:	5f a7       	srle	r7
8000c8b2:	ef e8 10 08 	or	r8,r7,r8
8000c8b6:	c4 61       	brne	8000c942 <fatfs_get_substring+0x9e>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8000c8b8:	19 8e       	ld.ub	lr,r12[0x0]
8000c8ba:	32 f8       	mov	r8,47
8000c8bc:	f0 0e 18 00 	cp.b	lr,r8
8000c8c0:	c4 40       	breq	8000c948 <fatfs_get_substring+0xa4>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c8c2:	19 9e       	ld.ub	lr,r12[0x1]
8000c8c4:	33 a8       	mov	r8,58
8000c8c6:	f0 0e 18 00 	cp.b	lr,r8
8000c8ca:	c3 71       	brne	8000c938 <fatfs_get_substring+0x94>
    {
        expectedchar = '\\';
        path += 3;
8000c8cc:	f8 c6 ff fd 	sub	r6,r12,-3
8000c8d0:	35 c7       	mov	r7,92
    }
    else
        return -1;

    // Get string length of path
    pathlen = (int)strlen (path);
8000c8d2:	50 2b       	stdsp	sp[0x8],r11
8000c8d4:	50 1a       	stdsp	sp[0x4],r10
8000c8d6:	50 09       	stdsp	sp[0x0],r9
8000c8d8:	0c 9c       	mov	r12,r6
8000c8da:	e0 a0 12 e8 	rcall	8000eeaa <strlen>

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8000c8de:	40 2b       	lddsp	r11,sp[0x8]
8000c8e0:	40 1a       	lddsp	r10,sp[0x4]
8000c8e2:	40 09       	lddsp	r9,sp[0x0]
8000c8e4:	e0 8a 00 36 	brle	8000c950 <fatfs_get_substring+0xac>
8000c8e8:	30 04       	mov	r4,0
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
8000c8ea:	20 19       	sub	r9,1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8000c8ec:	08 95       	mov	r5,r4
8000c8ee:	08 98       	mov	r8,r4
8000c8f0:	c0 48       	rjmp	8000c8f8 <fatfs_get_substring+0x54>
8000c8f2:	2f f8       	sub	r8,-1
8000c8f4:	10 3c       	cp.w	r12,r8
8000c8f6:	c1 70       	breq	8000c924 <fatfs_get_substring+0x80>
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;
8000c8f8:	ec 08 07 0e 	ld.ub	lr,r6[r8]
8000c8fc:	0e 93       	mov	r3,r7
8000c8fe:	ee 0e 18 00 	cp.b	lr,r7
8000c902:	f7 b5 00 ff 	subeq	r5,-1

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
8000c906:	16 35       	cp.w	r5,r11
8000c908:	cf 51       	brne	8000c8f2 <fatfs_get_substring+0x4e>
8000c90a:	0e 93       	mov	r3,r7
8000c90c:	fc 07 18 00 	cp.b	r7,lr
8000c910:	cf 10       	breq	8000c8f2 <fatfs_get_substring+0x4e>
8000c912:	08 39       	cp.w	r9,r4
8000c914:	fe 9a ff ef 	brle	8000c8f2 <fatfs_get_substring+0x4e>
            output[copypnt++] = *path;
8000c918:	f4 04 0b 0e 	st.b	r10[r4],lr

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8000c91c:	2f f8       	sub	r8,-1
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
            output[copypnt++] = *path;
8000c91e:	2f f4       	sub	r4,-1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8000c920:	10 3c       	cp.w	r12,r8
8000c922:	ce b1       	brne	8000c8f8 <fatfs_get_substring+0x54>
        // Increment through path string
        path++;
    }

    // Null Terminate
    output[copypnt] = '\0';
8000c924:	30 08       	mov	r8,0
8000c926:	f4 04 0b 08 	st.b	r10[r4],r8

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
8000c92a:	15 89       	ld.ub	r9,r10[0x0]
8000c92c:	f0 09 18 00 	cp.b	r9,r8
8000c930:	c0 90       	breq	8000c942 <fatfs_get_substring+0x9e>
8000c932:	2f dd       	sub	sp,-12
8000c934:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c938:	19 ae       	ld.ub	lr,r12[0x2]
8000c93a:	35 c8       	mov	r8,92
8000c93c:	f0 0e 18 00 	cp.b	lr,r8
8000c940:	cc 60       	breq	8000c8cc <fatfs_get_substring+0x28>

    // Null Terminate
    output[copypnt] = '\0';

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
8000c942:	2f dd       	sub	sp,-12
8000c944:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8000c948:	f8 c6 ff ff 	sub	r6,r12,-1
8000c94c:	32 f7       	mov	r7,47
8000c94e:	cc 2b       	rjmp	8000c8d2 <fatfs_get_substring+0x2e>

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8000c950:	30 04       	mov	r4,0
8000c952:	ce 9b       	rjmp	8000c924 <fatfs_get_substring+0x80>

8000c954 <fatfs_split_path>:
8000c954:	eb cd 40 fc 	pushm	r2-r7,lr
// Returned is the path string and file Name string
// E.g. C:\folder\file.zip -> path = C:\folder  filename = file.zip
// E.g. C:\file.zip -> path = [blank]  filename = file.zip
//-----------------------------------------------------------------------------
int fatfs_split_path(char *full_path, char *path, int max_path, char *filename, int max_filename)
{
8000c958:	18 97       	mov	r7,r12
8000c95a:	16 95       	mov	r5,r11
8000c95c:	14 93       	mov	r3,r10
8000c95e:	12 96       	mov	r6,r9
int fatfs_total_path_levels(char *path)
{
    int levels = 0;
    char expectedchar;

    if (!path)
8000c960:	58 0c       	cp.w	r12,0
8000c962:	c4 60       	breq	8000c9ee <fatfs_split_path+0x9a>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8000c964:	19 8b       	ld.ub	r11,r12[0x0]
8000c966:	32 fa       	mov	r10,47
8000c968:	f4 0b 18 00 	cp.b	r11,r10
8000c96c:	c4 30       	breq	8000c9f2 <fatfs_split_path+0x9e>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c96e:	19 9a       	ld.ub	r10,r12[0x1]
8000c970:	33 a9       	mov	r9,58
8000c972:	f2 0a 18 00 	cp.b	r10,r9
8000c976:	c3 71       	brne	8000c9e4 <fatfs_split_path+0x90>
    {
        expectedchar = '\\';
        path += 3;
8000c978:	ee ca ff fd 	sub	r10,r7,-3
8000c97c:	35 cc       	mov	r12,92
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8000c97e:	15 8b       	ld.ub	r11,r10[0x0]
8000c980:	58 0b       	cp.w	r11,0
8000c982:	c3 60       	breq	8000c9ee <fatfs_split_path+0x9a>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8000c984:	30 04       	mov	r4,0
8000c986:	c0 58       	rjmp	8000c990 <fatfs_split_path+0x3c>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
            path++;
8000c988:	2f fa       	sub	r10,-1

    // Count levels in path string
    while (*path)
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8000c98a:	15 8b       	ld.ub	r11,r10[0x0]
8000c98c:	58 0b       	cp.w	r11,0
8000c98e:	c0 a0       	breq	8000c9a2 <fatfs_split_path+0x4e>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8000c990:	f8 0b 18 00 	cp.b	r11,r12
8000c994:	cf a1       	brne	8000c988 <fatfs_split_path+0x34>
8000c996:	2f fa       	sub	r10,-1
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8000c998:	2f f4       	sub	r4,-1
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8000c99a:	15 8b       	ld.ub	r11,r10[0x0]
8000c99c:	58 0b       	cp.w	r11,0
8000c99e:	cf 91       	brne	8000c990 <fatfs_split_path+0x3c>
8000c9a0:	c0 28       	rjmp	8000c9a4 <fatfs_split_path+0x50>
            if (*path == expectedchar) { path++; break; }
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8000c9a2:	2f f4       	sub	r4,-1
    }
    
    // Subtract the file itself
    return levels-1;
8000c9a4:	20 14       	sub	r4,1
    int levels = fatfs_total_path_levels(full_path);
    if (levels == -1)
        return -1;

    // Get filename part of string
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
8000c9a6:	10 99       	mov	r9,r8
8000c9a8:	0c 9a       	mov	r10,r6
8000c9aa:	08 9b       	mov	r11,r4
8000c9ac:	0e 9c       	mov	r12,r7
8000c9ae:	c7 bf       	rcall	8000c8a4 <fatfs_get_substring>
8000c9b0:	18 92       	mov	r2,r12
8000c9b2:	c1 e1       	brne	8000c9ee <fatfs_split_path+0x9a>
8000c9b4:	58 04       	cp.w	r4,0
        return -1;

    // If root file
    if (levels == 0)
8000c9b6:	c2 20       	breq	8000c9fa <fatfs_split_path+0xa6>
8000c9b8:	0e 9c       	mov	r12,r7
        path[0] = '\0';
    else
    {
        strindex = (int)strlen(full_path) - (int)strlen(filename);
8000c9ba:	e0 a0 12 78 	rcall	8000eeaa <strlen>
8000c9be:	18 94       	mov	r4,r12
8000c9c0:	0c 9c       	mov	r12,r6
8000c9c2:	e0 a0 12 74 	rcall	8000eeaa <strlen>
8000c9c6:	e8 0c 01 0c 	sub	r12,r4,r12
8000c9ca:	0e 9b       	mov	r11,r7
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
8000c9cc:	f8 03 0d 43 	min	r3,r12,r3
8000c9d0:	0a 9c       	mov	r12,r5
8000c9d2:	06 9a       	mov	r10,r3
8000c9d4:	e0 a0 10 f8 	rcall	8000ebc4 <memcpy>
8000c9d8:	06 05       	add	r5,r3
        path[strindex-1] = '\0';
8000c9da:	04 9c       	mov	r12,r2
8000c9dc:	eb 62 ff ff 	st.b	r5[-1],r2
8000c9e0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000c9e4:	19 aa       	ld.ub	r10,r12[0x2]
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000c9e6:	35 c9       	mov	r9,92
8000c9e8:	f2 0a 18 00 	cp.b	r10,r9
8000c9ec:	cc 60       	breq	8000c978 <fatfs_split_path+0x24>
8000c9ee:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
        strindex = (int)strlen(full_path) - (int)strlen(filename);
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
        path[strindex-1] = '\0';
8000c9f2:	f8 ca ff ff 	sub	r10,r12,-1
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8000c9f6:	32 fc       	mov	r12,47
8000c9f8:	cc 3b       	rjmp	8000c97e <fatfs_split_path+0x2a>
8000c9fa:	aa 84       	st.b	r5[0x0],r4
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
        return -1;

    // If root file
    if (levels == 0)
        path[0] = '\0';
8000c9fc:	08 9c       	mov	r12,r4
8000c9fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000ca02:	d7 03       	nop

8000ca04 <fatfs_fat_writeback>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
8000ca04:	eb cd 40 80 	pushm	r7,lr
8000ca08:	16 97       	mov	r7,r11
    if (pcur)
8000ca0a:	58 0b       	cp.w	r11,0
8000ca0c:	c1 e0       	breq	8000ca48 <fatfs_fat_writeback+0x44>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
8000ca0e:	f6 f8 02 04 	ld.w	r8,r11[516]
8000ca12:	58 08       	cp.w	r8,0
8000ca14:	c1 80       	breq	8000ca44 <fatfs_fat_writeback+0x40>
        {
            if (fs->disk_io.write_media)
8000ca16:	78 e8       	ld.w	r8,r12[0x38]
8000ca18:	58 08       	cp.w	r8,0
8000ca1a:	c1 20       	breq	8000ca3e <fatfs_fat_writeback+0x3a>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000ca1c:	78 8b       	ld.w	r11,r12[0x20]
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8000ca1e:	ee f9 02 00 	ld.w	r9,r7[512]
8000ca22:	78 5a       	ld.w	r10,r12[0x14]
8000ca24:	f2 0a 01 0a 	sub	r10,r9,r10

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000ca28:	f4 cc ff ff 	sub	r12,r10,-1
8000ca2c:	16 3c       	cp.w	r12,r11
8000ca2e:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8000ca32:	f7 da eb 1a 	subhi	r10,r11,r10

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8000ca36:	12 9c       	mov	r12,r9
8000ca38:	0e 9b       	mov	r11,r7
8000ca3a:	5d 18       	icall	r8
8000ca3c:	c0 60       	breq	8000ca48 <fatfs_fat_writeback+0x44>
                    return 0;
            }
                
            pcur->dirty = 0;
8000ca3e:	30 08       	mov	r8,0
8000ca40:	ef 48 02 04 	st.w	r7[516],r8
8000ca44:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000ca48:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

8000ca4c <fatfs_set_fs_info_next_free_cluster>:
} 
//-----------------------------------------------------------------------------
// fatfs_set_fs_info_next_free_cluster: Write the next free cluster to the FSINFO table
//-----------------------------------------------------------------------------
void fatfs_set_fs_info_next_free_cluster(struct fatfs *fs, uint32 newValue)
{
8000ca4c:	d4 21       	pushm	r4-r7,lr
8000ca4e:	18 96       	mov	r6,r12
8000ca50:	16 95       	mov	r5,r11
    if (fs->fat_type == FAT_TYPE_16)
8000ca52:	78 c8       	ld.w	r8,r12[0x30]
8000ca54:	58 08       	cp.w	r8,0
8000ca56:	c0 21       	brne	8000ca5a <fatfs_set_fs_info_next_free_cluster+0xe>
8000ca58:	d8 22       	popm	r4-r7,pc
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
8000ca5a:	f9 14 00 18 	ld.uh	r4,r12[24]
8000ca5e:	78 78       	ld.w	r8,r12[0x1c]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000ca60:	f8 f7 02 54 	ld.w	r7,r12[596]
    if (fs->fat_type == FAT_TYPE_16)
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
8000ca64:	10 04       	add	r4,r8
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000ca66:	58 07       	cp.w	r7,0
8000ca68:	c6 00       	breq	8000cb28 <fatfs_set_fs_info_next_free_cluster+0xdc>
8000ca6a:	30 09       	mov	r9,0
8000ca6c:	c0 38       	rjmp	8000ca72 <fatfs_set_fs_info_next_free_cluster+0x26>
8000ca6e:	0e 99       	mov	r9,r7
8000ca70:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000ca72:	ee f8 02 00 	ld.w	r8,r7[512]
8000ca76:	10 34       	cp.w	r4,r8
8000ca78:	c0 53       	brcs	8000ca82 <fatfs_set_fs_info_next_free_cluster+0x36>
8000ca7a:	f0 ca ff ff 	sub	r10,r8,-1
8000ca7e:	14 34       	cp.w	r4,r10
8000ca80:	c4 93       	brcs	8000cb12 <fatfs_set_fs_info_next_free_cluster+0xc6>
            break;

        // End of list?
        if (pcur->next == NULL)
8000ca82:	ee f8 02 0c 	ld.w	r8,r7[524]
8000ca86:	58 08       	cp.w	r8,0
8000ca88:	cf 31       	brne	8000ca6e <fatfs_set_fs_info_next_free_cluster+0x22>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000ca8a:	58 09       	cp.w	r9,0
8000ca8c:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000ca90:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000ca94:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000ca98:	58 08       	cp.w	r8,0
8000ca9a:	ce a1       	brne	8000ca6e <fatfs_set_fs_info_next_free_cluster+0x22>
8000ca9c:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000caa0:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000caa4:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000caa8:	ee f8 02 04 	ld.w	r8,r7[516]
8000caac:	58 08       	cp.w	r8,0
8000caae:	c3 f1       	brne	8000cb2c <fatfs_set_fs_info_next_free_cluster+0xe0>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000cab0:	ef 44 02 00 	st.w	r7[512],r4

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000cab4:	08 9c       	mov	r12,r4
8000cab6:	6c d8       	ld.w	r8,r6[0x34]
8000cab8:	0e 94       	mov	r4,r7
8000caba:	30 1a       	mov	r10,1
8000cabc:	0e 9b       	mov	r11,r7
8000cabe:	5d 18       	icall	r8
8000cac0:	c3 00       	breq	8000cb20 <fatfs_set_fs_info_next_free_cluster+0xd4>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000cac2:	ef 47 02 08 	st.w	r7[520],r7
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
        if (!pbuf)
            return ;

        // Change 
        FAT32_SET_32BIT_WORD(pbuf, 492, newValue);
8000cac6:	e9 65 01 ec 	st.b	r4[492],r5
8000caca:	ea 09 16 08 	lsr	r9,r5,0x8
8000cace:	ee f8 02 08 	ld.w	r8,r7[520]
8000cad2:	f1 69 01 ed 	st.b	r8[493],r9
8000cad6:	ea 09 16 10 	lsr	r9,r5,0x10
8000cada:	ee f8 02 08 	ld.w	r8,r7[520]
8000cade:	f1 69 01 ee 	st.b	r8[494],r9
8000cae2:	ea 09 16 18 	lsr	r9,r5,0x18
8000cae6:	ee f8 02 08 	ld.w	r8,r7[520]
8000caea:	f1 69 01 ef 	st.b	r8[495],r9
8000caee:	30 1a       	mov	r10,1
8000caf0:	ef 4a 02 04 	st.w	r7[516],r10
        fs->next_free_cluster = newValue;
8000caf4:	8d 95       	st.w	r6[0x24],r5

        // Write back FSINFO sector to disk
        if (fs->disk_io.write_media)
8000caf6:	6c e8       	ld.w	r8,r6[0x38]
8000caf8:	58 08       	cp.w	r8,0
8000cafa:	c0 50       	breq	8000cb04 <fatfs_set_fs_info_next_free_cluster+0xb8>
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);    
8000cafc:	0e 9b       	mov	r11,r7
8000cafe:	ee fc 02 00 	ld.w	r12,r7[512]
8000cb02:	5d 18       	icall	r8

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
8000cb04:	3f f8       	mov	r8,-1
8000cb06:	ef 48 02 00 	st.w	r7[512],r8
        pbuf->dirty = 0;
8000cb0a:	30 08       	mov	r8,0
8000cb0c:	ef 48 02 04 	st.w	r7[516],r8
8000cb10:	d8 22       	popm	r4-r7,pc
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000cb12:	10 14       	sub	r4,r8
8000cb14:	a9 74       	lsl	r4,0x9
8000cb16:	ee 04 00 04 	add	r4,r7,r4
8000cb1a:	ef 44 02 08 	st.w	r7[520],r4
8000cb1e:	cd 4b       	rjmp	8000cac6 <fatfs_set_fs_info_next_free_cluster+0x7a>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000cb20:	3f f8       	mov	r8,-1
8000cb22:	ef 48 02 00 	st.w	r7[512],r8
8000cb26:	d8 22       	popm	r4-r7,pc
        if (fs->disk_io.write_media)
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);    

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
        pbuf->dirty = 0;
8000cb28:	0e 98       	mov	r8,r7
8000cb2a:	cb bb       	rjmp	8000caa0 <fatfs_set_fs_info_next_free_cluster+0x54>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8000cb2c:	0e 9b       	mov	r11,r7
8000cb2e:	0c 9c       	mov	r12,r6
8000cb30:	c6 af       	rcall	8000ca04 <fatfs_fat_writeback>
8000cb32:	cb f1       	brne	8000cab0 <fatfs_set_fs_info_next_free_cluster+0x64>
8000cb34:	c9 2b       	rjmp	8000ca58 <fatfs_set_fs_info_next_free_cluster+0xc>
8000cb36:	d7 03       	nop

8000cb38 <fatfs_fat_init>:
8000cb38:	eb cd 40 e0 	pushm	r5-r7,lr
    fs->fat_buffer_head = NULL;

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
8000cb3c:	3f f8       	mov	r8,-1

//-----------------------------------------------------------------------------
// fatfs_fat_init:
//-----------------------------------------------------------------------------
void fatfs_fat_init(struct fatfs *fs)
{
8000cb3e:	18 97       	mov	r7,r12
    int i;

    // FAT buffer chain head
    fs->fat_buffer_head = NULL;
8000cb40:	30 06       	mov	r6,0

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
8000cb42:	f9 48 04 58 	st.w	r12[1112],r8
void fatfs_fat_init(struct fatfs *fs)
{
    int i;

    // FAT buffer chain head
    fs->fat_buffer_head = NULL;
8000cb46:	f9 46 02 54 	st.w	r12[596],r6

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
8000cb4a:	f9 46 04 5c 	st.w	r12[1116],r6
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
8000cb4e:	f8 c5 fd a8 	sub	r5,r12,-600
8000cb52:	e0 6a 02 00 	mov	r10,512
8000cb56:	0c 9b       	mov	r11,r6
8000cb58:	0a 9c       	mov	r12,r5
8000cb5a:	e0 a0 10 d9 	rcall	8000ed0c <memset>
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
8000cb5e:	ee f8 02 54 	ld.w	r8,r7[596]
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;
8000cb62:	ef 46 04 60 	st.w	r7[1120],r6

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
        fs->fat_buffer_head = &fs->fat_buffers[i];
8000cb66:	ef 45 02 54 	st.w	r7[596],r5
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
8000cb6a:	ef 48 04 64 	st.w	r7[1124],r8
        fs->fat_buffer_head = &fs->fat_buffers[i];
    }
}
8000cb6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000cb72:	d7 03       	nop

8000cb74 <fatfs_fat_purge>:
8000cb74:	eb cd 40 e0 	pushm	r5-r7,lr
}
//-----------------------------------------------------------------------------
// fatfs_fat_purge: Purge 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
int fatfs_fat_purge(struct fatfs *fs)
{
8000cb78:	18 96       	mov	r6,r12
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000cb7a:	f8 f7 02 54 	ld.w	r7,r12[596]

    // Itterate through sector buffer list
    while (pcur)
8000cb7e:	58 07       	cp.w	r7,0
8000cb80:	c2 30       	breq	8000cbc6 <fatfs_fat_purge+0x52>

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
                    return 0;
            }
                
            pcur->dirty = 0;
8000cb82:	30 05       	mov	r5,0
8000cb84:	c0 58       	rjmp	8000cb8e <fatfs_fat_purge+0x1a>
        // Writeback sector if changed
        if (pcur->dirty) 
            if (!fatfs_fat_writeback(fs, pcur))
                return 0;
        
        pcur = pcur->next;
8000cb86:	ee f7 02 0c 	ld.w	r7,r7[524]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cb8a:	58 07       	cp.w	r7,0
8000cb8c:	c1 d0       	breq	8000cbc6 <fatfs_fat_purge+0x52>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
8000cb8e:	ee f8 02 04 	ld.w	r8,r7[516]
8000cb92:	58 08       	cp.w	r8,0
8000cb94:	cf 90       	breq	8000cb86 <fatfs_fat_purge+0x12>
    if (pcur)
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8000cb96:	6c e8       	ld.w	r8,r6[0x38]
8000cb98:	58 08       	cp.w	r8,0
8000cb9a:	c1 00       	breq	8000cbba <fatfs_fat_purge+0x46>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000cb9c:	6c 89       	ld.w	r9,r6[0x20]
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8000cb9e:	ee fc 02 00 	ld.w	r12,r7[512]
8000cba2:	6c 5b       	ld.w	r11,r6[0x14]
8000cba4:	f8 0b 01 0b 	sub	r11,r12,r11

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8000cba8:	f2 0b 01 0a 	sub	r10,r9,r11
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000cbac:	2f fb       	sub	r11,-1
8000cbae:	12 3b       	cp.w	r11,r9
8000cbb0:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8000cbb4:	0e 9b       	mov	r11,r7
8000cbb6:	5d 18       	icall	r8
8000cbb8:	c0 80       	breq	8000cbc8 <fatfs_fat_purge+0x54>
                    return 0;
            }
                
            pcur->dirty = 0;
8000cbba:	ef 45 02 04 	st.w	r7[516],r5
        // Writeback sector if changed
        if (pcur->dirty) 
            if (!fatfs_fat_writeback(fs, pcur))
                return 0;
        
        pcur = pcur->next;
8000cbbe:	ee f7 02 0c 	ld.w	r7,r7[524]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cbc2:	58 07       	cp.w	r7,0
8000cbc4:	ce 51       	brne	8000cb8e <fatfs_fat_purge+0x1a>
8000cbc6:	30 1c       	mov	r12,1
        
        pcur = pcur->next;
    }

    return 1;
}
8000cbc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cbcc <fatfs_find_next_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_next_cluster: Return cluster number of next cluster in chain by 
// reading FAT table and traversing it. Return 0xffffffff for end of chain.
//-----------------------------------------------------------------------------
uint32 fatfs_find_next_cluster(struct fatfs *fs, uint32 current_cluster)
{
8000cbcc:	eb cd 40 f8 	pushm	r3-r7,lr
8000cbd0:	18 96       	mov	r6,r12
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8000cbd2:	58 0b       	cp.w	r11,0
8000cbd4:	f6 03 17 10 	movne	r3,r11
8000cbd8:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000cbdc:	78 c8       	ld.w	r8,r12[0x30]
8000cbde:	58 08       	cp.w	r8,0
8000cbe0:	c5 a1       	brne	8000cc94 <fatfs_find_next_cluster+0xc8>
        fat_sector_offset = current_cluster / 256;
8000cbe2:	e6 04 16 08 	lsr	r4,r3,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cbe6:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000cbe8:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cbec:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cbf0:	58 07       	cp.w	r7,0
8000cbf2:	c7 80       	breq	8000cce2 <fatfs_find_next_cluster+0x116>
8000cbf4:	30 09       	mov	r9,0
8000cbf6:	c0 38       	rjmp	8000cbfc <fatfs_find_next_cluster+0x30>
8000cbf8:	0e 99       	mov	r9,r7
8000cbfa:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000cbfc:	ee f8 02 00 	ld.w	r8,r7[512]
8000cc00:	10 35       	cp.w	r5,r8
8000cc02:	c0 53       	brcs	8000cc0c <fatfs_find_next_cluster+0x40>
8000cc04:	f0 ca ff ff 	sub	r10,r8,-1
8000cc08:	14 35       	cp.w	r5,r10
8000cc0a:	c4 83       	brcs	8000cc9a <fatfs_find_next_cluster+0xce>
            break;

        // End of list?
        if (pcur->next == NULL)
8000cc0c:	ee f8 02 0c 	ld.w	r8,r7[524]
8000cc10:	58 08       	cp.w	r8,0
8000cc12:	cf 31       	brne	8000cbf8 <fatfs_find_next_cluster+0x2c>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000cc14:	58 09       	cp.w	r9,0
8000cc16:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000cc1a:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000cc1e:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cc22:	58 08       	cp.w	r8,0
8000cc24:	ce a1       	brne	8000cbf8 <fatfs_find_next_cluster+0x2c>
8000cc26:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000cc2a:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000cc2e:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000cc32:	ee f8 02 04 	ld.w	r8,r7[516]
8000cc36:	58 08       	cp.w	r8,0
8000cc38:	c5 71       	brne	8000cce6 <fatfs_find_next_cluster+0x11a>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000cc3a:	ef 45 02 00 	st.w	r7[512],r5

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000cc3e:	0a 9c       	mov	r12,r5
8000cc40:	6c d8       	ld.w	r8,r6[0x34]
8000cc42:	0e 95       	mov	r5,r7
8000cc44:	30 1a       	mov	r10,1
8000cc46:	0e 9b       	mov	r11,r7
8000cc48:	5d 18       	icall	r8
8000cc4a:	c4 70       	breq	8000ccd8 <fatfs_find_next_cluster+0x10c>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000cc4c:	eb 47 02 08 	st.w	r5[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8000cc50:	6c c8       	ld.w	r8,r6[0x30]
8000cc52:	58 08       	cp.w	r8,0
8000cc54:	c2 c0       	breq	8000ccac <fatfs_find_next_cluster+0xe0>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8000cc56:	e8 08 15 07 	lsl	r8,r4,0x7
8000cc5a:	e6 08 01 08 	sub	r8,r3,r8
8000cc5e:	a3 68       	lsl	r8,0x2
8000cc60:	5c 78       	castu.h	r8
8000cc62:	ea 08 07 09 	ld.ub	r9,r5[r8]
8000cc66:	10 05       	add	r5,r8
8000cc68:	0b 98       	ld.ub	r8,r5[0x1]
8000cc6a:	a9 68       	lsl	r8,0x8
8000cc6c:	0b bc       	ld.ub	r12,r5[0x3]
8000cc6e:	0b aa       	ld.ub	r10,r5[0x2]
8000cc70:	b9 6c       	lsl	r12,0x18
8000cc72:	b1 6a       	lsl	r10,0x10
8000cc74:	14 0c       	add	r12,r10
8000cc76:	12 0c       	add	r12,r9
8000cc78:	10 0c       	add	r12,r8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000cc7a:	30 88       	mov	r8,8
8000cc7c:	ea 18 f0 00 	orh	r8,0xf000

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8000cc80:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000cc84:	f8 08 00 08 	add	r8,r12,r8
8000cc88:	58 78       	cp.w	r8,7
8000cc8a:	e0 8b 00 25 	brhi	8000ccd4 <fatfs_find_next_cluster+0x108>
8000cc8e:	3f fc       	mov	r12,-1
            return (FAT32_LAST_CLUSTER); 
    }

    // Else return next cluster
    return (nextcluster);                         
} 
8000cc90:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8000cc94:	e6 04 16 07 	lsr	r4,r3,0x7
8000cc98:	ca 7b       	rjmp	8000cbe6 <fatfs_find_next_cluster+0x1a>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000cc9a:	10 15       	sub	r5,r8
8000cc9c:	a9 75       	lsl	r5,0x9
8000cc9e:	ee 05 00 05 	add	r5,r7,r5
8000cca2:	ef 45 02 08 	st.w	r7[520],r5
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8000cca6:	6c c8       	ld.w	r8,r6[0x30]
8000cca8:	58 08       	cp.w	r8,0
8000ccaa:	cd 61       	brne	8000cc56 <fatfs_find_next_cluster+0x8a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8000ccac:	e8 08 15 08 	lsl	r8,r4,0x8
8000ccb0:	e6 08 01 08 	sub	r8,r3,r8
8000ccb4:	a1 78       	lsl	r8,0x1
8000ccb6:	5c 78       	castu.h	r8
8000ccb8:	ea 08 07 09 	ld.ub	r9,r5[r8]
8000ccbc:	ea 08 00 08 	add	r8,r5,r8
8000ccc0:	11 9c       	ld.ub	r12,r8[0x1]
8000ccc2:	a9 6c       	lsl	r12,0x8
8000ccc4:	12 0c       	add	r12,r9

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8000ccc6:	fe 79 00 08 	mov	r9,-65528
8000ccca:	f8 09 00 08 	add	r8,r12,r9
8000ccce:	58 78       	cp.w	r8,7
8000ccd0:	fe 98 ff df 	brls	8000cc8e <fatfs_find_next_cluster+0xc2>
            return (FAT32_LAST_CLUSTER); 
    }

    // Else return next cluster
    return (nextcluster);                         
} 
8000ccd4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000ccd8:	3f fc       	mov	r12,-1
8000ccda:	ef 4c 02 00 	st.w	r7[512],r12
8000ccde:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000cce2:	0e 98       	mov	r8,r7
8000cce4:	ca 3b       	rjmp	8000cc2a <fatfs_find_next_cluster+0x5e>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8000cce6:	0e 9b       	mov	r11,r7
8000cce8:	0c 9c       	mov	r12,r6
8000ccea:	c8 de       	rcall	8000ca04 <fatfs_fat_writeback>
8000ccec:	ca 71       	brne	8000cc3a <fatfs_find_next_cluster+0x6e>
8000ccee:	3f fc       	mov	r12,-1

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000ccf0:	cd 0b       	rjmp	8000cc90 <fatfs_find_next_cluster+0xc4>
8000ccf2:	d7 03       	nop

8000ccf4 <fatfs_fat_set_cluster>:
8000ccf4:	eb cd 40 fc 	pushm	r2-r7,lr
// fatfs_fat_set_cluster: Set a cluster link in the chain. NOTE: Immediate
// write (slow).
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_set_cluster(struct fatfs *fs, uint32 cluster, uint32 next_cluster)
{
8000ccf8:	18 96       	mov	r6,r12
8000ccfa:	16 93       	mov	r3,r11
8000ccfc:	14 95       	mov	r5,r10
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000ccfe:	78 c8       	ld.w	r8,r12[0x30]
8000cd00:	58 08       	cp.w	r8,0
8000cd02:	c4 f1       	brne	8000cda0 <fatfs_fat_set_cluster+0xac>
        fat_sector_offset = cluster / 256;
8000cd04:	f6 04 16 08 	lsr	r4,r11,0x8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cd08:	6c 52       	ld.w	r2,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000cd0a:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cd0e:	e8 02 00 02 	add	r2,r4,r2
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cd12:	58 07       	cp.w	r7,0
8000cd14:	c7 70       	breq	8000ce02 <fatfs_fat_set_cluster+0x10e>
8000cd16:	30 09       	mov	r9,0
8000cd18:	c0 38       	rjmp	8000cd1e <fatfs_fat_set_cluster+0x2a>
8000cd1a:	0e 99       	mov	r9,r7
8000cd1c:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000cd1e:	ee f8 02 00 	ld.w	r8,r7[512]
8000cd22:	10 32       	cp.w	r2,r8
8000cd24:	c0 53       	brcs	8000cd2e <fatfs_fat_set_cluster+0x3a>
8000cd26:	f0 ca ff ff 	sub	r10,r8,-1
8000cd2a:	14 32       	cp.w	r2,r10
8000cd2c:	c3 d3       	brcs	8000cda6 <fatfs_fat_set_cluster+0xb2>
            break;

        // End of list?
        if (pcur->next == NULL)
8000cd2e:	ee f8 02 0c 	ld.w	r8,r7[524]
8000cd32:	58 08       	cp.w	r8,0
8000cd34:	cf 31       	brne	8000cd1a <fatfs_fat_set_cluster+0x26>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000cd36:	58 09       	cp.w	r9,0
8000cd38:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000cd3c:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000cd40:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cd44:	58 08       	cp.w	r8,0
8000cd46:	ce a1       	brne	8000cd1a <fatfs_fat_set_cluster+0x26>
8000cd48:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000cd4c:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000cd50:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000cd54:	ee f8 02 04 	ld.w	r8,r7[516]
8000cd58:	58 08       	cp.w	r8,0
8000cd5a:	c5 61       	brne	8000ce06 <fatfs_fat_set_cluster+0x112>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000cd5c:	ef 42 02 00 	st.w	r7[512],r2

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000cd60:	04 9c       	mov	r12,r2
8000cd62:	6c d8       	ld.w	r8,r6[0x34]
8000cd64:	30 1a       	mov	r10,1
8000cd66:	0e 9b       	mov	r11,r7
8000cd68:	5d 18       	icall	r8
8000cd6a:	0e 99       	mov	r9,r7
8000cd6c:	c4 60       	breq	8000cdf8 <fatfs_fat_set_cluster+0x104>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000cd6e:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8000cd72:	6c c8       	ld.w	r8,r6[0x30]
8000cd74:	58 08       	cp.w	r8,0
8000cd76:	c2 21       	brne	8000cdba <fatfs_fat_set_cluster+0xc6>
    {
        // Find 16 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 256)) * 2; 

        // Write Next Clusters value to Sector Buffer
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));     
8000cd78:	e8 08 15 08 	lsl	r8,r4,0x8
8000cd7c:	e6 08 01 08 	sub	r8,r3,r8
8000cd80:	a1 78       	lsl	r8,0x1
8000cd82:	5c 78       	castu.h	r8
8000cd84:	f2 08 0b 05 	st.b	r9[r8],r5
8000cd88:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
8000cd8c:	ee f9 02 08 	ld.w	r9,r7[520]
8000cd90:	f2 08 00 08 	add	r8,r9,r8
8000cd94:	b0 95       	st.b	r8[0x1],r5
8000cd96:	30 1c       	mov	r12,1
8000cd98:	ef 4c 02 04 	st.w	r7[516],r12
8000cd9c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;
8000cda0:	f6 04 16 07 	lsr	r4,r11,0x7
8000cda4:	cb 2b       	rjmp	8000cd08 <fatfs_fat_set_cluster+0x14>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000cda6:	e4 08 01 09 	sub	r9,r2,r8
8000cdaa:	a9 79       	lsl	r9,0x9
8000cdac:	ee 09 00 09 	add	r9,r7,r9
8000cdb0:	ef 49 02 08 	st.w	r7[520],r9
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8000cdb4:	6c c8       	ld.w	r8,r6[0x30]
8000cdb6:	58 08       	cp.w	r8,0
8000cdb8:	ce 00       	breq	8000cd78 <fatfs_fat_set_cluster+0x84>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8000cdba:	ea 0a 16 08 	lsr	r10,r5,0x8
8000cdbe:	e8 08 15 07 	lsl	r8,r4,0x7
8000cdc2:	e6 08 01 08 	sub	r8,r3,r8
8000cdc6:	a3 68       	lsl	r8,0x2
8000cdc8:	5c 78       	castu.h	r8
8000cdca:	f2 08 0b 05 	st.b	r9[r8],r5
8000cdce:	ee f9 02 08 	ld.w	r9,r7[520]
8000cdd2:	10 09       	add	r9,r8
8000cdd4:	b2 9a       	st.b	r9[0x1],r10
8000cdd6:	ea 0a 16 10 	lsr	r10,r5,0x10
8000cdda:	ee f9 02 08 	ld.w	r9,r7[520]
8000cdde:	10 09       	add	r9,r8
8000cde0:	b2 aa       	st.b	r9[0x2],r10
8000cde2:	b9 85       	lsr	r5,0x18
8000cde4:	ee f9 02 08 	ld.w	r9,r7[520]
8000cde8:	f2 08 00 08 	add	r8,r9,r8
8000cdec:	b0 b5       	st.b	r8[0x3],r5
8000cdee:	30 1c       	mov	r12,1
8000cdf0:	ef 4c 02 04 	st.w	r7[516],r12
    }

    return 1;                     
} 
8000cdf4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000cdf8:	3f f8       	mov	r8,-1
8000cdfa:	ef 48 02 00 	st.w	r7[512],r8
8000cdfe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8000ce02:	0e 98       	mov	r8,r7
8000ce04:	ca 4b       	rjmp	8000cd4c <fatfs_fat_set_cluster+0x58>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8000ce06:	0e 9b       	mov	r11,r7
8000ce08:	0c 9c       	mov	r12,r6
8000ce0a:	fe b0 fd fd 	rcall	8000ca04 <fatfs_fat_writeback>
8000ce0e:	ca 71       	brne	8000cd5c <fatfs_fat_set_cluster+0x68>
8000ce10:	cf 2b       	rjmp	8000cdf4 <fatfs_fat_set_cluster+0x100>
8000ce12:	d7 03       	nop

8000ce14 <fatfs_fat_add_cluster_to_chain>:
8000ce14:	d4 31       	pushm	r0-r7,lr
8000ce16:	18 96       	mov	r6,r12
// fatfs_fat_add_cluster_to_chain: Follow a chain marking and then add a new entry
// to the current tail.
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_add_cluster_to_chain(struct fatfs *fs, uint32 start_cluster, uint32 newEntry)
{
8000ce18:	14 90       	mov	r0,r10
    uint32 last_cluster = FAT32_LAST_CLUSTER;
    uint32 next_cluster = start_cluster;

    if (start_cluster == FAT32_LAST_CLUSTER)
8000ce1a:	5b fb       	cp.w	r11,-1
8000ce1c:	e0 80 00 a5 	breq	8000cf66 <fatfs_fat_add_cluster_to_chain+0x152>
8000ce20:	16 92       	mov	r2,r11
8000ce22:	78 c8       	ld.w	r8,r12[0x30]

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000ce24:	30 81       	mov	r1,8
8000ce26:	ea 11 f0 00 	orh	r1,0xf000
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8000ce2a:	58 02       	cp.w	r2,0
8000ce2c:	e4 03 17 10 	movne	r3,r2
8000ce30:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000ce34:	58 08       	cp.w	r8,0
8000ce36:	c5 c1       	brne	8000ceee <fatfs_fat_add_cluster_to_chain+0xda>
        fat_sector_offset = current_cluster / 256;
8000ce38:	e6 04 16 08 	lsr	r4,r3,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000ce3c:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000ce3e:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000ce42:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000ce46:	58 07       	cp.w	r7,0
8000ce48:	c5 c0       	breq	8000cf00 <fatfs_fat_add_cluster_to_chain+0xec>
8000ce4a:	30 09       	mov	r9,0
8000ce4c:	c0 38       	rjmp	8000ce52 <fatfs_fat_add_cluster_to_chain+0x3e>
8000ce4e:	0e 99       	mov	r9,r7
8000ce50:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000ce52:	ee f8 02 00 	ld.w	r8,r7[512]
8000ce56:	10 35       	cp.w	r5,r8
8000ce58:	c0 63       	brcs	8000ce64 <fatfs_fat_add_cluster_to_chain+0x50>
8000ce5a:	f0 ca ff ff 	sub	r10,r8,-1
8000ce5e:	14 35       	cp.w	r5,r10
8000ce60:	e0 83 00 84 	brlo	8000cf68 <fatfs_fat_add_cluster_to_chain+0x154>
            break;

        // End of list?
        if (pcur->next == NULL)
8000ce64:	ee f8 02 0c 	ld.w	r8,r7[524]
8000ce68:	58 08       	cp.w	r8,0
8000ce6a:	cf 21       	brne	8000ce4e <fatfs_fat_add_cluster_to_chain+0x3a>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000ce6c:	58 09       	cp.w	r9,0
8000ce6e:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000ce72:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000ce76:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000ce7a:	58 08       	cp.w	r8,0
8000ce7c:	ce 91       	brne	8000ce4e <fatfs_fat_add_cluster_to_chain+0x3a>
8000ce7e:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000ce82:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000ce86:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000ce8a:	ee f8 02 04 	ld.w	r8,r7[516]
8000ce8e:	58 08       	cp.w	r8,0
8000ce90:	c4 11       	brne	8000cf12 <fatfs_fat_add_cluster_to_chain+0xfe>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000ce92:	ef 45 02 00 	st.w	r7[512],r5

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000ce96:	0a 9c       	mov	r12,r5
8000ce98:	6c d8       	ld.w	r8,r6[0x34]
8000ce9a:	0e 95       	mov	r5,r7
8000ce9c:	30 1a       	mov	r10,1
8000ce9e:	0e 9b       	mov	r11,r7
8000cea0:	5d 18       	icall	r8
8000cea2:	c6 a0       	breq	8000cf76 <fatfs_fat_add_cluster_to_chain+0x162>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000cea4:	ef 47 02 08 	st.w	r7[520],r7
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
8000cea8:	58 07       	cp.w	r7,0
8000ceaa:	c3 90       	breq	8000cf1c <fatfs_fat_add_cluster_to_chain+0x108>
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8000ceac:	6c c8       	ld.w	r8,r6[0x30]
8000ceae:	58 08       	cp.w	r8,0
8000ceb0:	c3 f1       	brne	8000cf2e <fatfs_fat_add_cluster_to_chain+0x11a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8000ceb2:	e8 0a 15 08 	lsl	r10,r4,0x8
8000ceb6:	e6 0a 01 0a 	sub	r10,r3,r10
8000ceba:	a1 7a       	lsl	r10,0x1
8000cebc:	5c 7a       	castu.h	r10
8000cebe:	ea 0a 07 0b 	ld.ub	r11,r5[r10]
8000cec2:	ea 0a 00 0a 	add	r10,r5,r10
8000cec6:	15 99       	ld.ub	r9,r10[0x1]
8000cec8:	a9 69       	lsl	r9,0x8
8000ceca:	16 09       	add	r9,r11

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8000cecc:	fe 7b 00 08 	mov	r11,-65528
8000ced0:	f2 0b 00 0a 	add	r10,r9,r11
8000ced4:	58 7a       	cp.w	r10,7
8000ced6:	e0 88 00 23 	brls	8000cf1c <fatfs_fat_add_cluster_to_chain+0x108>
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
        if (!next_cluster)
8000ceda:	58 09       	cp.w	r9,0
8000cedc:	c4 50       	breq	8000cf66 <fatfs_fat_add_cluster_to_chain+0x152>

    if (start_cluster == FAT32_LAST_CLUSTER)
        return 0;
    
    // Loop until end of chain
    while ( next_cluster != FAT32_LAST_CLUSTER )
8000cede:	12 92       	mov	r2,r9
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8000cee0:	58 02       	cp.w	r2,0
8000cee2:	e4 03 17 10 	movne	r3,r2
8000cee6:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000ceea:	58 08       	cp.w	r8,0
8000ceec:	ca 60       	breq	8000ce38 <fatfs_fat_add_cluster_to_chain+0x24>
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8000ceee:	e6 04 16 07 	lsr	r4,r3,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cef2:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000cef4:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cef8:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cefc:	58 07       	cp.w	r7,0
8000cefe:	ca 61       	brne	8000ce4a <fatfs_fat_add_cluster_to_chain+0x36>
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);

    return 1;
8000cf00:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000cf02:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000cf06:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000cf0a:	ee f8 02 04 	ld.w	r8,r7[516]
8000cf0e:	58 08       	cp.w	r8,0
8000cf10:	cc 10       	breq	8000ce92 <fatfs_fat_add_cluster_to_chain+0x7e>
        if (!fatfs_fat_writeback(fs, pcur))
8000cf12:	0e 9b       	mov	r11,r7
8000cf14:	0c 9c       	mov	r12,r6
8000cf16:	fe b0 fd 77 	rcall	8000ca04 <fatfs_fat_writeback>
8000cf1a:	cb c1       	brne	8000ce92 <fatfs_fat_add_cluster_to_chain+0x7e>
        if (!next_cluster)
            return 0;
    }

    // Add link in for new cluster
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);
8000cf1c:	04 9b       	mov	r11,r2
8000cf1e:	00 9a       	mov	r10,r0
8000cf20:	0c 9c       	mov	r12,r6
8000cf22:	ce 9e       	rcall	8000ccf4 <fatfs_fat_set_cluster>
8000cf24:	00 9b       	mov	r11,r0

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);
8000cf26:	0c 9c       	mov	r12,r6
8000cf28:	3f fa       	mov	r10,-1
8000cf2a:	ce 5e       	rcall	8000ccf4 <fatfs_fat_set_cluster>
8000cf2c:	da 3a       	popm	r0-r7,pc,r12=1
8000cf2e:	e8 09 15 07 	lsl	r9,r4,0x7
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8000cf32:	e6 09 01 09 	sub	r9,r3,r9
8000cf36:	a3 69       	lsl	r9,0x2
8000cf38:	5c 79       	castu.h	r9
8000cf3a:	ea 09 07 0b 	ld.ub	r11,r5[r9]

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8000cf3e:	12 05       	add	r5,r9
8000cf40:	0b 9a       	ld.ub	r10,r5[0x1]
8000cf42:	a9 6a       	lsl	r10,0x8
8000cf44:	0b bc       	ld.ub	r12,r5[0x3]
8000cf46:	0b a9       	ld.ub	r9,r5[0x2]
8000cf48:	b9 6c       	lsl	r12,0x18
8000cf4a:	b1 69       	lsl	r9,0x10
8000cf4c:	f8 09 00 09 	add	r9,r12,r9
8000cf50:	16 09       	add	r9,r11
8000cf52:	14 09       	add	r9,r10
8000cf54:	f3 d9 c0 1c 	bfextu	r9,r9,0x0,0x1c
8000cf58:	f2 01 00 0a 	add	r10,r9,r1

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000cf5c:	58 7a       	cp.w	r10,7
8000cf5e:	fe 98 ff df 	brls	8000cf1c <fatfs_fat_add_cluster_to_chain+0x108>
8000cf62:	58 09       	cp.w	r9,0
8000cf64:	cb d1       	brne	8000cede <fatfs_fat_add_cluster_to_chain+0xca>
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
        if (!next_cluster)
8000cf66:	d8 3a       	popm	r0-r7,pc,r12=0
8000cf68:	10 15       	sub	r5,r8
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);

    return 1;
8000cf6a:	a9 75       	lsl	r5,0x9
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000cf6c:	ee 05 00 05 	add	r5,r7,r5
8000cf70:	ef 45 02 08 	st.w	r7[520],r5
8000cf74:	c9 cb       	rjmp	8000ceac <fatfs_fat_add_cluster_to_chain+0x98>
8000cf76:	3f f8       	mov	r8,-1
8000cf78:	ef 48 02 00 	st.w	r7[512],r8

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000cf7c:	cd 0b       	rjmp	8000cf1c <fatfs_fat_add_cluster_to_chain+0x108>
8000cf7e:	d7 03       	nop

8000cf80 <fatfs_free_cluster_chain>:
8000cf80:	d4 31       	pushm	r0-r7,lr
8000cf82:	30 10       	mov	r0,1
8000cf84:	16 94       	mov	r4,r11
8000cf86:	18 95       	mov	r5,r12
8000cf88:	30 01       	mov	r1,0
8000cf8a:	e8 c8 00 01 	sub	r8,r4,1
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8000cf8e:	5b d8       	cp.w	r8,-3
8000cf90:	e0 8b 00 b5 	brhi	8000d0fa <fatfs_free_cluster_chain+0x17a>
    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000cf94:	6a c8       	ld.w	r8,r5[0x30]
8000cf96:	58 08       	cp.w	r8,0
8000cf98:	e0 81 00 b2 	brne	8000d0fc <fatfs_free_cluster_chain+0x17c>
        fat_sector_offset = current_cluster / 256;
8000cf9c:	e8 03 16 08 	lsr	r3,r4,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cfa0:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000cfa2:	ea f7 02 54 	ld.w	r7,r5[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000cfa6:	e6 06 00 06 	add	r6,r3,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cfaa:	58 07       	cp.w	r7,0
8000cfac:	e0 80 00 b2 	breq	8000d110 <fatfs_free_cluster_chain+0x190>
8000cfb0:	30 09       	mov	r9,0
8000cfb2:	c0 38       	rjmp	8000cfb8 <fatfs_free_cluster_chain+0x38>
8000cfb4:	0e 99       	mov	r9,r7
8000cfb6:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000cfb8:	ee f8 02 00 	ld.w	r8,r7[512]
8000cfbc:	10 36       	cp.w	r6,r8
8000cfbe:	c0 63       	brcs	8000cfca <fatfs_free_cluster_chain+0x4a>
8000cfc0:	f0 ca ff ff 	sub	r10,r8,-1
8000cfc4:	14 36       	cp.w	r6,r10
8000cfc6:	e0 83 01 2a 	brlo	8000d21a <fatfs_free_cluster_chain+0x29a>
            break;

        // End of list?
        if (pcur->next == NULL)
8000cfca:	ee f8 02 0c 	ld.w	r8,r7[524]
8000cfce:	58 08       	cp.w	r8,0
8000cfd0:	cf 21       	brne	8000cfb4 <fatfs_free_cluster_chain+0x34>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000cfd2:	58 09       	cp.w	r9,0
8000cfd4:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000cfd8:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000cfdc:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000cfe0:	58 08       	cp.w	r8,0
8000cfe2:	ce 91       	brne	8000cfb4 <fatfs_free_cluster_chain+0x34>
8000cfe4:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000cfe8:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000cfec:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000cff0:	ee f8 02 04 	ld.w	r8,r7[516]
8000cff4:	58 08       	cp.w	r8,0
8000cff6:	e0 81 00 97 	brne	8000d124 <fatfs_free_cluster_chain+0x1a4>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000cffa:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000cffe:	0c 9c       	mov	r12,r6
8000d000:	6a d8       	ld.w	r8,r5[0x34]
8000d002:	0e 96       	mov	r6,r7
8000d004:	30 1a       	mov	r10,1
8000d006:	0e 9b       	mov	r11,r7
8000d008:	5d 18       	icall	r8
8000d00a:	e0 80 01 14 	breq	8000d232 <fatfs_free_cluster_chain+0x2b2>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000d00e:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8000d012:	6a c8       	ld.w	r8,r5[0x30]
8000d014:	58 08       	cp.w	r8,0
8000d016:	e0 81 00 a1 	brne	8000d158 <fatfs_free_cluster_chain+0x1d8>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8000d01a:	e6 08 15 08 	lsl	r8,r3,0x8
8000d01e:	e8 08 01 08 	sub	r8,r4,r8
8000d022:	a1 78       	lsl	r8,0x1
8000d024:	5c 78       	castu.h	r8
8000d026:	ec 08 07 09 	ld.ub	r9,r6[r8]
8000d02a:	ec 08 00 08 	add	r8,r6,r8
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000d02e:	ea f7 02 54 	ld.w	r7,r5[596]
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8000d032:	11 93       	ld.ub	r3,r8[0x1]
8000d034:	a9 63       	lsl	r3,0x8
8000d036:	12 03       	add	r3,r9

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8000d038:	fe 79 00 08 	mov	r9,-65528
8000d03c:	e6 09 00 08 	add	r8,r3,r9
8000d040:	58 78       	cp.w	r8,7
8000d042:	f9 b3 08 ff 	movls	r3,-1
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
8000d046:	e8 02 16 08 	lsr	r2,r4,0x8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d04a:	6a 56       	ld.w	r6,r5[0x14]
8000d04c:	e4 06 00 06 	add	r6,r2,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d050:	58 07       	cp.w	r7,0
8000d052:	e0 80 00 a9 	breq	8000d1a4 <fatfs_free_cluster_chain+0x224>
8000d056:	30 09       	mov	r9,0
8000d058:	c0 38       	rjmp	8000d05e <fatfs_free_cluster_chain+0xde>
8000d05a:	0e 99       	mov	r9,r7
8000d05c:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000d05e:	ee f8 02 00 	ld.w	r8,r7[512]
8000d062:	10 36       	cp.w	r6,r8
8000d064:	c0 63       	brcs	8000d070 <fatfs_free_cluster_chain+0xf0>
8000d066:	f0 ca ff ff 	sub	r10,r8,-1
8000d06a:	14 36       	cp.w	r6,r10
8000d06c:	e0 83 00 d0 	brlo	8000d20c <fatfs_free_cluster_chain+0x28c>
            break;

        // End of list?
        if (pcur->next == NULL)
8000d070:	ee f8 02 0c 	ld.w	r8,r7[524]
8000d074:	58 08       	cp.w	r8,0
8000d076:	cf 21       	brne	8000d05a <fatfs_free_cluster_chain+0xda>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000d078:	58 09       	cp.w	r9,0
8000d07a:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000d07e:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000d082:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d086:	58 08       	cp.w	r8,0
8000d088:	ce 91       	brne	8000d05a <fatfs_free_cluster_chain+0xda>
8000d08a:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000d08e:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000d092:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000d096:	ee f8 02 04 	ld.w	r8,r7[516]
8000d09a:	58 08       	cp.w	r8,0
8000d09c:	e0 81 00 8e 	brne	8000d1b8 <fatfs_free_cluster_chain+0x238>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000d0a0:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000d0a4:	0c 9c       	mov	r12,r6
8000d0a6:	6a d8       	ld.w	r8,r5[0x34]
8000d0a8:	0e 96       	mov	r6,r7
8000d0aa:	30 1a       	mov	r10,1
8000d0ac:	0e 9b       	mov	r11,r7
8000d0ae:	5d 18       	icall	r8
8000d0b0:	e0 80 00 bc 	breq	8000d228 <fatfs_free_cluster_chain+0x2a8>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000d0b4:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8000d0b8:	6a c8       	ld.w	r8,r5[0x30]
8000d0ba:	58 08       	cp.w	r8,0
8000d0bc:	e0 80 00 97 	breq	8000d1ea <fatfs_free_cluster_chain+0x26a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8000d0c0:	e4 08 15 07 	lsl	r8,r2,0x7
8000d0c4:	e8 08 01 08 	sub	r8,r4,r8
8000d0c8:	a3 68       	lsl	r8,0x2
8000d0ca:	5c 78       	castu.h	r8
8000d0cc:	ec 08 0b 01 	st.b	r6[r8],r1
8000d0d0:	ee f9 02 08 	ld.w	r9,r7[520]
8000d0d4:	10 09       	add	r9,r8
8000d0d6:	b2 91       	st.b	r9[0x1],r1
8000d0d8:	ee f9 02 08 	ld.w	r9,r7[520]
8000d0dc:	10 09       	add	r9,r8
8000d0de:	b2 a1       	st.b	r9[0x2],r1
8000d0e0:	ee f9 02 08 	ld.w	r9,r7[520]
8000d0e4:	f2 08 00 08 	add	r8,r9,r8
8000d0e8:	b0 b1       	st.b	r8[0x3],r1
8000d0ea:	ef 40 02 04 	st.w	r7[516],r0
8000d0ee:	06 94       	mov	r4,r3
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8000d0f0:	e8 c8 00 01 	sub	r8,r4,1
8000d0f4:	5b d8       	cp.w	r8,-3
8000d0f6:	fe 98 ff 4f 	brls	8000cf94 <fatfs_free_cluster_chain+0x14>
        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    }

    return 1;
} 
8000d0fa:	da 3a       	popm	r0-r7,pc,r12=1

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8000d0fc:	e8 03 16 07 	lsr	r3,r4,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d100:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000d102:	ea f7 02 54 	ld.w	r7,r5[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d106:	e6 06 00 06 	add	r6,r3,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d10a:	58 07       	cp.w	r7,0
8000d10c:	fe 91 ff 52 	brne	8000cfb0 <fatfs_free_cluster_chain+0x30>
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8000d110:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000d112:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000d116:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000d11a:	ee f8 02 04 	ld.w	r8,r7[516]
8000d11e:	58 08       	cp.w	r8,0
8000d120:	fe 90 ff 6d 	breq	8000cffa <fatfs_free_cluster_chain+0x7a>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8000d124:	58 07       	cp.w	r7,0
8000d126:	e0 80 00 8b 	breq	8000d23c <fatfs_free_cluster_chain+0x2bc>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8000d12a:	6a e8       	ld.w	r8,r5[0x38]
8000d12c:	58 08       	cp.w	r8,0
8000d12e:	c1 10       	breq	8000d150 <fatfs_free_cluster_chain+0x1d0>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8000d130:	ee fc 02 00 	ld.w	r12,r7[512]
8000d134:	6a 59       	ld.w	r9,r5[0x14]
8000d136:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000d13a:	f2 cb ff ff 	sub	r11,r9,-1
8000d13e:	6a 8a       	ld.w	r10,r5[0x20]
8000d140:	14 3b       	cp.w	r11,r10
8000d142:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8000d146:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8000d14a:	0e 9b       	mov	r11,r7
8000d14c:	5d 18       	icall	r8
8000d14e:	c7 50       	breq	8000d238 <fatfs_free_cluster_chain+0x2b8>
                    return 0;
            }
                
            pcur->dirty = 0;
8000d150:	30 09       	mov	r9,0
8000d152:	ef 49 02 04 	st.w	r7[516],r9
8000d156:	c5 2b       	rjmp	8000cffa <fatfs_free_cluster_chain+0x7a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8000d158:	e6 08 15 07 	lsl	r8,r3,0x7
8000d15c:	e8 08 01 08 	sub	r8,r4,r8
8000d160:	a3 68       	lsl	r8,0x2
8000d162:	5c 78       	castu.h	r8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8000d164:	ec 08 07 09 	ld.ub	r9,r6[r8]
8000d168:	10 06       	add	r6,r8
8000d16a:	0d 98       	ld.ub	r8,r6[0x1]
8000d16c:	a9 68       	lsl	r8,0x8
8000d16e:	0d b3       	ld.ub	r3,r6[0x3]
8000d170:	0d aa       	ld.ub	r10,r6[0x2]
8000d172:	b9 63       	lsl	r3,0x18
8000d174:	b1 6a       	lsl	r10,0x10
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000d176:	ea f7 02 54 	ld.w	r7,r5[596]

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8000d17a:	14 03       	add	r3,r10
8000d17c:	12 03       	add	r3,r9

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000d17e:	30 89       	mov	r9,8
8000d180:	ea 19 f0 00 	orh	r9,0xf000

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8000d184:	10 03       	add	r3,r8
8000d186:	e7 d3 c0 1c 	bfextu	r3,r3,0x0,0x1c

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000d18a:	e6 09 00 08 	add	r8,r3,r9
8000d18e:	58 78       	cp.w	r8,7
8000d190:	f9 b3 08 ff 	movls	r3,-1

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;
8000d194:	e8 02 16 07 	lsr	r2,r4,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d198:	6a 56       	ld.w	r6,r5[0x14]
8000d19a:	e4 06 00 06 	add	r6,r2,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d19e:	58 07       	cp.w	r7,0
8000d1a0:	fe 91 ff 5b 	brne	8000d056 <fatfs_free_cluster_chain+0xd6>
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000d1a4:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000d1a6:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000d1aa:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000d1ae:	ee f8 02 04 	ld.w	r8,r7[516]
8000d1b2:	58 08       	cp.w	r8,0
8000d1b4:	fe 90 ff 76 	breq	8000d0a0 <fatfs_free_cluster_chain+0x120>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8000d1b8:	58 07       	cp.w	r7,0
8000d1ba:	c9 a0       	breq	8000d0ee <fatfs_free_cluster_chain+0x16e>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8000d1bc:	6a e8       	ld.w	r8,r5[0x38]
8000d1be:	58 08       	cp.w	r8,0
8000d1c0:	c1 10       	breq	8000d1e2 <fatfs_free_cluster_chain+0x262>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8000d1c2:	ee fc 02 00 	ld.w	r12,r7[512]
8000d1c6:	6a 59       	ld.w	r9,r5[0x14]
8000d1c8:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000d1cc:	f2 cb ff ff 	sub	r11,r9,-1
8000d1d0:	6a 8a       	ld.w	r10,r5[0x20]
8000d1d2:	14 3b       	cp.w	r11,r10
8000d1d4:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8000d1d8:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8000d1dc:	0e 9b       	mov	r11,r7
8000d1de:	5d 18       	icall	r8
8000d1e0:	c8 70       	breq	8000d0ee <fatfs_free_cluster_chain+0x16e>
                    return 0;
            }
                
            pcur->dirty = 0;
8000d1e2:	30 08       	mov	r8,0
8000d1e4:	ef 48 02 04 	st.w	r7[516],r8
8000d1e8:	c5 cb       	rjmp	8000d0a0 <fatfs_free_cluster_chain+0x120>
    {
        // Find 16 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 256)) * 2; 

        // Write Next Clusters value to Sector Buffer
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));     
8000d1ea:	e4 09 15 08 	lsl	r9,r2,0x8
8000d1ee:	e8 09 01 09 	sub	r9,r4,r9
8000d1f2:	a1 79       	lsl	r9,0x1
8000d1f4:	5c 79       	castu.h	r9
8000d1f6:	ec 09 0b 08 	st.b	r6[r9],r8
8000d1fa:	ee fa 02 08 	ld.w	r10,r7[520]
8000d1fe:	f4 09 00 09 	add	r9,r10,r9
8000d202:	b2 98       	st.b	r9[0x1],r8
8000d204:	ef 40 02 04 	st.w	r7[516],r0
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8000d208:	06 94       	mov	r4,r3
8000d20a:	c7 3b       	rjmp	8000d0f0 <fatfs_free_cluster_chain+0x170>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000d20c:	10 16       	sub	r6,r8
8000d20e:	a9 76       	lsl	r6,0x9
8000d210:	ee 06 00 06 	add	r6,r7,r6
8000d214:	ef 46 02 08 	st.w	r7[520],r6
8000d218:	c5 0b       	rjmp	8000d0b8 <fatfs_free_cluster_chain+0x138>
8000d21a:	10 16       	sub	r6,r8
8000d21c:	a9 76       	lsl	r6,0x9
8000d21e:	ee 06 00 06 	add	r6,r7,r6
8000d222:	ef 46 02 08 	st.w	r7[520],r6
8000d226:	cf 6a       	rjmp	8000d012 <fatfs_free_cluster_chain+0x92>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000d228:	3f f9       	mov	r9,-1
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8000d22a:	06 94       	mov	r4,r3

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000d22c:	ef 49 02 00 	st.w	r7[512],r9
8000d230:	c6 0b       	rjmp	8000d0f0 <fatfs_free_cluster_chain+0x170>
8000d232:	3f f8       	mov	r8,-1
8000d234:	ef 48 02 00 	st.w	r7[512],r8
8000d238:	ea f7 02 54 	ld.w	r7,r5[596]
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8000d23c:	6a c8       	ld.w	r8,r5[0x30]
8000d23e:	58 08       	cp.w	r8,0
8000d240:	c0 31       	brne	8000d246 <fatfs_free_cluster_chain+0x2c6>

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8000d242:	3f f3       	mov	r3,-1
8000d244:	c0 1b       	rjmp	8000d046 <fatfs_free_cluster_chain+0xc6>
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
8000d246:	3f f3       	mov	r3,-1
8000d248:	ca 6b       	rjmp	8000d194 <fatfs_free_cluster_chain+0x214>

8000d24a <fatfs_find_blank_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
8000d24a:	eb cd 40 fe 	pushm	r1-r7,lr

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
                    return 0;
            }
                
            pcur->dirty = 0;
8000d24e:	30 01       	mov	r1,0
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
8000d250:	18 95       	mov	r5,r12
8000d252:	14 92       	mov	r2,r10
8000d254:	16 93       	mov	r3,r11
8000d256:	78 c8       	ld.w	r8,r12[0x30]
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
8000d258:	58 08       	cp.w	r8,0
8000d25a:	c5 11       	brne	8000d2fc <fatfs_find_blank_cluster+0xb2>
            fat_sector_offset = current_cluster / 256;
8000d25c:	e6 04 16 08 	lsr	r4,r3,0x8
        else
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
8000d260:	6a 88       	ld.w	r8,r5[0x20]
8000d262:	10 34       	cp.w	r4,r8
8000d264:	c5 12       	brcc	8000d306 <fatfs_find_blank_cluster+0xbc>
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d266:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000d268:	ea f7 02 54 	ld.w	r7,r5[596]
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8000d26c:	e8 06 00 06 	add	r6,r4,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d270:	58 07       	cp.w	r7,0
8000d272:	c6 d0       	breq	8000d34c <fatfs_find_blank_cluster+0x102>
8000d274:	30 09       	mov	r9,0
8000d276:	c0 38       	rjmp	8000d27c <fatfs_find_blank_cluster+0x32>
8000d278:	0e 99       	mov	r9,r7
8000d27a:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000d27c:	ee f8 02 00 	ld.w	r8,r7[512]
8000d280:	10 36       	cp.w	r6,r8
8000d282:	c0 53       	brcs	8000d28c <fatfs_find_blank_cluster+0x42>
8000d284:	f0 ca ff ff 	sub	r10,r8,-1
8000d288:	14 36       	cp.w	r6,r10
8000d28a:	c5 93       	brcs	8000d33c <fatfs_find_blank_cluster+0xf2>
            break;

        // End of list?
        if (pcur->next == NULL)
8000d28c:	ee f8 02 0c 	ld.w	r8,r7[524]
8000d290:	58 08       	cp.w	r8,0
8000d292:	cf 31       	brne	8000d278 <fatfs_find_blank_cluster+0x2e>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8000d294:	58 09       	cp.w	r9,0
8000d296:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000d29a:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8000d29e:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8000d2a2:	58 08       	cp.w	r8,0
8000d2a4:	ce a1       	brne	8000d278 <fatfs_find_blank_cluster+0x2e>
8000d2a6:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000d2aa:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000d2ae:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000d2b2:	ee f8 02 04 	ld.w	r8,r7[516]
8000d2b6:	58 08       	cp.w	r8,0
8000d2b8:	c5 31       	brne	8000d35e <fatfs_find_blank_cluster+0x114>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000d2ba:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8000d2be:	0c 9c       	mov	r12,r6
8000d2c0:	6a d8       	ld.w	r8,r5[0x34]
8000d2c2:	30 1a       	mov	r10,1
8000d2c4:	0e 9b       	mov	r11,r7
8000d2c6:	5d 18       	icall	r8
8000d2c8:	0e 99       	mov	r9,r7
8000d2ca:	c6 20       	breq	8000d38e <fatfs_find_blank_cluster+0x144>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000d2cc:	ef 47 02 08 	st.w	r7[520],r7

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
            if (!pbuf)
8000d2d0:	58 07       	cp.w	r7,0
8000d2d2:	c1 a0       	breq	8000d306 <fatfs_find_blank_cluster+0xbc>
                return 0;

            if (fs->fat_type == FAT_TYPE_16)
8000d2d4:	6a c8       	ld.w	r8,r5[0x30]
8000d2d6:	58 08       	cp.w	r8,0
8000d2d8:	c1 c1       	brne	8000d310 <fatfs_find_blank_cluster+0xc6>
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8000d2da:	e8 0a 15 08 	lsl	r10,r4,0x8
8000d2de:	e6 0a 01 0a 	sub	r10,r3,r10
8000d2e2:	a1 7a       	lsl	r10,0x1
8000d2e4:	5c 7a       	castu.h	r10
8000d2e6:	f2 0a 07 0b 	ld.ub	r11,r9[r10]
8000d2ea:	14 09       	add	r9,r10
8000d2ec:	13 99       	ld.ub	r9,r9[0x1]
8000d2ee:	a9 69       	lsl	r9,0x8
8000d2f0:	16 09       	add	r9,r11

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
8000d2f2:	58 09       	cp.w	r9,0
8000d2f4:	c0 b0       	breq	8000d30a <fatfs_find_blank_cluster+0xc0>
                current_cluster++;
8000d2f6:	2f f3       	sub	r3,-1
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
8000d2f8:	58 08       	cp.w	r8,0
8000d2fa:	cb 10       	breq	8000d25c <fatfs_find_blank_cluster+0x12>
            fat_sector_offset = current_cluster / 256;
        else
            fat_sector_offset = current_cluster / 128;
8000d2fc:	e6 04 16 07 	lsr	r4,r3,0x7

        if ( fat_sector_offset < fs->fat_sectors)
8000d300:	6a 88       	ld.w	r8,r5[0x20]
8000d302:	10 34       	cp.w	r4,r8
8000d304:	cb 13       	brcs	8000d266 <fatfs_find_blank_cluster+0x1c>
                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
                current_cluster++;
8000d306:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
            return 0;
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
8000d30a:	85 03       	st.w	r2[0x0],r3
8000d30c:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8000d310:	e8 0a 15 07 	lsl	r10,r4,0x7
8000d314:	e6 0a 01 0a 	sub	r10,r3,r10
8000d318:	a3 6a       	lsl	r10,0x2
8000d31a:	5c 7a       	castu.h	r10
8000d31c:	f2 0a 07 0b 	ld.ub	r11,r9[r10]
8000d320:	14 09       	add	r9,r10
8000d322:	13 9a       	ld.ub	r10,r9[0x1]
8000d324:	13 bc       	ld.ub	r12,r9[0x3]
8000d326:	a9 6a       	lsl	r10,0x8
8000d328:	b9 6c       	lsl	r12,0x18
8000d32a:	13 a9       	ld.ub	r9,r9[0x2]
8000d32c:	b1 69       	lsl	r9,0x10
8000d32e:	f8 09 00 09 	add	r9,r12,r9
8000d332:	16 09       	add	r9,r11
8000d334:	14 09       	add	r9,r10

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
8000d336:	f3 d9 c0 1c 	bfextu	r9,r9,0x0,0x1c
8000d33a:	cd cb       	rjmp	8000d2f2 <fatfs_find_blank_cluster+0xa8>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8000d33c:	ec 08 01 09 	sub	r9,r6,r8
8000d340:	a9 79       	lsl	r9,0x9
8000d342:	ee 09 00 09 	add	r9,r7,r9
8000d346:	ef 49 02 08 	st.w	r7[520],r9
8000d34a:	cc 5b       	rjmp	8000d2d4 <fatfs_find_blank_cluster+0x8a>
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
    return 1;
8000d34c:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000d34e:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8000d352:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8000d356:	ee f8 02 04 	ld.w	r8,r7[516]
8000d35a:	58 08       	cp.w	r8,0
8000d35c:	ca f0       	breq	8000d2ba <fatfs_find_blank_cluster+0x70>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8000d35e:	58 07       	cp.w	r7,0
8000d360:	cd 30       	breq	8000d306 <fatfs_find_blank_cluster+0xbc>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8000d362:	6a e8       	ld.w	r8,r5[0x38]
8000d364:	58 08       	cp.w	r8,0
8000d366:	c1 10       	breq	8000d388 <fatfs_find_blank_cluster+0x13e>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8000d368:	ee fc 02 00 	ld.w	r12,r7[512]
8000d36c:	6a 59       	ld.w	r9,r5[0x14]
8000d36e:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8000d372:	f2 cb ff ff 	sub	r11,r9,-1
8000d376:	6a 8a       	ld.w	r10,r5[0x20]
8000d378:	14 3b       	cp.w	r11,r10
8000d37a:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8000d37e:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8000d382:	0e 9b       	mov	r11,r7
8000d384:	5d 18       	icall	r8
8000d386:	cc 00       	breq	8000d306 <fatfs_find_blank_cluster+0xbc>
                    return 0;
            }
                
            pcur->dirty = 0;
8000d388:	ef 41 02 04 	st.w	r7[516],r1
8000d38c:	c9 7b       	rjmp	8000d2ba <fatfs_find_blank_cluster+0x70>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000d38e:	3f f8       	mov	r8,-1
8000d390:	ef 48 02 00 	st.w	r7[512],r8
8000d394:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

8000d398 <fatfs_add_file_entry>:
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
{
8000d398:	d4 31       	pushm	r0-r7,lr
8000d39a:	fa cd 00 88 	sub	sp,sp,136
8000d39e:	50 2b       	stdsp	sp[0x8],r11
8000d3a0:	50 4a       	stdsp	sp[0x10],r10
8000d3a2:	51 49       	stdsp	sp[0x50],r9
8000d3a4:	51 58       	stdsp	sp[0x54],r8
8000d3a6:	fa c4 ff 54 	sub	r4,sp,-172
8000d3aa:	68 19       	ld.w	r9,r4[0x4]
8000d3ac:	51 79       	stdsp	sp[0x5c],r9
8000d3ae:	68 04       	ld.w	r4,r4[0x0]
8000d3b0:	51 64       	stdsp	sp[0x58],r4
8000d3b2:	18 93       	mov	r3,r12

    uint8 checksum;
    uint8 *pSname;

    // No write access?
    if (!fs->disk_io.write_media)
8000d3b4:	78 e8       	ld.w	r8,r12[0x38]
8000d3b6:	58 08       	cp.w	r8,0
8000d3b8:	c0 60       	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
        return 0;

#if FATFS_INC_LFN_SUPPORT
    // How many LFN entries are required?
    // NOTE: We always request one LFN even if it would fit in a SFN!
    entryCount = fatfs_lfn_entries_required(filename);
8000d3ba:	14 9c       	mov	r12,r10
8000d3bc:	fe b0 f7 44 	rcall	8000c244 <fatfs_lfn_entries_required>
8000d3c0:	18 94       	mov	r4,r12
    if (!entryCount)
8000d3c2:	c0 31       	brne	8000d3c8 <fatfs_add_file_entry+0x30>
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000d3c4:	2d ed       	sub	sp,-136
8000d3c6:	d8 3a       	popm	r0-r7,pc,r12=0
    entryCount = 0;    
#endif

    // Find space in the directory for this filename (or allocate some more)
    // NOTE: We need to find space for at least the LFN + SFN (or just the SFN if LFNs not supported).
    if (!fatfs_find_free_dir_offset(fs, dirCluster, entryCount + 1, &dirSector, &dirOffset))
8000d3c8:	f8 c8 ff ff 	sub	r8,r12,-1
    int x=0;
    int possible_spaces = 0;
    int start_recorded = 0;

    // No entries required?
    if (entryCount == 0)
8000d3cc:	cf c0       	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000d3ce:	e6 c9 ff bc 	sub	r9,r3,-68
8000d3d2:	50 39       	stdsp	sp[0xc],r9
8000d3d4:	e6 c9 ff 9c 	sub	r9,r3,-100
8000d3d8:	50 59       	stdsp	sp[0x14],r9
8000d3da:	e6 c9 ff 7c 	sub	r9,r3,-132
8000d3de:	50 69       	stdsp	sp[0x18],r9
8000d3e0:	e6 c9 ff 5c 	sub	r9,r3,-164
8000d3e4:	50 79       	stdsp	sp[0x1c],r9
8000d3e6:	e6 c9 ff 3c 	sub	r9,r3,-196
8000d3ea:	50 89       	stdsp	sp[0x20],r9
8000d3ec:	e6 c9 ff 1c 	sub	r9,r3,-228
8000d3f0:	50 99       	stdsp	sp[0x24],r9
8000d3f2:	e6 c9 fe fc 	sub	r9,r3,-260
8000d3f6:	50 a9       	stdsp	sp[0x28],r9
8000d3f8:	e6 c9 fe dc 	sub	r9,r3,-292
8000d3fc:	50 b9       	stdsp	sp[0x2c],r9
8000d3fe:	e6 c9 fe bc 	sub	r9,r3,-324
8000d402:	50 c9       	stdsp	sp[0x30],r9
8000d404:	e6 c9 fe 9c 	sub	r9,r3,-356
8000d408:	50 d9       	stdsp	sp[0x34],r9
8000d40a:	e6 c9 fe 7c 	sub	r9,r3,-388
8000d40e:	50 e9       	stdsp	sp[0x38],r9
8000d410:	e6 c9 fe 5c 	sub	r9,r3,-420
8000d414:	50 f9       	stdsp	sp[0x3c],r9
8000d416:	e6 c9 fe 3c 	sub	r9,r3,-452
8000d41a:	51 19       	stdsp	sp[0x44],r9
8000d41c:	e6 c9 fe 1c 	sub	r9,r3,-484
8000d420:	51 09       	stdsp	sp[0x40],r9
8000d422:	e6 c9 fd fc 	sub	r9,r3,-516
8000d426:	30 06       	mov	r6,0
8000d428:	51 29       	stdsp	sp[0x48],r9
8000d42a:	0c 95       	mov	r5,r6
8000d42c:	e6 c9 fd dc 	sub	r9,r3,-548
8000d430:	0c 97       	mov	r7,r6
8000d432:	51 39       	stdsp	sp[0x4c],r9
8000d434:	0c 90       	mov	r0,r6
8000d436:	50 16       	stdsp	sp[0x4],r6
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d438:	3e 51       	mov	r1,-27
8000d43a:	51 8c       	stdsp	sp[0x60],r12
8000d43c:	10 94       	mov	r4,r8
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000d43e:	40 12       	lddsp	r2,sp[0x4]

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
8000d440:	04 98       	mov	r8,r2
8000d442:	2f f8       	sub	r8,-1
8000d444:	30 09       	mov	r9,0
8000d446:	50 18       	stdsp	sp[0x4],r8
8000d448:	04 9a       	mov	r10,r2
8000d44a:	40 2b       	lddsp	r11,sp[0x8]
8000d44c:	06 9c       	mov	r12,r3
8000d44e:	fe b0 ed 1b 	rcall	8000ae84 <fatfs_sector_reader>
8000d452:	e0 80 03 fd 	breq	8000dc4c <fatfs_add_file_entry+0x8b4>

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d456:	40 3c       	lddsp	r12,sp[0xc]
8000d458:	fe b0 f4 eb 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d45c:	e0 81 00 fe 	brne	8000d658 <fatfs_add_file_entry+0x2c0>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d460:	e7 38 00 44 	ld.ub	r8,r3[68]
8000d464:	e2 08 18 00 	cp.b	r8,r1
8000d468:	e0 80 01 89 	breq	8000d77a <fatfs_add_file_entry+0x3e2>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d46c:	58 08       	cp.w	r8,0
8000d46e:	e0 80 01 86 	breq	8000d77a <fatfs_add_file_entry+0x3e2>
8000d472:	18 97       	mov	r7,r12
8000d474:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d476:	40 5c       	lddsp	r12,sp[0x14]
8000d478:	fe b0 f4 db 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d47c:	e0 81 01 00 	brne	8000d67c <fatfs_add_file_entry+0x2e4>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d480:	e7 38 00 64 	ld.ub	r8,r3[100]
8000d484:	e2 08 18 00 	cp.b	r8,r1
8000d488:	e0 80 03 13 	breq	8000daae <fatfs_add_file_entry+0x716>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d48c:	58 08       	cp.w	r8,0
8000d48e:	e0 80 03 10 	breq	8000daae <fatfs_add_file_entry+0x716>
8000d492:	18 97       	mov	r7,r12
8000d494:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d496:	40 6c       	lddsp	r12,sp[0x18]
8000d498:	fe b0 f4 cb 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d49c:	e0 81 00 e7 	brne	8000d66a <fatfs_add_file_entry+0x2d2>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d4a0:	e7 38 00 84 	ld.ub	r8,r3[132]
8000d4a4:	e2 08 18 00 	cp.b	r8,r1
8000d4a8:	e0 80 02 f7 	breq	8000da96 <fatfs_add_file_entry+0x6fe>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d4ac:	58 08       	cp.w	r8,0
8000d4ae:	e0 80 02 f4 	breq	8000da96 <fatfs_add_file_entry+0x6fe>
8000d4b2:	18 97       	mov	r7,r12
8000d4b4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d4b6:	40 7c       	lddsp	r12,sp[0x1c]
8000d4b8:	fe b0 f4 bb 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d4bc:	e0 81 00 e9 	brne	8000d68e <fatfs_add_file_entry+0x2f6>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d4c0:	e7 38 00 a4 	ld.ub	r8,r3[164]
8000d4c4:	e2 08 18 00 	cp.b	r8,r1
8000d4c8:	e0 80 03 00 	breq	8000dac8 <fatfs_add_file_entry+0x730>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d4cc:	58 08       	cp.w	r8,0
8000d4ce:	e0 80 02 fd 	breq	8000dac8 <fatfs_add_file_entry+0x730>
8000d4d2:	18 97       	mov	r7,r12
8000d4d4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d4d6:	40 8c       	lddsp	r12,sp[0x20]
8000d4d8:	fe b0 f4 ab 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d4dc:	e0 81 00 e2 	brne	8000d6a0 <fatfs_add_file_entry+0x308>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d4e0:	e7 38 00 c4 	ld.ub	r8,r3[196]
8000d4e4:	e2 08 18 00 	cp.b	r8,r1
8000d4e8:	e0 80 02 fd 	breq	8000dae2 <fatfs_add_file_entry+0x74a>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d4ec:	58 08       	cp.w	r8,0
8000d4ee:	e0 80 02 fa 	breq	8000dae2 <fatfs_add_file_entry+0x74a>
8000d4f2:	18 97       	mov	r7,r12
8000d4f4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d4f6:	40 9c       	lddsp	r12,sp[0x24]
8000d4f8:	fe b0 f4 9b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d4fc:	e0 81 00 db 	brne	8000d6b2 <fatfs_add_file_entry+0x31a>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d500:	e7 38 00 e4 	ld.ub	r8,r3[228]
8000d504:	e2 08 18 00 	cp.b	r8,r1
8000d508:	e0 80 02 fa 	breq	8000dafc <fatfs_add_file_entry+0x764>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d50c:	58 08       	cp.w	r8,0
8000d50e:	e0 80 02 f7 	breq	8000dafc <fatfs_add_file_entry+0x764>
8000d512:	18 97       	mov	r7,r12
8000d514:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d516:	40 ac       	lddsp	r12,sp[0x28]
8000d518:	fe b0 f4 8b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d51c:	e0 81 00 d4 	brne	8000d6c4 <fatfs_add_file_entry+0x32c>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d520:	e7 38 01 04 	ld.ub	r8,r3[260]
8000d524:	e2 08 18 00 	cp.b	r8,r1
8000d528:	e0 80 02 f7 	breq	8000db16 <fatfs_add_file_entry+0x77e>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d52c:	58 08       	cp.w	r8,0
8000d52e:	e0 80 02 f4 	breq	8000db16 <fatfs_add_file_entry+0x77e>
8000d532:	18 97       	mov	r7,r12
8000d534:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d536:	40 bc       	lddsp	r12,sp[0x2c]
8000d538:	fe b0 f4 7b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d53c:	e0 81 00 cd 	brne	8000d6d6 <fatfs_add_file_entry+0x33e>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d540:	e7 38 01 24 	ld.ub	r8,r3[292]
8000d544:	e2 08 18 00 	cp.b	r8,r1
8000d548:	e0 80 02 f4 	breq	8000db30 <fatfs_add_file_entry+0x798>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d54c:	58 08       	cp.w	r8,0
8000d54e:	e0 80 02 f1 	breq	8000db30 <fatfs_add_file_entry+0x798>
8000d552:	18 97       	mov	r7,r12
8000d554:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d556:	40 cc       	lddsp	r12,sp[0x30]
8000d558:	fe b0 f4 6b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d55c:	e0 81 00 c6 	brne	8000d6e8 <fatfs_add_file_entry+0x350>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d560:	e7 38 01 44 	ld.ub	r8,r3[324]
8000d564:	e2 08 18 00 	cp.b	r8,r1
8000d568:	e0 80 02 f1 	breq	8000db4a <fatfs_add_file_entry+0x7b2>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d56c:	58 08       	cp.w	r8,0
8000d56e:	e0 80 02 ee 	breq	8000db4a <fatfs_add_file_entry+0x7b2>
8000d572:	18 97       	mov	r7,r12
8000d574:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d576:	40 dc       	lddsp	r12,sp[0x34]
8000d578:	fe b0 f4 5b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d57c:	e0 81 00 c8 	brne	8000d70c <fatfs_add_file_entry+0x374>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d580:	e7 38 01 64 	ld.ub	r8,r3[356]
8000d584:	e2 08 18 00 	cp.b	r8,r1
8000d588:	e0 80 02 ee 	breq	8000db64 <fatfs_add_file_entry+0x7cc>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d58c:	58 08       	cp.w	r8,0
8000d58e:	e0 80 02 eb 	breq	8000db64 <fatfs_add_file_entry+0x7cc>
8000d592:	18 97       	mov	r7,r12
8000d594:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d596:	40 ec       	lddsp	r12,sp[0x38]
8000d598:	fe b0 f4 4b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d59c:	e0 81 00 af 	brne	8000d6fa <fatfs_add_file_entry+0x362>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d5a0:	e7 38 01 84 	ld.ub	r8,r3[388]
8000d5a4:	e2 08 18 00 	cp.b	r8,r1
8000d5a8:	e0 80 02 eb 	breq	8000db7e <fatfs_add_file_entry+0x7e6>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d5ac:	58 08       	cp.w	r8,0
8000d5ae:	e0 80 02 e8 	breq	8000db7e <fatfs_add_file_entry+0x7e6>
8000d5b2:	18 97       	mov	r7,r12
8000d5b4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d5b6:	40 fc       	lddsp	r12,sp[0x3c]
8000d5b8:	fe b0 f4 3b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d5bc:	e0 81 00 ba 	brne	8000d730 <fatfs_add_file_entry+0x398>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d5c0:	e7 38 01 a4 	ld.ub	r8,r3[420]
8000d5c4:	e2 08 18 00 	cp.b	r8,r1
8000d5c8:	e0 80 02 e8 	breq	8000db98 <fatfs_add_file_entry+0x800>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d5cc:	58 08       	cp.w	r8,0
8000d5ce:	e0 80 02 e5 	breq	8000db98 <fatfs_add_file_entry+0x800>
8000d5d2:	18 97       	mov	r7,r12
8000d5d4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d5d6:	41 1c       	lddsp	r12,sp[0x44]
8000d5d8:	fe b0 f4 2b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d5dc:	e0 81 00 a1 	brne	8000d71e <fatfs_add_file_entry+0x386>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d5e0:	e7 38 01 c4 	ld.ub	r8,r3[452]
8000d5e4:	e2 08 18 00 	cp.b	r8,r1
8000d5e8:	e0 80 02 e5 	breq	8000dbb2 <fatfs_add_file_entry+0x81a>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d5ec:	58 08       	cp.w	r8,0
8000d5ee:	e0 80 02 e2 	breq	8000dbb2 <fatfs_add_file_entry+0x81a>
8000d5f2:	18 97       	mov	r7,r12
8000d5f4:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d5f6:	41 0c       	lddsp	r12,sp[0x40]
8000d5f8:	fe b0 f4 1b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d5fc:	e0 81 00 ac 	brne	8000d754 <fatfs_add_file_entry+0x3bc>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d600:	e7 38 01 e4 	ld.ub	r8,r3[484]
8000d604:	e2 08 18 00 	cp.b	r8,r1
8000d608:	e0 80 02 e2 	breq	8000dbcc <fatfs_add_file_entry+0x834>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d60c:	58 08       	cp.w	r8,0
8000d60e:	e0 80 02 df 	breq	8000dbcc <fatfs_add_file_entry+0x834>
8000d612:	18 97       	mov	r7,r12
8000d614:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d616:	41 2c       	lddsp	r12,sp[0x48]
8000d618:	fe b0 f4 0b 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d61c:	e0 81 00 93 	brne	8000d742 <fatfs_add_file_entry+0x3aa>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d620:	e7 38 02 04 	ld.ub	r8,r3[516]
8000d624:	e2 08 18 00 	cp.b	r8,r1
8000d628:	e0 80 02 df 	breq	8000dbe6 <fatfs_add_file_entry+0x84e>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d62c:	58 08       	cp.w	r8,0
8000d62e:	e0 80 02 dc 	breq	8000dbe6 <fatfs_add_file_entry+0x84e>
8000d632:	18 97       	mov	r7,r12
8000d634:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8000d636:	41 3c       	lddsp	r12,sp[0x4c]
8000d638:	fe b0 f3 fb 	rcall	8000be2e <fatfs_entry_lfn_text>
8000d63c:	e0 81 00 95 	brne	8000d766 <fatfs_add_file_entry+0x3ce>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8000d640:	e7 38 02 24 	ld.ub	r8,r3[548]
8000d644:	e2 08 18 00 	cp.b	r8,r1
8000d648:	e0 80 02 dc 	breq	8000dc00 <fatfs_add_file_entry+0x868>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8000d64c:	58 08       	cp.w	r8,0
8000d64e:	e0 80 02 d9 	breq	8000dc00 <fatfs_add_file_entry+0x868>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8000d652:	18 97       	mov	r7,r12
8000d654:	18 90       	mov	r0,r12
8000d656:	cf 4a       	rjmp	8000d43e <fatfs_add_file_entry+0xa6>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d658:	58 00       	cp.w	r0,0
8000d65a:	e4 05 17 00 	moveq	r5,r2
8000d65e:	e0 06 17 00 	moveq	r6,r0
8000d662:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d666:	2f f0       	sub	r0,-1
8000d668:	c0 7b       	rjmp	8000d476 <fatfs_add_file_entry+0xde>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d66a:	58 00       	cp.w	r0,0
8000d66c:	e4 05 17 00 	moveq	r5,r2
8000d670:	f9 b6 00 02 	moveq	r6,2
8000d674:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d678:	2f f0       	sub	r0,-1
8000d67a:	c1 eb       	rjmp	8000d4b6 <fatfs_add_file_entry+0x11e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d67c:	58 00       	cp.w	r0,0
8000d67e:	f9 b6 00 01 	moveq	r6,1
8000d682:	e4 05 17 00 	moveq	r5,r2
8000d686:	ec 07 17 00 	moveq	r7,r6
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d68a:	2f f0       	sub	r0,-1
8000d68c:	c0 5b       	rjmp	8000d496 <fatfs_add_file_entry+0xfe>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d68e:	58 00       	cp.w	r0,0
8000d690:	e4 05 17 00 	moveq	r5,r2
8000d694:	f9 b6 00 03 	moveq	r6,3
8000d698:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d69c:	2f f0       	sub	r0,-1
8000d69e:	c1 cb       	rjmp	8000d4d6 <fatfs_add_file_entry+0x13e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6a0:	58 00       	cp.w	r0,0
8000d6a2:	e4 05 17 00 	moveq	r5,r2
8000d6a6:	f9 b6 00 04 	moveq	r6,4
8000d6aa:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d6ae:	2f f0       	sub	r0,-1
8000d6b0:	c2 3b       	rjmp	8000d4f6 <fatfs_add_file_entry+0x15e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6b2:	58 00       	cp.w	r0,0
8000d6b4:	e4 05 17 00 	moveq	r5,r2
8000d6b8:	f9 b6 00 05 	moveq	r6,5
8000d6bc:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d6c0:	2f f0       	sub	r0,-1
8000d6c2:	c2 ab       	rjmp	8000d516 <fatfs_add_file_entry+0x17e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6c4:	58 00       	cp.w	r0,0
8000d6c6:	e4 05 17 00 	moveq	r5,r2
8000d6ca:	f9 b6 00 06 	moveq	r6,6
8000d6ce:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d6d2:	2f f0       	sub	r0,-1
8000d6d4:	c3 1b       	rjmp	8000d536 <fatfs_add_file_entry+0x19e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6d6:	58 00       	cp.w	r0,0
8000d6d8:	e4 05 17 00 	moveq	r5,r2
8000d6dc:	f9 b6 00 07 	moveq	r6,7
8000d6e0:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d6e4:	2f f0       	sub	r0,-1
8000d6e6:	c3 8b       	rjmp	8000d556 <fatfs_add_file_entry+0x1be>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6e8:	58 00       	cp.w	r0,0
8000d6ea:	e4 05 17 00 	moveq	r5,r2
8000d6ee:	f9 b6 00 08 	moveq	r6,8
8000d6f2:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d6f6:	2f f0       	sub	r0,-1
8000d6f8:	c3 fb       	rjmp	8000d576 <fatfs_add_file_entry+0x1de>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d6fa:	58 00       	cp.w	r0,0
8000d6fc:	e4 05 17 00 	moveq	r5,r2
8000d700:	f9 b6 00 0a 	moveq	r6,10
8000d704:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d708:	2f f0       	sub	r0,-1
8000d70a:	c5 6b       	rjmp	8000d5b6 <fatfs_add_file_entry+0x21e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d70c:	58 00       	cp.w	r0,0
8000d70e:	e4 05 17 00 	moveq	r5,r2
8000d712:	f9 b6 00 09 	moveq	r6,9
8000d716:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d71a:	2f f0       	sub	r0,-1
8000d71c:	c3 db       	rjmp	8000d596 <fatfs_add_file_entry+0x1fe>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d71e:	58 00       	cp.w	r0,0
8000d720:	e4 05 17 00 	moveq	r5,r2
8000d724:	f9 b6 00 0c 	moveq	r6,12
8000d728:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d72c:	2f f0       	sub	r0,-1
8000d72e:	c6 4b       	rjmp	8000d5f6 <fatfs_add_file_entry+0x25e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d730:	58 00       	cp.w	r0,0
8000d732:	e4 05 17 00 	moveq	r5,r2
8000d736:	f9 b6 00 0b 	moveq	r6,11
8000d73a:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d73e:	2f f0       	sub	r0,-1
8000d740:	c4 bb       	rjmp	8000d5d6 <fatfs_add_file_entry+0x23e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d742:	58 00       	cp.w	r0,0
8000d744:	e4 05 17 00 	moveq	r5,r2
8000d748:	f9 b6 00 0e 	moveq	r6,14
8000d74c:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d750:	2f f0       	sub	r0,-1
8000d752:	c7 2b       	rjmp	8000d636 <fatfs_add_file_entry+0x29e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d754:	58 00       	cp.w	r0,0
8000d756:	e4 05 17 00 	moveq	r5,r2
8000d75a:	f9 b6 00 0d 	moveq	r6,13
8000d75e:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d762:	2f f0       	sub	r0,-1
8000d764:	c5 9b       	rjmp	8000d616 <fatfs_add_file_entry+0x27e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8000d766:	58 00       	cp.w	r0,0
8000d768:	e4 05 17 00 	moveq	r5,r2
8000d76c:	f9 b6 00 0f 	moveq	r6,15
8000d770:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8000d774:	2f f0       	sub	r0,-1
8000d776:	fe 9f fe 64 	bral	8000d43e <fatfs_add_file_entry+0xa6>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000d77a:	58 00       	cp.w	r0,0
8000d77c:	e4 05 17 00 	moveq	r5,r2
8000d780:	e0 06 17 00 	moveq	r6,r0
8000d784:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000d788:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000d78a:	00 34       	cp.w	r4,r0
8000d78c:	fe 99 fe 75 	brgt	8000d476 <fatfs_add_file_entry+0xde>
8000d790:	41 84       	lddsp	r4,sp[0x60]
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8000d792:	41 49       	lddsp	r9,sp[0x50]
8000d794:	13 3a       	ld.ub	r10,r9++
8000d796:	13 3c       	ld.ub	r12,r9++
8000d798:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d79c:	f8 0b 00 0b 	add	r11,r12,r11
8000d7a0:	e0 68 00 80 	mov	r8,128
8000d7a4:	13 3c       	ld.ub	r12,r9++
8000d7a6:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d7aa:	f0 0a 17 10 	movne	r10,r8
8000d7ae:	f6 0a 00 0a 	add	r10,r11,r10
8000d7b2:	5c 5a       	castu.b	r10
8000d7b4:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d7b8:	f8 0b 00 0b 	add	r11,r12,r11
8000d7bc:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d7c0:	13 3c       	ld.ub	r12,r9++
8000d7c2:	f0 0a 17 10 	movne	r10,r8
8000d7c6:	f6 0a 00 0a 	add	r10,r11,r10
8000d7ca:	5c 5a       	castu.b	r10
8000d7cc:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d7d0:	f8 0b 00 0b 	add	r11,r12,r11
8000d7d4:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d7d8:	13 3c       	ld.ub	r12,r9++
8000d7da:	f0 0a 17 10 	movne	r10,r8
8000d7de:	f6 0a 00 0a 	add	r10,r11,r10
8000d7e2:	5c 5a       	castu.b	r10
8000d7e4:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d7e8:	f8 0b 00 0b 	add	r11,r12,r11
8000d7ec:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d7f0:	13 3c       	ld.ub	r12,r9++
8000d7f2:	f0 0a 17 10 	movne	r10,r8
8000d7f6:	f6 0a 00 0a 	add	r10,r11,r10
8000d7fa:	5c 5a       	castu.b	r10
8000d7fc:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d800:	f8 0b 00 0b 	add	r11,r12,r11
8000d804:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d808:	13 3c       	ld.ub	r12,r9++
8000d80a:	f0 0a 17 10 	movne	r10,r8
8000d80e:	f6 0a 00 0a 	add	r10,r11,r10
8000d812:	5c 5a       	castu.b	r10
8000d814:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d818:	f8 0b 00 0b 	add	r11,r12,r11
8000d81c:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d820:	13 3c       	ld.ub	r12,r9++
8000d822:	f0 0a 17 10 	movne	r10,r8
8000d826:	f6 0a 00 0a 	add	r10,r11,r10
8000d82a:	5c 5a       	castu.b	r10
8000d82c:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d830:	f8 0b 00 0b 	add	r11,r12,r11
8000d834:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d838:	13 3c       	ld.ub	r12,r9++
8000d83a:	f0 0a 17 10 	movne	r10,r8
8000d83e:	f6 0a 00 0a 	add	r10,r11,r10
8000d842:	5c 5a       	castu.b	r10
8000d844:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d848:	f8 0b 00 0b 	add	r11,r12,r11
8000d84c:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d850:	13 3c       	ld.ub	r12,r9++
8000d852:	f0 0a 17 10 	movne	r10,r8
8000d856:	f6 0a 00 0a 	add	r10,r11,r10
8000d85a:	5c 5a       	castu.b	r10
8000d85c:	f4 0b 16 01 	lsr	r11,r10,0x1
8000d860:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d864:	f0 0a 17 10 	movne	r10,r8
8000d868:	f8 0b 00 0b 	add	r11,r12,r11
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d86c:	0a 92       	mov	r2,r5
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8000d86e:	13 8c       	ld.ub	r12,r9[0x0]
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d870:	30 01       	mov	r1,0
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8000d872:	f6 0a 00 09 	add	r9,r11,r10
8000d876:	50 15       	stdsp	sp[0x4],r5
8000d878:	5c 59       	castu.b	r9
8000d87a:	0c 95       	mov	r5,r6
8000d87c:	f2 0a 16 01 	lsr	r10,r9,0x1
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8000d880:	30 10       	mov	r0,1
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8000d882:	f8 0a 00 0a 	add	r10,r12,r10
8000d886:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000d88a:	40 46       	lddsp	r6,sp[0x10]
8000d88c:	f0 09 17 10 	movne	r9,r8
8000d890:	f4 09 00 09 	add	r9,r10,r9
8000d894:	ef d9 c0 08 	bfextu	r7,r9,0x0,0x8

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
8000d898:	30 09       	mov	r9,0
8000d89a:	04 9a       	mov	r10,r2
8000d89c:	40 2b       	lddsp	r11,sp[0x8]
8000d89e:	06 9c       	mov	r12,r3
8000d8a0:	fe b0 ea f2 	rcall	8000ae84 <fatfs_sector_reader>
8000d8a4:	fe 90 fd 90 	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
8000d8a8:	58 01       	cp.w	r1,0
8000d8aa:	c4 b1       	brne	8000d940 <fatfs_add_file_entry+0x5a8>
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8000d8ac:	40 19       	lddsp	r9,sp[0x4]
8000d8ae:	12 32       	cp.w	r2,r9
8000d8b0:	c0 30       	breq	8000d8b6 <fatfs_add_file_entry+0x51e>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8000d8b2:	2f f2       	sub	r2,-1
8000d8b4:	cf 2b       	rjmp	8000d898 <fatfs_add_file_entry+0x500>
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8000d8b6:	58 05       	cp.w	r5,0
8000d8b8:	c4 40       	breq	8000d940 <fatfs_add_file_entry+0x5a8>
8000d8ba:	e0 05 18 00 	cp.b	r5,r0
8000d8be:	c4 b0       	breq	8000d954 <fatfs_add_file_entry+0x5bc>
8000d8c0:	30 28       	mov	r8,2
8000d8c2:	f0 05 18 00 	cp.b	r5,r8
8000d8c6:	c5 10       	breq	8000d968 <fatfs_add_file_entry+0x5d0>
8000d8c8:	30 39       	mov	r9,3
8000d8ca:	f2 05 18 00 	cp.b	r5,r9
8000d8ce:	c5 70       	breq	8000d97c <fatfs_add_file_entry+0x5e4>
8000d8d0:	30 48       	mov	r8,4
8000d8d2:	f0 05 18 00 	cp.b	r5,r8
8000d8d6:	c5 d0       	breq	8000d990 <fatfs_add_file_entry+0x5f8>
8000d8d8:	30 59       	mov	r9,5
8000d8da:	f2 05 18 00 	cp.b	r5,r9
8000d8de:	c6 30       	breq	8000d9a4 <fatfs_add_file_entry+0x60c>
8000d8e0:	30 68       	mov	r8,6
8000d8e2:	f0 05 18 00 	cp.b	r5,r8
8000d8e6:	c6 90       	breq	8000d9b8 <fatfs_add_file_entry+0x620>
8000d8e8:	30 79       	mov	r9,7
8000d8ea:	f2 05 18 00 	cp.b	r5,r9
8000d8ee:	c6 f0       	breq	8000d9cc <fatfs_add_file_entry+0x634>
8000d8f0:	30 88       	mov	r8,8
8000d8f2:	f0 05 18 00 	cp.b	r5,r8
8000d8f6:	c7 50       	breq	8000d9e0 <fatfs_add_file_entry+0x648>
8000d8f8:	30 98       	mov	r8,9
8000d8fa:	f0 05 18 00 	cp.b	r5,r8
8000d8fe:	c7 b0       	breq	8000d9f4 <fatfs_add_file_entry+0x65c>
8000d900:	30 a8       	mov	r8,10
8000d902:	f0 05 18 00 	cp.b	r5,r8
8000d906:	e0 80 00 81 	breq	8000da08 <fatfs_add_file_entry+0x670>
8000d90a:	30 b8       	mov	r8,11
8000d90c:	f0 05 18 00 	cp.b	r5,r8
8000d910:	e0 80 00 86 	breq	8000da1c <fatfs_add_file_entry+0x684>
8000d914:	30 c8       	mov	r8,12
8000d916:	f0 05 18 00 	cp.b	r5,r8
8000d91a:	e0 80 00 8b 	breq	8000da30 <fatfs_add_file_entry+0x698>
8000d91e:	30 d8       	mov	r8,13
8000d920:	f0 05 18 00 	cp.b	r5,r8
8000d924:	e0 80 00 90 	breq	8000da44 <fatfs_add_file_entry+0x6ac>
8000d928:	30 e8       	mov	r8,14
8000d92a:	f0 05 18 00 	cp.b	r5,r8
8000d92e:	e0 80 00 95 	breq	8000da58 <fatfs_add_file_entry+0x6c0>
8000d932:	30 f8       	mov	r8,15
8000d934:	f0 05 18 00 	cp.b	r5,r8
8000d938:	e0 80 00 9a 	breq	8000da6c <fatfs_add_file_entry+0x6d4>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8000d93c:	2f f2       	sub	r2,-1
8000d93e:	ca db       	rjmp	8000d898 <fatfs_add_file_entry+0x500>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d940:	58 04       	cp.w	r4,0
8000d942:	e0 80 01 6e 	breq	8000dc1e <fatfs_add_file_entry+0x886>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d946:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d948:	0e 99       	mov	r9,r7
8000d94a:	08 9a       	mov	r10,r4
8000d94c:	40 3b       	lddsp	r11,sp[0xc]
8000d94e:	0c 9c       	mov	r12,r6
8000d950:	fe b0 f4 8c 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d954:	58 04       	cp.w	r4,0
8000d956:	e0 80 01 b0 	breq	8000dcb6 <fatfs_add_file_entry+0x91e>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d95a:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d95c:	0e 99       	mov	r9,r7
8000d95e:	08 9a       	mov	r10,r4
8000d960:	40 5b       	lddsp	r11,sp[0x14]
8000d962:	0c 9c       	mov	r12,r6
8000d964:	fe b0 f4 82 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d968:	58 04       	cp.w	r4,0
8000d96a:	e0 80 01 a4 	breq	8000dcb2 <fatfs_add_file_entry+0x91a>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d96e:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d970:	0e 99       	mov	r9,r7
8000d972:	08 9a       	mov	r10,r4
8000d974:	40 6b       	lddsp	r11,sp[0x18]
8000d976:	0c 9c       	mov	r12,r6
8000d978:	fe b0 f4 78 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d97c:	58 04       	cp.w	r4,0
8000d97e:	e0 80 01 9e 	breq	8000dcba <fatfs_add_file_entry+0x922>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d982:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d984:	0e 99       	mov	r9,r7
8000d986:	08 9a       	mov	r10,r4
8000d988:	40 7b       	lddsp	r11,sp[0x1c]
8000d98a:	0c 9c       	mov	r12,r6
8000d98c:	fe b0 f4 6e 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d990:	58 04       	cp.w	r4,0
8000d992:	e0 80 01 8d 	breq	8000dcac <fatfs_add_file_entry+0x914>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d996:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d998:	0e 99       	mov	r9,r7
8000d99a:	08 9a       	mov	r10,r4
8000d99c:	40 8b       	lddsp	r11,sp[0x20]
8000d99e:	0c 9c       	mov	r12,r6
8000d9a0:	fe b0 f4 64 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d9a4:	58 04       	cp.w	r4,0
8000d9a6:	e0 80 01 9e 	breq	8000dce2 <fatfs_add_file_entry+0x94a>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d9aa:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d9ac:	0e 99       	mov	r9,r7
8000d9ae:	08 9a       	mov	r10,r4
8000d9b0:	40 9b       	lddsp	r11,sp[0x24]
8000d9b2:	0c 9c       	mov	r12,r6
8000d9b4:	fe b0 f4 5a 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d9b8:	58 04       	cp.w	r4,0
8000d9ba:	e0 80 01 91 	breq	8000dcdc <fatfs_add_file_entry+0x944>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d9be:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d9c0:	0e 99       	mov	r9,r7
8000d9c2:	08 9a       	mov	r10,r4
8000d9c4:	40 ab       	lddsp	r11,sp[0x28]
8000d9c6:	0c 9c       	mov	r12,r6
8000d9c8:	fe b0 f4 50 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d9cc:	58 04       	cp.w	r4,0
8000d9ce:	e0 80 01 84 	breq	8000dcd6 <fatfs_add_file_entry+0x93e>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d9d2:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d9d4:	0e 99       	mov	r9,r7
8000d9d6:	08 9a       	mov	r10,r4
8000d9d8:	40 bb       	lddsp	r11,sp[0x2c]
8000d9da:	0c 9c       	mov	r12,r6
8000d9dc:	fe b0 f4 46 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d9e0:	58 04       	cp.w	r4,0
8000d9e2:	e0 80 01 77 	breq	8000dcd0 <fatfs_add_file_entry+0x938>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d9e6:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d9e8:	0e 99       	mov	r9,r7
8000d9ea:	08 9a       	mov	r10,r4
8000d9ec:	40 cb       	lddsp	r11,sp[0x30]
8000d9ee:	0c 9c       	mov	r12,r6
8000d9f0:	fe b0 f4 3c 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000d9f4:	58 04       	cp.w	r4,0
8000d9f6:	e0 80 01 6a 	breq	8000dcca <fatfs_add_file_entry+0x932>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000d9fa:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000d9fc:	0e 99       	mov	r9,r7
8000d9fe:	08 9a       	mov	r10,r4
8000da00:	40 db       	lddsp	r11,sp[0x34]
8000da02:	0c 9c       	mov	r12,r6
8000da04:	fe b0 f4 32 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da08:	58 04       	cp.w	r4,0
8000da0a:	e0 80 01 5d 	breq	8000dcc4 <fatfs_add_file_entry+0x92c>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da0e:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da10:	0e 99       	mov	r9,r7
8000da12:	08 9a       	mov	r10,r4
8000da14:	40 eb       	lddsp	r11,sp[0x38]
8000da16:	0c 9c       	mov	r12,r6
8000da18:	fe b0 f4 28 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da1c:	58 04       	cp.w	r4,0
8000da1e:	e0 80 01 50 	breq	8000dcbe <fatfs_add_file_entry+0x926>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da22:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da24:	0e 99       	mov	r9,r7
8000da26:	08 9a       	mov	r10,r4
8000da28:	40 fb       	lddsp	r11,sp[0x3c]
8000da2a:	0c 9c       	mov	r12,r6
8000da2c:	fe b0 f4 1e 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da30:	58 04       	cp.w	r4,0
8000da32:	e0 80 01 5b 	breq	8000dce8 <fatfs_add_file_entry+0x950>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da36:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da38:	0e 99       	mov	r9,r7
8000da3a:	08 9a       	mov	r10,r4
8000da3c:	41 1b       	lddsp	r11,sp[0x44]
8000da3e:	0c 9c       	mov	r12,r6
8000da40:	fe b0 f4 14 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da44:	58 04       	cp.w	r4,0
8000da46:	e0 80 01 57 	breq	8000dcf4 <fatfs_add_file_entry+0x95c>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da4a:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da4c:	0e 99       	mov	r9,r7
8000da4e:	08 9a       	mov	r10,r4
8000da50:	41 0b       	lddsp	r11,sp[0x40]
8000da52:	0c 9c       	mov	r12,r6
8000da54:	fe b0 f4 0a 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da58:	58 04       	cp.w	r4,0
8000da5a:	e0 80 01 4a 	breq	8000dcee <fatfs_add_file_entry+0x956>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da5e:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da60:	0e 99       	mov	r9,r7
8000da62:	08 9a       	mov	r10,r4
8000da64:	41 2b       	lddsp	r11,sp[0x48]
8000da66:	0c 9c       	mov	r12,r6
8000da68:	fe b0 f4 00 	rcall	8000c268 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000da6c:	58 04       	cp.w	r4,0
8000da6e:	e0 80 00 d6 	breq	8000dc1a <fatfs_add_file_entry+0x882>
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da72:	41 3b       	lddsp	r11,sp[0x4c]
8000da74:	0c 9c       	mov	r12,r6
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8000da76:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8000da78:	0e 99       	mov	r9,r7
8000da7a:	08 9a       	mov	r10,r4
8000da7c:	fe b0 f3 f6 	rcall	8000c268 <fatfs_filename_to_lfn>
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
8000da80:	30 1a       	mov	r10,1
8000da82:	66 e8       	ld.w	r8,r3[0x38]
8000da84:	40 3b       	lddsp	r11,sp[0xc]
8000da86:	e6 fc 02 44 	ld.w	r12,r3[580]
8000da8a:	5d 18       	icall	r8
8000da8c:	fe 90 fc 9c 	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8000da90:	30 11       	mov	r1,1
8000da92:	2f f2       	sub	r2,-1
8000da94:	c0 2b       	rjmp	8000d898 <fatfs_add_file_entry+0x500>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000da96:	58 00       	cp.w	r0,0
8000da98:	e4 05 17 00 	moveq	r5,r2
8000da9c:	f9 b6 00 02 	moveq	r6,2
8000daa0:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000daa4:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000daa6:	00 34       	cp.w	r4,r0
8000daa8:	fe 99 fd 07 	brgt	8000d4b6 <fatfs_add_file_entry+0x11e>
8000daac:	c7 2a       	rjmp	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000daae:	58 00       	cp.w	r0,0
8000dab0:	f9 b6 00 01 	moveq	r6,1
8000dab4:	e4 05 17 00 	moveq	r5,r2
8000dab8:	ec 07 17 00 	moveq	r7,r6
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dabc:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dabe:	00 34       	cp.w	r4,r0
8000dac0:	fe 99 fc eb 	brgt	8000d496 <fatfs_add_file_entry+0xfe>
8000dac4:	fe 9f fe 66 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dac8:	58 00       	cp.w	r0,0
8000daca:	e4 05 17 00 	moveq	r5,r2
8000dace:	f9 b6 00 03 	moveq	r6,3
8000dad2:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dad6:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dad8:	00 34       	cp.w	r4,r0
8000dada:	fe 99 fc fe 	brgt	8000d4d6 <fatfs_add_file_entry+0x13e>
8000dade:	fe 9f fe 59 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dae2:	58 00       	cp.w	r0,0
8000dae4:	e4 05 17 00 	moveq	r5,r2
8000dae8:	f9 b6 00 04 	moveq	r6,4
8000daec:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000daf0:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000daf2:	00 34       	cp.w	r4,r0
8000daf4:	fe 99 fd 01 	brgt	8000d4f6 <fatfs_add_file_entry+0x15e>
8000daf8:	fe 9f fe 4c 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dafc:	58 00       	cp.w	r0,0
8000dafe:	e4 05 17 00 	moveq	r5,r2
8000db02:	f9 b6 00 05 	moveq	r6,5
8000db06:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db0a:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db0c:	00 34       	cp.w	r4,r0
8000db0e:	fe 99 fd 04 	brgt	8000d516 <fatfs_add_file_entry+0x17e>
8000db12:	fe 9f fe 3f 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db16:	58 00       	cp.w	r0,0
8000db18:	e4 05 17 00 	moveq	r5,r2
8000db1c:	f9 b6 00 06 	moveq	r6,6
8000db20:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db24:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db26:	00 34       	cp.w	r4,r0
8000db28:	fe 99 fd 07 	brgt	8000d536 <fatfs_add_file_entry+0x19e>
8000db2c:	fe 9f fe 32 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db30:	58 00       	cp.w	r0,0
8000db32:	e4 05 17 00 	moveq	r5,r2
8000db36:	f9 b6 00 07 	moveq	r6,7
8000db3a:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db3e:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db40:	00 34       	cp.w	r4,r0
8000db42:	fe 99 fd 0a 	brgt	8000d556 <fatfs_add_file_entry+0x1be>
8000db46:	fe 9f fe 25 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db4a:	58 00       	cp.w	r0,0
8000db4c:	e4 05 17 00 	moveq	r5,r2
8000db50:	f9 b6 00 08 	moveq	r6,8
8000db54:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db58:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db5a:	00 34       	cp.w	r4,r0
8000db5c:	fe 99 fd 0d 	brgt	8000d576 <fatfs_add_file_entry+0x1de>
8000db60:	fe 9f fe 18 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db64:	58 00       	cp.w	r0,0
8000db66:	e4 05 17 00 	moveq	r5,r2
8000db6a:	f9 b6 00 09 	moveq	r6,9
8000db6e:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db72:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db74:	00 34       	cp.w	r4,r0
8000db76:	fe 99 fd 10 	brgt	8000d596 <fatfs_add_file_entry+0x1fe>
8000db7a:	fe 9f fe 0b 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db7e:	58 00       	cp.w	r0,0
8000db80:	e4 05 17 00 	moveq	r5,r2
8000db84:	f9 b6 00 0a 	moveq	r6,10
8000db88:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000db8c:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000db8e:	00 34       	cp.w	r4,r0
8000db90:	fe 99 fd 13 	brgt	8000d5b6 <fatfs_add_file_entry+0x21e>
8000db94:	fe 9f fd fe 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000db98:	58 00       	cp.w	r0,0
8000db9a:	e4 05 17 00 	moveq	r5,r2
8000db9e:	f9 b6 00 0b 	moveq	r6,11
8000dba2:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dba6:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dba8:	00 34       	cp.w	r4,r0
8000dbaa:	fe 99 fd 16 	brgt	8000d5d6 <fatfs_add_file_entry+0x23e>
8000dbae:	fe 9f fd f1 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dbb2:	58 00       	cp.w	r0,0
8000dbb4:	e4 05 17 00 	moveq	r5,r2
8000dbb8:	f9 b6 00 0c 	moveq	r6,12
8000dbbc:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dbc0:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dbc2:	00 34       	cp.w	r4,r0
8000dbc4:	fe 99 fd 19 	brgt	8000d5f6 <fatfs_add_file_entry+0x25e>
8000dbc8:	fe 9f fd e4 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dbcc:	58 00       	cp.w	r0,0
8000dbce:	e4 05 17 00 	moveq	r5,r2
8000dbd2:	f9 b6 00 0d 	moveq	r6,13
8000dbd6:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dbda:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dbdc:	00 34       	cp.w	r4,r0
8000dbde:	fe 99 fd 1c 	brgt	8000d616 <fatfs_add_file_entry+0x27e>
8000dbe2:	fe 9f fd d7 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dbe6:	58 00       	cp.w	r0,0
8000dbe8:	e4 05 17 00 	moveq	r5,r2
8000dbec:	f9 b6 00 0e 	moveq	r6,14
8000dbf0:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dbf4:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dbf6:	00 34       	cp.w	r4,r0
8000dbf8:	fe 99 fd 1f 	brgt	8000d636 <fatfs_add_file_entry+0x29e>
8000dbfc:	fe 9f fd ca 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8000dc00:	58 00       	cp.w	r0,0
8000dc02:	e4 05 17 00 	moveq	r5,r2
8000dc06:	f9 b6 00 0f 	moveq	r6,15
8000dc0a:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8000dc0e:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8000dc10:	00 34       	cp.w	r4,r0
8000dc12:	fe 99 fc 16 	brgt	8000d43e <fatfs_add_file_entry+0xa6>
8000dc16:	fe 9f fd bd 	bral	8000d790 <fatfs_add_file_entry+0x3f8>
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
8000dc1a:	e0 64 01 e0 	mov	r4,480
                if (foundEnd)
                {                
                    if (entryCount==0)
                    {
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
8000dc1e:	fa c7 ff 9c 	sub	r7,sp,-100
8000dc22:	41 78       	lddsp	r8,sp[0x5c]
8000dc24:	41 5a       	lddsp	r10,sp[0x54]
8000dc26:	41 6b       	lddsp	r11,sp[0x58]
8000dc28:	41 4c       	lddsp	r12,sp[0x50]
8000dc2a:	0e 99       	mov	r9,r7
8000dc2c:	fe b0 f1 5c 	rcall	8000bee4 <fatfs_sfn_create_entry>
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));
8000dc30:	0e 9b       	mov	r11,r7
8000dc32:	40 3c       	lddsp	r12,sp[0xc]
8000dc34:	32 0a       	mov	r10,32
8000dc36:	08 0c       	add	r12,r4
8000dc38:	e0 a0 07 c6 	rcall	8000ebc4 <memcpy>

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000dc3c:	40 3b       	lddsp	r11,sp[0xc]
8000dc3e:	e6 fc 02 44 	ld.w	r12,r3[580]
8000dc42:	66 e8       	ld.w	r8,r3[0x38]
8000dc44:	30 1a       	mov	r10,1
8000dc46:	5d 18       	icall	r8
        else
            return 0;
    } // End of while loop

    return 0;
}
8000dc48:	2d ed       	sub	sp,-136
8000dc4a:	d8 32       	popm	r0-r7,pc
8000dc4c:	18 98       	mov	r8,r12
        else
        {
            uint32 newCluster;

            // Get a new cluster for directory
            if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &newCluster))
8000dc4e:	66 2b       	ld.w	r11,r3[0x8]
8000dc50:	41 84       	lddsp	r4,sp[0x60]
8000dc52:	fa ca ff 7c 	sub	r10,sp,-132
8000dc56:	06 9c       	mov	r12,r3
8000dc58:	50 08       	stdsp	sp[0x0],r8
8000dc5a:	fe b0 fa f8 	rcall	8000d24a <fatfs_find_blank_cluster>
8000dc5e:	fe 90 fb b3 	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
                return 0;

            // Add cluster to end of directory tree
            if (!fatfs_fat_add_cluster_to_chain(fs, dirCluster, newCluster))
8000dc62:	42 1a       	lddsp	r10,sp[0x84]
8000dc64:	40 2b       	lddsp	r11,sp[0x8]
8000dc66:	06 9c       	mov	r12,r3
8000dc68:	fe b0 f8 d6 	rcall	8000ce14 <fatfs_fat_add_cluster_to_chain>
8000dc6c:	40 08       	lddsp	r8,sp[0x0]
8000dc6e:	fe 90 fb ab 	breq	8000d3c4 <fatfs_add_file_entry+0x2c>
                return 0;

            // Erase new directory cluster
            memset(fs->currentsector.sector, 0x00, FAT_SECTOR_SIZE);
8000dc72:	e0 6a 02 00 	mov	r10,512
8000dc76:	10 9b       	mov	r11,r8
8000dc78:	40 3c       	lddsp	r12,sp[0xc]
8000dc7a:	e0 a0 08 49 	rcall	8000ed0c <memset>
            for (i=0;i<fs->sectors_per_cluster;i++)
8000dc7e:	07 8a       	ld.ub	r10,r3[0x0]
8000dc80:	40 08       	lddsp	r8,sp[0x0]
8000dc82:	f0 0a 18 00 	cp.b	r10,r8
8000dc86:	c3 a0       	breq	8000dcfa <fatfs_add_file_entry+0x962>
8000dc88:	10 91       	mov	r1,r8
8000dc8a:	c0 88       	rjmp	8000dc9a <fatfs_add_file_entry+0x902>
8000dc8c:	2f f1       	sub	r1,-1
8000dc8e:	07 88       	ld.ub	r8,r3[0x0]
8000dc90:	5c 51       	castu.b	r1
8000dc92:	e2 08 18 00 	cp.b	r8,r1
8000dc96:	e0 88 00 32 	brls	8000dcfa <fatfs_add_file_entry+0x962>
            {
                if (!fatfs_write_sector(fs, newCluster, i, 0))
8000dc9a:	02 9a       	mov	r10,r1
8000dc9c:	30 09       	mov	r9,0
8000dc9e:	42 1b       	lddsp	r11,sp[0x84]
8000dca0:	06 9c       	mov	r12,r3
8000dca2:	fe b0 e8 a3 	rcall	8000ade8 <fatfs_write_sector>
8000dca6:	cf 31       	brne	8000dc8c <fatfs_add_file_entry+0x8f4>
8000dca8:	fe 9f fb 8e 	bral	8000d3c4 <fatfs_add_file_entry+0x2c>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8000dcac:	e0 64 00 80 	mov	r4,128
8000dcb0:	cb 7b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcb2:	34 04       	mov	r4,64
8000dcb4:	cb 5b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcb6:	32 04       	mov	r4,32
8000dcb8:	cb 3b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcba:	36 04       	mov	r4,96
8000dcbc:	cb 1b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcbe:	e0 64 01 60 	mov	r4,352
8000dcc2:	ca eb       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcc4:	e0 64 01 40 	mov	r4,320
8000dcc8:	ca bb       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcca:	e0 64 01 20 	mov	r4,288
8000dcce:	ca 8b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcd0:	e0 64 01 00 	mov	r4,256
8000dcd4:	ca 5b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcd6:	e0 64 00 e0 	mov	r4,224
8000dcda:	ca 2b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcdc:	e0 64 00 c0 	mov	r4,192
8000dce0:	c9 fb       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dce2:	e0 64 00 a0 	mov	r4,160
8000dce6:	c9 cb       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dce8:	e0 64 01 80 	mov	r4,384
8000dcec:	c9 9b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcee:	e0 64 01 c0 	mov	r4,448
8000dcf2:	c9 6b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
8000dcf4:	e0 64 01 a0 	mov	r4,416
8000dcf8:	c9 3b       	rjmp	8000dc1e <fatfs_add_file_entry+0x886>
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000dcfa:	58 07       	cp.w	r7,0
8000dcfc:	e4 05 17 00 	moveq	r5,r2
8000dd00:	ee 06 17 00 	moveq	r6,r7
8000dd04:	fe 9f fd 47 	bral	8000d792 <fatfs_add_file_entry+0x3fa>

8000dd08 <fatfs_add_free_space>:
8000dd08:	eb cd 40 fc 	pushm	r2-r7,lr
8000dd0c:	20 1d       	sub	sp,4
8000dd0e:	16 92       	mov	r2,r11
8000dd10:	14 94       	mov	r4,r10
8000dd12:	18 97       	mov	r7,r12
8000dd14:	76 05       	ld.w	r5,r11[0x0]
8000dd16:	78 98       	ld.w	r8,r12[0x24]
8000dd18:	5b f8       	cp.w	r8,-1
8000dd1a:	c0 40       	breq	8000dd22 <fatfs_add_free_space+0x1a>
8000dd1c:	3f fb       	mov	r11,-1
8000dd1e:	fe b0 f6 97 	rcall	8000ca4c <fatfs_set_fs_info_next_free_cluster>
8000dd22:	58 04       	cp.w	r4,0
8000dd24:	c2 20       	breq	8000dd68 <fatfs_add_free_space+0x60>
8000dd26:	30 06       	mov	r6,0
8000dd28:	1a 93       	mov	r3,sp
8000dd2a:	c1 18       	rjmp	8000dd4c <fatfs_add_free_space+0x44>
8000dd2c:	40 0a       	lddsp	r10,sp[0x0]
8000dd2e:	fe b0 f7 e3 	rcall	8000ccf4 <fatfs_fat_set_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
            
            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8000dd32:	3f fa       	mov	r10,-1
8000dd34:	40 0b       	lddsp	r11,sp[0x0]
8000dd36:	0e 9c       	mov	r12,r7
8000dd38:	fe b0 f7 de 	rcall	8000ccf4 <fatfs_fat_set_cluster>

            // Adjust argument reference
            start = nextcluster;
8000dd3c:	40 05       	lddsp	r5,sp[0x0]
            if (i == 0)
                *startCluster = nextcluster;
8000dd3e:	58 06       	cp.w	r6,0
8000dd40:	e5 f5 0a 00 	st.weq	r2[0x0],r5

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8000dd44:	2f f6       	sub	r6,-1
8000dd46:	0c 34       	cp.w	r4,r6
8000dd48:	e0 88 00 10 	brls	8000dd68 <fatfs_add_free_space+0x60>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000dd4c:	6e 2b       	ld.w	r11,r7[0x8]
8000dd4e:	1a 9a       	mov	r10,sp
8000dd50:	0e 9c       	mov	r12,r7
8000dd52:	fe b0 fa 7c 	rcall	8000d24a <fatfs_find_blank_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8000dd56:	0a 9b       	mov	r11,r5
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000dd58:	18 98       	mov	r8,r12
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8000dd5a:	0e 9c       	mov	r12,r7
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000dd5c:	58 08       	cp.w	r8,0
8000dd5e:	ce 71       	brne	8000dd2c <fatfs_add_free_space+0x24>
8000dd60:	10 9c       	mov	r12,r8
        else
            return 0;
    }

    return 1;
}
8000dd62:	2f fd       	sub	sp,-4
8000dd64:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8000dd68:	2f fd       	sub	sp,-4
8000dd6a:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000dd6e:	d7 03       	nop

8000dd70 <fatfs_allocate_free_space>:
8000dd70:	eb cd 40 f8 	pushm	r3-r7,lr
8000dd74:	20 3d       	sub	sp,12
8000dd76:	16 97       	mov	r7,r11
8000dd78:	14 96       	mov	r6,r10
8000dd7a:	18 95       	mov	r5,r12
{
    uint32 clusterSize;
    uint32 clusterCount;
    uint32 nextcluster;

    if (size==0)
8000dd7c:	58 09       	cp.w	r9,0
8000dd7e:	c3 c0       	breq	8000ddf6 <fatfs_allocate_free_space+0x86>
        return 0;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
8000dd80:	78 98       	ld.w	r8,r12[0x24]
8000dd82:	5b f8       	cp.w	r8,-1
8000dd84:	c0 60       	breq	8000dd90 <fatfs_allocate_free_space+0x20>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 
8000dd86:	50 09       	stdsp	sp[0x0],r9
8000dd88:	3f fb       	mov	r11,-1
8000dd8a:	fe b0 f6 61 	rcall	8000ca4c <fatfs_set_fs_info_next_free_cluster>
8000dd8e:	40 09       	lddsp	r9,sp[0x0]

    // Work out size and clusters
    clusterSize = fs->sectors_per_cluster * FAT_SECTOR_SIZE;
8000dd90:	0b 88       	ld.ub	r8,r5[0x0]
8000dd92:	a9 78       	lsl	r8,0x9
    clusterCount = (size / clusterSize);
8000dd94:	f2 08 0d 0a 	divu	r10,r9,r8
8000dd98:	14 94       	mov	r4,r10

    // If any left over
    if (size-(clusterSize*clusterCount))
8000dd9a:	f4 08 02 48 	mul	r8,r10,r8
        clusterCount++;
8000dd9e:	12 38       	cp.w	r8,r9
8000dda0:	f7 b4 01 ff 	subne	r4,-1

    // Allocated first link in the chain if a new file
    if (newFile)
8000dda4:	58 07       	cp.w	r7,0
8000dda6:	c2 f1       	brne	8000de04 <fatfs_allocate_free_space+0x94>
            return 1;
        }
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;
8000dda8:	6c 06       	ld.w	r6,r6[0x0]
8000ddaa:	50 26       	stdsp	sp[0x8],r6
    uint32 i;
    uint32 nextcluster;
    uint32 start = *startCluster;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
8000ddac:	6a 98       	ld.w	r8,r5[0x24]
8000ddae:	5b f8       	cp.w	r8,-1
8000ddb0:	c0 50       	breq	8000ddba <fatfs_allocate_free_space+0x4a>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 
8000ddb2:	3f fb       	mov	r11,-1
8000ddb4:	0a 9c       	mov	r12,r5
8000ddb6:	fe b0 f6 4b 	rcall	8000ca4c <fatfs_set_fs_info_next_free_cluster>

    for (i=0;i<clusters;i++)
8000ddba:	58 04       	cp.w	r4,0
8000ddbc:	c2 10       	breq	8000ddfe <fatfs_allocate_free_space+0x8e>
8000ddbe:	30 07       	mov	r7,0
8000ddc0:	fa c3 ff fc 	sub	r3,sp,-4
8000ddc4:	c1 28       	rjmp	8000dde8 <fatfs_allocate_free_space+0x78>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8000ddc6:	40 1a       	lddsp	r10,sp[0x4]
8000ddc8:	0a 9c       	mov	r12,r5
8000ddca:	fe b0 f7 95 	rcall	8000ccf4 <fatfs_fat_set_cluster>
            
            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8000ddce:	3f fa       	mov	r10,-1
8000ddd0:	40 1b       	lddsp	r11,sp[0x4]
8000ddd2:	0a 9c       	mov	r12,r5
8000ddd4:	fe b0 f7 90 	rcall	8000ccf4 <fatfs_fat_set_cluster>

            // Adjust argument reference
            start = nextcluster;
8000ddd8:	40 16       	lddsp	r6,sp[0x4]
            if (i == 0)
                *startCluster = nextcluster;
8000ddda:	58 07       	cp.w	r7,0
8000dddc:	fb f6 0a 02 	st.weq	sp[0x8],r6

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8000dde0:	2f f7       	sub	r7,-1
8000dde2:	0e 34       	cp.w	r4,r7
8000dde4:	e0 88 00 0d 	brls	8000ddfe <fatfs_allocate_free_space+0x8e>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000dde8:	6a 2b       	ld.w	r11,r5[0x8]
8000ddea:	06 9a       	mov	r10,r3
8000ddec:	0a 9c       	mov	r12,r5
8000ddee:	fe b0 fa 2e 	rcall	8000d24a <fatfs_find_blank_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8000ddf2:	0c 9b       	mov	r11,r6
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000ddf4:	ce 91       	brne	8000ddc6 <fatfs_allocate_free_space+0x56>

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8000ddf6:	30 0c       	mov	r12,0

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
            return 0;

    return 1;
}
8000ddf8:	2f dd       	sub	sp,-12
8000ddfa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8000ddfe:	2f dd       	sub	sp,-12
8000de00:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
        clusterCount++;

    // Allocated first link in the chain if a new file
    if (newFile)
    {
        if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8000de04:	fa ca ff f8 	sub	r10,sp,-8
8000de08:	6a 2b       	ld.w	r11,r5[0x8]
8000de0a:	0a 9c       	mov	r12,r5
8000de0c:	fe b0 fa 1f 	rcall	8000d24a <fatfs_find_blank_cluster>
8000de10:	cf 30       	breq	8000ddf6 <fatfs_allocate_free_space+0x86>
            return 0;

        // If this is all that is needed then all done
        if (clusterCount==1)
8000de12:	58 14       	cp.w	r4,1
8000de14:	c0 30       	breq	8000de1a <fatfs_allocate_free_space+0xaa>
8000de16:	40 26       	lddsp	r6,sp[0x8]
8000de18:	cc ab       	rjmp	8000ddac <fatfs_allocate_free_space+0x3c>
        {
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8000de1a:	0a 9c       	mov	r12,r5
8000de1c:	3f fa       	mov	r10,-1
8000de1e:	40 2b       	lddsp	r11,sp[0x8]
8000de20:	fe b0 f7 6a 	rcall	8000ccf4 <fatfs_fat_set_cluster>
            *startCluster = nextcluster;
8000de24:	40 28       	lddsp	r8,sp[0x8]
8000de26:	08 9c       	mov	r12,r4
8000de28:	8d 08       	st.w	r6[0x0],r8
            return 1;
8000de2a:	ce 7b       	rjmp	8000ddf8 <fatfs_allocate_free_space+0x88>

8000de2c <_stext>:
8000de2c:	e0 7d 00 00 	mov	sp,65536
8000de30:	fe c0 a4 30 	sub	r0,pc,-23504
8000de34:	e3 b0 00 01 	mtsr	0x4,r0
8000de38:	d5 53       	csrf	0x15
8000de3a:	30 80       	mov	r0,8
8000de3c:	e0 61 05 78 	mov	r1,1400
8000de40:	02 30       	cp.w	r0,r1
8000de42:	c0 72       	brcc	8000de50 <idata_load_loop_end>
8000de44:	fe c2 88 fc 	sub	r2,pc,-30468

8000de48 <idata_load_loop>:
8000de48:	a5 05       	ld.d	r4,r2++
8000de4a:	a1 24       	st.d	r0++,r4
8000de4c:	02 30       	cp.w	r0,r1
8000de4e:	cf d3       	brcs	8000de48 <idata_load_loop>

8000de50 <idata_load_loop_end>:
8000de50:	e0 60 05 78 	mov	r0,1400
8000de54:	e0 61 79 a0 	mov	r1,31136
8000de58:	02 30       	cp.w	r0,r1
8000de5a:	c0 62       	brcc	8000de66 <udata_clear_loop_end>
8000de5c:	30 02       	mov	r2,0
8000de5e:	30 03       	mov	r3,0

8000de60 <udata_clear_loop>:
8000de60:	a1 22       	st.d	r0++,r2
8000de62:	02 30       	cp.w	r0,r1
8000de64:	cf e3       	brcs	8000de60 <udata_clear_loop>

8000de66 <udata_clear_loop_end>:
8000de66:	fe cf 56 ea 	sub	pc,pc,22250
8000de6a:	d7 03       	nop

8000de6c <__avr32_f32_to_s32>:
8000de6c:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
8000de70:	27 fb       	sub	r11,127
8000de72:	5e 3d       	retlo	0
8000de74:	f6 0b 11 1f 	rsub	r11,r11,31
8000de78:	f8 0a 15 08 	lsl	r10,r12,0x8
8000de7c:	bf ba       	sbr	r10,0x1f
8000de7e:	f4 0b 0a 4a 	lsr	r10,r10,r11
8000de82:	a1 7c       	lsl	r12,0x1
8000de84:	5e 2a       	reths	r10
8000de86:	5c 3a       	neg	r10
8000de88:	5e fa       	retal	r10

8000de8a <__avr32_udiv64>:
8000de8a:	d4 31       	pushm	r0-r7,lr
8000de8c:	1a 97       	mov	r7,sp
8000de8e:	20 2d       	sub	sp,8
8000de90:	10 9e       	mov	lr,r8
8000de92:	12 95       	mov	r5,r9
8000de94:	14 96       	mov	r6,r10
8000de96:	58 09       	cp.w	r9,0
8000de98:	c4 91       	brne	8000df2a <__avr32_udiv64+0xa0>
8000de9a:	16 38       	cp.w	r8,r11
8000de9c:	e0 88 00 57 	brls	8000df4a <__avr32_udiv64+0xc0>
8000dea0:	f0 08 12 00 	clz	r8,r8
8000dea4:	c0 d0       	breq	8000debe <__avr32_udiv64+0x34>
8000dea6:	f6 08 09 4b 	lsl	r11,r11,r8
8000deaa:	f0 09 11 20 	rsub	r9,r8,32
8000deae:	fc 08 09 4e 	lsl	lr,lr,r8
8000deb2:	f4 09 0a 49 	lsr	r9,r10,r9
8000deb6:	f4 08 09 46 	lsl	r6,r10,r8
8000deba:	f3 eb 10 0b 	or	r11,r9,r11
8000debe:	fc 05 16 10 	lsr	r5,lr,0x10
8000dec2:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
8000dec6:	f6 05 0d 0a 	divu	r10,r11,r5
8000deca:	ec 08 16 10 	lsr	r8,r6,0x10
8000dece:	14 99       	mov	r9,r10
8000ded0:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000ded4:	b9 3a       	mul	r10,r12
8000ded6:	10 3a       	cp.w	r10,r8
8000ded8:	e0 88 00 0c 	brls	8000def0 <__avr32_udiv64+0x66>
8000dedc:	20 19       	sub	r9,1
8000dede:	1c 08       	add	r8,lr
8000dee0:	10 3e       	cp.w	lr,r8
8000dee2:	e0 8b 00 07 	brhi	8000def0 <__avr32_udiv64+0x66>
8000dee6:	10 3a       	cp.w	r10,r8
8000dee8:	f7 b9 0b 01 	subhi	r9,1
8000deec:	f1 de eb 08 	addhi	r8,r8,lr
8000def0:	f0 0a 01 0b 	sub	r11,r8,r10
8000def4:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000def8:	f6 05 0d 0a 	divu	r10,r11,r5
8000defc:	ed eb 11 06 	or	r6,r6,r11<<0x10
8000df00:	14 98       	mov	r8,r10
8000df02:	f4 0c 02 4c 	mul	r12,r10,r12
8000df06:	0c 3c       	cp.w	r12,r6
8000df08:	e0 88 00 0a 	brls	8000df1c <__avr32_udiv64+0x92>
8000df0c:	20 18       	sub	r8,1
8000df0e:	1c 06       	add	r6,lr
8000df10:	0c 3e       	cp.w	lr,r6
8000df12:	e0 8b 00 05 	brhi	8000df1c <__avr32_udiv64+0x92>
8000df16:	0c 3c       	cp.w	r12,r6
8000df18:	f7 b8 0b 01 	subhi	r8,1
8000df1c:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
8000df20:	30 0c       	mov	r12,0
8000df22:	16 9a       	mov	r10,r11
8000df24:	18 9b       	mov	r11,r12
8000df26:	2f ed       	sub	sp,-8
8000df28:	d8 32       	popm	r0-r7,pc
8000df2a:	16 39       	cp.w	r9,r11
8000df2c:	e0 8b 00 51 	brhi	8000dfce <__avr32_udiv64+0x144>
8000df30:	f2 0c 12 00 	clz	r12,r9
8000df34:	c5 31       	brne	8000dfda <__avr32_udiv64+0x150>
8000df36:	14 38       	cp.w	r8,r10
8000df38:	5f 89       	srls	r9
8000df3a:	16 35       	cp.w	r5,r11
8000df3c:	5f 38       	srlo	r8
8000df3e:	10 49       	or	r9,r8
8000df40:	f8 09 18 00 	cp.b	r9,r12
8000df44:	c4 50       	breq	8000dfce <__avr32_udiv64+0x144>
8000df46:	30 1b       	mov	r11,1
8000df48:	c4 58       	rjmp	8000dfd2 <__avr32_udiv64+0x148>
8000df4a:	58 08       	cp.w	r8,0
8000df4c:	c0 51       	brne	8000df56 <__avr32_udiv64+0xcc>
8000df4e:	30 19       	mov	r9,1
8000df50:	f2 08 0d 08 	divu	r8,r9,r8
8000df54:	10 9e       	mov	lr,r8
8000df56:	fc 08 12 00 	clz	r8,lr
8000df5a:	e0 81 00 91 	brne	8000e07c <__avr32_udiv64+0x1f2>
8000df5e:	1c 1b       	sub	r11,lr
8000df60:	fc 05 16 10 	lsr	r5,lr,0x10
8000df64:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000df68:	30 1c       	mov	r12,1
8000df6a:	f6 05 0d 0a 	divu	r10,r11,r5
8000df6e:	ec 08 16 10 	lsr	r8,r6,0x10
8000df72:	f4 09 02 43 	mul	r3,r10,r9
8000df76:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000df7a:	14 9b       	mov	r11,r10
8000df7c:	10 33       	cp.w	r3,r8
8000df7e:	e0 88 00 0c 	brls	8000df96 <__avr32_udiv64+0x10c>
8000df82:	20 1b       	sub	r11,1
8000df84:	1c 08       	add	r8,lr
8000df86:	10 3e       	cp.w	lr,r8
8000df88:	e0 8b 00 07 	brhi	8000df96 <__avr32_udiv64+0x10c>
8000df8c:	10 33       	cp.w	r3,r8
8000df8e:	f7 bb 0b 01 	subhi	r11,1
8000df92:	f1 de eb 08 	addhi	r8,r8,lr
8000df96:	f0 03 01 03 	sub	r3,r8,r3
8000df9a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000df9e:	e6 05 0d 02 	divu	r2,r3,r5
8000dfa2:	ed e3 11 06 	or	r6,r6,r3<<0x10
8000dfa6:	04 98       	mov	r8,r2
8000dfa8:	e4 09 02 49 	mul	r9,r2,r9
8000dfac:	0c 39       	cp.w	r9,r6
8000dfae:	e0 88 00 0a 	brls	8000dfc2 <__avr32_udiv64+0x138>
8000dfb2:	20 18       	sub	r8,1
8000dfb4:	1c 06       	add	r6,lr
8000dfb6:	0c 3e       	cp.w	lr,r6
8000dfb8:	e0 8b 00 05 	brhi	8000dfc2 <__avr32_udiv64+0x138>
8000dfbc:	0c 39       	cp.w	r9,r6
8000dfbe:	f7 b8 0b 01 	subhi	r8,1
8000dfc2:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
8000dfc6:	16 9a       	mov	r10,r11
8000dfc8:	18 9b       	mov	r11,r12
8000dfca:	2f ed       	sub	sp,-8
8000dfcc:	d8 32       	popm	r0-r7,pc
8000dfce:	30 0b       	mov	r11,0
8000dfd0:	16 9c       	mov	r12,r11
8000dfd2:	16 9a       	mov	r10,r11
8000dfd4:	18 9b       	mov	r11,r12
8000dfd6:	2f ed       	sub	sp,-8
8000dfd8:	d8 32       	popm	r0-r7,pc
8000dfda:	f2 0c 09 45 	lsl	r5,r9,r12
8000dfde:	f8 0e 11 20 	rsub	lr,r12,32
8000dfe2:	f0 0c 09 43 	lsl	r3,r8,r12
8000dfe6:	f4 0e 0a 46 	lsr	r6,r10,lr
8000dfea:	f0 0e 0a 48 	lsr	r8,r8,lr
8000dfee:	f6 0e 0a 4e 	lsr	lr,r11,lr
8000dff2:	0a 48       	or	r8,r5
8000dff4:	f0 01 16 10 	lsr	r1,r8,0x10
8000dff8:	fc 01 0d 04 	divu	r4,lr,r1
8000dffc:	ee e5 ff f8 	st.d	r7[-8],r4
8000e000:	f6 0c 09 49 	lsl	r9,r11,r12
8000e004:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
8000e008:	ed e9 10 09 	or	r9,r6,r9
8000e00c:	08 96       	mov	r6,r4
8000e00e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000e012:	ee f4 ff f8 	ld.w	r4,r7[-8]
8000e016:	ec 05 02 4b 	mul	r11,r6,r5
8000e01a:	fd e4 11 0e 	or	lr,lr,r4<<0x10
8000e01e:	1c 3b       	cp.w	r11,lr
8000e020:	e0 88 00 07 	brls	8000e02e <__avr32_udiv64+0x1a4>
8000e024:	20 16       	sub	r6,1
8000e026:	10 0e       	add	lr,r8
8000e028:	1c 38       	cp.w	r8,lr
8000e02a:	e0 88 00 6d 	brls	8000e104 <__avr32_udiv64+0x27a>
8000e02e:	16 1e       	sub	lr,r11
8000e030:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000e034:	fc 01 0d 00 	divu	r0,lr,r1
8000e038:	f3 e1 11 09 	or	r9,r9,r1<<0x10
8000e03c:	00 9b       	mov	r11,r0
8000e03e:	e0 05 02 4e 	mul	lr,r0,r5
8000e042:	12 3e       	cp.w	lr,r9
8000e044:	e0 88 00 07 	brls	8000e052 <__avr32_udiv64+0x1c8>
8000e048:	20 1b       	sub	r11,1
8000e04a:	10 09       	add	r9,r8
8000e04c:	12 38       	cp.w	r8,r9
8000e04e:	e0 88 00 55 	brls	8000e0f8 <__avr32_udiv64+0x26e>
8000e052:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
8000e056:	1c 19       	sub	r9,lr
8000e058:	f6 03 06 42 	mulu.d	r2,r11,r3
8000e05c:	06 39       	cp.w	r9,r3
8000e05e:	c0 93       	brcs	8000e070 <__avr32_udiv64+0x1e6>
8000e060:	5f 09       	sreq	r9
8000e062:	f4 0c 09 4c 	lsl	r12,r10,r12
8000e066:	04 3c       	cp.w	r12,r2
8000e068:	5f 38       	srlo	r8
8000e06a:	f3 e8 00 08 	and	r8,r9,r8
8000e06e:	c0 20       	breq	8000e072 <__avr32_udiv64+0x1e8>
8000e070:	20 1b       	sub	r11,1
8000e072:	30 0c       	mov	r12,0
8000e074:	16 9a       	mov	r10,r11
8000e076:	18 9b       	mov	r11,r12
8000e078:	2f ed       	sub	sp,-8
8000e07a:	d8 32       	popm	r0-r7,pc
8000e07c:	f6 08 09 49 	lsl	r9,r11,r8
8000e080:	fc 08 09 4e 	lsl	lr,lr,r8
8000e084:	f0 01 11 20 	rsub	r1,r8,32
8000e088:	fc 05 16 10 	lsr	r5,lr,0x10
8000e08c:	f4 01 0a 42 	lsr	r2,r10,r1
8000e090:	f6 01 0a 41 	lsr	r1,r11,r1
8000e094:	12 42       	or	r2,r9
8000e096:	e2 05 0d 00 	divu	r0,r1,r5
8000e09a:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000e09e:	e4 06 16 10 	lsr	r6,r2,0x10
8000e0a2:	00 93       	mov	r3,r0
8000e0a4:	ed e1 11 06 	or	r6,r6,r1<<0x10
8000e0a8:	e0 09 02 4c 	mul	r12,r0,r9
8000e0ac:	0c 3c       	cp.w	r12,r6
8000e0ae:	e0 88 00 07 	brls	8000e0bc <__avr32_udiv64+0x232>
8000e0b2:	20 13       	sub	r3,1
8000e0b4:	1c 06       	add	r6,lr
8000e0b6:	0c 3e       	cp.w	lr,r6
8000e0b8:	e0 88 00 2c 	brls	8000e110 <__avr32_udiv64+0x286>
8000e0bc:	ec 0c 01 01 	sub	r1,r6,r12
8000e0c0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000e0c4:	e2 05 0d 00 	divu	r0,r1,r5
8000e0c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000e0cc:	00 9c       	mov	r12,r0
8000e0ce:	e0 09 02 41 	mul	r1,r0,r9
8000e0d2:	16 31       	cp.w	r1,r11
8000e0d4:	e0 88 00 0c 	brls	8000e0ec <__avr32_udiv64+0x262>
8000e0d8:	20 1c       	sub	r12,1
8000e0da:	1c 0b       	add	r11,lr
8000e0dc:	16 3e       	cp.w	lr,r11
8000e0de:	e0 8b 00 07 	brhi	8000e0ec <__avr32_udiv64+0x262>
8000e0e2:	16 31       	cp.w	r1,r11
8000e0e4:	f7 bc 0b 01 	subhi	r12,1
8000e0e8:	f7 de eb 0b 	addhi	r11,r11,lr
8000e0ec:	f4 08 09 46 	lsl	r6,r10,r8
8000e0f0:	02 1b       	sub	r11,r1
8000e0f2:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
8000e0f6:	c3 ab       	rjmp	8000df6a <__avr32_udiv64+0xe0>
8000e0f8:	12 3e       	cp.w	lr,r9
8000e0fa:	f3 d8 eb 09 	addhi	r9,r9,r8
8000e0fe:	f7 bb 0b 01 	subhi	r11,1
8000e102:	ca 8b       	rjmp	8000e052 <__avr32_udiv64+0x1c8>
8000e104:	1c 3b       	cp.w	r11,lr
8000e106:	f7 b6 0b 01 	subhi	r6,1
8000e10a:	fd d8 eb 0e 	addhi	lr,lr,r8
8000e10e:	c9 0b       	rjmp	8000e02e <__avr32_udiv64+0x1a4>
8000e110:	0c 3c       	cp.w	r12,r6
8000e112:	f7 b3 0b 01 	subhi	r3,1
8000e116:	ed de eb 06 	addhi	r6,r6,lr
8000e11a:	cd 1b       	rjmp	8000e0bc <__avr32_udiv64+0x232>

8000e11c <_fclose_r>:
8000e11c:	d4 21       	pushm	r4-r7,lr
8000e11e:	18 96       	mov	r6,r12
8000e120:	16 97       	mov	r7,r11
8000e122:	58 0b       	cp.w	r11,0
8000e124:	c0 31       	brne	8000e12a <_fclose_r+0xe>
8000e126:	16 95       	mov	r5,r11
8000e128:	c4 b8       	rjmp	8000e1be <_fclose_r+0xa2>
8000e12a:	cd bc       	rcall	8000e2e0 <__sfp_lock_acquire>
8000e12c:	58 06       	cp.w	r6,0
8000e12e:	c0 60       	breq	8000e13a <_fclose_r+0x1e>
8000e130:	6c 68       	ld.w	r8,r6[0x18]
8000e132:	58 08       	cp.w	r8,0
8000e134:	c0 31       	brne	8000e13a <_fclose_r+0x1e>
8000e136:	0c 9c       	mov	r12,r6
8000e138:	c2 6d       	rcall	8000e384 <__sinit>
8000e13a:	fe c8 91 62 	sub	r8,pc,-28318
8000e13e:	10 37       	cp.w	r7,r8
8000e140:	c0 31       	brne	8000e146 <_fclose_r+0x2a>
8000e142:	6c 07       	ld.w	r7,r6[0x0]
8000e144:	c0 c8       	rjmp	8000e15c <_fclose_r+0x40>
8000e146:	fe c8 91 4e 	sub	r8,pc,-28338
8000e14a:	10 37       	cp.w	r7,r8
8000e14c:	c0 31       	brne	8000e152 <_fclose_r+0x36>
8000e14e:	6c 17       	ld.w	r7,r6[0x4]
8000e150:	c0 68       	rjmp	8000e15c <_fclose_r+0x40>
8000e152:	fe c8 91 3a 	sub	r8,pc,-28358
8000e156:	10 37       	cp.w	r7,r8
8000e158:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e15c:	8e 69       	ld.sh	r9,r7[0xc]
8000e15e:	30 08       	mov	r8,0
8000e160:	f0 09 19 00 	cp.h	r9,r8
8000e164:	c0 41       	brne	8000e16c <_fclose_r+0x50>
8000e166:	cb ec       	rcall	8000e2e2 <__sfp_lock_release>
8000e168:	30 05       	mov	r5,0
8000e16a:	c2 a8       	rjmp	8000e1be <_fclose_r+0xa2>
8000e16c:	0e 9b       	mov	r11,r7
8000e16e:	0c 9c       	mov	r12,r6
8000e170:	c3 2c       	rcall	8000e1d4 <_fflush_r>
8000e172:	6e c8       	ld.w	r8,r7[0x30]
8000e174:	18 95       	mov	r5,r12
8000e176:	58 08       	cp.w	r8,0
8000e178:	c0 60       	breq	8000e184 <_fclose_r+0x68>
8000e17a:	6e 8b       	ld.w	r11,r7[0x20]
8000e17c:	0c 9c       	mov	r12,r6
8000e17e:	5d 18       	icall	r8
8000e180:	f9 b5 05 ff 	movlt	r5,-1
8000e184:	8e 68       	ld.sh	r8,r7[0xc]
8000e186:	ed b8 00 07 	bld	r8,0x7
8000e18a:	c0 41       	brne	8000e192 <_fclose_r+0x76>
8000e18c:	6e 4b       	ld.w	r11,r7[0x10]
8000e18e:	0c 9c       	mov	r12,r6
8000e190:	c9 4d       	rcall	8000e4b8 <_free_r>
8000e192:	6e db       	ld.w	r11,r7[0x34]
8000e194:	58 0b       	cp.w	r11,0
8000e196:	c0 90       	breq	8000e1a8 <_fclose_r+0x8c>
8000e198:	ee c8 ff bc 	sub	r8,r7,-68
8000e19c:	10 3b       	cp.w	r11,r8
8000e19e:	c0 30       	breq	8000e1a4 <_fclose_r+0x88>
8000e1a0:	0c 9c       	mov	r12,r6
8000e1a2:	c8 bd       	rcall	8000e4b8 <_free_r>
8000e1a4:	30 08       	mov	r8,0
8000e1a6:	8f d8       	st.w	r7[0x34],r8
8000e1a8:	6f 2b       	ld.w	r11,r7[0x48]
8000e1aa:	58 0b       	cp.w	r11,0
8000e1ac:	c0 60       	breq	8000e1b8 <_fclose_r+0x9c>
8000e1ae:	0c 9c       	mov	r12,r6
8000e1b0:	c8 4d       	rcall	8000e4b8 <_free_r>
8000e1b2:	30 08       	mov	r8,0
8000e1b4:	ef 48 00 48 	st.w	r7[72],r8
8000e1b8:	30 08       	mov	r8,0
8000e1ba:	ae 68       	st.h	r7[0xc],r8
8000e1bc:	c9 3c       	rcall	8000e2e2 <__sfp_lock_release>
8000e1be:	0a 9c       	mov	r12,r5
8000e1c0:	d8 22       	popm	r4-r7,pc
8000e1c2:	d7 03       	nop

8000e1c4 <fclose>:
8000e1c4:	d4 01       	pushm	lr
8000e1c6:	e0 68 01 60 	mov	r8,352
8000e1ca:	18 9b       	mov	r11,r12
8000e1cc:	70 0c       	ld.w	r12,r8[0x0]
8000e1ce:	ca 7f       	rcall	8000e11c <_fclose_r>
8000e1d0:	d8 02       	popm	pc
8000e1d2:	d7 03       	nop

8000e1d4 <_fflush_r>:
8000e1d4:	d4 21       	pushm	r4-r7,lr
8000e1d6:	16 97       	mov	r7,r11
8000e1d8:	18 96       	mov	r6,r12
8000e1da:	76 48       	ld.w	r8,r11[0x10]
8000e1dc:	58 08       	cp.w	r8,0
8000e1de:	c7 f0       	breq	8000e2dc <_fflush_r+0x108>
8000e1e0:	58 0c       	cp.w	r12,0
8000e1e2:	c0 50       	breq	8000e1ec <_fflush_r+0x18>
8000e1e4:	78 68       	ld.w	r8,r12[0x18]
8000e1e6:	58 08       	cp.w	r8,0
8000e1e8:	c0 21       	brne	8000e1ec <_fflush_r+0x18>
8000e1ea:	cc dc       	rcall	8000e384 <__sinit>
8000e1ec:	fe c8 92 14 	sub	r8,pc,-28140
8000e1f0:	10 37       	cp.w	r7,r8
8000e1f2:	c0 31       	brne	8000e1f8 <_fflush_r+0x24>
8000e1f4:	6c 07       	ld.w	r7,r6[0x0]
8000e1f6:	c0 c8       	rjmp	8000e20e <_fflush_r+0x3a>
8000e1f8:	fe c8 92 00 	sub	r8,pc,-28160
8000e1fc:	10 37       	cp.w	r7,r8
8000e1fe:	c0 31       	brne	8000e204 <_fflush_r+0x30>
8000e200:	6c 17       	ld.w	r7,r6[0x4]
8000e202:	c0 68       	rjmp	8000e20e <_fflush_r+0x3a>
8000e204:	fe c8 91 ec 	sub	r8,pc,-28180
8000e208:	10 37       	cp.w	r7,r8
8000e20a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e20e:	8e 6a       	ld.sh	r10,r7[0xc]
8000e210:	14 98       	mov	r8,r10
8000e212:	ed ba 00 03 	bld	r10,0x3
8000e216:	c4 20       	breq	8000e29a <_fflush_r+0xc6>
8000e218:	ab ba       	sbr	r10,0xb
8000e21a:	ae 6a       	st.h	r7[0xc],r10
8000e21c:	6e 18       	ld.w	r8,r7[0x4]
8000e21e:	58 08       	cp.w	r8,0
8000e220:	e0 89 00 06 	brgt	8000e22c <_fflush_r+0x58>
8000e224:	6f 08       	ld.w	r8,r7[0x40]
8000e226:	58 08       	cp.w	r8,0
8000e228:	e0 8a 00 5a 	brle	8000e2dc <_fflush_r+0x108>
8000e22c:	6e b8       	ld.w	r8,r7[0x2c]
8000e22e:	58 08       	cp.w	r8,0
8000e230:	c5 60       	breq	8000e2dc <_fflush_r+0x108>
8000e232:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e236:	c0 30       	breq	8000e23c <_fflush_r+0x68>
8000e238:	6f 55       	ld.w	r5,r7[0x54]
8000e23a:	c0 f8       	rjmp	8000e258 <_fflush_r+0x84>
8000e23c:	30 19       	mov	r9,1
8000e23e:	6e 8b       	ld.w	r11,r7[0x20]
8000e240:	0c 9c       	mov	r12,r6
8000e242:	5d 18       	icall	r8
8000e244:	18 95       	mov	r5,r12
8000e246:	5b fc       	cp.w	r12,-1
8000e248:	c0 81       	brne	8000e258 <_fflush_r+0x84>
8000e24a:	6c 38       	ld.w	r8,r6[0xc]
8000e24c:	59 d8       	cp.w	r8,29
8000e24e:	c4 70       	breq	8000e2dc <_fflush_r+0x108>
8000e250:	8e 68       	ld.sh	r8,r7[0xc]
8000e252:	a7 a8       	sbr	r8,0x6
8000e254:	ae 68       	st.h	r7[0xc],r8
8000e256:	d8 22       	popm	r4-r7,pc
8000e258:	8e 68       	ld.sh	r8,r7[0xc]
8000e25a:	ed b8 00 02 	bld	r8,0x2
8000e25e:	c0 91       	brne	8000e270 <_fflush_r+0x9c>
8000e260:	6e 18       	ld.w	r8,r7[0x4]
8000e262:	10 15       	sub	r5,r8
8000e264:	6e d8       	ld.w	r8,r7[0x34]
8000e266:	58 08       	cp.w	r8,0
8000e268:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e26c:	eb d8 e1 15 	subne	r5,r5,r8
8000e270:	6e b8       	ld.w	r8,r7[0x2c]
8000e272:	0c 9c       	mov	r12,r6
8000e274:	30 09       	mov	r9,0
8000e276:	0a 9a       	mov	r10,r5
8000e278:	6e 8b       	ld.w	r11,r7[0x20]
8000e27a:	5d 18       	icall	r8
8000e27c:	8e 68       	ld.sh	r8,r7[0xc]
8000e27e:	0a 3c       	cp.w	r12,r5
8000e280:	c2 61       	brne	8000e2cc <_fflush_r+0xf8>
8000e282:	ab d8       	cbr	r8,0xb
8000e284:	30 0c       	mov	r12,0
8000e286:	6e 49       	ld.w	r9,r7[0x10]
8000e288:	ae 68       	st.h	r7[0xc],r8
8000e28a:	8f 1c       	st.w	r7[0x4],r12
8000e28c:	8f 09       	st.w	r7[0x0],r9
8000e28e:	ed b8 00 0c 	bld	r8,0xc
8000e292:	c2 51       	brne	8000e2dc <_fflush_r+0x108>
8000e294:	ef 45 00 54 	st.w	r7[84],r5
8000e298:	d8 22       	popm	r4-r7,pc
8000e29a:	6e 45       	ld.w	r5,r7[0x10]
8000e29c:	58 05       	cp.w	r5,0
8000e29e:	c1 f0       	breq	8000e2dc <_fflush_r+0x108>
8000e2a0:	6e 04       	ld.w	r4,r7[0x0]
8000e2a2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e2a6:	8f 05       	st.w	r7[0x0],r5
8000e2a8:	f9 b8 01 00 	movne	r8,0
8000e2ac:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e2b0:	0a 14       	sub	r4,r5
8000e2b2:	8f 28       	st.w	r7[0x8],r8
8000e2b4:	c1 18       	rjmp	8000e2d6 <_fflush_r+0x102>
8000e2b6:	08 99       	mov	r9,r4
8000e2b8:	0a 9a       	mov	r10,r5
8000e2ba:	6e a8       	ld.w	r8,r7[0x28]
8000e2bc:	6e 8b       	ld.w	r11,r7[0x20]
8000e2be:	0c 9c       	mov	r12,r6
8000e2c0:	5d 18       	icall	r8
8000e2c2:	18 14       	sub	r4,r12
8000e2c4:	58 0c       	cp.w	r12,0
8000e2c6:	e0 89 00 07 	brgt	8000e2d4 <_fflush_r+0x100>
8000e2ca:	8e 68       	ld.sh	r8,r7[0xc]
8000e2cc:	a7 a8       	sbr	r8,0x6
8000e2ce:	3f fc       	mov	r12,-1
8000e2d0:	ae 68       	st.h	r7[0xc],r8
8000e2d2:	d8 22       	popm	r4-r7,pc
8000e2d4:	18 05       	add	r5,r12
8000e2d6:	58 04       	cp.w	r4,0
8000e2d8:	fe 99 ff ef 	brgt	8000e2b6 <_fflush_r+0xe2>
8000e2dc:	d8 2a       	popm	r4-r7,pc,r12=0
8000e2de:	d7 03       	nop

8000e2e0 <__sfp_lock_acquire>:
8000e2e0:	5e fc       	retal	r12

8000e2e2 <__sfp_lock_release>:
8000e2e2:	5e fc       	retal	r12

8000e2e4 <_cleanup_r>:
8000e2e4:	d4 01       	pushm	lr
8000e2e6:	fe cb 01 22 	sub	r11,pc,290
8000e2ea:	cb fd       	rcall	8000e668 <_fwalk>
8000e2ec:	d8 02       	popm	pc
8000e2ee:	d7 03       	nop

8000e2f0 <__sfmoreglue>:
8000e2f0:	d4 21       	pushm	r4-r7,lr
8000e2f2:	16 95       	mov	r5,r11
8000e2f4:	f6 06 10 5c 	mul	r6,r11,92
8000e2f8:	ec cb ff f4 	sub	r11,r6,-12
8000e2fc:	e0 a0 02 4a 	rcall	8000e790 <_malloc_r>
8000e300:	18 97       	mov	r7,r12
8000e302:	c0 90       	breq	8000e314 <__sfmoreglue+0x24>
8000e304:	99 15       	st.w	r12[0x4],r5
8000e306:	30 0b       	mov	r11,0
8000e308:	2f 4c       	sub	r12,-12
8000e30a:	0c 9a       	mov	r10,r6
8000e30c:	8f 2c       	st.w	r7[0x8],r12
8000e30e:	8f 0b       	st.w	r7[0x0],r11
8000e310:	e0 a0 04 fe 	rcall	8000ed0c <memset>
8000e314:	0e 9c       	mov	r12,r7
8000e316:	d8 22       	popm	r4-r7,pc

8000e318 <__sfp>:
8000e318:	d4 21       	pushm	r4-r7,lr
8000e31a:	fe c8 92 de 	sub	r8,pc,-27938
8000e31e:	18 96       	mov	r6,r12
8000e320:	70 07       	ld.w	r7,r8[0x0]
8000e322:	6e 68       	ld.w	r8,r7[0x18]
8000e324:	58 08       	cp.w	r8,0
8000e326:	c0 31       	brne	8000e32c <__sfp+0x14>
8000e328:	0e 9c       	mov	r12,r7
8000e32a:	c2 dc       	rcall	8000e384 <__sinit>
8000e32c:	ee c7 ff 28 	sub	r7,r7,-216
8000e330:	30 05       	mov	r5,0
8000e332:	6e 2c       	ld.w	r12,r7[0x8]
8000e334:	6e 18       	ld.w	r8,r7[0x4]
8000e336:	c0 68       	rjmp	8000e342 <__sfp+0x2a>
8000e338:	98 69       	ld.sh	r9,r12[0xc]
8000e33a:	ea 09 19 00 	cp.h	r9,r5
8000e33e:	c1 10       	breq	8000e360 <__sfp+0x48>
8000e340:	2a 4c       	sub	r12,-92
8000e342:	20 18       	sub	r8,1
8000e344:	cf a7       	brpl	8000e338 <__sfp+0x20>
8000e346:	6e 08       	ld.w	r8,r7[0x0]
8000e348:	58 08       	cp.w	r8,0
8000e34a:	c0 61       	brne	8000e356 <__sfp+0x3e>
8000e34c:	30 4b       	mov	r11,4
8000e34e:	0c 9c       	mov	r12,r6
8000e350:	cd 0f       	rcall	8000e2f0 <__sfmoreglue>
8000e352:	8f 0c       	st.w	r7[0x0],r12
8000e354:	c0 30       	breq	8000e35a <__sfp+0x42>
8000e356:	6e 07       	ld.w	r7,r7[0x0]
8000e358:	ce db       	rjmp	8000e332 <__sfp+0x1a>
8000e35a:	30 c8       	mov	r8,12
8000e35c:	8d 38       	st.w	r6[0xc],r8
8000e35e:	d8 22       	popm	r4-r7,pc
8000e360:	30 08       	mov	r8,0
8000e362:	f9 48 00 4c 	st.w	r12[76],r8
8000e366:	99 08       	st.w	r12[0x0],r8
8000e368:	99 28       	st.w	r12[0x8],r8
8000e36a:	99 18       	st.w	r12[0x4],r8
8000e36c:	99 48       	st.w	r12[0x10],r8
8000e36e:	99 58       	st.w	r12[0x14],r8
8000e370:	99 68       	st.w	r12[0x18],r8
8000e372:	99 d8       	st.w	r12[0x34],r8
8000e374:	99 e8       	st.w	r12[0x38],r8
8000e376:	f9 48 00 48 	st.w	r12[72],r8
8000e37a:	3f f8       	mov	r8,-1
8000e37c:	b8 78       	st.h	r12[0xe],r8
8000e37e:	30 18       	mov	r8,1
8000e380:	b8 68       	st.h	r12[0xc],r8
8000e382:	d8 22       	popm	r4-r7,pc

8000e384 <__sinit>:
8000e384:	d4 21       	pushm	r4-r7,lr
8000e386:	18 96       	mov	r6,r12
8000e388:	78 67       	ld.w	r7,r12[0x18]
8000e38a:	58 07       	cp.w	r7,0
8000e38c:	c4 91       	brne	8000e41e <__sinit+0x9a>
8000e38e:	fe c8 00 aa 	sub	r8,pc,170
8000e392:	30 15       	mov	r5,1
8000e394:	99 a8       	st.w	r12[0x28],r8
8000e396:	f9 47 00 d8 	st.w	r12[216],r7
8000e39a:	f9 47 00 dc 	st.w	r12[220],r7
8000e39e:	f9 47 00 e0 	st.w	r12[224],r7
8000e3a2:	99 65       	st.w	r12[0x18],r5
8000e3a4:	cb af       	rcall	8000e318 <__sfp>
8000e3a6:	8d 0c       	st.w	r6[0x0],r12
8000e3a8:	0c 9c       	mov	r12,r6
8000e3aa:	cb 7f       	rcall	8000e318 <__sfp>
8000e3ac:	8d 1c       	st.w	r6[0x4],r12
8000e3ae:	0c 9c       	mov	r12,r6
8000e3b0:	cb 4f       	rcall	8000e318 <__sfp>
8000e3b2:	6c 09       	ld.w	r9,r6[0x0]
8000e3b4:	30 48       	mov	r8,4
8000e3b6:	93 07       	st.w	r9[0x0],r7
8000e3b8:	b2 68       	st.h	r9[0xc],r8
8000e3ba:	93 17       	st.w	r9[0x4],r7
8000e3bc:	93 27       	st.w	r9[0x8],r7
8000e3be:	6c 18       	ld.w	r8,r6[0x4]
8000e3c0:	b2 77       	st.h	r9[0xe],r7
8000e3c2:	93 47       	st.w	r9[0x10],r7
8000e3c4:	93 57       	st.w	r9[0x14],r7
8000e3c6:	93 67       	st.w	r9[0x18],r7
8000e3c8:	93 89       	st.w	r9[0x20],r9
8000e3ca:	91 07       	st.w	r8[0x0],r7
8000e3cc:	91 17       	st.w	r8[0x4],r7
8000e3ce:	91 27       	st.w	r8[0x8],r7
8000e3d0:	fe ce f6 00 	sub	lr,pc,-2560
8000e3d4:	fe cb f6 34 	sub	r11,pc,-2508
8000e3d8:	93 9e       	st.w	r9[0x24],lr
8000e3da:	93 ab       	st.w	r9[0x28],r11
8000e3dc:	fe ca f6 64 	sub	r10,pc,-2460
8000e3e0:	fe c4 f6 74 	sub	r4,pc,-2444
8000e3e4:	93 ba       	st.w	r9[0x2c],r10
8000e3e6:	93 c4       	st.w	r9[0x30],r4
8000e3e8:	30 99       	mov	r9,9
8000e3ea:	b0 69       	st.h	r8[0xc],r9
8000e3ec:	b0 75       	st.h	r8[0xe],r5
8000e3ee:	91 c4       	st.w	r8[0x30],r4
8000e3f0:	91 47       	st.w	r8[0x10],r7
8000e3f2:	91 57       	st.w	r8[0x14],r7
8000e3f4:	91 67       	st.w	r8[0x18],r7
8000e3f6:	91 88       	st.w	r8[0x20],r8
8000e3f8:	91 9e       	st.w	r8[0x24],lr
8000e3fa:	91 ab       	st.w	r8[0x28],r11
8000e3fc:	91 ba       	st.w	r8[0x2c],r10
8000e3fe:	8d 2c       	st.w	r6[0x8],r12
8000e400:	31 28       	mov	r8,18
8000e402:	99 07       	st.w	r12[0x0],r7
8000e404:	b8 68       	st.h	r12[0xc],r8
8000e406:	99 17       	st.w	r12[0x4],r7
8000e408:	99 27       	st.w	r12[0x8],r7
8000e40a:	30 28       	mov	r8,2
8000e40c:	b8 78       	st.h	r12[0xe],r8
8000e40e:	99 c4       	st.w	r12[0x30],r4
8000e410:	99 67       	st.w	r12[0x18],r7
8000e412:	99 9e       	st.w	r12[0x24],lr
8000e414:	99 ab       	st.w	r12[0x28],r11
8000e416:	99 ba       	st.w	r12[0x2c],r10
8000e418:	99 47       	st.w	r12[0x10],r7
8000e41a:	99 57       	st.w	r12[0x14],r7
8000e41c:	99 8c       	st.w	r12[0x20],r12
8000e41e:	d8 22       	popm	r4-r7,pc

8000e420 <_malloc_trim_r>:
8000e420:	d4 21       	pushm	r4-r7,lr
8000e422:	16 95       	mov	r5,r11
8000e424:	18 97       	mov	r7,r12
8000e426:	e0 a0 04 7a 	rcall	8000ed1a <__malloc_lock>
8000e42a:	e0 64 01 64 	mov	r4,356
8000e42e:	68 28       	ld.w	r8,r4[0x8]
8000e430:	70 16       	ld.w	r6,r8[0x4]
8000e432:	e0 16 ff fc 	andl	r6,0xfffc
8000e436:	ec c8 ff 91 	sub	r8,r6,-111
8000e43a:	f0 05 01 05 	sub	r5,r8,r5
8000e43e:	e0 15 ff 80 	andl	r5,0xff80
8000e442:	ea c5 00 80 	sub	r5,r5,128
8000e446:	e0 45 00 7f 	cp.w	r5,127
8000e44a:	e0 8a 00 25 	brle	8000e494 <_malloc_trim_r+0x74>
8000e44e:	30 0b       	mov	r11,0
8000e450:	0e 9c       	mov	r12,r7
8000e452:	e0 a0 04 7d 	rcall	8000ed4c <_sbrk_r>
8000e456:	68 28       	ld.w	r8,r4[0x8]
8000e458:	0c 08       	add	r8,r6
8000e45a:	10 3c       	cp.w	r12,r8
8000e45c:	c1 c1       	brne	8000e494 <_malloc_trim_r+0x74>
8000e45e:	ea 0b 11 00 	rsub	r11,r5,0
8000e462:	0e 9c       	mov	r12,r7
8000e464:	e0 a0 04 74 	rcall	8000ed4c <_sbrk_r>
8000e468:	5b fc       	cp.w	r12,-1
8000e46a:	c1 91       	brne	8000e49c <_malloc_trim_r+0x7c>
8000e46c:	30 0b       	mov	r11,0
8000e46e:	0e 9c       	mov	r12,r7
8000e470:	e0 a0 04 6e 	rcall	8000ed4c <_sbrk_r>
8000e474:	68 28       	ld.w	r8,r4[0x8]
8000e476:	f8 08 01 09 	sub	r9,r12,r8
8000e47a:	58 f9       	cp.w	r9,15
8000e47c:	e0 8a 00 0c 	brle	8000e494 <_malloc_trim_r+0x74>
8000e480:	a1 a9       	sbr	r9,0x0
8000e482:	91 19       	st.w	r8[0x4],r9
8000e484:	e0 68 05 70 	mov	r8,1392
8000e488:	70 09       	ld.w	r9,r8[0x0]
8000e48a:	e0 68 26 68 	mov	r8,9832
8000e48e:	f8 09 01 09 	sub	r9,r12,r9
8000e492:	91 09       	st.w	r8[0x0],r9
8000e494:	0e 9c       	mov	r12,r7
8000e496:	e0 a0 04 43 	rcall	8000ed1c <__malloc_unlock>
8000e49a:	d8 2a       	popm	r4-r7,pc,r12=0
8000e49c:	68 28       	ld.w	r8,r4[0x8]
8000e49e:	0a 16       	sub	r6,r5
8000e4a0:	a1 a6       	sbr	r6,0x0
8000e4a2:	91 16       	st.w	r8[0x4],r6
8000e4a4:	e0 68 26 68 	mov	r8,9832
8000e4a8:	70 09       	ld.w	r9,r8[0x0]
8000e4aa:	0a 19       	sub	r9,r5
8000e4ac:	0e 9c       	mov	r12,r7
8000e4ae:	91 09       	st.w	r8[0x0],r9
8000e4b0:	e0 a0 04 36 	rcall	8000ed1c <__malloc_unlock>
8000e4b4:	da 2a       	popm	r4-r7,pc,r12=1
8000e4b6:	d7 03       	nop

8000e4b8 <_free_r>:
8000e4b8:	d4 21       	pushm	r4-r7,lr
8000e4ba:	16 96       	mov	r6,r11
8000e4bc:	18 97       	mov	r7,r12
8000e4be:	58 0b       	cp.w	r11,0
8000e4c0:	e0 80 00 c0 	breq	8000e640 <_free_r+0x188>
8000e4c4:	e0 a0 04 2b 	rcall	8000ed1a <__malloc_lock>
8000e4c8:	20 86       	sub	r6,8
8000e4ca:	e0 6a 01 64 	mov	r10,356
8000e4ce:	6c 18       	ld.w	r8,r6[0x4]
8000e4d0:	74 2e       	ld.w	lr,r10[0x8]
8000e4d2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e4d6:	a1 c8       	cbr	r8,0x0
8000e4d8:	ec 08 00 09 	add	r9,r6,r8
8000e4dc:	72 1b       	ld.w	r11,r9[0x4]
8000e4de:	e0 1b ff fc 	andl	r11,0xfffc
8000e4e2:	1c 39       	cp.w	r9,lr
8000e4e4:	c1 e1       	brne	8000e520 <_free_r+0x68>
8000e4e6:	f6 08 00 08 	add	r8,r11,r8
8000e4ea:	58 0c       	cp.w	r12,0
8000e4ec:	c0 81       	brne	8000e4fc <_free_r+0x44>
8000e4ee:	6c 09       	ld.w	r9,r6[0x0]
8000e4f0:	12 16       	sub	r6,r9
8000e4f2:	12 08       	add	r8,r9
8000e4f4:	6c 3b       	ld.w	r11,r6[0xc]
8000e4f6:	6c 29       	ld.w	r9,r6[0x8]
8000e4f8:	97 29       	st.w	r11[0x8],r9
8000e4fa:	93 3b       	st.w	r9[0xc],r11
8000e4fc:	10 99       	mov	r9,r8
8000e4fe:	95 26       	st.w	r10[0x8],r6
8000e500:	a1 a9       	sbr	r9,0x0
8000e502:	8d 19       	st.w	r6[0x4],r9
8000e504:	e0 69 05 6c 	mov	r9,1388
8000e508:	72 09       	ld.w	r9,r9[0x0]
8000e50a:	12 38       	cp.w	r8,r9
8000e50c:	c0 63       	brcs	8000e518 <_free_r+0x60>
8000e50e:	e0 68 26 64 	mov	r8,9828
8000e512:	0e 9c       	mov	r12,r7
8000e514:	70 0b       	ld.w	r11,r8[0x0]
8000e516:	c8 5f       	rcall	8000e420 <_malloc_trim_r>
8000e518:	0e 9c       	mov	r12,r7
8000e51a:	e0 a0 04 01 	rcall	8000ed1c <__malloc_unlock>
8000e51e:	d8 22       	popm	r4-r7,pc
8000e520:	93 1b       	st.w	r9[0x4],r11
8000e522:	58 0c       	cp.w	r12,0
8000e524:	c0 30       	breq	8000e52a <_free_r+0x72>
8000e526:	30 0c       	mov	r12,0
8000e528:	c1 08       	rjmp	8000e548 <_free_r+0x90>
8000e52a:	6c 0e       	ld.w	lr,r6[0x0]
8000e52c:	f4 c5 ff f8 	sub	r5,r10,-8
8000e530:	1c 16       	sub	r6,lr
8000e532:	1c 08       	add	r8,lr
8000e534:	6c 2e       	ld.w	lr,r6[0x8]
8000e536:	0a 3e       	cp.w	lr,r5
8000e538:	f9 bc 00 01 	moveq	r12,1
8000e53c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e540:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e544:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e548:	f2 0b 00 0e 	add	lr,r9,r11
8000e54c:	7c 1e       	ld.w	lr,lr[0x4]
8000e54e:	ed be 00 00 	bld	lr,0x0
8000e552:	c1 40       	breq	8000e57a <_free_r+0xc2>
8000e554:	16 08       	add	r8,r11
8000e556:	58 0c       	cp.w	r12,0
8000e558:	c0 d1       	brne	8000e572 <_free_r+0xba>
8000e55a:	e0 6e 01 64 	mov	lr,356
8000e55e:	72 2b       	ld.w	r11,r9[0x8]
8000e560:	2f 8e       	sub	lr,-8
8000e562:	1c 3b       	cp.w	r11,lr
8000e564:	c0 71       	brne	8000e572 <_free_r+0xba>
8000e566:	97 36       	st.w	r11[0xc],r6
8000e568:	97 26       	st.w	r11[0x8],r6
8000e56a:	8d 2b       	st.w	r6[0x8],r11
8000e56c:	8d 3b       	st.w	r6[0xc],r11
8000e56e:	30 1c       	mov	r12,1
8000e570:	c0 58       	rjmp	8000e57a <_free_r+0xc2>
8000e572:	72 2b       	ld.w	r11,r9[0x8]
8000e574:	72 39       	ld.w	r9,r9[0xc]
8000e576:	93 2b       	st.w	r9[0x8],r11
8000e578:	97 39       	st.w	r11[0xc],r9
8000e57a:	10 99       	mov	r9,r8
8000e57c:	ec 08 09 08 	st.w	r6[r8],r8
8000e580:	a1 a9       	sbr	r9,0x0
8000e582:	8d 19       	st.w	r6[0x4],r9
8000e584:	58 0c       	cp.w	r12,0
8000e586:	c5 a1       	brne	8000e63a <_free_r+0x182>
8000e588:	e0 48 01 ff 	cp.w	r8,511
8000e58c:	e0 8b 00 13 	brhi	8000e5b2 <_free_r+0xfa>
8000e590:	a3 98       	lsr	r8,0x3
8000e592:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e596:	72 2b       	ld.w	r11,r9[0x8]
8000e598:	8d 39       	st.w	r6[0xc],r9
8000e59a:	8d 2b       	st.w	r6[0x8],r11
8000e59c:	97 36       	st.w	r11[0xc],r6
8000e59e:	93 26       	st.w	r9[0x8],r6
8000e5a0:	a3 48       	asr	r8,0x2
8000e5a2:	74 19       	ld.w	r9,r10[0x4]
8000e5a4:	30 1b       	mov	r11,1
8000e5a6:	f6 08 09 48 	lsl	r8,r11,r8
8000e5aa:	f3 e8 10 08 	or	r8,r9,r8
8000e5ae:	95 18       	st.w	r10[0x4],r8
8000e5b0:	c4 58       	rjmp	8000e63a <_free_r+0x182>
8000e5b2:	f0 09 16 09 	lsr	r9,r8,0x9
8000e5b6:	58 49       	cp.w	r9,4
8000e5b8:	e0 8b 00 06 	brhi	8000e5c4 <_free_r+0x10c>
8000e5bc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e5c0:	2c 8b       	sub	r11,-56
8000e5c2:	c2 08       	rjmp	8000e602 <_free_r+0x14a>
8000e5c4:	59 49       	cp.w	r9,20
8000e5c6:	e0 8b 00 05 	brhi	8000e5d0 <_free_r+0x118>
8000e5ca:	f2 cb ff a5 	sub	r11,r9,-91
8000e5ce:	c1 a8       	rjmp	8000e602 <_free_r+0x14a>
8000e5d0:	e0 49 00 54 	cp.w	r9,84
8000e5d4:	e0 8b 00 06 	brhi	8000e5e0 <_free_r+0x128>
8000e5d8:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e5dc:	29 2b       	sub	r11,-110
8000e5de:	c1 28       	rjmp	8000e602 <_free_r+0x14a>
8000e5e0:	e0 49 01 54 	cp.w	r9,340
8000e5e4:	e0 8b 00 06 	brhi	8000e5f0 <_free_r+0x138>
8000e5e8:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e5ec:	28 9b       	sub	r11,-119
8000e5ee:	c0 a8       	rjmp	8000e602 <_free_r+0x14a>
8000e5f0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e5f4:	e0 49 05 54 	cp.w	r9,1364
8000e5f8:	e0 88 00 04 	brls	8000e600 <_free_r+0x148>
8000e5fc:	37 eb       	mov	r11,126
8000e5fe:	c0 28       	rjmp	8000e602 <_free_r+0x14a>
8000e600:	28 4b       	sub	r11,-124
8000e602:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e606:	78 29       	ld.w	r9,r12[0x8]
8000e608:	18 39       	cp.w	r9,r12
8000e60a:	c0 e1       	brne	8000e626 <_free_r+0x16e>
8000e60c:	74 18       	ld.w	r8,r10[0x4]
8000e60e:	a3 4b       	asr	r11,0x2
8000e610:	30 1c       	mov	r12,1
8000e612:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e616:	f1 eb 10 0b 	or	r11,r8,r11
8000e61a:	12 98       	mov	r8,r9
8000e61c:	95 1b       	st.w	r10[0x4],r11
8000e61e:	c0 a8       	rjmp	8000e632 <_free_r+0x17a>
8000e620:	72 29       	ld.w	r9,r9[0x8]
8000e622:	18 39       	cp.w	r9,r12
8000e624:	c0 60       	breq	8000e630 <_free_r+0x178>
8000e626:	72 1a       	ld.w	r10,r9[0x4]
8000e628:	e0 1a ff fc 	andl	r10,0xfffc
8000e62c:	14 38       	cp.w	r8,r10
8000e62e:	cf 93       	brcs	8000e620 <_free_r+0x168>
8000e630:	72 38       	ld.w	r8,r9[0xc]
8000e632:	8d 38       	st.w	r6[0xc],r8
8000e634:	8d 29       	st.w	r6[0x8],r9
8000e636:	93 36       	st.w	r9[0xc],r6
8000e638:	91 26       	st.w	r8[0x8],r6
8000e63a:	0e 9c       	mov	r12,r7
8000e63c:	e0 a0 03 70 	rcall	8000ed1c <__malloc_unlock>
8000e640:	d8 22       	popm	r4-r7,pc
8000e642:	d7 03       	nop

8000e644 <_fstat_r>:
8000e644:	d4 21       	pushm	r4-r7,lr
8000e646:	16 98       	mov	r8,r11
8000e648:	18 97       	mov	r7,r12
8000e64a:	10 9c       	mov	r12,r8
8000e64c:	30 08       	mov	r8,0
8000e64e:	e0 66 79 98 	mov	r6,31128
8000e652:	14 9b       	mov	r11,r10
8000e654:	8d 08       	st.w	r6[0x0],r8
8000e656:	e0 a0 04 ab 	rcall	8000efac <_fstat>
8000e65a:	5b fc       	cp.w	r12,-1
8000e65c:	c0 51       	brne	8000e666 <_fstat_r+0x22>
8000e65e:	6c 08       	ld.w	r8,r6[0x0]
8000e660:	58 08       	cp.w	r8,0
8000e662:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000e666:	d8 22       	popm	r4-r7,pc

8000e668 <_fwalk>:
8000e668:	d4 31       	pushm	r0-r7,lr
8000e66a:	30 05       	mov	r5,0
8000e66c:	16 91       	mov	r1,r11
8000e66e:	f8 c7 ff 28 	sub	r7,r12,-216
8000e672:	0a 92       	mov	r2,r5
8000e674:	c3 6e       	rcall	8000e2e0 <__sfp_lock_acquire>
8000e676:	3f f3       	mov	r3,-1
8000e678:	c1 68       	rjmp	8000e6a4 <_fwalk+0x3c>
8000e67a:	6e 26       	ld.w	r6,r7[0x8]
8000e67c:	6e 14       	ld.w	r4,r7[0x4]
8000e67e:	2f 46       	sub	r6,-12
8000e680:	c0 c8       	rjmp	8000e698 <_fwalk+0x30>
8000e682:	8c 08       	ld.sh	r8,r6[0x0]
8000e684:	e4 08 19 00 	cp.h	r8,r2
8000e688:	c0 70       	breq	8000e696 <_fwalk+0x2e>
8000e68a:	8c 18       	ld.sh	r8,r6[0x2]
8000e68c:	e6 08 19 00 	cp.h	r8,r3
8000e690:	c0 30       	breq	8000e696 <_fwalk+0x2e>
8000e692:	5d 11       	icall	r1
8000e694:	18 45       	or	r5,r12
8000e696:	2a 46       	sub	r6,-92
8000e698:	20 14       	sub	r4,1
8000e69a:	ec cc 00 0c 	sub	r12,r6,12
8000e69e:	58 04       	cp.w	r4,0
8000e6a0:	cf 14       	brge	8000e682 <_fwalk+0x1a>
8000e6a2:	6e 07       	ld.w	r7,r7[0x0]
8000e6a4:	58 07       	cp.w	r7,0
8000e6a6:	ce a1       	brne	8000e67a <_fwalk+0x12>
8000e6a8:	c1 de       	rcall	8000e2e2 <__sfp_lock_release>
8000e6aa:	0a 9c       	mov	r12,r5
8000e6ac:	d8 32       	popm	r0-r7,pc
8000e6ae:	d7 03       	nop

8000e6b0 <__smakebuf_r>:
8000e6b0:	d4 21       	pushm	r4-r7,lr
8000e6b2:	20 fd       	sub	sp,60
8000e6b4:	96 68       	ld.sh	r8,r11[0xc]
8000e6b6:	16 97       	mov	r7,r11
8000e6b8:	18 96       	mov	r6,r12
8000e6ba:	e2 18 00 02 	andl	r8,0x2,COH
8000e6be:	c3 b1       	brne	8000e734 <__smakebuf_r+0x84>
8000e6c0:	96 7b       	ld.sh	r11,r11[0xe]
8000e6c2:	f0 0b 19 00 	cp.h	r11,r8
8000e6c6:	c0 45       	brlt	8000e6ce <__smakebuf_r+0x1e>
8000e6c8:	1a 9a       	mov	r10,sp
8000e6ca:	cb df       	rcall	8000e644 <_fstat_r>
8000e6cc:	c0 f4       	brge	8000e6ea <__smakebuf_r+0x3a>
8000e6ce:	8e 65       	ld.sh	r5,r7[0xc]
8000e6d0:	0a 98       	mov	r8,r5
8000e6d2:	ab b8       	sbr	r8,0xb
8000e6d4:	e2 15 00 80 	andl	r5,0x80,COH
8000e6d8:	ae 68       	st.h	r7[0xc],r8
8000e6da:	30 04       	mov	r4,0
8000e6dc:	e0 68 04 00 	mov	r8,1024
8000e6e0:	f9 b5 01 40 	movne	r5,64
8000e6e4:	f0 05 17 00 	moveq	r5,r8
8000e6e8:	c1 c8       	rjmp	8000e720 <__smakebuf_r+0x70>
8000e6ea:	40 18       	lddsp	r8,sp[0x4]
8000e6ec:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e6f0:	e0 48 20 00 	cp.w	r8,8192
8000e6f4:	5f 04       	sreq	r4
8000e6f6:	e0 48 80 00 	cp.w	r8,32768
8000e6fa:	c0 e1       	brne	8000e716 <__smakebuf_r+0x66>
8000e6fc:	6e b9       	ld.w	r9,r7[0x2c]
8000e6fe:	fe c8 f9 86 	sub	r8,pc,-1658
8000e702:	10 39       	cp.w	r9,r8
8000e704:	c0 91       	brne	8000e716 <__smakebuf_r+0x66>
8000e706:	8e 68       	ld.sh	r8,r7[0xc]
8000e708:	e0 65 04 00 	mov	r5,1024
8000e70c:	ab a8       	sbr	r8,0xa
8000e70e:	ef 45 00 50 	st.w	r7[80],r5
8000e712:	ae 68       	st.h	r7[0xc],r8
8000e714:	c0 68       	rjmp	8000e720 <__smakebuf_r+0x70>
8000e716:	8e 68       	ld.sh	r8,r7[0xc]
8000e718:	e0 65 04 00 	mov	r5,1024
8000e71c:	ab b8       	sbr	r8,0xb
8000e71e:	ae 68       	st.h	r7[0xc],r8
8000e720:	0a 9b       	mov	r11,r5
8000e722:	0c 9c       	mov	r12,r6
8000e724:	c3 6c       	rcall	8000e790 <_malloc_r>
8000e726:	8e 68       	ld.sh	r8,r7[0xc]
8000e728:	c0 d1       	brne	8000e742 <__smakebuf_r+0x92>
8000e72a:	ed b8 00 09 	bld	r8,0x9
8000e72e:	c1 f0       	breq	8000e76c <__smakebuf_r+0xbc>
8000e730:	a1 b8       	sbr	r8,0x1
8000e732:	ae 68       	st.h	r7[0xc],r8
8000e734:	ee c8 ff b9 	sub	r8,r7,-71
8000e738:	8f 48       	st.w	r7[0x10],r8
8000e73a:	8f 08       	st.w	r7[0x0],r8
8000e73c:	30 18       	mov	r8,1
8000e73e:	8f 58       	st.w	r7[0x14],r8
8000e740:	c1 68       	rjmp	8000e76c <__smakebuf_r+0xbc>
8000e742:	a7 b8       	sbr	r8,0x7
8000e744:	8f 4c       	st.w	r7[0x10],r12
8000e746:	ae 68       	st.h	r7[0xc],r8
8000e748:	8f 55       	st.w	r7[0x14],r5
8000e74a:	fe c8 04 66 	sub	r8,pc,1126
8000e74e:	8f 0c       	st.w	r7[0x0],r12
8000e750:	8d a8       	st.w	r6[0x28],r8
8000e752:	58 04       	cp.w	r4,0
8000e754:	c0 c0       	breq	8000e76c <__smakebuf_r+0xbc>
8000e756:	8e 7c       	ld.sh	r12,r7[0xe]
8000e758:	e0 a0 04 16 	rcall	8000ef84 <isatty>
8000e75c:	ef f8 12 06 	ld.shne	r8,r7[0xc]
8000e760:	f9 b9 01 01 	movne	r9,1
8000e764:	f1 d9 e1 38 	orne	r8,r8,r9
8000e768:	ef f8 1c 06 	st.hne	r7[0xc],r8
8000e76c:	2f 1d       	sub	sp,-60
8000e76e:	d8 22       	popm	r4-r7,pc

8000e770 <free>:
8000e770:	d4 01       	pushm	lr
8000e772:	e0 68 01 60 	mov	r8,352
8000e776:	18 9b       	mov	r11,r12
8000e778:	70 0c       	ld.w	r12,r8[0x0]
8000e77a:	c9 fe       	rcall	8000e4b8 <_free_r>
8000e77c:	d8 02       	popm	pc
8000e77e:	d7 03       	nop

8000e780 <malloc>:
8000e780:	d4 01       	pushm	lr
8000e782:	e0 68 01 60 	mov	r8,352
8000e786:	18 9b       	mov	r11,r12
8000e788:	70 0c       	ld.w	r12,r8[0x0]
8000e78a:	c0 3c       	rcall	8000e790 <_malloc_r>
8000e78c:	d8 02       	popm	pc
8000e78e:	d7 03       	nop

8000e790 <_malloc_r>:
8000e790:	d4 31       	pushm	r0-r7,lr
8000e792:	f6 c7 ff f5 	sub	r7,r11,-11
8000e796:	18 95       	mov	r5,r12
8000e798:	59 67       	cp.w	r7,22
8000e79a:	f9 b7 08 10 	movls	r7,16
8000e79e:	f9 b8 0b f8 	movhi	r8,-8
8000e7a2:	ef d8 eb 27 	andhi	r7,r7,r8
8000e7a6:	16 37       	cp.w	r7,r11
8000e7a8:	5f 38       	srlo	r8
8000e7aa:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000e7ae:	c0 50       	breq	8000e7b8 <_malloc_r+0x28>
8000e7b0:	30 c8       	mov	r8,12
8000e7b2:	99 38       	st.w	r12[0xc],r8
8000e7b4:	e0 8f 01 f8 	bral	8000eba4 <_malloc_r+0x414>
8000e7b8:	e0 a0 02 b1 	rcall	8000ed1a <__malloc_lock>
8000e7bc:	e0 47 01 f7 	cp.w	r7,503
8000e7c0:	e0 8b 00 1d 	brhi	8000e7fa <_malloc_r+0x6a>
8000e7c4:	ee 03 16 03 	lsr	r3,r7,0x3
8000e7c8:	e0 68 01 64 	mov	r8,356
8000e7cc:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000e7d0:	70 36       	ld.w	r6,r8[0xc]
8000e7d2:	10 36       	cp.w	r6,r8
8000e7d4:	c0 61       	brne	8000e7e0 <_malloc_r+0x50>
8000e7d6:	ec c8 ff f8 	sub	r8,r6,-8
8000e7da:	70 36       	ld.w	r6,r8[0xc]
8000e7dc:	10 36       	cp.w	r6,r8
8000e7de:	c0 c0       	breq	8000e7f6 <_malloc_r+0x66>
8000e7e0:	6c 18       	ld.w	r8,r6[0x4]
8000e7e2:	e0 18 ff fc 	andl	r8,0xfffc
8000e7e6:	6c 3a       	ld.w	r10,r6[0xc]
8000e7e8:	ec 08 00 09 	add	r9,r6,r8
8000e7ec:	0a 9c       	mov	r12,r5
8000e7ee:	6c 28       	ld.w	r8,r6[0x8]
8000e7f0:	95 28       	st.w	r10[0x8],r8
8000e7f2:	91 3a       	st.w	r8[0xc],r10
8000e7f4:	c4 88       	rjmp	8000e884 <_malloc_r+0xf4>
8000e7f6:	2f e3       	sub	r3,-2
8000e7f8:	c4 e8       	rjmp	8000e894 <_malloc_r+0x104>
8000e7fa:	ee 08 16 09 	lsr	r8,r7,0x9
8000e7fe:	c0 41       	brne	8000e806 <_malloc_r+0x76>
8000e800:	ee 03 16 03 	lsr	r3,r7,0x3
8000e804:	c2 78       	rjmp	8000e852 <_malloc_r+0xc2>
8000e806:	58 48       	cp.w	r8,4
8000e808:	e0 8b 00 06 	brhi	8000e814 <_malloc_r+0x84>
8000e80c:	ee 03 16 06 	lsr	r3,r7,0x6
8000e810:	2c 83       	sub	r3,-56
8000e812:	c2 08       	rjmp	8000e852 <_malloc_r+0xc2>
8000e814:	59 48       	cp.w	r8,20
8000e816:	e0 8b 00 05 	brhi	8000e820 <_malloc_r+0x90>
8000e81a:	f0 c3 ff a5 	sub	r3,r8,-91
8000e81e:	c1 a8       	rjmp	8000e852 <_malloc_r+0xc2>
8000e820:	e0 48 00 54 	cp.w	r8,84
8000e824:	e0 8b 00 06 	brhi	8000e830 <_malloc_r+0xa0>
8000e828:	ee 03 16 0c 	lsr	r3,r7,0xc
8000e82c:	29 23       	sub	r3,-110
8000e82e:	c1 28       	rjmp	8000e852 <_malloc_r+0xc2>
8000e830:	e0 48 01 54 	cp.w	r8,340
8000e834:	e0 8b 00 06 	brhi	8000e840 <_malloc_r+0xb0>
8000e838:	ee 03 16 0f 	lsr	r3,r7,0xf
8000e83c:	28 93       	sub	r3,-119
8000e83e:	c0 a8       	rjmp	8000e852 <_malloc_r+0xc2>
8000e840:	ee 03 16 12 	lsr	r3,r7,0x12
8000e844:	e0 48 05 54 	cp.w	r8,1364
8000e848:	e0 88 00 04 	brls	8000e850 <_malloc_r+0xc0>
8000e84c:	37 e3       	mov	r3,126
8000e84e:	c0 28       	rjmp	8000e852 <_malloc_r+0xc2>
8000e850:	28 43       	sub	r3,-124
8000e852:	e0 6a 01 64 	mov	r10,356
8000e856:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000e85a:	74 36       	ld.w	r6,r10[0xc]
8000e85c:	c1 98       	rjmp	8000e88e <_malloc_r+0xfe>
8000e85e:	6c 19       	ld.w	r9,r6[0x4]
8000e860:	e0 19 ff fc 	andl	r9,0xfffc
8000e864:	f2 07 01 0b 	sub	r11,r9,r7
8000e868:	58 fb       	cp.w	r11,15
8000e86a:	e0 8a 00 04 	brle	8000e872 <_malloc_r+0xe2>
8000e86e:	20 13       	sub	r3,1
8000e870:	c1 18       	rjmp	8000e892 <_malloc_r+0x102>
8000e872:	6c 38       	ld.w	r8,r6[0xc]
8000e874:	58 0b       	cp.w	r11,0
8000e876:	c0 b5       	brlt	8000e88c <_malloc_r+0xfc>
8000e878:	6c 2a       	ld.w	r10,r6[0x8]
8000e87a:	ec 09 00 09 	add	r9,r6,r9
8000e87e:	0a 9c       	mov	r12,r5
8000e880:	91 2a       	st.w	r8[0x8],r10
8000e882:	95 38       	st.w	r10[0xc],r8
8000e884:	72 18       	ld.w	r8,r9[0x4]
8000e886:	a1 a8       	sbr	r8,0x0
8000e888:	93 18       	st.w	r9[0x4],r8
8000e88a:	cb d8       	rjmp	8000ea04 <_malloc_r+0x274>
8000e88c:	10 96       	mov	r6,r8
8000e88e:	14 36       	cp.w	r6,r10
8000e890:	ce 71       	brne	8000e85e <_malloc_r+0xce>
8000e892:	2f f3       	sub	r3,-1
8000e894:	e0 6a 01 64 	mov	r10,356
8000e898:	f4 cc ff f8 	sub	r12,r10,-8
8000e89c:	78 26       	ld.w	r6,r12[0x8]
8000e89e:	18 36       	cp.w	r6,r12
8000e8a0:	c6 d0       	breq	8000e97a <_malloc_r+0x1ea>
8000e8a2:	6c 19       	ld.w	r9,r6[0x4]
8000e8a4:	e0 19 ff fc 	andl	r9,0xfffc
8000e8a8:	f2 07 01 08 	sub	r8,r9,r7
8000e8ac:	58 f8       	cp.w	r8,15
8000e8ae:	e0 89 00 90 	brgt	8000e9ce <_malloc_r+0x23e>
8000e8b2:	99 3c       	st.w	r12[0xc],r12
8000e8b4:	99 2c       	st.w	r12[0x8],r12
8000e8b6:	58 08       	cp.w	r8,0
8000e8b8:	c0 55       	brlt	8000e8c2 <_malloc_r+0x132>
8000e8ba:	ec 09 00 09 	add	r9,r6,r9
8000e8be:	0a 9c       	mov	r12,r5
8000e8c0:	ce 2b       	rjmp	8000e884 <_malloc_r+0xf4>
8000e8c2:	e0 49 01 ff 	cp.w	r9,511
8000e8c6:	e0 8b 00 13 	brhi	8000e8ec <_malloc_r+0x15c>
8000e8ca:	a3 99       	lsr	r9,0x3
8000e8cc:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000e8d0:	70 2b       	ld.w	r11,r8[0x8]
8000e8d2:	8d 38       	st.w	r6[0xc],r8
8000e8d4:	8d 2b       	st.w	r6[0x8],r11
8000e8d6:	97 36       	st.w	r11[0xc],r6
8000e8d8:	91 26       	st.w	r8[0x8],r6
8000e8da:	a3 49       	asr	r9,0x2
8000e8dc:	74 18       	ld.w	r8,r10[0x4]
8000e8de:	30 1b       	mov	r11,1
8000e8e0:	f6 09 09 49 	lsl	r9,r11,r9
8000e8e4:	f1 e9 10 09 	or	r9,r8,r9
8000e8e8:	95 19       	st.w	r10[0x4],r9
8000e8ea:	c4 88       	rjmp	8000e97a <_malloc_r+0x1ea>
8000e8ec:	f2 08 16 09 	lsr	r8,r9,0x9
8000e8f0:	58 48       	cp.w	r8,4
8000e8f2:	e0 8b 00 07 	brhi	8000e900 <_malloc_r+0x170>
8000e8f6:	f2 0a 16 06 	lsr	r10,r9,0x6
8000e8fa:	2c 8a       	sub	r10,-56
8000e8fc:	c2 18       	rjmp	8000e93e <_malloc_r+0x1ae>
8000e8fe:	d7 03       	nop
8000e900:	59 48       	cp.w	r8,20
8000e902:	e0 8b 00 05 	brhi	8000e90c <_malloc_r+0x17c>
8000e906:	f0 ca ff a5 	sub	r10,r8,-91
8000e90a:	c1 a8       	rjmp	8000e93e <_malloc_r+0x1ae>
8000e90c:	e0 48 00 54 	cp.w	r8,84
8000e910:	e0 8b 00 06 	brhi	8000e91c <_malloc_r+0x18c>
8000e914:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000e918:	29 2a       	sub	r10,-110
8000e91a:	c1 28       	rjmp	8000e93e <_malloc_r+0x1ae>
8000e91c:	e0 48 01 54 	cp.w	r8,340
8000e920:	e0 8b 00 06 	brhi	8000e92c <_malloc_r+0x19c>
8000e924:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000e928:	28 9a       	sub	r10,-119
8000e92a:	c0 a8       	rjmp	8000e93e <_malloc_r+0x1ae>
8000e92c:	f2 0a 16 12 	lsr	r10,r9,0x12
8000e930:	e0 48 05 54 	cp.w	r8,1364
8000e934:	e0 88 00 04 	brls	8000e93c <_malloc_r+0x1ac>
8000e938:	37 ea       	mov	r10,126
8000e93a:	c0 28       	rjmp	8000e93e <_malloc_r+0x1ae>
8000e93c:	28 4a       	sub	r10,-124
8000e93e:	e0 6b 01 64 	mov	r11,356
8000e942:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000e946:	68 28       	ld.w	r8,r4[0x8]
8000e948:	08 38       	cp.w	r8,r4
8000e94a:	c0 e1       	brne	8000e966 <_malloc_r+0x1d6>
8000e94c:	76 19       	ld.w	r9,r11[0x4]
8000e94e:	a3 4a       	asr	r10,0x2
8000e950:	30 1e       	mov	lr,1
8000e952:	fc 0a 09 4a 	lsl	r10,lr,r10
8000e956:	f3 ea 10 0a 	or	r10,r9,r10
8000e95a:	10 99       	mov	r9,r8
8000e95c:	97 1a       	st.w	r11[0x4],r10
8000e95e:	c0 a8       	rjmp	8000e972 <_malloc_r+0x1e2>
8000e960:	70 28       	ld.w	r8,r8[0x8]
8000e962:	08 38       	cp.w	r8,r4
8000e964:	c0 60       	breq	8000e970 <_malloc_r+0x1e0>
8000e966:	70 1a       	ld.w	r10,r8[0x4]
8000e968:	e0 1a ff fc 	andl	r10,0xfffc
8000e96c:	14 39       	cp.w	r9,r10
8000e96e:	cf 93       	brcs	8000e960 <_malloc_r+0x1d0>
8000e970:	70 39       	ld.w	r9,r8[0xc]
8000e972:	8d 39       	st.w	r6[0xc],r9
8000e974:	8d 28       	st.w	r6[0x8],r8
8000e976:	91 36       	st.w	r8[0xc],r6
8000e978:	93 26       	st.w	r9[0x8],r6
8000e97a:	e6 08 14 02 	asr	r8,r3,0x2
8000e97e:	30 1b       	mov	r11,1
8000e980:	e0 64 01 64 	mov	r4,356
8000e984:	f6 08 09 4b 	lsl	r11,r11,r8
8000e988:	68 18       	ld.w	r8,r4[0x4]
8000e98a:	10 3b       	cp.w	r11,r8
8000e98c:	e0 8b 00 6a 	brhi	8000ea60 <_malloc_r+0x2d0>
8000e990:	f7 e8 00 09 	and	r9,r11,r8
8000e994:	c0 b1       	brne	8000e9aa <_malloc_r+0x21a>
8000e996:	e0 13 ff fc 	andl	r3,0xfffc
8000e99a:	a1 7b       	lsl	r11,0x1
8000e99c:	2f c3       	sub	r3,-4
8000e99e:	c0 38       	rjmp	8000e9a4 <_malloc_r+0x214>
8000e9a0:	2f c3       	sub	r3,-4
8000e9a2:	a1 7b       	lsl	r11,0x1
8000e9a4:	f7 e8 00 09 	and	r9,r11,r8
8000e9a8:	cf c0       	breq	8000e9a0 <_malloc_r+0x210>
8000e9aa:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000e9ae:	06 92       	mov	r2,r3
8000e9b0:	1c 91       	mov	r1,lr
8000e9b2:	62 36       	ld.w	r6,r1[0xc]
8000e9b4:	c2 d8       	rjmp	8000ea0e <_malloc_r+0x27e>
8000e9b6:	6c 1a       	ld.w	r10,r6[0x4]
8000e9b8:	e0 1a ff fc 	andl	r10,0xfffc
8000e9bc:	f4 07 01 08 	sub	r8,r10,r7
8000e9c0:	58 f8       	cp.w	r8,15
8000e9c2:	e0 8a 00 15 	brle	8000e9ec <_malloc_r+0x25c>
8000e9c6:	6c 3a       	ld.w	r10,r6[0xc]
8000e9c8:	6c 29       	ld.w	r9,r6[0x8]
8000e9ca:	95 29       	st.w	r10[0x8],r9
8000e9cc:	93 3a       	st.w	r9[0xc],r10
8000e9ce:	0e 99       	mov	r9,r7
8000e9d0:	ec 07 00 07 	add	r7,r6,r7
8000e9d4:	a1 a9       	sbr	r9,0x0
8000e9d6:	99 37       	st.w	r12[0xc],r7
8000e9d8:	99 27       	st.w	r12[0x8],r7
8000e9da:	8d 19       	st.w	r6[0x4],r9
8000e9dc:	ee 08 09 08 	st.w	r7[r8],r8
8000e9e0:	8f 2c       	st.w	r7[0x8],r12
8000e9e2:	8f 3c       	st.w	r7[0xc],r12
8000e9e4:	a1 a8       	sbr	r8,0x0
8000e9e6:	0a 9c       	mov	r12,r5
8000e9e8:	8f 18       	st.w	r7[0x4],r8
8000e9ea:	c0 d8       	rjmp	8000ea04 <_malloc_r+0x274>
8000e9ec:	6c 39       	ld.w	r9,r6[0xc]
8000e9ee:	58 08       	cp.w	r8,0
8000e9f0:	c0 e5       	brlt	8000ea0c <_malloc_r+0x27c>
8000e9f2:	ec 0a 00 0a 	add	r10,r6,r10
8000e9f6:	74 18       	ld.w	r8,r10[0x4]
8000e9f8:	a1 a8       	sbr	r8,0x0
8000e9fa:	0a 9c       	mov	r12,r5
8000e9fc:	95 18       	st.w	r10[0x4],r8
8000e9fe:	6c 28       	ld.w	r8,r6[0x8]
8000ea00:	93 28       	st.w	r9[0x8],r8
8000ea02:	91 39       	st.w	r8[0xc],r9
8000ea04:	c8 cd       	rcall	8000ed1c <__malloc_unlock>
8000ea06:	ec cc ff f8 	sub	r12,r6,-8
8000ea0a:	d8 32       	popm	r0-r7,pc
8000ea0c:	12 96       	mov	r6,r9
8000ea0e:	02 36       	cp.w	r6,r1
8000ea10:	cd 31       	brne	8000e9b6 <_malloc_r+0x226>
8000ea12:	2f f2       	sub	r2,-1
8000ea14:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000ea18:	c0 30       	breq	8000ea1e <_malloc_r+0x28e>
8000ea1a:	2f 81       	sub	r1,-8
8000ea1c:	cc bb       	rjmp	8000e9b2 <_malloc_r+0x222>
8000ea1e:	1c 98       	mov	r8,lr
8000ea20:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000ea24:	c0 81       	brne	8000ea34 <_malloc_r+0x2a4>
8000ea26:	68 19       	ld.w	r9,r4[0x4]
8000ea28:	f6 08 11 ff 	rsub	r8,r11,-1
8000ea2c:	f3 e8 00 08 	and	r8,r9,r8
8000ea30:	89 18       	st.w	r4[0x4],r8
8000ea32:	c0 78       	rjmp	8000ea40 <_malloc_r+0x2b0>
8000ea34:	f0 c9 00 08 	sub	r9,r8,8
8000ea38:	20 13       	sub	r3,1
8000ea3a:	70 08       	ld.w	r8,r8[0x0]
8000ea3c:	12 38       	cp.w	r8,r9
8000ea3e:	cf 10       	breq	8000ea20 <_malloc_r+0x290>
8000ea40:	a1 7b       	lsl	r11,0x1
8000ea42:	68 18       	ld.w	r8,r4[0x4]
8000ea44:	10 3b       	cp.w	r11,r8
8000ea46:	e0 8b 00 0d 	brhi	8000ea60 <_malloc_r+0x2d0>
8000ea4a:	58 0b       	cp.w	r11,0
8000ea4c:	c0 a0       	breq	8000ea60 <_malloc_r+0x2d0>
8000ea4e:	04 93       	mov	r3,r2
8000ea50:	c0 38       	rjmp	8000ea56 <_malloc_r+0x2c6>
8000ea52:	2f c3       	sub	r3,-4
8000ea54:	a1 7b       	lsl	r11,0x1
8000ea56:	f7 e8 00 09 	and	r9,r11,r8
8000ea5a:	ca 81       	brne	8000e9aa <_malloc_r+0x21a>
8000ea5c:	cf bb       	rjmp	8000ea52 <_malloc_r+0x2c2>
8000ea5e:	d7 03       	nop
8000ea60:	68 23       	ld.w	r3,r4[0x8]
8000ea62:	66 12       	ld.w	r2,r3[0x4]
8000ea64:	e0 12 ff fc 	andl	r2,0xfffc
8000ea68:	0e 32       	cp.w	r2,r7
8000ea6a:	5f 39       	srlo	r9
8000ea6c:	e4 07 01 08 	sub	r8,r2,r7
8000ea70:	58 f8       	cp.w	r8,15
8000ea72:	5f aa       	srle	r10
8000ea74:	f5 e9 10 09 	or	r9,r10,r9
8000ea78:	e0 80 00 98 	breq	8000eba8 <_malloc_r+0x418>
8000ea7c:	e0 68 26 64 	mov	r8,9828
8000ea80:	70 01       	ld.w	r1,r8[0x0]
8000ea82:	e0 68 05 70 	mov	r8,1392
8000ea86:	2f 01       	sub	r1,-16
8000ea88:	70 08       	ld.w	r8,r8[0x0]
8000ea8a:	0e 01       	add	r1,r7
8000ea8c:	5b f8       	cp.w	r8,-1
8000ea8e:	c0 40       	breq	8000ea96 <_malloc_r+0x306>
8000ea90:	28 11       	sub	r1,-127
8000ea92:	e0 11 ff 80 	andl	r1,0xff80
8000ea96:	02 9b       	mov	r11,r1
8000ea98:	0a 9c       	mov	r12,r5
8000ea9a:	c5 9d       	rcall	8000ed4c <_sbrk_r>
8000ea9c:	18 96       	mov	r6,r12
8000ea9e:	5b fc       	cp.w	r12,-1
8000eaa0:	c7 40       	breq	8000eb88 <_malloc_r+0x3f8>
8000eaa2:	e6 02 00 08 	add	r8,r3,r2
8000eaa6:	10 3c       	cp.w	r12,r8
8000eaa8:	c0 32       	brcc	8000eaae <_malloc_r+0x31e>
8000eaaa:	08 33       	cp.w	r3,r4
8000eaac:	c6 e1       	brne	8000eb88 <_malloc_r+0x3f8>
8000eaae:	e0 6a 26 68 	mov	r10,9832
8000eab2:	74 09       	ld.w	r9,r10[0x0]
8000eab4:	e2 09 00 09 	add	r9,r1,r9
8000eab8:	95 09       	st.w	r10[0x0],r9
8000eaba:	10 36       	cp.w	r6,r8
8000eabc:	c0 a1       	brne	8000ead0 <_malloc_r+0x340>
8000eabe:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000eac2:	c0 71       	brne	8000ead0 <_malloc_r+0x340>
8000eac4:	e2 02 00 02 	add	r2,r1,r2
8000eac8:	68 28       	ld.w	r8,r4[0x8]
8000eaca:	a1 a2       	sbr	r2,0x0
8000eacc:	91 12       	st.w	r8[0x4],r2
8000eace:	c4 e8       	rjmp	8000eb6a <_malloc_r+0x3da>
8000ead0:	e0 6a 05 70 	mov	r10,1392
8000ead4:	74 0b       	ld.w	r11,r10[0x0]
8000ead6:	5b fb       	cp.w	r11,-1
8000ead8:	c0 31       	brne	8000eade <_malloc_r+0x34e>
8000eada:	95 06       	st.w	r10[0x0],r6
8000eadc:	c0 78       	rjmp	8000eaea <_malloc_r+0x35a>
8000eade:	ec 09 00 09 	add	r9,r6,r9
8000eae2:	e0 6a 26 68 	mov	r10,9832
8000eae6:	10 19       	sub	r9,r8
8000eae8:	95 09       	st.w	r10[0x0],r9
8000eaea:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000eaee:	f0 09 11 08 	rsub	r9,r8,8
8000eaf2:	58 08       	cp.w	r8,0
8000eaf4:	f2 08 17 10 	movne	r8,r9
8000eaf8:	ed d8 e1 06 	addne	r6,r6,r8
8000eafc:	28 08       	sub	r8,-128
8000eafe:	ec 01 00 01 	add	r1,r6,r1
8000eb02:	0a 9c       	mov	r12,r5
8000eb04:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000eb08:	f0 01 01 01 	sub	r1,r8,r1
8000eb0c:	02 9b       	mov	r11,r1
8000eb0e:	c1 fd       	rcall	8000ed4c <_sbrk_r>
8000eb10:	e0 68 26 68 	mov	r8,9832
8000eb14:	5b fc       	cp.w	r12,-1
8000eb16:	ec 0c 17 00 	moveq	r12,r6
8000eb1a:	f9 b1 00 00 	moveq	r1,0
8000eb1e:	70 09       	ld.w	r9,r8[0x0]
8000eb20:	0c 1c       	sub	r12,r6
8000eb22:	89 26       	st.w	r4[0x8],r6
8000eb24:	02 0c       	add	r12,r1
8000eb26:	12 01       	add	r1,r9
8000eb28:	a1 ac       	sbr	r12,0x0
8000eb2a:	91 01       	st.w	r8[0x0],r1
8000eb2c:	8d 1c       	st.w	r6[0x4],r12
8000eb2e:	08 33       	cp.w	r3,r4
8000eb30:	c1 d0       	breq	8000eb6a <_malloc_r+0x3da>
8000eb32:	58 f2       	cp.w	r2,15
8000eb34:	e0 8b 00 05 	brhi	8000eb3e <_malloc_r+0x3ae>
8000eb38:	30 18       	mov	r8,1
8000eb3a:	8d 18       	st.w	r6[0x4],r8
8000eb3c:	c2 68       	rjmp	8000eb88 <_malloc_r+0x3f8>
8000eb3e:	30 59       	mov	r9,5
8000eb40:	20 c2       	sub	r2,12
8000eb42:	e0 12 ff f8 	andl	r2,0xfff8
8000eb46:	e6 02 00 08 	add	r8,r3,r2
8000eb4a:	91 29       	st.w	r8[0x8],r9
8000eb4c:	91 19       	st.w	r8[0x4],r9
8000eb4e:	66 18       	ld.w	r8,r3[0x4]
8000eb50:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000eb54:	e5 e8 10 08 	or	r8,r2,r8
8000eb58:	87 18       	st.w	r3[0x4],r8
8000eb5a:	58 f2       	cp.w	r2,15
8000eb5c:	e0 88 00 07 	brls	8000eb6a <_malloc_r+0x3da>
8000eb60:	e6 cb ff f8 	sub	r11,r3,-8
8000eb64:	0a 9c       	mov	r12,r5
8000eb66:	fe b0 fc a9 	rcall	8000e4b8 <_free_r>
8000eb6a:	e0 69 26 60 	mov	r9,9824
8000eb6e:	72 0a       	ld.w	r10,r9[0x0]
8000eb70:	e0 68 26 68 	mov	r8,9832
8000eb74:	70 08       	ld.w	r8,r8[0x0]
8000eb76:	14 38       	cp.w	r8,r10
8000eb78:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000eb7c:	e0 69 26 5c 	mov	r9,9820
8000eb80:	72 0a       	ld.w	r10,r9[0x0]
8000eb82:	14 38       	cp.w	r8,r10
8000eb84:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000eb88:	68 28       	ld.w	r8,r4[0x8]
8000eb8a:	70 18       	ld.w	r8,r8[0x4]
8000eb8c:	e0 18 ff fc 	andl	r8,0xfffc
8000eb90:	0e 38       	cp.w	r8,r7
8000eb92:	5f 39       	srlo	r9
8000eb94:	0e 18       	sub	r8,r7
8000eb96:	58 f8       	cp.w	r8,15
8000eb98:	5f aa       	srle	r10
8000eb9a:	f5 e9 10 09 	or	r9,r10,r9
8000eb9e:	c0 50       	breq	8000eba8 <_malloc_r+0x418>
8000eba0:	0a 9c       	mov	r12,r5
8000eba2:	cb dc       	rcall	8000ed1c <__malloc_unlock>
8000eba4:	d8 3a       	popm	r0-r7,pc,r12=0
8000eba6:	d7 03       	nop
8000eba8:	68 26       	ld.w	r6,r4[0x8]
8000ebaa:	a1 a8       	sbr	r8,0x0
8000ebac:	0e 99       	mov	r9,r7
8000ebae:	a1 a9       	sbr	r9,0x0
8000ebb0:	8d 19       	st.w	r6[0x4],r9
8000ebb2:	ec 07 00 07 	add	r7,r6,r7
8000ebb6:	0a 9c       	mov	r12,r5
8000ebb8:	89 27       	st.w	r4[0x8],r7
8000ebba:	8f 18       	st.w	r7[0x4],r8
8000ebbc:	cb 0c       	rcall	8000ed1c <__malloc_unlock>
8000ebbe:	ec cc ff f8 	sub	r12,r6,-8
8000ebc2:	d8 32       	popm	r0-r7,pc

8000ebc4 <memcpy>:
8000ebc4:	58 8a       	cp.w	r10,8
8000ebc6:	c2 f5       	brlt	8000ec24 <memcpy+0x60>
8000ebc8:	f9 eb 10 09 	or	r9,r12,r11
8000ebcc:	e2 19 00 03 	andl	r9,0x3,COH
8000ebd0:	e0 81 00 97 	brne	8000ecfe <memcpy+0x13a>
8000ebd4:	e0 4a 00 20 	cp.w	r10,32
8000ebd8:	c3 b4       	brge	8000ec4e <memcpy+0x8a>
8000ebda:	f4 08 14 02 	asr	r8,r10,0x2
8000ebde:	f0 09 11 08 	rsub	r9,r8,8
8000ebe2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000ebe6:	76 69       	ld.w	r9,r11[0x18]
8000ebe8:	99 69       	st.w	r12[0x18],r9
8000ebea:	76 59       	ld.w	r9,r11[0x14]
8000ebec:	99 59       	st.w	r12[0x14],r9
8000ebee:	76 49       	ld.w	r9,r11[0x10]
8000ebf0:	99 49       	st.w	r12[0x10],r9
8000ebf2:	76 39       	ld.w	r9,r11[0xc]
8000ebf4:	99 39       	st.w	r12[0xc],r9
8000ebf6:	76 29       	ld.w	r9,r11[0x8]
8000ebf8:	99 29       	st.w	r12[0x8],r9
8000ebfa:	76 19       	ld.w	r9,r11[0x4]
8000ebfc:	99 19       	st.w	r12[0x4],r9
8000ebfe:	76 09       	ld.w	r9,r11[0x0]
8000ec00:	99 09       	st.w	r12[0x0],r9
8000ec02:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000ec06:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000ec0a:	e0 1a 00 03 	andl	r10,0x3
8000ec0e:	f4 0a 11 04 	rsub	r10,r10,4
8000ec12:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000ec16:	17 a9       	ld.ub	r9,r11[0x2]
8000ec18:	b0 a9       	st.b	r8[0x2],r9
8000ec1a:	17 99       	ld.ub	r9,r11[0x1]
8000ec1c:	b0 99       	st.b	r8[0x1],r9
8000ec1e:	17 89       	ld.ub	r9,r11[0x0]
8000ec20:	b0 89       	st.b	r8[0x0],r9
8000ec22:	5e fc       	retal	r12
8000ec24:	f4 0a 11 09 	rsub	r10,r10,9
8000ec28:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000ec2c:	17 f9       	ld.ub	r9,r11[0x7]
8000ec2e:	b8 f9       	st.b	r12[0x7],r9
8000ec30:	17 e9       	ld.ub	r9,r11[0x6]
8000ec32:	b8 e9       	st.b	r12[0x6],r9
8000ec34:	17 d9       	ld.ub	r9,r11[0x5]
8000ec36:	b8 d9       	st.b	r12[0x5],r9
8000ec38:	17 c9       	ld.ub	r9,r11[0x4]
8000ec3a:	b8 c9       	st.b	r12[0x4],r9
8000ec3c:	17 b9       	ld.ub	r9,r11[0x3]
8000ec3e:	b8 b9       	st.b	r12[0x3],r9
8000ec40:	17 a9       	ld.ub	r9,r11[0x2]
8000ec42:	b8 a9       	st.b	r12[0x2],r9
8000ec44:	17 99       	ld.ub	r9,r11[0x1]
8000ec46:	b8 99       	st.b	r12[0x1],r9
8000ec48:	17 89       	ld.ub	r9,r11[0x0]
8000ec4a:	b8 89       	st.b	r12[0x0],r9
8000ec4c:	5e fc       	retal	r12
8000ec4e:	eb cd 40 c0 	pushm	r6-r7,lr
8000ec52:	18 99       	mov	r9,r12
8000ec54:	22 0a       	sub	r10,32
8000ec56:	b7 07       	ld.d	r6,r11++
8000ec58:	b3 26       	st.d	r9++,r6
8000ec5a:	b7 07       	ld.d	r6,r11++
8000ec5c:	b3 26       	st.d	r9++,r6
8000ec5e:	b7 07       	ld.d	r6,r11++
8000ec60:	b3 26       	st.d	r9++,r6
8000ec62:	b7 07       	ld.d	r6,r11++
8000ec64:	b3 26       	st.d	r9++,r6
8000ec66:	22 0a       	sub	r10,32
8000ec68:	cf 74       	brge	8000ec56 <memcpy+0x92>
8000ec6a:	2f 0a       	sub	r10,-16
8000ec6c:	c0 65       	brlt	8000ec78 <memcpy+0xb4>
8000ec6e:	b7 07       	ld.d	r6,r11++
8000ec70:	b3 26       	st.d	r9++,r6
8000ec72:	b7 07       	ld.d	r6,r11++
8000ec74:	b3 26       	st.d	r9++,r6
8000ec76:	21 0a       	sub	r10,16
8000ec78:	5c 3a       	neg	r10
8000ec7a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000ec7e:	d7 03       	nop
8000ec80:	d7 03       	nop
8000ec82:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000ec86:	f3 66 00 0e 	st.b	r9[14],r6
8000ec8a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000ec8e:	f3 66 00 0d 	st.b	r9[13],r6
8000ec92:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000ec96:	f3 66 00 0c 	st.b	r9[12],r6
8000ec9a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000ec9e:	f3 66 00 0b 	st.b	r9[11],r6
8000eca2:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000eca6:	f3 66 00 0a 	st.b	r9[10],r6
8000ecaa:	f7 36 00 09 	ld.ub	r6,r11[9]
8000ecae:	f3 66 00 09 	st.b	r9[9],r6
8000ecb2:	f7 36 00 08 	ld.ub	r6,r11[8]
8000ecb6:	f3 66 00 08 	st.b	r9[8],r6
8000ecba:	f7 36 00 07 	ld.ub	r6,r11[7]
8000ecbe:	f3 66 00 07 	st.b	r9[7],r6
8000ecc2:	f7 36 00 06 	ld.ub	r6,r11[6]
8000ecc6:	f3 66 00 06 	st.b	r9[6],r6
8000ecca:	f7 36 00 05 	ld.ub	r6,r11[5]
8000ecce:	f3 66 00 05 	st.b	r9[5],r6
8000ecd2:	f7 36 00 04 	ld.ub	r6,r11[4]
8000ecd6:	f3 66 00 04 	st.b	r9[4],r6
8000ecda:	f7 36 00 03 	ld.ub	r6,r11[3]
8000ecde:	f3 66 00 03 	st.b	r9[3],r6
8000ece2:	f7 36 00 02 	ld.ub	r6,r11[2]
8000ece6:	f3 66 00 02 	st.b	r9[2],r6
8000ecea:	f7 36 00 01 	ld.ub	r6,r11[1]
8000ecee:	f3 66 00 01 	st.b	r9[1],r6
8000ecf2:	f7 36 00 00 	ld.ub	r6,r11[0]
8000ecf6:	f3 66 00 00 	st.b	r9[0],r6
8000ecfa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ecfe:	20 1a       	sub	r10,1
8000ed00:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000ed04:	f8 0a 0b 09 	st.b	r12[r10],r9
8000ed08:	cf b1       	brne	8000ecfe <memcpy+0x13a>
8000ed0a:	5e fc       	retal	r12

8000ed0c <memset>:
8000ed0c:	18 98       	mov	r8,r12
8000ed0e:	c0 38       	rjmp	8000ed14 <memset+0x8>
8000ed10:	10 cb       	st.b	r8++,r11
8000ed12:	20 1a       	sub	r10,1
8000ed14:	58 0a       	cp.w	r10,0
8000ed16:	cf d1       	brne	8000ed10 <memset+0x4>
8000ed18:	5e fc       	retal	r12

8000ed1a <__malloc_lock>:
8000ed1a:	5e fc       	retal	r12

8000ed1c <__malloc_unlock>:
8000ed1c:	5e fc       	retal	r12
8000ed1e:	d7 03       	nop

8000ed20 <printf>:
8000ed20:	d4 21       	pushm	r4-r7,lr
8000ed22:	e0 68 01 60 	mov	r8,352
8000ed26:	fa c4 ff ec 	sub	r4,sp,-20
8000ed2a:	18 96       	mov	r6,r12
8000ed2c:	70 07       	ld.w	r7,r8[0x0]
8000ed2e:	58 07       	cp.w	r7,0
8000ed30:	c0 70       	breq	8000ed3e <printf+0x1e>
8000ed32:	6e 68       	ld.w	r8,r7[0x18]
8000ed34:	58 08       	cp.w	r8,0
8000ed36:	c0 41       	brne	8000ed3e <printf+0x1e>
8000ed38:	0e 9c       	mov	r12,r7
8000ed3a:	fe b0 fb 25 	rcall	8000e384 <__sinit>
8000ed3e:	08 99       	mov	r9,r4
8000ed40:	0c 9a       	mov	r10,r6
8000ed42:	0e 9c       	mov	r12,r7
8000ed44:	6e 1b       	ld.w	r11,r7[0x4]
8000ed46:	e0 a0 03 0d 	rcall	8000f360 <_vfprintf_r>
8000ed4a:	d8 22       	popm	r4-r7,pc

8000ed4c <_sbrk_r>:
8000ed4c:	d4 21       	pushm	r4-r7,lr
8000ed4e:	30 08       	mov	r8,0
8000ed50:	18 97       	mov	r7,r12
8000ed52:	e0 66 79 98 	mov	r6,31128
8000ed56:	16 9c       	mov	r12,r11
8000ed58:	8d 08       	st.w	r6[0x0],r8
8000ed5a:	c4 fd       	rcall	8000eff8 <_sbrk>
8000ed5c:	5b fc       	cp.w	r12,-1
8000ed5e:	c0 51       	brne	8000ed68 <_sbrk_r+0x1c>
8000ed60:	6c 08       	ld.w	r8,r6[0x0]
8000ed62:	58 08       	cp.w	r8,0
8000ed64:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ed68:	d8 22       	popm	r4-r7,pc
8000ed6a:	d7 03       	nop

8000ed6c <__sclose>:
8000ed6c:	d4 01       	pushm	lr
8000ed6e:	96 7b       	ld.sh	r11,r11[0xe]
8000ed70:	e0 a0 13 00 	rcall	80011370 <_close_r>
8000ed74:	d8 02       	popm	pc
8000ed76:	d7 03       	nop

8000ed78 <__sseek>:
8000ed78:	d4 21       	pushm	r4-r7,lr
8000ed7a:	16 97       	mov	r7,r11
8000ed7c:	96 7b       	ld.sh	r11,r11[0xe]
8000ed7e:	e0 a0 1a df 	rcall	8001233c <_lseek_r>
8000ed82:	8e 68       	ld.sh	r8,r7[0xc]
8000ed84:	10 99       	mov	r9,r8
8000ed86:	ad c9       	cbr	r9,0xc
8000ed88:	5b fc       	cp.w	r12,-1
8000ed8a:	ef f9 0c 06 	st.heq	r7[0xc],r9
8000ed8e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ed92:	e0 69 10 00 	mov	r9,4096
8000ed96:	f1 d9 e1 38 	orne	r8,r8,r9
8000ed9a:	ef f8 1c 06 	st.hne	r7[0xc],r8
8000ed9e:	d8 22       	popm	r4-r7,pc

8000eda0 <__swrite>:
8000eda0:	d4 21       	pushm	r4-r7,lr
8000eda2:	96 68       	ld.sh	r8,r11[0xc]
8000eda4:	16 97       	mov	r7,r11
8000eda6:	14 95       	mov	r5,r10
8000eda8:	12 94       	mov	r4,r9
8000edaa:	e2 18 01 00 	andl	r8,0x100,COH
8000edae:	18 96       	mov	r6,r12
8000edb0:	c0 60       	breq	8000edbc <__swrite+0x1c>
8000edb2:	30 29       	mov	r9,2
8000edb4:	30 0a       	mov	r10,0
8000edb6:	96 7b       	ld.sh	r11,r11[0xe]
8000edb8:	e0 a0 1a c2 	rcall	8001233c <_lseek_r>
8000edbc:	8e 68       	ld.sh	r8,r7[0xc]
8000edbe:	ad c8       	cbr	r8,0xc
8000edc0:	08 99       	mov	r9,r4
8000edc2:	0a 9a       	mov	r10,r5
8000edc4:	8e 7b       	ld.sh	r11,r7[0xe]
8000edc6:	0c 9c       	mov	r12,r6
8000edc8:	ae 68       	st.h	r7[0xc],r8
8000edca:	e0 a0 12 51 	rcall	8001126c <_write_r>
8000edce:	d8 22       	popm	r4-r7,pc

8000edd0 <__sread>:
8000edd0:	d4 21       	pushm	r4-r7,lr
8000edd2:	16 97       	mov	r7,r11
8000edd4:	96 7b       	ld.sh	r11,r11[0xe]
8000edd6:	e0 a0 1d df 	rcall	80012994 <_read_r>
8000edda:	c0 65       	brlt	8000ede6 <__sread+0x16>
8000eddc:	6f 58       	ld.w	r8,r7[0x54]
8000edde:	18 08       	add	r8,r12
8000ede0:	ef 48 00 54 	st.w	r7[84],r8
8000ede4:	d8 22       	popm	r4-r7,pc
8000ede6:	8e 68       	ld.sh	r8,r7[0xc]
8000ede8:	ad c8       	cbr	r8,0xc
8000edea:	ae 68       	st.h	r7[0xc],r8
8000edec:	d8 22       	popm	r4-r7,pc
8000edee:	d7 03       	nop

8000edf0 <strcmp>:
8000edf0:	f9 eb 10 0a 	or	r10,r12,r11
8000edf4:	e2 1a 00 03 	andl	r10,0x3,COH
8000edf8:	c3 41       	brne	8000ee60 <strcmp+0x70>
8000edfa:	78 0a       	ld.w	r10,r12[0x0]
8000edfc:	76 09       	ld.w	r9,r11[0x0]
8000edfe:	5c ea       	tnbz	r10
8000ee00:	c1 70       	breq	8000ee2e <strcmp+0x3e>
8000ee02:	12 3a       	cp.w	r10,r9
8000ee04:	c1 51       	brne	8000ee2e <strcmp+0x3e>
8000ee06:	78 1a       	ld.w	r10,r12[0x4]
8000ee08:	76 19       	ld.w	r9,r11[0x4]
8000ee0a:	5c ea       	tnbz	r10
8000ee0c:	c1 10       	breq	8000ee2e <strcmp+0x3e>
8000ee0e:	12 3a       	cp.w	r10,r9
8000ee10:	c0 f1       	brne	8000ee2e <strcmp+0x3e>
8000ee12:	78 2a       	ld.w	r10,r12[0x8]
8000ee14:	76 29       	ld.w	r9,r11[0x8]
8000ee16:	5c ea       	tnbz	r10
8000ee18:	c0 b0       	breq	8000ee2e <strcmp+0x3e>
8000ee1a:	12 3a       	cp.w	r10,r9
8000ee1c:	c0 91       	brne	8000ee2e <strcmp+0x3e>
8000ee1e:	78 3a       	ld.w	r10,r12[0xc]
8000ee20:	76 39       	ld.w	r9,r11[0xc]
8000ee22:	5c ea       	tnbz	r10
8000ee24:	c0 50       	breq	8000ee2e <strcmp+0x3e>
8000ee26:	2f 0c       	sub	r12,-16
8000ee28:	2f 0b       	sub	r11,-16
8000ee2a:	12 3a       	cp.w	r10,r9
8000ee2c:	ce 70       	breq	8000edfa <strcmp+0xa>
8000ee2e:	f9 da c3 08 	bfextu	r12,r10,0x18,0x8
8000ee32:	f7 d9 c3 08 	bfextu	r11,r9,0x18,0x8
8000ee36:	5e 0c       	reteq	r12
8000ee38:	16 1c       	sub	r12,r11
8000ee3a:	5e 1c       	retne	r12
8000ee3c:	f9 da c2 08 	bfextu	r12,r10,0x10,0x8
8000ee40:	f7 d9 c2 08 	bfextu	r11,r9,0x10,0x8
8000ee44:	5e 0c       	reteq	r12
8000ee46:	16 1c       	sub	r12,r11
8000ee48:	5e 1c       	retne	r12
8000ee4a:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
8000ee4e:	f7 d9 c1 08 	bfextu	r11,r9,0x8,0x8
8000ee52:	5e 0c       	reteq	r12
8000ee54:	16 1c       	sub	r12,r11
8000ee56:	5e 1c       	retne	r12
8000ee58:	5c 5a       	castu.b	r10
8000ee5a:	5c 59       	castu.b	r9
8000ee5c:	12 1a       	sub	r10,r9
8000ee5e:	5e fa       	retal	r10
8000ee60:	17 8a       	ld.ub	r10,r11[0x0]
8000ee62:	19 89       	ld.ub	r9,r12[0x0]
8000ee64:	58 0a       	cp.w	r10,0
8000ee66:	5e 09       	reteq	r9
8000ee68:	14 19       	sub	r9,r10
8000ee6a:	5e 19       	retne	r9
8000ee6c:	17 9a       	ld.ub	r10,r11[0x1]
8000ee6e:	19 99       	ld.ub	r9,r12[0x1]
8000ee70:	58 0a       	cp.w	r10,0
8000ee72:	5e 09       	reteq	r9
8000ee74:	14 19       	sub	r9,r10
8000ee76:	5e 19       	retne	r9
8000ee78:	17 aa       	ld.ub	r10,r11[0x2]
8000ee7a:	19 a9       	ld.ub	r9,r12[0x2]
8000ee7c:	58 0a       	cp.w	r10,0
8000ee7e:	5e 09       	reteq	r9
8000ee80:	14 19       	sub	r9,r10
8000ee82:	5e 19       	retne	r9
8000ee84:	17 ba       	ld.ub	r10,r11[0x3]
8000ee86:	19 b9       	ld.ub	r9,r12[0x3]
8000ee88:	58 0a       	cp.w	r10,0
8000ee8a:	5e 09       	reteq	r9
8000ee8c:	14 19       	sub	r9,r10
8000ee8e:	5e 19       	retne	r9
8000ee90:	2f cb       	sub	r11,-4
8000ee92:	2f cc       	sub	r12,-4
8000ee94:	ce 6b       	rjmp	8000ee60 <strcmp+0x70>
8000ee96:	d7 03       	nop

8000ee98 <strcpy>:
8000ee98:	30 08       	mov	r8,0
8000ee9a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ee9e:	f8 08 0b 09 	st.b	r12[r8],r9
8000eea2:	2f f8       	sub	r8,-1
8000eea4:	58 09       	cp.w	r9,0
8000eea6:	cf a1       	brne	8000ee9a <strcpy+0x2>
8000eea8:	5e fc       	retal	r12

8000eeaa <strlen>:
8000eeaa:	30 09       	mov	r9,0
8000eeac:	18 98       	mov	r8,r12
8000eeae:	c0 28       	rjmp	8000eeb2 <strlen+0x8>
8000eeb0:	2f f8       	sub	r8,-1
8000eeb2:	11 8a       	ld.ub	r10,r8[0x0]
8000eeb4:	f2 0a 18 00 	cp.b	r10,r9
8000eeb8:	cf c1       	brne	8000eeb0 <strlen+0x6>
8000eeba:	f0 0c 01 0c 	sub	r12,r8,r12
8000eebe:	5e fc       	retal	r12

8000eec0 <strncat>:
8000eec0:	d4 01       	pushm	lr
8000eec2:	30 09       	mov	r9,0
8000eec4:	18 98       	mov	r8,r12
8000eec6:	c0 28       	rjmp	8000eeca <strncat+0xa>
8000eec8:	2f f8       	sub	r8,-1
8000eeca:	11 8e       	ld.ub	lr,r8[0x0]
8000eecc:	f2 0e 18 00 	cp.b	lr,r9
8000eed0:	cf c1       	brne	8000eec8 <strncat+0x8>
8000eed2:	c0 78       	rjmp	8000eee0 <strncat+0x20>
8000eed4:	20 1a       	sub	r10,1
8000eed6:	2f f8       	sub	r8,-1
8000eed8:	2f fb       	sub	r11,-1
8000eeda:	58 0a       	cp.w	r10,0
8000eedc:	f1 fa 0e 00 	st.beq	r8[0x0],r10
8000eee0:	58 0a       	cp.w	r10,0
8000eee2:	c0 50       	breq	8000eeec <strncat+0x2c>
8000eee4:	17 89       	ld.ub	r9,r11[0x0]
8000eee6:	b0 89       	st.b	r8[0x0],r9
8000eee8:	58 09       	cp.w	r9,0
8000eeea:	cf 51       	brne	8000eed4 <strncat+0x14>
8000eeec:	d8 02       	popm	pc

8000eeee <strncmp>:
8000eeee:	58 0a       	cp.w	r10,0
8000eef0:	c0 81       	brne	8000ef00 <strncmp+0x12>
8000eef2:	5e fa       	retal	r10
8000eef4:	58 0a       	cp.w	r10,0
8000eef6:	c0 b0       	breq	8000ef0c <strncmp+0x1e>
8000eef8:	58 08       	cp.w	r8,0
8000eefa:	c0 90       	breq	8000ef0c <strncmp+0x1e>
8000eefc:	2f fc       	sub	r12,-1
8000eefe:	2f fb       	sub	r11,-1
8000ef00:	20 1a       	sub	r10,1
8000ef02:	19 88       	ld.ub	r8,r12[0x0]
8000ef04:	17 89       	ld.ub	r9,r11[0x0]
8000ef06:	f0 09 18 00 	cp.b	r9,r8
8000ef0a:	cf 50       	breq	8000eef4 <strncmp+0x6>
8000ef0c:	19 8c       	ld.ub	r12,r12[0x0]
8000ef0e:	17 88       	ld.ub	r8,r11[0x0]
8000ef10:	10 1c       	sub	r12,r8
8000ef12:	5e fc       	retal	r12

8000ef14 <strncpy>:
8000ef14:	30 08       	mov	r8,0
8000ef16:	10 3a       	cp.w	r10,r8
8000ef18:	5e 0c       	reteq	r12
8000ef1a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ef1e:	f8 08 0b 09 	st.b	r12[r8],r9
8000ef22:	2f f8       	sub	r8,-1
8000ef24:	58 09       	cp.w	r9,0
8000ef26:	cf 81       	brne	8000ef16 <strncpy+0x2>
8000ef28:	10 3a       	cp.w	r10,r8
8000ef2a:	5e 0c       	reteq	r12
8000ef2c:	f8 08 0b 09 	st.b	r12[r8],r9
8000ef30:	2f f8       	sub	r8,-1
8000ef32:	cf bb       	rjmp	8000ef28 <strncpy+0x14>

8000ef34 <_close>:
8000ef34:	30 28       	mov	r8,2
8000ef36:	d6 73       	breakpoint
8000ef38:	3f fc       	mov	r12,-1
8000ef3a:	35 8b       	mov	r11,88
8000ef3c:	58 0c       	cp.w	r12,0
8000ef3e:	5e 4c       	retge	r12
8000ef40:	e0 6a 79 98 	mov	r10,31128
8000ef44:	95 0b       	st.w	r10[0x0],r11
8000ef46:	5e fc       	retal	r12

8000ef48 <_lseek>:
8000ef48:	30 58       	mov	r8,5
8000ef4a:	d6 73       	breakpoint
8000ef4c:	3f fc       	mov	r12,-1
8000ef4e:	35 8b       	mov	r11,88
8000ef50:	58 0c       	cp.w	r12,0
8000ef52:	5e 4c       	retge	r12
8000ef54:	e0 6a 79 98 	mov	r10,31128
8000ef58:	95 0b       	st.w	r10[0x0],r11
8000ef5a:	5e fc       	retal	r12

8000ef5c <_read>:
8000ef5c:	30 38       	mov	r8,3
8000ef5e:	d6 73       	breakpoint
8000ef60:	3f fc       	mov	r12,-1
8000ef62:	35 8b       	mov	r11,88
8000ef64:	58 0c       	cp.w	r12,0
8000ef66:	5e 4c       	retge	r12
8000ef68:	e0 6a 79 98 	mov	r10,31128
8000ef6c:	95 0b       	st.w	r10[0x0],r11
8000ef6e:	5e fc       	retal	r12

8000ef70 <_write>:
8000ef70:	30 48       	mov	r8,4
8000ef72:	d6 73       	breakpoint
8000ef74:	3f fc       	mov	r12,-1
8000ef76:	35 8b       	mov	r11,88
8000ef78:	58 0c       	cp.w	r12,0
8000ef7a:	5e 4c       	retge	r12
8000ef7c:	e0 6a 79 98 	mov	r10,31128
8000ef80:	95 0b       	st.w	r10[0x0],r11
8000ef82:	5e fc       	retal	r12

8000ef84 <isatty>:
8000ef84:	30 b8       	mov	r8,11
8000ef86:	d6 73       	breakpoint
8000ef88:	3f fc       	mov	r12,-1
8000ef8a:	35 8b       	mov	r11,88
8000ef8c:	58 0c       	cp.w	r12,0
8000ef8e:	5e 4c       	retge	r12
8000ef90:	e0 6a 79 98 	mov	r10,31128
8000ef94:	95 0b       	st.w	r10[0x0],r11
8000ef96:	5e fc       	retal	r12

8000ef98 <_fstat_host>:
8000ef98:	30 98       	mov	r8,9
8000ef9a:	d6 73       	breakpoint
8000ef9c:	3f fc       	mov	r12,-1
8000ef9e:	35 8b       	mov	r11,88
8000efa0:	58 0c       	cp.w	r12,0
8000efa2:	5e 4c       	retge	r12
8000efa4:	e0 6a 79 98 	mov	r10,31128
8000efa8:	95 0b       	st.w	r10[0x0],r11
8000efaa:	5e fc       	retal	r12

8000efac <_fstat>:
8000efac:	d4 21       	pushm	r4-r7,lr
8000efae:	21 0d       	sub	sp,64
8000efb0:	16 97       	mov	r7,r11
8000efb2:	1a 9b       	mov	r11,sp
8000efb4:	cf 2f       	rcall	8000ef98 <_fstat_host>
8000efb6:	c0 34       	brge	8000efbc <_fstat+0x10>
8000efb8:	3f fc       	mov	r12,-1
8000efba:	c1 c8       	rjmp	8000eff2 <_fstat+0x46>
8000efbc:	40 08       	lddsp	r8,sp[0x0]
8000efbe:	ae 08       	st.h	r7[0x0],r8
8000efc0:	40 18       	lddsp	r8,sp[0x4]
8000efc2:	ae 18       	st.h	r7[0x2],r8
8000efc4:	40 28       	lddsp	r8,sp[0x8]
8000efc6:	8f 18       	st.w	r7[0x4],r8
8000efc8:	40 38       	lddsp	r8,sp[0xc]
8000efca:	ae 48       	st.h	r7[0x8],r8
8000efcc:	40 48       	lddsp	r8,sp[0x10]
8000efce:	ae 58       	st.h	r7[0xa],r8
8000efd0:	40 58       	lddsp	r8,sp[0x14]
8000efd2:	ae 68       	st.h	r7[0xc],r8
8000efd4:	40 68       	lddsp	r8,sp[0x18]
8000efd6:	ae 78       	st.h	r7[0xe],r8
8000efd8:	40 88       	lddsp	r8,sp[0x20]
8000efda:	8f 48       	st.w	r7[0x10],r8
8000efdc:	40 a8       	lddsp	r8,sp[0x28]
8000efde:	8f b8       	st.w	r7[0x2c],r8
8000efe0:	40 c8       	lddsp	r8,sp[0x30]
8000efe2:	8f c8       	st.w	r7[0x30],r8
8000efe4:	40 d8       	lddsp	r8,sp[0x34]
8000efe6:	8f 58       	st.w	r7[0x14],r8
8000efe8:	40 e8       	lddsp	r8,sp[0x38]
8000efea:	30 0c       	mov	r12,0
8000efec:	8f 78       	st.w	r7[0x1c],r8
8000efee:	40 f8       	lddsp	r8,sp[0x3c]
8000eff0:	8f 98       	st.w	r7[0x24],r8
8000eff2:	2f 0d       	sub	sp,-64
8000eff4:	d8 22       	popm	r4-r7,pc
8000eff6:	d7 03       	nop

8000eff8 <_sbrk>:
8000eff8:	d4 01       	pushm	lr
8000effa:	e0 68 26 90 	mov	r8,9872
8000effe:	70 09       	ld.w	r9,r8[0x0]
8000f000:	58 09       	cp.w	r9,0
8000f002:	c0 41       	brne	8000f00a <_sbrk+0x12>
8000f004:	e0 69 79 a0 	mov	r9,31136
8000f008:	91 09       	st.w	r8[0x0],r9
8000f00a:	e0 69 26 90 	mov	r9,9872
8000f00e:	e0 6a f0 00 	mov	r10,61440
8000f012:	72 08       	ld.w	r8,r9[0x0]
8000f014:	f0 0c 00 0c 	add	r12,r8,r12
8000f018:	14 3c       	cp.w	r12,r10
8000f01a:	e0 8b 00 04 	brhi	8000f022 <_sbrk+0x2a>
8000f01e:	93 0c       	st.w	r9[0x0],r12
8000f020:	c0 68       	rjmp	8000f02c <_sbrk+0x34>
8000f022:	e0 a0 18 35 	rcall	8001208c <__errno>
8000f026:	30 c8       	mov	r8,12
8000f028:	99 08       	st.w	r12[0x0],r8
8000f02a:	3f f8       	mov	r8,-1
8000f02c:	10 9c       	mov	r12,r8
8000f02e:	d8 02       	popm	pc

8000f030 <get_arg>:
8000f030:	d4 31       	pushm	r0-r7,lr
8000f032:	20 8d       	sub	sp,32
8000f034:	fa c4 ff bc 	sub	r4,sp,-68
8000f038:	50 4b       	stdsp	sp[0x10],r11
8000f03a:	68 2e       	ld.w	lr,r4[0x8]
8000f03c:	50 58       	stdsp	sp[0x14],r8
8000f03e:	12 96       	mov	r6,r9
8000f040:	7c 0b       	ld.w	r11,lr[0x0]
8000f042:	70 05       	ld.w	r5,r8[0x0]
8000f044:	50 6e       	stdsp	sp[0x18],lr
8000f046:	58 0b       	cp.w	r11,0
8000f048:	f4 0b 17 00 	moveq	r11,r10
8000f04c:	68 03       	ld.w	r3,r4[0x0]
8000f04e:	68 11       	ld.w	r1,r4[0x4]
8000f050:	40 49       	lddsp	r9,sp[0x10]
8000f052:	30 08       	mov	r8,0
8000f054:	c2 89       	rjmp	8000f2a4 <get_arg+0x274>
8000f056:	2f fb       	sub	r11,-1
8000f058:	32 5c       	mov	r12,37
8000f05a:	17 8a       	ld.ub	r10,r11[0x0]
8000f05c:	f8 0a 18 00 	cp.b	r10,r12
8000f060:	5f 1e       	srne	lr
8000f062:	f0 0a 18 00 	cp.b	r10,r8
8000f066:	5f 1c       	srne	r12
8000f068:	fd ec 00 0c 	and	r12,lr,r12
8000f06c:	f0 0c 18 00 	cp.b	r12,r8
8000f070:	cf 31       	brne	8000f056 <get_arg+0x26>
8000f072:	58 0a       	cp.w	r10,0
8000f074:	e0 80 01 25 	breq	8000f2be <get_arg+0x28e>
8000f078:	30 0c       	mov	r12,0
8000f07a:	3f fa       	mov	r10,-1
8000f07c:	18 90       	mov	r0,r12
8000f07e:	50 3a       	stdsp	sp[0xc],r10
8000f080:	18 94       	mov	r4,r12
8000f082:	18 92       	mov	r2,r12
8000f084:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000f088:	16 97       	mov	r7,r11
8000f08a:	50 7c       	stdsp	sp[0x1c],r12
8000f08c:	fe cc 9d 8c 	sub	r12,pc,-25204
8000f090:	0f 3a       	ld.ub	r10,r7++
8000f092:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000f096:	40 7c       	lddsp	r12,sp[0x1c]
8000f098:	1c 0c       	add	r12,lr
8000f09a:	fe ce 9e 4e 	sub	lr,pc,-25010
8000f09e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000f0a2:	20 1e       	sub	lr,1
8000f0a4:	50 0e       	stdsp	sp[0x0],lr
8000f0a6:	fe ce 9e c6 	sub	lr,pc,-24890
8000f0aa:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000f0ae:	50 7c       	stdsp	sp[0x1c],r12
8000f0b0:	40 0c       	lddsp	r12,sp[0x0]
8000f0b2:	58 7c       	cp.w	r12,7
8000f0b4:	e0 8b 00 f1 	brhi	8000f296 <get_arg+0x266>
8000f0b8:	fe ce a0 78 	sub	lr,pc,-24456
8000f0bc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000f0c0:	36 8b       	mov	r11,104
8000f0c2:	f6 0a 18 00 	cp.b	r10,r11
8000f0c6:	e0 80 00 e8 	breq	8000f296 <get_arg+0x266>
8000f0ca:	37 1b       	mov	r11,113
8000f0cc:	f6 0a 18 00 	cp.b	r10,r11
8000f0d0:	c0 70       	breq	8000f0de <get_arg+0xae>
8000f0d2:	34 cb       	mov	r11,76
8000f0d4:	f6 0a 18 00 	cp.b	r10,r11
8000f0d8:	c0 51       	brne	8000f0e2 <get_arg+0xb2>
8000f0da:	a3 b4       	sbr	r4,0x3
8000f0dc:	cd d8       	rjmp	8000f296 <get_arg+0x266>
8000f0de:	a5 b4       	sbr	r4,0x5
8000f0e0:	cd b8       	rjmp	8000f296 <get_arg+0x266>
8000f0e2:	0f 8b       	ld.ub	r11,r7[0x0]
8000f0e4:	36 ca       	mov	r10,108
8000f0e6:	f4 0b 18 00 	cp.b	r11,r10
8000f0ea:	c0 51       	brne	8000f0f4 <get_arg+0xc4>
8000f0ec:	a5 b4       	sbr	r4,0x5
8000f0ee:	ee cb ff ff 	sub	r11,r7,-1
8000f0f2:	cd 38       	rjmp	8000f298 <get_arg+0x268>
8000f0f4:	a5 a4       	sbr	r4,0x4
8000f0f6:	cd 08       	rjmp	8000f296 <get_arg+0x266>
8000f0f8:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000f0fc:	36 7c       	mov	r12,103
8000f0fe:	f8 0a 18 00 	cp.b	r10,r12
8000f102:	e0 8b 00 27 	brhi	8000f150 <get_arg+0x120>
8000f106:	36 5b       	mov	r11,101
8000f108:	f6 0a 18 00 	cp.b	r10,r11
8000f10c:	c4 82       	brcc	8000f19c <get_arg+0x16c>
8000f10e:	34 fb       	mov	r11,79
8000f110:	f6 0a 18 00 	cp.b	r10,r11
8000f114:	c4 80       	breq	8000f1a4 <get_arg+0x174>
8000f116:	e0 8b 00 0c 	brhi	8000f12e <get_arg+0xfe>
8000f11a:	34 5b       	mov	r11,69
8000f11c:	f6 0a 18 00 	cp.b	r10,r11
8000f120:	c3 e0       	breq	8000f19c <get_arg+0x16c>
8000f122:	34 7b       	mov	r11,71
8000f124:	f6 0a 18 00 	cp.b	r10,r11
8000f128:	c3 a0       	breq	8000f19c <get_arg+0x16c>
8000f12a:	34 4b       	mov	r11,68
8000f12c:	c0 88       	rjmp	8000f13c <get_arg+0x10c>
8000f12e:	35 8b       	mov	r11,88
8000f130:	f6 0a 18 00 	cp.b	r10,r11
8000f134:	c2 c0       	breq	8000f18c <get_arg+0x15c>
8000f136:	e0 8b 00 07 	brhi	8000f144 <get_arg+0x114>
8000f13a:	35 5b       	mov	r11,85
8000f13c:	f6 0a 18 00 	cp.b	r10,r11
8000f140:	c3 51       	brne	8000f1aa <get_arg+0x17a>
8000f142:	c3 18       	rjmp	8000f1a4 <get_arg+0x174>
8000f144:	36 3b       	mov	r11,99
8000f146:	f6 0a 18 00 	cp.b	r10,r11
8000f14a:	c2 f0       	breq	8000f1a8 <get_arg+0x178>
8000f14c:	36 4b       	mov	r11,100
8000f14e:	c0 e8       	rjmp	8000f16a <get_arg+0x13a>
8000f150:	37 0b       	mov	r11,112
8000f152:	f6 0a 18 00 	cp.b	r10,r11
8000f156:	c2 50       	breq	8000f1a0 <get_arg+0x170>
8000f158:	e0 8b 00 0d 	brhi	8000f172 <get_arg+0x142>
8000f15c:	36 eb       	mov	r11,110
8000f15e:	f6 0a 18 00 	cp.b	r10,r11
8000f162:	c1 f0       	breq	8000f1a0 <get_arg+0x170>
8000f164:	e0 8b 00 14 	brhi	8000f18c <get_arg+0x15c>
8000f168:	36 9b       	mov	r11,105
8000f16a:	f6 0a 18 00 	cp.b	r10,r11
8000f16e:	c1 e1       	brne	8000f1aa <get_arg+0x17a>
8000f170:	c0 e8       	rjmp	8000f18c <get_arg+0x15c>
8000f172:	37 5b       	mov	r11,117
8000f174:	f6 0a 18 00 	cp.b	r10,r11
8000f178:	c0 a0       	breq	8000f18c <get_arg+0x15c>
8000f17a:	37 8b       	mov	r11,120
8000f17c:	f6 0a 18 00 	cp.b	r10,r11
8000f180:	c0 60       	breq	8000f18c <get_arg+0x15c>
8000f182:	37 3b       	mov	r11,115
8000f184:	f6 0a 18 00 	cp.b	r10,r11
8000f188:	c1 11       	brne	8000f1aa <get_arg+0x17a>
8000f18a:	c0 b8       	rjmp	8000f1a0 <get_arg+0x170>
8000f18c:	ed b4 00 04 	bld	r4,0x4
8000f190:	c0 a0       	breq	8000f1a4 <get_arg+0x174>
8000f192:	ed b4 00 05 	bld	r4,0x5
8000f196:	c0 91       	brne	8000f1a8 <get_arg+0x178>
8000f198:	30 20       	mov	r0,2
8000f19a:	c0 88       	rjmp	8000f1aa <get_arg+0x17a>
8000f19c:	30 40       	mov	r0,4
8000f19e:	c0 68       	rjmp	8000f1aa <get_arg+0x17a>
8000f1a0:	30 30       	mov	r0,3
8000f1a2:	c0 48       	rjmp	8000f1aa <get_arg+0x17a>
8000f1a4:	30 10       	mov	r0,1
8000f1a6:	c0 28       	rjmp	8000f1aa <get_arg+0x17a>
8000f1a8:	30 00       	mov	r0,0
8000f1aa:	40 3b       	lddsp	r11,sp[0xc]
8000f1ac:	5b fb       	cp.w	r11,-1
8000f1ae:	c0 40       	breq	8000f1b6 <get_arg+0x186>
8000f1b0:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000f1b4:	c7 18       	rjmp	8000f296 <get_arg+0x266>
8000f1b6:	58 60       	cp.w	r0,6
8000f1b8:	e0 8b 00 6f 	brhi	8000f296 <get_arg+0x266>
8000f1bc:	6c 0a       	ld.w	r10,r6[0x0]
8000f1be:	ea cc ff ff 	sub	r12,r5,-1
8000f1c2:	fe ce a1 62 	sub	lr,pc,-24222
8000f1c6:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000f1ca:	d7 03       	nop
8000f1cc:	f4 cb ff f8 	sub	r11,r10,-8
8000f1d0:	8d 0b       	st.w	r6[0x0],r11
8000f1d2:	f4 ea 00 00 	ld.d	r10,r10[0]
8000f1d6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000f1da:	c0 f8       	rjmp	8000f1f8 <get_arg+0x1c8>
8000f1dc:	f4 cb ff fc 	sub	r11,r10,-4
8000f1e0:	8d 0b       	st.w	r6[0x0],r11
8000f1e2:	74 0a       	ld.w	r10,r10[0x0]
8000f1e4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000f1e8:	c0 88       	rjmp	8000f1f8 <get_arg+0x1c8>
8000f1ea:	f4 cb ff f8 	sub	r11,r10,-8
8000f1ee:	8d 0b       	st.w	r6[0x0],r11
8000f1f0:	f4 ea 00 00 	ld.d	r10,r10[0]
8000f1f4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000f1f8:	0e 9b       	mov	r11,r7
8000f1fa:	18 95       	mov	r5,r12
8000f1fc:	c4 e8       	rjmp	8000f298 <get_arg+0x268>
8000f1fe:	62 0a       	ld.w	r10,r1[0x0]
8000f200:	5b fa       	cp.w	r10,-1
8000f202:	c0 b1       	brne	8000f218 <get_arg+0x1e8>
8000f204:	50 19       	stdsp	sp[0x4],r9
8000f206:	50 28       	stdsp	sp[0x8],r8
8000f208:	e0 6a 00 80 	mov	r10,128
8000f20c:	30 0b       	mov	r11,0
8000f20e:	02 9c       	mov	r12,r1
8000f210:	fe b0 fd 7e 	rcall	8000ed0c <memset>
8000f214:	40 28       	lddsp	r8,sp[0x8]
8000f216:	40 19       	lddsp	r9,sp[0x4]
8000f218:	e4 cc 00 01 	sub	r12,r2,1
8000f21c:	0e 9b       	mov	r11,r7
8000f21e:	50 3c       	stdsp	sp[0xc],r12
8000f220:	f2 0c 0c 49 	max	r9,r9,r12
8000f224:	c3 a8       	rjmp	8000f298 <get_arg+0x268>
8000f226:	62 0a       	ld.w	r10,r1[0x0]
8000f228:	5b fa       	cp.w	r10,-1
8000f22a:	c0 b1       	brne	8000f240 <get_arg+0x210>
8000f22c:	50 19       	stdsp	sp[0x4],r9
8000f22e:	50 28       	stdsp	sp[0x8],r8
8000f230:	e0 6a 00 80 	mov	r10,128
8000f234:	30 0b       	mov	r11,0
8000f236:	02 9c       	mov	r12,r1
8000f238:	fe b0 fd 6a 	rcall	8000ed0c <memset>
8000f23c:	40 28       	lddsp	r8,sp[0x8]
8000f23e:	40 19       	lddsp	r9,sp[0x4]
8000f240:	20 12       	sub	r2,1
8000f242:	30 0a       	mov	r10,0
8000f244:	0e 9b       	mov	r11,r7
8000f246:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000f24a:	f2 02 0c 49 	max	r9,r9,r2
8000f24e:	c2 58       	rjmp	8000f298 <get_arg+0x268>
8000f250:	16 97       	mov	r7,r11
8000f252:	6c 0a       	ld.w	r10,r6[0x0]
8000f254:	f4 cb ff fc 	sub	r11,r10,-4
8000f258:	8d 0b       	st.w	r6[0x0],r11
8000f25a:	74 0a       	ld.w	r10,r10[0x0]
8000f25c:	0e 9b       	mov	r11,r7
8000f25e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000f262:	2f f5       	sub	r5,-1
8000f264:	c1 a8       	rjmp	8000f298 <get_arg+0x268>
8000f266:	f4 c2 00 30 	sub	r2,r10,48
8000f26a:	c0 68       	rjmp	8000f276 <get_arg+0x246>
8000f26c:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000f270:	2f f7       	sub	r7,-1
8000f272:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000f276:	0f 8a       	ld.ub	r10,r7[0x0]
8000f278:	58 0a       	cp.w	r10,0
8000f27a:	c0 e0       	breq	8000f296 <get_arg+0x266>
8000f27c:	23 0a       	sub	r10,48
8000f27e:	58 9a       	cp.w	r10,9
8000f280:	fe 98 ff f6 	brls	8000f26c <get_arg+0x23c>
8000f284:	c0 98       	rjmp	8000f296 <get_arg+0x266>
8000f286:	2f f7       	sub	r7,-1
8000f288:	0f 8a       	ld.ub	r10,r7[0x0]
8000f28a:	58 0a       	cp.w	r10,0
8000f28c:	c0 50       	breq	8000f296 <get_arg+0x266>
8000f28e:	23 0a       	sub	r10,48
8000f290:	58 9a       	cp.w	r10,9
8000f292:	fe 98 ff fa 	brls	8000f286 <get_arg+0x256>
8000f296:	0e 9b       	mov	r11,r7
8000f298:	40 7c       	lddsp	r12,sp[0x1c]
8000f29a:	30 ba       	mov	r10,11
8000f29c:	f4 0c 18 00 	cp.b	r12,r10
8000f2a0:	fe 91 fe f2 	brne	8000f084 <get_arg+0x54>
8000f2a4:	40 42       	lddsp	r2,sp[0x10]
8000f2a6:	17 8c       	ld.ub	r12,r11[0x0]
8000f2a8:	0a 32       	cp.w	r2,r5
8000f2aa:	5f 4a       	srge	r10
8000f2ac:	f0 0c 18 00 	cp.b	r12,r8
8000f2b0:	5f 1c       	srne	r12
8000f2b2:	f9 ea 00 0a 	and	r10,r12,r10
8000f2b6:	f0 0a 18 00 	cp.b	r10,r8
8000f2ba:	fe 91 fe cf 	brne	8000f058 <get_arg+0x28>
8000f2be:	30 08       	mov	r8,0
8000f2c0:	40 4e       	lddsp	lr,sp[0x10]
8000f2c2:	17 8a       	ld.ub	r10,r11[0x0]
8000f2c4:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000f2c8:	f0 0a 18 00 	cp.b	r10,r8
8000f2cc:	fc 09 17 10 	movne	r9,lr
8000f2d0:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000f2d4:	06 9e       	mov	lr,r3
8000f2d6:	c2 a8       	rjmp	8000f32a <get_arg+0x2fa>
8000f2d8:	62 0a       	ld.w	r10,r1[0x0]
8000f2da:	58 3a       	cp.w	r10,3
8000f2dc:	c1 e0       	breq	8000f318 <get_arg+0x2e8>
8000f2de:	e0 89 00 07 	brgt	8000f2ec <get_arg+0x2bc>
8000f2e2:	58 1a       	cp.w	r10,1
8000f2e4:	c1 a0       	breq	8000f318 <get_arg+0x2e8>
8000f2e6:	58 2a       	cp.w	r10,2
8000f2e8:	c1 81       	brne	8000f318 <get_arg+0x2e8>
8000f2ea:	c0 58       	rjmp	8000f2f4 <get_arg+0x2c4>
8000f2ec:	58 5a       	cp.w	r10,5
8000f2ee:	c0 c0       	breq	8000f306 <get_arg+0x2d6>
8000f2f0:	c0 b5       	brlt	8000f306 <get_arg+0x2d6>
8000f2f2:	c1 38       	rjmp	8000f318 <get_arg+0x2e8>
8000f2f4:	6c 0a       	ld.w	r10,r6[0x0]
8000f2f6:	f4 cc ff f8 	sub	r12,r10,-8
8000f2fa:	8d 0c       	st.w	r6[0x0],r12
8000f2fc:	f4 e2 00 00 	ld.d	r2,r10[0]
8000f300:	f0 e3 00 00 	st.d	r8[0],r2
8000f304:	c1 08       	rjmp	8000f324 <get_arg+0x2f4>
8000f306:	6c 0a       	ld.w	r10,r6[0x0]
8000f308:	f4 cc ff f8 	sub	r12,r10,-8
8000f30c:	8d 0c       	st.w	r6[0x0],r12
8000f30e:	f4 e2 00 00 	ld.d	r2,r10[0]
8000f312:	f0 e3 00 00 	st.d	r8[0],r2
8000f316:	c0 78       	rjmp	8000f324 <get_arg+0x2f4>
8000f318:	6c 0a       	ld.w	r10,r6[0x0]
8000f31a:	f4 cc ff fc 	sub	r12,r10,-4
8000f31e:	8d 0c       	st.w	r6[0x0],r12
8000f320:	74 0a       	ld.w	r10,r10[0x0]
8000f322:	91 0a       	st.w	r8[0x0],r10
8000f324:	2f f5       	sub	r5,-1
8000f326:	2f 88       	sub	r8,-8
8000f328:	2f c1       	sub	r1,-4
8000f32a:	12 35       	cp.w	r5,r9
8000f32c:	fe 9a ff d6 	brle	8000f2d8 <get_arg+0x2a8>
8000f330:	1c 93       	mov	r3,lr
8000f332:	40 52       	lddsp	r2,sp[0x14]
8000f334:	40 6e       	lddsp	lr,sp[0x18]
8000f336:	85 05       	st.w	r2[0x0],r5
8000f338:	9d 0b       	st.w	lr[0x0],r11
8000f33a:	40 4b       	lddsp	r11,sp[0x10]
8000f33c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000f340:	2f 8d       	sub	sp,-32
8000f342:	d8 32       	popm	r0-r7,pc

8000f344 <__sprint_r>:
8000f344:	d4 21       	pushm	r4-r7,lr
8000f346:	14 97       	mov	r7,r10
8000f348:	74 28       	ld.w	r8,r10[0x8]
8000f34a:	58 08       	cp.w	r8,0
8000f34c:	c0 41       	brne	8000f354 <__sprint_r+0x10>
8000f34e:	95 18       	st.w	r10[0x4],r8
8000f350:	10 9c       	mov	r12,r8
8000f352:	d8 22       	popm	r4-r7,pc
8000f354:	e0 a0 16 a2 	rcall	80012098 <__sfvwrite_r>
8000f358:	30 08       	mov	r8,0
8000f35a:	8f 18       	st.w	r7[0x4],r8
8000f35c:	8f 28       	st.w	r7[0x8],r8
8000f35e:	d8 22       	popm	r4-r7,pc

8000f360 <_vfprintf_r>:
8000f360:	d4 31       	pushm	r0-r7,lr
8000f362:	fa cd 06 bc 	sub	sp,sp,1724
8000f366:	51 09       	stdsp	sp[0x40],r9
8000f368:	16 91       	mov	r1,r11
8000f36a:	14 97       	mov	r7,r10
8000f36c:	18 95       	mov	r5,r12
8000f36e:	e0 a0 17 e3 	rcall	80012334 <_localeconv_r>
8000f372:	78 0c       	ld.w	r12,r12[0x0]
8000f374:	50 cc       	stdsp	sp[0x30],r12
8000f376:	58 05       	cp.w	r5,0
8000f378:	c0 70       	breq	8000f386 <_vfprintf_r+0x26>
8000f37a:	6a 68       	ld.w	r8,r5[0x18]
8000f37c:	58 08       	cp.w	r8,0
8000f37e:	c0 41       	brne	8000f386 <_vfprintf_r+0x26>
8000f380:	0a 9c       	mov	r12,r5
8000f382:	fe b0 f8 01 	rcall	8000e384 <__sinit>
8000f386:	fe c8 a3 ae 	sub	r8,pc,-23634
8000f38a:	10 31       	cp.w	r1,r8
8000f38c:	c0 31       	brne	8000f392 <_vfprintf_r+0x32>
8000f38e:	6a 01       	ld.w	r1,r5[0x0]
8000f390:	c0 c8       	rjmp	8000f3a8 <_vfprintf_r+0x48>
8000f392:	fe c8 a3 9a 	sub	r8,pc,-23654
8000f396:	10 31       	cp.w	r1,r8
8000f398:	c0 31       	brne	8000f39e <_vfprintf_r+0x3e>
8000f39a:	6a 11       	ld.w	r1,r5[0x4]
8000f39c:	c0 68       	rjmp	8000f3a8 <_vfprintf_r+0x48>
8000f39e:	fe c8 a3 86 	sub	r8,pc,-23674
8000f3a2:	10 31       	cp.w	r1,r8
8000f3a4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000f3a8:	82 68       	ld.sh	r8,r1[0xc]
8000f3aa:	ed b8 00 03 	bld	r8,0x3
8000f3ae:	c0 41       	brne	8000f3b6 <_vfprintf_r+0x56>
8000f3b0:	62 48       	ld.w	r8,r1[0x10]
8000f3b2:	58 08       	cp.w	r8,0
8000f3b4:	c0 71       	brne	8000f3c2 <_vfprintf_r+0x62>
8000f3b6:	02 9b       	mov	r11,r1
8000f3b8:	0a 9c       	mov	r12,r5
8000f3ba:	e0 a0 0f 6d 	rcall	80011294 <__swsetup_r>
8000f3be:	e0 81 0f 51 	brne	80011260 <_vfprintf_r+0x1f00>
8000f3c2:	82 68       	ld.sh	r8,r1[0xc]
8000f3c4:	10 99       	mov	r9,r8
8000f3c6:	e2 19 00 1a 	andl	r9,0x1a,COH
8000f3ca:	58 a9       	cp.w	r9,10
8000f3cc:	c3 c1       	brne	8000f444 <_vfprintf_r+0xe4>
8000f3ce:	82 79       	ld.sh	r9,r1[0xe]
8000f3d0:	30 0a       	mov	r10,0
8000f3d2:	f4 09 19 00 	cp.h	r9,r10
8000f3d6:	c3 75       	brlt	8000f444 <_vfprintf_r+0xe4>
8000f3d8:	a1 d8       	cbr	r8,0x1
8000f3da:	fb 58 05 d0 	st.h	sp[1488],r8
8000f3de:	62 88       	ld.w	r8,r1[0x20]
8000f3e0:	fb 48 05 e4 	st.w	sp[1508],r8
8000f3e4:	62 a8       	ld.w	r8,r1[0x28]
8000f3e6:	fb 48 05 ec 	st.w	sp[1516],r8
8000f3ea:	fa c8 ff bc 	sub	r8,sp,-68
8000f3ee:	fb 48 05 d4 	st.w	sp[1492],r8
8000f3f2:	fb 48 05 c4 	st.w	sp[1476],r8
8000f3f6:	e0 68 04 00 	mov	r8,1024
8000f3fa:	fb 48 05 d8 	st.w	sp[1496],r8
8000f3fe:	fb 48 05 cc 	st.w	sp[1484],r8
8000f402:	30 08       	mov	r8,0
8000f404:	fb 59 05 d2 	st.h	sp[1490],r9
8000f408:	0e 9a       	mov	r10,r7
8000f40a:	41 09       	lddsp	r9,sp[0x40]
8000f40c:	fa c7 fa 3c 	sub	r7,sp,-1476
8000f410:	fb 48 05 dc 	st.w	sp[1500],r8
8000f414:	0a 9c       	mov	r12,r5
8000f416:	0e 9b       	mov	r11,r7
8000f418:	ca 4f       	rcall	8000f360 <_vfprintf_r>
8000f41a:	50 bc       	stdsp	sp[0x2c],r12
8000f41c:	c0 95       	brlt	8000f42e <_vfprintf_r+0xce>
8000f41e:	0e 9b       	mov	r11,r7
8000f420:	0a 9c       	mov	r12,r5
8000f422:	fe b0 f6 d9 	rcall	8000e1d4 <_fflush_r>
8000f426:	40 be       	lddsp	lr,sp[0x2c]
8000f428:	f9 be 01 ff 	movne	lr,-1
8000f42c:	50 be       	stdsp	sp[0x2c],lr
8000f42e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000f432:	ed b8 00 06 	bld	r8,0x6
8000f436:	e0 81 0f 17 	brne	80011264 <_vfprintf_r+0x1f04>
8000f43a:	82 68       	ld.sh	r8,r1[0xc]
8000f43c:	a7 a8       	sbr	r8,0x6
8000f43e:	a2 68       	st.h	r1[0xc],r8
8000f440:	e0 8f 0f 12 	bral	80011264 <_vfprintf_r+0x1f04>
8000f444:	30 08       	mov	r8,0
8000f446:	fb 48 06 b4 	st.w	sp[1716],r8
8000f44a:	fb 48 06 90 	st.w	sp[1680],r8
8000f44e:	fb 48 06 8c 	st.w	sp[1676],r8
8000f452:	fb 48 06 b0 	st.w	sp[1712],r8
8000f456:	30 08       	mov	r8,0
8000f458:	30 09       	mov	r9,0
8000f45a:	50 a7       	stdsp	sp[0x28],r7
8000f45c:	50 78       	stdsp	sp[0x1c],r8
8000f45e:	fa c4 f9 e0 	sub	r4,sp,-1568
8000f462:	3f f8       	mov	r8,-1
8000f464:	50 59       	stdsp	sp[0x14],r9
8000f466:	fb 44 06 88 	st.w	sp[1672],r4
8000f46a:	fb 48 05 44 	st.w	sp[1348],r8
8000f46e:	12 9c       	mov	r12,r9
8000f470:	50 69       	stdsp	sp[0x18],r9
8000f472:	50 d9       	stdsp	sp[0x34],r9
8000f474:	50 e9       	stdsp	sp[0x38],r9
8000f476:	50 b9       	stdsp	sp[0x2c],r9
8000f478:	12 97       	mov	r7,r9
8000f47a:	40 a2       	lddsp	r2,sp[0x28]
8000f47c:	32 5a       	mov	r10,37
8000f47e:	30 08       	mov	r8,0
8000f480:	c0 28       	rjmp	8000f484 <_vfprintf_r+0x124>
8000f482:	2f f2       	sub	r2,-1
8000f484:	05 89       	ld.ub	r9,r2[0x0]
8000f486:	f0 09 18 00 	cp.b	r9,r8
8000f48a:	5f 1b       	srne	r11
8000f48c:	f4 09 18 00 	cp.b	r9,r10
8000f490:	5f 19       	srne	r9
8000f492:	f3 eb 00 0b 	and	r11,r9,r11
8000f496:	f0 0b 18 00 	cp.b	r11,r8
8000f49a:	cf 41       	brne	8000f482 <_vfprintf_r+0x122>
8000f49c:	40 ab       	lddsp	r11,sp[0x28]
8000f49e:	e4 0b 01 06 	sub	r6,r2,r11
8000f4a2:	c1 f0       	breq	8000f4e0 <_vfprintf_r+0x180>
8000f4a4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000f4a8:	0c 08       	add	r8,r6
8000f4aa:	89 0b       	st.w	r4[0x0],r11
8000f4ac:	fb 48 06 90 	st.w	sp[1680],r8
8000f4b0:	89 16       	st.w	r4[0x4],r6
8000f4b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000f4b6:	2f f8       	sub	r8,-1
8000f4b8:	fb 48 06 8c 	st.w	sp[1676],r8
8000f4bc:	58 78       	cp.w	r8,7
8000f4be:	e0 89 00 05 	brgt	8000f4c8 <_vfprintf_r+0x168>
8000f4c2:	2f 84       	sub	r4,-8
8000f4c4:	c0 b8       	rjmp	8000f4da <_vfprintf_r+0x17a>
8000f4c6:	d7 03       	nop
8000f4c8:	fa ca f9 78 	sub	r10,sp,-1672
8000f4cc:	02 9b       	mov	r11,r1
8000f4ce:	0a 9c       	mov	r12,r5
8000f4d0:	c3 af       	rcall	8000f344 <__sprint_r>
8000f4d2:	e0 81 0e c3 	brne	80011258 <_vfprintf_r+0x1ef8>
8000f4d6:	fa c4 f9 e0 	sub	r4,sp,-1568
8000f4da:	40 ba       	lddsp	r10,sp[0x2c]
8000f4dc:	0c 0a       	add	r10,r6
8000f4de:	50 ba       	stdsp	sp[0x2c],r10
8000f4e0:	05 89       	ld.ub	r9,r2[0x0]
8000f4e2:	30 08       	mov	r8,0
8000f4e4:	f0 09 18 00 	cp.b	r9,r8
8000f4e8:	e0 80 0e a8 	breq	80011238 <_vfprintf_r+0x1ed8>
8000f4ec:	30 09       	mov	r9,0
8000f4ee:	fb 68 06 bb 	st.b	sp[1723],r8
8000f4f2:	0e 96       	mov	r6,r7
8000f4f4:	e4 c8 ff ff 	sub	r8,r2,-1
8000f4f8:	3f fe       	mov	lr,-1
8000f4fa:	50 94       	stdsp	sp[0x24],r4
8000f4fc:	50 41       	stdsp	sp[0x10],r1
8000f4fe:	0e 94       	mov	r4,r7
8000f500:	04 91       	mov	r1,r2
8000f502:	50 89       	stdsp	sp[0x20],r9
8000f504:	50 a8       	stdsp	sp[0x28],r8
8000f506:	50 2e       	stdsp	sp[0x8],lr
8000f508:	50 39       	stdsp	sp[0xc],r9
8000f50a:	12 93       	mov	r3,r9
8000f50c:	12 90       	mov	r0,r9
8000f50e:	10 97       	mov	r7,r8
8000f510:	0a 92       	mov	r2,r5
8000f512:	c0 78       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f514:	3f fc       	mov	r12,-1
8000f516:	0a 97       	mov	r7,r5
8000f518:	50 2c       	stdsp	sp[0x8],r12
8000f51a:	c0 38       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f51c:	30 0b       	mov	r11,0
8000f51e:	50 3b       	stdsp	sp[0xc],r11
8000f520:	0f 38       	ld.ub	r8,r7++
8000f522:	c0 28       	rjmp	8000f526 <_vfprintf_r+0x1c6>
8000f524:	12 90       	mov	r0,r9
8000f526:	f0 c9 00 20 	sub	r9,r8,32
8000f52a:	e0 49 00 58 	cp.w	r9,88
8000f52e:	e0 8b 0a 2d 	brhi	80010988 <_vfprintf_r+0x1628>
8000f532:	fe ca a4 b6 	sub	r10,pc,-23370
8000f536:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000f53a:	50 a7       	stdsp	sp[0x28],r7
8000f53c:	50 80       	stdsp	sp[0x20],r0
8000f53e:	0c 97       	mov	r7,r6
8000f540:	04 95       	mov	r5,r2
8000f542:	08 96       	mov	r6,r4
8000f544:	02 92       	mov	r2,r1
8000f546:	fe c9 a5 b6 	sub	r9,pc,-23114
8000f54a:	40 94       	lddsp	r4,sp[0x24]
8000f54c:	10 90       	mov	r0,r8
8000f54e:	40 41       	lddsp	r1,sp[0x10]
8000f550:	50 d9       	stdsp	sp[0x34],r9
8000f552:	e0 8f 08 8e 	bral	8001066e <_vfprintf_r+0x130e>
8000f556:	30 08       	mov	r8,0
8000f558:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000f55c:	f0 09 18 00 	cp.b	r9,r8
8000f560:	ce 01       	brne	8000f520 <_vfprintf_r+0x1c0>
8000f562:	32 08       	mov	r8,32
8000f564:	c6 e8       	rjmp	8000f640 <_vfprintf_r+0x2e0>
8000f566:	a1 a3       	sbr	r3,0x0
8000f568:	cd cb       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f56a:	0f 89       	ld.ub	r9,r7[0x0]
8000f56c:	f2 c8 00 30 	sub	r8,r9,48
8000f570:	58 98       	cp.w	r8,9
8000f572:	e0 8b 00 1d 	brhi	8000f5ac <_vfprintf_r+0x24c>
8000f576:	ee c8 ff ff 	sub	r8,r7,-1
8000f57a:	30 0b       	mov	r11,0
8000f57c:	23 09       	sub	r9,48
8000f57e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000f582:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000f586:	11 39       	ld.ub	r9,r8++
8000f588:	f2 ca 00 30 	sub	r10,r9,48
8000f58c:	58 9a       	cp.w	r10,9
8000f58e:	fe 98 ff f7 	brls	8000f57c <_vfprintf_r+0x21c>
8000f592:	e0 49 00 24 	cp.w	r9,36
8000f596:	cc 31       	brne	8000f51c <_vfprintf_r+0x1bc>
8000f598:	e0 4b 00 20 	cp.w	r11,32
8000f59c:	e0 89 0e 5d 	brgt	80011256 <_vfprintf_r+0x1ef6>
8000f5a0:	20 1b       	sub	r11,1
8000f5a2:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000f5a6:	12 3b       	cp.w	r11,r9
8000f5a8:	c0 95       	brlt	8000f5ba <_vfprintf_r+0x25a>
8000f5aa:	c1 08       	rjmp	8000f5ca <_vfprintf_r+0x26a>
8000f5ac:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000f5b0:	ec ca ff ff 	sub	r10,r6,-1
8000f5b4:	12 36       	cp.w	r6,r9
8000f5b6:	c1 f5       	brlt	8000f5f4 <_vfprintf_r+0x294>
8000f5b8:	c2 68       	rjmp	8000f604 <_vfprintf_r+0x2a4>
8000f5ba:	fa ce f9 44 	sub	lr,sp,-1724
8000f5be:	10 97       	mov	r7,r8
8000f5c0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000f5c4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000f5c8:	c3 58       	rjmp	8000f632 <_vfprintf_r+0x2d2>
8000f5ca:	10 97       	mov	r7,r8
8000f5cc:	fa c8 f9 50 	sub	r8,sp,-1712
8000f5d0:	1a d8       	st.w	--sp,r8
8000f5d2:	fa c8 fa b8 	sub	r8,sp,-1352
8000f5d6:	1a d8       	st.w	--sp,r8
8000f5d8:	fa c8 fb b4 	sub	r8,sp,-1100
8000f5dc:	02 9a       	mov	r10,r1
8000f5de:	1a d8       	st.w	--sp,r8
8000f5e0:	04 9c       	mov	r12,r2
8000f5e2:	fa c8 f9 40 	sub	r8,sp,-1728
8000f5e6:	fa c9 ff b4 	sub	r9,sp,-76
8000f5ea:	fe b0 fd 23 	rcall	8000f030 <get_arg>
8000f5ee:	2f dd       	sub	sp,-12
8000f5f0:	78 00       	ld.w	r0,r12[0x0]
8000f5f2:	c2 08       	rjmp	8000f632 <_vfprintf_r+0x2d2>
8000f5f4:	fa cc f9 44 	sub	r12,sp,-1724
8000f5f8:	14 96       	mov	r6,r10
8000f5fa:	f8 04 00 38 	add	r8,r12,r4<<0x3
8000f5fe:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000f602:	c1 88       	rjmp	8000f632 <_vfprintf_r+0x2d2>
8000f604:	41 08       	lddsp	r8,sp[0x40]
8000f606:	59 f9       	cp.w	r9,31
8000f608:	e0 89 00 11 	brgt	8000f62a <_vfprintf_r+0x2ca>
8000f60c:	f0 cb ff fc 	sub	r11,r8,-4
8000f610:	51 0b       	stdsp	sp[0x40],r11
8000f612:	70 00       	ld.w	r0,r8[0x0]
8000f614:	fa cb f9 44 	sub	r11,sp,-1724
8000f618:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000f61c:	f1 40 fd 88 	st.w	r8[-632],r0
8000f620:	2f f9       	sub	r9,-1
8000f622:	14 96       	mov	r6,r10
8000f624:	fb 49 06 b4 	st.w	sp[1716],r9
8000f628:	c0 58       	rjmp	8000f632 <_vfprintf_r+0x2d2>
8000f62a:	70 00       	ld.w	r0,r8[0x0]
8000f62c:	14 96       	mov	r6,r10
8000f62e:	2f c8       	sub	r8,-4
8000f630:	51 08       	stdsp	sp[0x40],r8
8000f632:	58 00       	cp.w	r0,0
8000f634:	fe 94 ff 76 	brge	8000f520 <_vfprintf_r+0x1c0>
8000f638:	5c 30       	neg	r0
8000f63a:	a3 a3       	sbr	r3,0x2
8000f63c:	c7 2b       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f63e:	32 b8       	mov	r8,43
8000f640:	fb 68 06 bb 	st.b	sp[1723],r8
8000f644:	c6 eb       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f646:	0f 38       	ld.ub	r8,r7++
8000f648:	e0 48 00 2a 	cp.w	r8,42
8000f64c:	c0 30       	breq	8000f652 <_vfprintf_r+0x2f2>
8000f64e:	30 09       	mov	r9,0
8000f650:	c7 98       	rjmp	8000f742 <_vfprintf_r+0x3e2>
8000f652:	0f 88       	ld.ub	r8,r7[0x0]
8000f654:	f0 c9 00 30 	sub	r9,r8,48
8000f658:	58 99       	cp.w	r9,9
8000f65a:	e0 8b 00 1f 	brhi	8000f698 <_vfprintf_r+0x338>
8000f65e:	ee c5 ff ff 	sub	r5,r7,-1
8000f662:	30 0b       	mov	r11,0
8000f664:	23 08       	sub	r8,48
8000f666:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000f66a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000f66e:	0b 38       	ld.ub	r8,r5++
8000f670:	f0 c9 00 30 	sub	r9,r8,48
8000f674:	58 99       	cp.w	r9,9
8000f676:	fe 98 ff f7 	brls	8000f664 <_vfprintf_r+0x304>
8000f67a:	e0 48 00 24 	cp.w	r8,36
8000f67e:	fe 91 ff 4f 	brne	8000f51c <_vfprintf_r+0x1bc>
8000f682:	e0 4b 00 20 	cp.w	r11,32
8000f686:	e0 89 0d e8 	brgt	80011256 <_vfprintf_r+0x1ef6>
8000f68a:	20 1b       	sub	r11,1
8000f68c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f690:	10 3b       	cp.w	r11,r8
8000f692:	c0 a5       	brlt	8000f6a6 <_vfprintf_r+0x346>
8000f694:	c1 18       	rjmp	8000f6b6 <_vfprintf_r+0x356>
8000f696:	d7 03       	nop
8000f698:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000f69c:	ec c9 ff ff 	sub	r9,r6,-1
8000f6a0:	14 36       	cp.w	r6,r10
8000f6a2:	c1 f5       	brlt	8000f6e0 <_vfprintf_r+0x380>
8000f6a4:	c2 88       	rjmp	8000f6f4 <_vfprintf_r+0x394>
8000f6a6:	fa ca f9 44 	sub	r10,sp,-1724
8000f6aa:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000f6ae:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000f6b2:	50 2b       	stdsp	sp[0x8],r11
8000f6b4:	c3 c8       	rjmp	8000f72c <_vfprintf_r+0x3cc>
8000f6b6:	fa c8 f9 50 	sub	r8,sp,-1712
8000f6ba:	1a d8       	st.w	--sp,r8
8000f6bc:	fa c8 fa b8 	sub	r8,sp,-1352
8000f6c0:	1a d8       	st.w	--sp,r8
8000f6c2:	fa c8 fb b4 	sub	r8,sp,-1100
8000f6c6:	02 9a       	mov	r10,r1
8000f6c8:	1a d8       	st.w	--sp,r8
8000f6ca:	04 9c       	mov	r12,r2
8000f6cc:	fa c8 f9 40 	sub	r8,sp,-1728
8000f6d0:	fa c9 ff b4 	sub	r9,sp,-76
8000f6d4:	fe b0 fc ae 	rcall	8000f030 <get_arg>
8000f6d8:	2f dd       	sub	sp,-12
8000f6da:	78 0c       	ld.w	r12,r12[0x0]
8000f6dc:	50 2c       	stdsp	sp[0x8],r12
8000f6de:	c2 78       	rjmp	8000f72c <_vfprintf_r+0x3cc>
8000f6e0:	12 96       	mov	r6,r9
8000f6e2:	0e 95       	mov	r5,r7
8000f6e4:	fa c9 f9 44 	sub	r9,sp,-1724
8000f6e8:	f2 04 00 38 	add	r8,r9,r4<<0x3
8000f6ec:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000f6f0:	50 28       	stdsp	sp[0x8],r8
8000f6f2:	c1 d8       	rjmp	8000f72c <_vfprintf_r+0x3cc>
8000f6f4:	41 08       	lddsp	r8,sp[0x40]
8000f6f6:	59 fa       	cp.w	r10,31
8000f6f8:	e0 89 00 14 	brgt	8000f720 <_vfprintf_r+0x3c0>
8000f6fc:	f0 cb ff fc 	sub	r11,r8,-4
8000f700:	70 08       	ld.w	r8,r8[0x0]
8000f702:	51 0b       	stdsp	sp[0x40],r11
8000f704:	50 28       	stdsp	sp[0x8],r8
8000f706:	fa c6 f9 44 	sub	r6,sp,-1724
8000f70a:	40 2e       	lddsp	lr,sp[0x8]
8000f70c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000f710:	f1 4e fd 88 	st.w	r8[-632],lr
8000f714:	2f fa       	sub	r10,-1
8000f716:	0e 95       	mov	r5,r7
8000f718:	fb 4a 06 b4 	st.w	sp[1716],r10
8000f71c:	12 96       	mov	r6,r9
8000f71e:	c0 78       	rjmp	8000f72c <_vfprintf_r+0x3cc>
8000f720:	70 0c       	ld.w	r12,r8[0x0]
8000f722:	0e 95       	mov	r5,r7
8000f724:	2f c8       	sub	r8,-4
8000f726:	50 2c       	stdsp	sp[0x8],r12
8000f728:	12 96       	mov	r6,r9
8000f72a:	51 08       	stdsp	sp[0x40],r8
8000f72c:	40 2b       	lddsp	r11,sp[0x8]
8000f72e:	58 0b       	cp.w	r11,0
8000f730:	fe 95 fe f2 	brlt	8000f514 <_vfprintf_r+0x1b4>
8000f734:	0a 97       	mov	r7,r5
8000f736:	cf 5a       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f738:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000f73c:	0f 38       	ld.ub	r8,r7++
8000f73e:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000f742:	f0 ca 00 30 	sub	r10,r8,48
8000f746:	58 9a       	cp.w	r10,9
8000f748:	fe 98 ff f8 	brls	8000f738 <_vfprintf_r+0x3d8>
8000f74c:	3f fa       	mov	r10,-1
8000f74e:	f2 0a 0c 49 	max	r9,r9,r10
8000f752:	50 29       	stdsp	sp[0x8],r9
8000f754:	ce 9a       	rjmp	8000f526 <_vfprintf_r+0x1c6>
8000f756:	a7 b3       	sbr	r3,0x7
8000f758:	ce 4a       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f75a:	30 09       	mov	r9,0
8000f75c:	23 08       	sub	r8,48
8000f75e:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000f762:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000f766:	0f 38       	ld.ub	r8,r7++
8000f768:	f0 ca 00 30 	sub	r10,r8,48
8000f76c:	58 9a       	cp.w	r10,9
8000f76e:	fe 98 ff f7 	brls	8000f75c <_vfprintf_r+0x3fc>
8000f772:	e0 48 00 24 	cp.w	r8,36
8000f776:	fe 91 fe d7 	brne	8000f524 <_vfprintf_r+0x1c4>
8000f77a:	e0 49 00 20 	cp.w	r9,32
8000f77e:	e0 89 0d 6c 	brgt	80011256 <_vfprintf_r+0x1ef6>
8000f782:	f2 c4 00 01 	sub	r4,r9,1
8000f786:	30 19       	mov	r9,1
8000f788:	50 39       	stdsp	sp[0xc],r9
8000f78a:	cc ba       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f78c:	a3 b3       	sbr	r3,0x3
8000f78e:	cc 9a       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f790:	a7 a3       	sbr	r3,0x6
8000f792:	cc 7a       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f794:	0f 88       	ld.ub	r8,r7[0x0]
8000f796:	36 ce       	mov	lr,108
8000f798:	fc 08 18 00 	cp.b	r8,lr
8000f79c:	c0 41       	brne	8000f7a4 <_vfprintf_r+0x444>
8000f79e:	2f f7       	sub	r7,-1
8000f7a0:	a5 b3       	sbr	r3,0x5
8000f7a2:	cb fa       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f7a4:	a5 a3       	sbr	r3,0x4
8000f7a6:	cb da       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f7a8:	a5 b3       	sbr	r3,0x5
8000f7aa:	cb ba       	rjmp	8000f520 <_vfprintf_r+0x1c0>
8000f7ac:	50 a7       	stdsp	sp[0x28],r7
8000f7ae:	50 80       	stdsp	sp[0x20],r0
8000f7b0:	0c 97       	mov	r7,r6
8000f7b2:	10 90       	mov	r0,r8
8000f7b4:	08 96       	mov	r6,r4
8000f7b6:	04 95       	mov	r5,r2
8000f7b8:	40 94       	lddsp	r4,sp[0x24]
8000f7ba:	02 92       	mov	r2,r1
8000f7bc:	0e 99       	mov	r9,r7
8000f7be:	40 41       	lddsp	r1,sp[0x10]
8000f7c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f7c4:	40 3c       	lddsp	r12,sp[0xc]
8000f7c6:	58 0c       	cp.w	r12,0
8000f7c8:	c1 d0       	breq	8000f802 <_vfprintf_r+0x4a2>
8000f7ca:	10 36       	cp.w	r6,r8
8000f7cc:	c0 64       	brge	8000f7d8 <_vfprintf_r+0x478>
8000f7ce:	fa cb f9 44 	sub	r11,sp,-1724
8000f7d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f7d6:	c1 d8       	rjmp	8000f810 <_vfprintf_r+0x4b0>
8000f7d8:	fa c8 f9 50 	sub	r8,sp,-1712
8000f7dc:	1a d8       	st.w	--sp,r8
8000f7de:	fa c8 fa b8 	sub	r8,sp,-1352
8000f7e2:	1a d8       	st.w	--sp,r8
8000f7e4:	fa c8 fb b4 	sub	r8,sp,-1100
8000f7e8:	1a d8       	st.w	--sp,r8
8000f7ea:	fa c8 f9 40 	sub	r8,sp,-1728
8000f7ee:	fa c9 ff b4 	sub	r9,sp,-76
8000f7f2:	04 9a       	mov	r10,r2
8000f7f4:	0c 9b       	mov	r11,r6
8000f7f6:	0a 9c       	mov	r12,r5
8000f7f8:	fe b0 fc 1c 	rcall	8000f030 <get_arg>
8000f7fc:	2f dd       	sub	sp,-12
8000f7fe:	19 b8       	ld.ub	r8,r12[0x3]
8000f800:	c2 28       	rjmp	8000f844 <_vfprintf_r+0x4e4>
8000f802:	2f f7       	sub	r7,-1
8000f804:	10 39       	cp.w	r9,r8
8000f806:	c0 84       	brge	8000f816 <_vfprintf_r+0x4b6>
8000f808:	fa ca f9 44 	sub	r10,sp,-1724
8000f80c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000f810:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000f814:	c1 88       	rjmp	8000f844 <_vfprintf_r+0x4e4>
8000f816:	41 09       	lddsp	r9,sp[0x40]
8000f818:	59 f8       	cp.w	r8,31
8000f81a:	e0 89 00 12 	brgt	8000f83e <_vfprintf_r+0x4de>
8000f81e:	f2 ca ff fc 	sub	r10,r9,-4
8000f822:	51 0a       	stdsp	sp[0x40],r10
8000f824:	72 09       	ld.w	r9,r9[0x0]
8000f826:	fa c6 f9 44 	sub	r6,sp,-1724
8000f82a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000f82e:	2f f8       	sub	r8,-1
8000f830:	f5 49 fd 88 	st.w	r10[-632],r9
8000f834:	fb 48 06 b4 	st.w	sp[1716],r8
8000f838:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000f83c:	c0 48       	rjmp	8000f844 <_vfprintf_r+0x4e4>
8000f83e:	13 b8       	ld.ub	r8,r9[0x3]
8000f840:	2f c9       	sub	r9,-4
8000f842:	51 09       	stdsp	sp[0x40],r9
8000f844:	fb 68 06 60 	st.b	sp[1632],r8
8000f848:	30 0e       	mov	lr,0
8000f84a:	30 08       	mov	r8,0
8000f84c:	30 12       	mov	r2,1
8000f84e:	fb 68 06 bb 	st.b	sp[1723],r8
8000f852:	50 2e       	stdsp	sp[0x8],lr
8000f854:	e0 8f 08 ac 	bral	800109ac <_vfprintf_r+0x164c>
8000f858:	50 a7       	stdsp	sp[0x28],r7
8000f85a:	50 80       	stdsp	sp[0x20],r0
8000f85c:	0c 97       	mov	r7,r6
8000f85e:	04 95       	mov	r5,r2
8000f860:	08 96       	mov	r6,r4
8000f862:	02 92       	mov	r2,r1
8000f864:	40 94       	lddsp	r4,sp[0x24]
8000f866:	10 90       	mov	r0,r8
8000f868:	40 41       	lddsp	r1,sp[0x10]
8000f86a:	a5 a3       	sbr	r3,0x4
8000f86c:	c0 a8       	rjmp	8000f880 <_vfprintf_r+0x520>
8000f86e:	50 a7       	stdsp	sp[0x28],r7
8000f870:	50 80       	stdsp	sp[0x20],r0
8000f872:	0c 97       	mov	r7,r6
8000f874:	04 95       	mov	r5,r2
8000f876:	08 96       	mov	r6,r4
8000f878:	02 92       	mov	r2,r1
8000f87a:	40 94       	lddsp	r4,sp[0x24]
8000f87c:	10 90       	mov	r0,r8
8000f87e:	40 41       	lddsp	r1,sp[0x10]
8000f880:	ed b3 00 05 	bld	r3,0x5
8000f884:	c5 11       	brne	8000f926 <_vfprintf_r+0x5c6>
8000f886:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f88a:	40 3c       	lddsp	r12,sp[0xc]
8000f88c:	58 0c       	cp.w	r12,0
8000f88e:	c1 e0       	breq	8000f8ca <_vfprintf_r+0x56a>
8000f890:	10 36       	cp.w	r6,r8
8000f892:	c0 64       	brge	8000f89e <_vfprintf_r+0x53e>
8000f894:	fa cb f9 44 	sub	r11,sp,-1724
8000f898:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f89c:	c2 08       	rjmp	8000f8dc <_vfprintf_r+0x57c>
8000f89e:	fa c8 f9 50 	sub	r8,sp,-1712
8000f8a2:	1a d8       	st.w	--sp,r8
8000f8a4:	fa c8 fa b8 	sub	r8,sp,-1352
8000f8a8:	0c 9b       	mov	r11,r6
8000f8aa:	1a d8       	st.w	--sp,r8
8000f8ac:	fa c8 fb b4 	sub	r8,sp,-1100
8000f8b0:	1a d8       	st.w	--sp,r8
8000f8b2:	fa c9 ff b4 	sub	r9,sp,-76
8000f8b6:	fa c8 f9 40 	sub	r8,sp,-1728
8000f8ba:	04 9a       	mov	r10,r2
8000f8bc:	0a 9c       	mov	r12,r5
8000f8be:	fe b0 fb b9 	rcall	8000f030 <get_arg>
8000f8c2:	2f dd       	sub	sp,-12
8000f8c4:	78 1b       	ld.w	r11,r12[0x4]
8000f8c6:	78 09       	ld.w	r9,r12[0x0]
8000f8c8:	c2 b8       	rjmp	8000f91e <_vfprintf_r+0x5be>
8000f8ca:	ee ca ff ff 	sub	r10,r7,-1
8000f8ce:	10 37       	cp.w	r7,r8
8000f8d0:	c0 b4       	brge	8000f8e6 <_vfprintf_r+0x586>
8000f8d2:	fa c9 f9 44 	sub	r9,sp,-1724
8000f8d6:	14 97       	mov	r7,r10
8000f8d8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f8dc:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000f8e0:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000f8e4:	c1 d8       	rjmp	8000f91e <_vfprintf_r+0x5be>
8000f8e6:	41 09       	lddsp	r9,sp[0x40]
8000f8e8:	59 f8       	cp.w	r8,31
8000f8ea:	e0 89 00 14 	brgt	8000f912 <_vfprintf_r+0x5b2>
8000f8ee:	f2 cb ff f8 	sub	r11,r9,-8
8000f8f2:	51 0b       	stdsp	sp[0x40],r11
8000f8f4:	fa c6 f9 44 	sub	r6,sp,-1724
8000f8f8:	72 1b       	ld.w	r11,r9[0x4]
8000f8fa:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000f8fe:	72 09       	ld.w	r9,r9[0x0]
8000f900:	f9 4b fd 8c 	st.w	r12[-628],r11
8000f904:	f9 49 fd 88 	st.w	r12[-632],r9
8000f908:	2f f8       	sub	r8,-1
8000f90a:	14 97       	mov	r7,r10
8000f90c:	fb 48 06 b4 	st.w	sp[1716],r8
8000f910:	c0 78       	rjmp	8000f91e <_vfprintf_r+0x5be>
8000f912:	f2 c8 ff f8 	sub	r8,r9,-8
8000f916:	72 1b       	ld.w	r11,r9[0x4]
8000f918:	14 97       	mov	r7,r10
8000f91a:	51 08       	stdsp	sp[0x40],r8
8000f91c:	72 09       	ld.w	r9,r9[0x0]
8000f91e:	16 98       	mov	r8,r11
8000f920:	fa e9 00 00 	st.d	sp[0],r8
8000f924:	ca e8       	rjmp	8000fa80 <_vfprintf_r+0x720>
8000f926:	ed b3 00 04 	bld	r3,0x4
8000f92a:	c1 71       	brne	8000f958 <_vfprintf_r+0x5f8>
8000f92c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f930:	40 3e       	lddsp	lr,sp[0xc]
8000f932:	58 0e       	cp.w	lr,0
8000f934:	c0 80       	breq	8000f944 <_vfprintf_r+0x5e4>
8000f936:	10 36       	cp.w	r6,r8
8000f938:	c6 94       	brge	8000fa0a <_vfprintf_r+0x6aa>
8000f93a:	fa cc f9 44 	sub	r12,sp,-1724
8000f93e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000f942:	c8 28       	rjmp	8000fa46 <_vfprintf_r+0x6e6>
8000f944:	ee ca ff ff 	sub	r10,r7,-1
8000f948:	10 37       	cp.w	r7,r8
8000f94a:	e0 84 00 81 	brge	8000fa4c <_vfprintf_r+0x6ec>
8000f94e:	fa cb f9 44 	sub	r11,sp,-1724
8000f952:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f956:	c7 78       	rjmp	8000fa44 <_vfprintf_r+0x6e4>
8000f958:	ed b3 00 06 	bld	r3,0x6
8000f95c:	c4 b1       	brne	8000f9f2 <_vfprintf_r+0x692>
8000f95e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f962:	40 3c       	lddsp	r12,sp[0xc]
8000f964:	58 0c       	cp.w	r12,0
8000f966:	c1 d0       	breq	8000f9a0 <_vfprintf_r+0x640>
8000f968:	10 36       	cp.w	r6,r8
8000f96a:	c0 64       	brge	8000f976 <_vfprintf_r+0x616>
8000f96c:	fa cb f9 44 	sub	r11,sp,-1724
8000f970:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000f974:	c1 f8       	rjmp	8000f9b2 <_vfprintf_r+0x652>
8000f976:	fa c8 f9 50 	sub	r8,sp,-1712
8000f97a:	1a d8       	st.w	--sp,r8
8000f97c:	fa c8 fa b8 	sub	r8,sp,-1352
8000f980:	1a d8       	st.w	--sp,r8
8000f982:	fa c8 fb b4 	sub	r8,sp,-1100
8000f986:	1a d8       	st.w	--sp,r8
8000f988:	fa c8 f9 40 	sub	r8,sp,-1728
8000f98c:	fa c9 ff b4 	sub	r9,sp,-76
8000f990:	04 9a       	mov	r10,r2
8000f992:	0c 9b       	mov	r11,r6
8000f994:	0a 9c       	mov	r12,r5
8000f996:	fe b0 fb 4d 	rcall	8000f030 <get_arg>
8000f99a:	2f dd       	sub	sp,-12
8000f99c:	98 18       	ld.sh	r8,r12[0x2]
8000f99e:	c2 68       	rjmp	8000f9ea <_vfprintf_r+0x68a>
8000f9a0:	ee ca ff ff 	sub	r10,r7,-1
8000f9a4:	10 37       	cp.w	r7,r8
8000f9a6:	c0 94       	brge	8000f9b8 <_vfprintf_r+0x658>
8000f9a8:	fa c9 f9 44 	sub	r9,sp,-1724
8000f9ac:	14 97       	mov	r7,r10
8000f9ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000f9b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000f9b6:	c1 a8       	rjmp	8000f9ea <_vfprintf_r+0x68a>
8000f9b8:	41 09       	lddsp	r9,sp[0x40]
8000f9ba:	59 f8       	cp.w	r8,31
8000f9bc:	e0 89 00 13 	brgt	8000f9e2 <_vfprintf_r+0x682>
8000f9c0:	f2 cb ff fc 	sub	r11,r9,-4
8000f9c4:	51 0b       	stdsp	sp[0x40],r11
8000f9c6:	72 09       	ld.w	r9,r9[0x0]
8000f9c8:	fa c6 f9 44 	sub	r6,sp,-1724
8000f9cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000f9d0:	2f f8       	sub	r8,-1
8000f9d2:	f7 49 fd 88 	st.w	r11[-632],r9
8000f9d6:	fb 48 06 b4 	st.w	sp[1716],r8
8000f9da:	14 97       	mov	r7,r10
8000f9dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000f9e0:	c0 58       	rjmp	8000f9ea <_vfprintf_r+0x68a>
8000f9e2:	92 18       	ld.sh	r8,r9[0x2]
8000f9e4:	14 97       	mov	r7,r10
8000f9e6:	2f c9       	sub	r9,-4
8000f9e8:	51 09       	stdsp	sp[0x40],r9
8000f9ea:	50 18       	stdsp	sp[0x4],r8
8000f9ec:	bf 58       	asr	r8,0x1f
8000f9ee:	50 08       	stdsp	sp[0x0],r8
8000f9f0:	c4 88       	rjmp	8000fa80 <_vfprintf_r+0x720>
8000f9f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000f9f6:	40 3c       	lddsp	r12,sp[0xc]
8000f9f8:	58 0c       	cp.w	r12,0
8000f9fa:	c1 d0       	breq	8000fa34 <_vfprintf_r+0x6d4>
8000f9fc:	10 36       	cp.w	r6,r8
8000f9fe:	c0 64       	brge	8000fa0a <_vfprintf_r+0x6aa>
8000fa00:	fa cb f9 44 	sub	r11,sp,-1724
8000fa04:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000fa08:	c1 f8       	rjmp	8000fa46 <_vfprintf_r+0x6e6>
8000fa0a:	fa c8 f9 50 	sub	r8,sp,-1712
8000fa0e:	1a d8       	st.w	--sp,r8
8000fa10:	fa c8 fa b8 	sub	r8,sp,-1352
8000fa14:	0c 9b       	mov	r11,r6
8000fa16:	1a d8       	st.w	--sp,r8
8000fa18:	fa c8 fb b4 	sub	r8,sp,-1100
8000fa1c:	04 9a       	mov	r10,r2
8000fa1e:	1a d8       	st.w	--sp,r8
8000fa20:	0a 9c       	mov	r12,r5
8000fa22:	fa c8 f9 40 	sub	r8,sp,-1728
8000fa26:	fa c9 ff b4 	sub	r9,sp,-76
8000fa2a:	fe b0 fb 03 	rcall	8000f030 <get_arg>
8000fa2e:	2f dd       	sub	sp,-12
8000fa30:	78 0b       	ld.w	r11,r12[0x0]
8000fa32:	c2 48       	rjmp	8000fa7a <_vfprintf_r+0x71a>
8000fa34:	ee ca ff ff 	sub	r10,r7,-1
8000fa38:	10 37       	cp.w	r7,r8
8000fa3a:	c0 94       	brge	8000fa4c <_vfprintf_r+0x6ec>
8000fa3c:	fa c9 f9 44 	sub	r9,sp,-1724
8000fa40:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000fa44:	14 97       	mov	r7,r10
8000fa46:	ec fb fd 88 	ld.w	r11,r6[-632]
8000fa4a:	c1 88       	rjmp	8000fa7a <_vfprintf_r+0x71a>
8000fa4c:	41 09       	lddsp	r9,sp[0x40]
8000fa4e:	59 f8       	cp.w	r8,31
8000fa50:	e0 89 00 11 	brgt	8000fa72 <_vfprintf_r+0x712>
8000fa54:	f2 cb ff fc 	sub	r11,r9,-4
8000fa58:	51 0b       	stdsp	sp[0x40],r11
8000fa5a:	fa c6 f9 44 	sub	r6,sp,-1724
8000fa5e:	72 0b       	ld.w	r11,r9[0x0]
8000fa60:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000fa64:	f3 4b fd 88 	st.w	r9[-632],r11
8000fa68:	2f f8       	sub	r8,-1
8000fa6a:	14 97       	mov	r7,r10
8000fa6c:	fb 48 06 b4 	st.w	sp[1716],r8
8000fa70:	c0 58       	rjmp	8000fa7a <_vfprintf_r+0x71a>
8000fa72:	72 0b       	ld.w	r11,r9[0x0]
8000fa74:	14 97       	mov	r7,r10
8000fa76:	2f c9       	sub	r9,-4
8000fa78:	51 09       	stdsp	sp[0x40],r9
8000fa7a:	50 1b       	stdsp	sp[0x4],r11
8000fa7c:	bf 5b       	asr	r11,0x1f
8000fa7e:	50 0b       	stdsp	sp[0x0],r11
8000fa80:	fa ea 00 00 	ld.d	r10,sp[0]
8000fa84:	58 0a       	cp.w	r10,0
8000fa86:	5c 2b       	cpc	r11
8000fa88:	c0 e4       	brge	8000faa4 <_vfprintf_r+0x744>
8000fa8a:	30 08       	mov	r8,0
8000fa8c:	fa ea 00 00 	ld.d	r10,sp[0]
8000fa90:	30 09       	mov	r9,0
8000fa92:	f0 0a 01 0a 	sub	r10,r8,r10
8000fa96:	f2 0b 01 4b 	sbc	r11,r9,r11
8000fa9a:	32 d8       	mov	r8,45
8000fa9c:	fa eb 00 00 	st.d	sp[0],r10
8000faa0:	fb 68 06 bb 	st.b	sp[1723],r8
8000faa4:	30 18       	mov	r8,1
8000faa6:	e0 8f 06 f9 	bral	80010898 <_vfprintf_r+0x1538>
8000faaa:	50 a7       	stdsp	sp[0x28],r7
8000faac:	50 80       	stdsp	sp[0x20],r0
8000faae:	0c 97       	mov	r7,r6
8000fab0:	04 95       	mov	r5,r2
8000fab2:	08 96       	mov	r6,r4
8000fab4:	02 92       	mov	r2,r1
8000fab6:	40 94       	lddsp	r4,sp[0x24]
8000fab8:	10 90       	mov	r0,r8
8000faba:	40 41       	lddsp	r1,sp[0x10]
8000fabc:	0e 99       	mov	r9,r7
8000fabe:	ed b3 00 03 	bld	r3,0x3
8000fac2:	c4 11       	brne	8000fb44 <_vfprintf_r+0x7e4>
8000fac4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000fac8:	40 3a       	lddsp	r10,sp[0xc]
8000faca:	58 0a       	cp.w	r10,0
8000facc:	c1 90       	breq	8000fafe <_vfprintf_r+0x79e>
8000face:	10 36       	cp.w	r6,r8
8000fad0:	c6 45       	brlt	8000fb98 <_vfprintf_r+0x838>
8000fad2:	fa c8 f9 50 	sub	r8,sp,-1712
8000fad6:	1a d8       	st.w	--sp,r8
8000fad8:	fa c8 fa b8 	sub	r8,sp,-1352
8000fadc:	1a d8       	st.w	--sp,r8
8000fade:	fa c8 fb b4 	sub	r8,sp,-1100
8000fae2:	0c 9b       	mov	r11,r6
8000fae4:	1a d8       	st.w	--sp,r8
8000fae6:	04 9a       	mov	r10,r2
8000fae8:	fa c8 f9 40 	sub	r8,sp,-1728
8000faec:	fa c9 ff b4 	sub	r9,sp,-76
8000faf0:	0a 9c       	mov	r12,r5
8000faf2:	fe b0 fa 9f 	rcall	8000f030 <get_arg>
8000faf6:	2f dd       	sub	sp,-12
8000faf8:	78 16       	ld.w	r6,r12[0x4]
8000fafa:	50 76       	stdsp	sp[0x1c],r6
8000fafc:	c4 88       	rjmp	8000fb8c <_vfprintf_r+0x82c>
8000fafe:	2f f7       	sub	r7,-1
8000fb00:	10 39       	cp.w	r9,r8
8000fb02:	c0 c4       	brge	8000fb1a <_vfprintf_r+0x7ba>
8000fb04:	fa ce f9 44 	sub	lr,sp,-1724
8000fb08:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000fb0c:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000fb10:	50 7c       	stdsp	sp[0x1c],r12
8000fb12:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000fb16:	50 56       	stdsp	sp[0x14],r6
8000fb18:	c6 68       	rjmp	8000fbe4 <_vfprintf_r+0x884>
8000fb1a:	41 09       	lddsp	r9,sp[0x40]
8000fb1c:	59 f8       	cp.w	r8,31
8000fb1e:	e0 89 00 10 	brgt	8000fb3e <_vfprintf_r+0x7de>
8000fb22:	f2 ca ff f8 	sub	r10,r9,-8
8000fb26:	72 1b       	ld.w	r11,r9[0x4]
8000fb28:	51 0a       	stdsp	sp[0x40],r10
8000fb2a:	72 09       	ld.w	r9,r9[0x0]
8000fb2c:	fa ca f9 44 	sub	r10,sp,-1724
8000fb30:	50 7b       	stdsp	sp[0x1c],r11
8000fb32:	50 59       	stdsp	sp[0x14],r9
8000fb34:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000fb38:	40 5b       	lddsp	r11,sp[0x14]
8000fb3a:	40 7a       	lddsp	r10,sp[0x1c]
8000fb3c:	c4 78       	rjmp	8000fbca <_vfprintf_r+0x86a>
8000fb3e:	72 18       	ld.w	r8,r9[0x4]
8000fb40:	50 78       	stdsp	sp[0x1c],r8
8000fb42:	c4 c8       	rjmp	8000fbda <_vfprintf_r+0x87a>
8000fb44:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000fb48:	40 3e       	lddsp	lr,sp[0xc]
8000fb4a:	58 0e       	cp.w	lr,0
8000fb4c:	c2 30       	breq	8000fb92 <_vfprintf_r+0x832>
8000fb4e:	10 36       	cp.w	r6,r8
8000fb50:	c0 94       	brge	8000fb62 <_vfprintf_r+0x802>
8000fb52:	fa cc f9 44 	sub	r12,sp,-1724
8000fb56:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000fb5a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000fb5e:	50 7b       	stdsp	sp[0x1c],r11
8000fb60:	cd 9b       	rjmp	8000fb12 <_vfprintf_r+0x7b2>
8000fb62:	fa c8 f9 50 	sub	r8,sp,-1712
8000fb66:	1a d8       	st.w	--sp,r8
8000fb68:	fa c8 fa b8 	sub	r8,sp,-1352
8000fb6c:	04 9a       	mov	r10,r2
8000fb6e:	1a d8       	st.w	--sp,r8
8000fb70:	fa c8 fb b4 	sub	r8,sp,-1100
8000fb74:	0c 9b       	mov	r11,r6
8000fb76:	1a d8       	st.w	--sp,r8
8000fb78:	0a 9c       	mov	r12,r5
8000fb7a:	fa c8 f9 40 	sub	r8,sp,-1728
8000fb7e:	fa c9 ff b4 	sub	r9,sp,-76
8000fb82:	fe b0 fa 57 	rcall	8000f030 <get_arg>
8000fb86:	2f dd       	sub	sp,-12
8000fb88:	78 1a       	ld.w	r10,r12[0x4]
8000fb8a:	50 7a       	stdsp	sp[0x1c],r10
8000fb8c:	78 0c       	ld.w	r12,r12[0x0]
8000fb8e:	50 5c       	stdsp	sp[0x14],r12
8000fb90:	c2 a8       	rjmp	8000fbe4 <_vfprintf_r+0x884>
8000fb92:	2f f7       	sub	r7,-1
8000fb94:	10 39       	cp.w	r9,r8
8000fb96:	c0 94       	brge	8000fba8 <_vfprintf_r+0x848>
8000fb98:	fa c9 f9 44 	sub	r9,sp,-1724
8000fb9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000fba0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000fba4:	50 78       	stdsp	sp[0x1c],r8
8000fba6:	cb 6b       	rjmp	8000fb12 <_vfprintf_r+0x7b2>
8000fba8:	41 09       	lddsp	r9,sp[0x40]
8000fbaa:	59 f8       	cp.w	r8,31
8000fbac:	e0 89 00 15 	brgt	8000fbd6 <_vfprintf_r+0x876>
8000fbb0:	f2 ca ff f8 	sub	r10,r9,-8
8000fbb4:	72 16       	ld.w	r6,r9[0x4]
8000fbb6:	72 09       	ld.w	r9,r9[0x0]
8000fbb8:	51 0a       	stdsp	sp[0x40],r10
8000fbba:	50 59       	stdsp	sp[0x14],r9
8000fbbc:	fa ce f9 44 	sub	lr,sp,-1724
8000fbc0:	50 76       	stdsp	sp[0x1c],r6
8000fbc2:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000fbc6:	40 5b       	lddsp	r11,sp[0x14]
8000fbc8:	0c 9a       	mov	r10,r6
8000fbca:	f2 eb fd 88 	st.d	r9[-632],r10
8000fbce:	2f f8       	sub	r8,-1
8000fbd0:	fb 48 06 b4 	st.w	sp[1716],r8
8000fbd4:	c0 88       	rjmp	8000fbe4 <_vfprintf_r+0x884>
8000fbd6:	72 1c       	ld.w	r12,r9[0x4]
8000fbd8:	50 7c       	stdsp	sp[0x1c],r12
8000fbda:	f2 c8 ff f8 	sub	r8,r9,-8
8000fbde:	51 08       	stdsp	sp[0x40],r8
8000fbe0:	72 09       	ld.w	r9,r9[0x0]
8000fbe2:	50 59       	stdsp	sp[0x14],r9
8000fbe4:	40 5b       	lddsp	r11,sp[0x14]
8000fbe6:	40 7a       	lddsp	r10,sp[0x1c]
8000fbe8:	e0 a0 18 4c 	rcall	80012c80 <__isinfd>
8000fbec:	18 96       	mov	r6,r12
8000fbee:	c1 70       	breq	8000fc1c <_vfprintf_r+0x8bc>
8000fbf0:	30 08       	mov	r8,0
8000fbf2:	30 09       	mov	r9,0
8000fbf4:	40 5b       	lddsp	r11,sp[0x14]
8000fbf6:	40 7a       	lddsp	r10,sp[0x1c]
8000fbf8:	e0 a0 1b a2 	rcall	8001333c <__avr32_f64_cmp_lt>
8000fbfc:	c0 40       	breq	8000fc04 <_vfprintf_r+0x8a4>
8000fbfe:	32 d8       	mov	r8,45
8000fc00:	fb 68 06 bb 	st.b	sp[1723],r8
8000fc04:	fe c8 a9 4c 	sub	r8,pc,-22196
8000fc08:	fe c6 a9 4c 	sub	r6,pc,-22196
8000fc0c:	a7 d3       	cbr	r3,0x7
8000fc0e:	e0 40 00 47 	cp.w	r0,71
8000fc12:	f0 06 17 a0 	movle	r6,r8
8000fc16:	30 32       	mov	r2,3
8000fc18:	e0 8f 06 cd 	bral	800109b2 <_vfprintf_r+0x1652>
8000fc1c:	40 5b       	lddsp	r11,sp[0x14]
8000fc1e:	40 7a       	lddsp	r10,sp[0x1c]
8000fc20:	e0 a0 18 45 	rcall	80012caa <__isnand>
8000fc24:	c0 e0       	breq	8000fc40 <_vfprintf_r+0x8e0>
8000fc26:	50 26       	stdsp	sp[0x8],r6
8000fc28:	fe c8 a9 68 	sub	r8,pc,-22168
8000fc2c:	fe c6 a9 68 	sub	r6,pc,-22168
8000fc30:	a7 d3       	cbr	r3,0x7
8000fc32:	e0 40 00 47 	cp.w	r0,71
8000fc36:	f0 06 17 a0 	movle	r6,r8
8000fc3a:	30 32       	mov	r2,3
8000fc3c:	e0 8f 06 c1 	bral	800109be <_vfprintf_r+0x165e>
8000fc40:	40 2a       	lddsp	r10,sp[0x8]
8000fc42:	5b fa       	cp.w	r10,-1
8000fc44:	c0 41       	brne	8000fc4c <_vfprintf_r+0x8ec>
8000fc46:	30 69       	mov	r9,6
8000fc48:	50 29       	stdsp	sp[0x8],r9
8000fc4a:	c1 18       	rjmp	8000fc6c <_vfprintf_r+0x90c>
8000fc4c:	e0 40 00 47 	cp.w	r0,71
8000fc50:	5f 09       	sreq	r9
8000fc52:	e0 40 00 67 	cp.w	r0,103
8000fc56:	5f 08       	sreq	r8
8000fc58:	f3 e8 10 08 	or	r8,r9,r8
8000fc5c:	f8 08 18 00 	cp.b	r8,r12
8000fc60:	c0 60       	breq	8000fc6c <_vfprintf_r+0x90c>
8000fc62:	40 28       	lddsp	r8,sp[0x8]
8000fc64:	58 08       	cp.w	r8,0
8000fc66:	f9 b8 00 01 	moveq	r8,1
8000fc6a:	50 28       	stdsp	sp[0x8],r8
8000fc6c:	40 78       	lddsp	r8,sp[0x1c]
8000fc6e:	40 59       	lddsp	r9,sp[0x14]
8000fc70:	fa e9 06 94 	st.d	sp[1684],r8
8000fc74:	a9 a3       	sbr	r3,0x8
8000fc76:	fa f8 06 94 	ld.w	r8,sp[1684]
8000fc7a:	58 08       	cp.w	r8,0
8000fc7c:	c0 65       	brlt	8000fc88 <_vfprintf_r+0x928>
8000fc7e:	40 5e       	lddsp	lr,sp[0x14]
8000fc80:	30 0c       	mov	r12,0
8000fc82:	50 6e       	stdsp	sp[0x18],lr
8000fc84:	50 9c       	stdsp	sp[0x24],r12
8000fc86:	c0 78       	rjmp	8000fc94 <_vfprintf_r+0x934>
8000fc88:	40 5b       	lddsp	r11,sp[0x14]
8000fc8a:	32 da       	mov	r10,45
8000fc8c:	ee 1b 80 00 	eorh	r11,0x8000
8000fc90:	50 9a       	stdsp	sp[0x24],r10
8000fc92:	50 6b       	stdsp	sp[0x18],r11
8000fc94:	e0 40 00 46 	cp.w	r0,70
8000fc98:	5f 09       	sreq	r9
8000fc9a:	e0 40 00 66 	cp.w	r0,102
8000fc9e:	5f 08       	sreq	r8
8000fca0:	f3 e8 10 08 	or	r8,r9,r8
8000fca4:	50 48       	stdsp	sp[0x10],r8
8000fca6:	c0 40       	breq	8000fcae <_vfprintf_r+0x94e>
8000fca8:	40 22       	lddsp	r2,sp[0x8]
8000fcaa:	30 39       	mov	r9,3
8000fcac:	c1 28       	rjmp	8000fcd0 <_vfprintf_r+0x970>
8000fcae:	e0 40 00 45 	cp.w	r0,69
8000fcb2:	5f 09       	sreq	r9
8000fcb4:	e0 40 00 65 	cp.w	r0,101
8000fcb8:	5f 08       	sreq	r8
8000fcba:	40 46       	lddsp	r6,sp[0x10]
8000fcbc:	10 49       	or	r9,r8
8000fcbe:	ec 09 18 00 	cp.b	r9,r6
8000fcc2:	c0 31       	brne	8000fcc8 <_vfprintf_r+0x968>
8000fcc4:	40 22       	lddsp	r2,sp[0x8]
8000fcc6:	c0 48       	rjmp	8000fcce <_vfprintf_r+0x96e>
8000fcc8:	40 2e       	lddsp	lr,sp[0x8]
8000fcca:	fc c2 ff ff 	sub	r2,lr,-1
8000fcce:	30 29       	mov	r9,2
8000fcd0:	fa c8 f9 5c 	sub	r8,sp,-1700
8000fcd4:	1a d8       	st.w	--sp,r8
8000fcd6:	fa c8 f9 54 	sub	r8,sp,-1708
8000fcda:	1a d8       	st.w	--sp,r8
8000fcdc:	fa c8 f9 4c 	sub	r8,sp,-1716
8000fce0:	0a 9c       	mov	r12,r5
8000fce2:	1a d8       	st.w	--sp,r8
8000fce4:	04 98       	mov	r8,r2
8000fce6:	40 9b       	lddsp	r11,sp[0x24]
8000fce8:	40 aa       	lddsp	r10,sp[0x28]
8000fcea:	e0 a0 0b e3 	rcall	800114b0 <_dtoa_r>
8000fcee:	e0 40 00 47 	cp.w	r0,71
8000fcf2:	5f 19       	srne	r9
8000fcf4:	e0 40 00 67 	cp.w	r0,103
8000fcf8:	5f 18       	srne	r8
8000fcfa:	18 96       	mov	r6,r12
8000fcfc:	2f dd       	sub	sp,-12
8000fcfe:	f3 e8 00 08 	and	r8,r9,r8
8000fd02:	c0 41       	brne	8000fd0a <_vfprintf_r+0x9aa>
8000fd04:	ed b3 00 00 	bld	r3,0x0
8000fd08:	c3 01       	brne	8000fd68 <_vfprintf_r+0xa08>
8000fd0a:	ec 02 00 0c 	add	r12,r6,r2
8000fd0e:	50 3c       	stdsp	sp[0xc],r12
8000fd10:	40 4b       	lddsp	r11,sp[0x10]
8000fd12:	58 0b       	cp.w	r11,0
8000fd14:	c1 50       	breq	8000fd3e <_vfprintf_r+0x9de>
8000fd16:	0d 89       	ld.ub	r9,r6[0x0]
8000fd18:	33 08       	mov	r8,48
8000fd1a:	f0 09 18 00 	cp.b	r9,r8
8000fd1e:	c0 b1       	brne	8000fd34 <_vfprintf_r+0x9d4>
8000fd20:	30 08       	mov	r8,0
8000fd22:	30 09       	mov	r9,0
8000fd24:	40 6b       	lddsp	r11,sp[0x18]
8000fd26:	40 7a       	lddsp	r10,sp[0x1c]
8000fd28:	e0 a0 1a c3 	rcall	800132ae <__avr32_f64_cmp_eq>
8000fd2c:	fb b2 00 01 	rsubeq	r2,1
8000fd30:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000fd34:	40 3a       	lddsp	r10,sp[0xc]
8000fd36:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000fd3a:	10 0a       	add	r10,r8
8000fd3c:	50 3a       	stdsp	sp[0xc],r10
8000fd3e:	40 6b       	lddsp	r11,sp[0x18]
8000fd40:	30 08       	mov	r8,0
8000fd42:	30 09       	mov	r9,0
8000fd44:	40 7a       	lddsp	r10,sp[0x1c]
8000fd46:	e0 a0 1a b4 	rcall	800132ae <__avr32_f64_cmp_eq>
8000fd4a:	c0 90       	breq	8000fd5c <_vfprintf_r+0x9fc>
8000fd4c:	40 39       	lddsp	r9,sp[0xc]
8000fd4e:	fb 49 06 a4 	st.w	sp[1700],r9
8000fd52:	c0 58       	rjmp	8000fd5c <_vfprintf_r+0x9fc>
8000fd54:	10 c9       	st.b	r8++,r9
8000fd56:	fb 48 06 a4 	st.w	sp[1700],r8
8000fd5a:	c0 28       	rjmp	8000fd5e <_vfprintf_r+0x9fe>
8000fd5c:	33 09       	mov	r9,48
8000fd5e:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000fd62:	40 3e       	lddsp	lr,sp[0xc]
8000fd64:	1c 38       	cp.w	r8,lr
8000fd66:	cf 73       	brcs	8000fd54 <_vfprintf_r+0x9f4>
8000fd68:	e0 40 00 47 	cp.w	r0,71
8000fd6c:	5f 09       	sreq	r9
8000fd6e:	e0 40 00 67 	cp.w	r0,103
8000fd72:	5f 08       	sreq	r8
8000fd74:	f3 e8 10 08 	or	r8,r9,r8
8000fd78:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000fd7c:	0c 19       	sub	r9,r6
8000fd7e:	50 69       	stdsp	sp[0x18],r9
8000fd80:	58 08       	cp.w	r8,0
8000fd82:	c0 b0       	breq	8000fd98 <_vfprintf_r+0xa38>
8000fd84:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000fd88:	5b d8       	cp.w	r8,-3
8000fd8a:	c0 55       	brlt	8000fd94 <_vfprintf_r+0xa34>
8000fd8c:	40 2c       	lddsp	r12,sp[0x8]
8000fd8e:	18 38       	cp.w	r8,r12
8000fd90:	e0 8a 00 6a 	brle	8000fe64 <_vfprintf_r+0xb04>
8000fd94:	20 20       	sub	r0,2
8000fd96:	c0 58       	rjmp	8000fda0 <_vfprintf_r+0xa40>
8000fd98:	e0 40 00 65 	cp.w	r0,101
8000fd9c:	e0 89 00 46 	brgt	8000fe28 <_vfprintf_r+0xac8>
8000fda0:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000fda4:	fb 60 06 9c 	st.b	sp[1692],r0
8000fda8:	20 1b       	sub	r11,1
8000fdaa:	fb 4b 06 ac 	st.w	sp[1708],r11
8000fdae:	c0 47       	brpl	8000fdb6 <_vfprintf_r+0xa56>
8000fdb0:	5c 3b       	neg	r11
8000fdb2:	32 d8       	mov	r8,45
8000fdb4:	c0 28       	rjmp	8000fdb8 <_vfprintf_r+0xa58>
8000fdb6:	32 b8       	mov	r8,43
8000fdb8:	fb 68 06 9d 	st.b	sp[1693],r8
8000fdbc:	58 9b       	cp.w	r11,9
8000fdbe:	e0 8a 00 1d 	brle	8000fdf8 <_vfprintf_r+0xa98>
8000fdc2:	fa c9 fa 35 	sub	r9,sp,-1483
8000fdc6:	30 aa       	mov	r10,10
8000fdc8:	12 98       	mov	r8,r9
8000fdca:	0e 9c       	mov	r12,r7
8000fdcc:	0c 92       	mov	r2,r6
8000fdce:	f6 0a 0c 06 	divs	r6,r11,r10
8000fdd2:	0e 9b       	mov	r11,r7
8000fdd4:	2d 0b       	sub	r11,-48
8000fdd6:	10 fb       	st.b	--r8,r11
8000fdd8:	0c 9b       	mov	r11,r6
8000fdda:	58 96       	cp.w	r6,9
8000fddc:	fe 99 ff f9 	brgt	8000fdce <_vfprintf_r+0xa6e>
8000fde0:	2d 0b       	sub	r11,-48
8000fde2:	18 97       	mov	r7,r12
8000fde4:	04 96       	mov	r6,r2
8000fde6:	10 fb       	st.b	--r8,r11
8000fde8:	fa ca f9 62 	sub	r10,sp,-1694
8000fdec:	c0 38       	rjmp	8000fdf2 <_vfprintf_r+0xa92>
8000fdee:	11 3b       	ld.ub	r11,r8++
8000fdf0:	14 cb       	st.b	r10++,r11
8000fdf2:	12 38       	cp.w	r8,r9
8000fdf4:	cf d3       	brcs	8000fdee <_vfprintf_r+0xa8e>
8000fdf6:	c0 98       	rjmp	8000fe08 <_vfprintf_r+0xaa8>
8000fdf8:	2d 0b       	sub	r11,-48
8000fdfa:	33 08       	mov	r8,48
8000fdfc:	fb 6b 06 9f 	st.b	sp[1695],r11
8000fe00:	fb 68 06 9e 	st.b	sp[1694],r8
8000fe04:	fa ca f9 60 	sub	r10,sp,-1696
8000fe08:	fa c8 f9 64 	sub	r8,sp,-1692
8000fe0c:	f4 08 01 08 	sub	r8,r10,r8
8000fe10:	50 e8       	stdsp	sp[0x38],r8
8000fe12:	10 92       	mov	r2,r8
8000fe14:	40 6b       	lddsp	r11,sp[0x18]
8000fe16:	16 02       	add	r2,r11
8000fe18:	58 1b       	cp.w	r11,1
8000fe1a:	e0 89 00 05 	brgt	8000fe24 <_vfprintf_r+0xac4>
8000fe1e:	ed b3 00 00 	bld	r3,0x0
8000fe22:	c3 51       	brne	8000fe8c <_vfprintf_r+0xb2c>
8000fe24:	2f f2       	sub	r2,-1
8000fe26:	c3 38       	rjmp	8000fe8c <_vfprintf_r+0xb2c>
8000fe28:	e0 40 00 66 	cp.w	r0,102
8000fe2c:	c1 c1       	brne	8000fe64 <_vfprintf_r+0xb04>
8000fe2e:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000fe32:	58 02       	cp.w	r2,0
8000fe34:	e0 8a 00 0c 	brle	8000fe4c <_vfprintf_r+0xaec>
8000fe38:	40 2a       	lddsp	r10,sp[0x8]
8000fe3a:	58 0a       	cp.w	r10,0
8000fe3c:	c0 41       	brne	8000fe44 <_vfprintf_r+0xae4>
8000fe3e:	ed b3 00 00 	bld	r3,0x0
8000fe42:	c2 51       	brne	8000fe8c <_vfprintf_r+0xb2c>
8000fe44:	2f f2       	sub	r2,-1
8000fe46:	40 29       	lddsp	r9,sp[0x8]
8000fe48:	12 02       	add	r2,r9
8000fe4a:	c0 b8       	rjmp	8000fe60 <_vfprintf_r+0xb00>
8000fe4c:	40 28       	lddsp	r8,sp[0x8]
8000fe4e:	58 08       	cp.w	r8,0
8000fe50:	c0 61       	brne	8000fe5c <_vfprintf_r+0xafc>
8000fe52:	ed b3 00 00 	bld	r3,0x0
8000fe56:	c0 30       	breq	8000fe5c <_vfprintf_r+0xafc>
8000fe58:	30 12       	mov	r2,1
8000fe5a:	c1 98       	rjmp	8000fe8c <_vfprintf_r+0xb2c>
8000fe5c:	40 22       	lddsp	r2,sp[0x8]
8000fe5e:	2f e2       	sub	r2,-2
8000fe60:	36 60       	mov	r0,102
8000fe62:	c1 58       	rjmp	8000fe8c <_vfprintf_r+0xb2c>
8000fe64:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000fe68:	40 6e       	lddsp	lr,sp[0x18]
8000fe6a:	1c 32       	cp.w	r2,lr
8000fe6c:	c0 65       	brlt	8000fe78 <_vfprintf_r+0xb18>
8000fe6e:	ed b3 00 00 	bld	r3,0x0
8000fe72:	f7 b2 00 ff 	subeq	r2,-1
8000fe76:	c0 a8       	rjmp	8000fe8a <_vfprintf_r+0xb2a>
8000fe78:	e4 08 11 02 	rsub	r8,r2,2
8000fe7c:	40 6c       	lddsp	r12,sp[0x18]
8000fe7e:	58 02       	cp.w	r2,0
8000fe80:	f0 02 17 a0 	movle	r2,r8
8000fe84:	f9 b2 09 01 	movgt	r2,1
8000fe88:	18 02       	add	r2,r12
8000fe8a:	36 70       	mov	r0,103
8000fe8c:	40 9b       	lddsp	r11,sp[0x24]
8000fe8e:	58 0b       	cp.w	r11,0
8000fe90:	e0 80 05 91 	breq	800109b2 <_vfprintf_r+0x1652>
8000fe94:	32 d8       	mov	r8,45
8000fe96:	fb 68 06 bb 	st.b	sp[1723],r8
8000fe9a:	e0 8f 05 90 	bral	800109ba <_vfprintf_r+0x165a>
8000fe9e:	50 a7       	stdsp	sp[0x28],r7
8000fea0:	04 95       	mov	r5,r2
8000fea2:	0c 97       	mov	r7,r6
8000fea4:	02 92       	mov	r2,r1
8000fea6:	08 96       	mov	r6,r4
8000fea8:	40 41       	lddsp	r1,sp[0x10]
8000feaa:	40 94       	lddsp	r4,sp[0x24]
8000feac:	0e 99       	mov	r9,r7
8000feae:	ed b3 00 05 	bld	r3,0x5
8000feb2:	c4 81       	brne	8000ff42 <_vfprintf_r+0xbe2>
8000feb4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000feb8:	40 3e       	lddsp	lr,sp[0xc]
8000feba:	58 0e       	cp.w	lr,0
8000febc:	c1 d0       	breq	8000fef6 <_vfprintf_r+0xb96>
8000febe:	10 36       	cp.w	r6,r8
8000fec0:	c0 64       	brge	8000fecc <_vfprintf_r+0xb6c>
8000fec2:	fa cc f9 44 	sub	r12,sp,-1724
8000fec6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000feca:	c1 d8       	rjmp	8000ff04 <_vfprintf_r+0xba4>
8000fecc:	fa c8 f9 50 	sub	r8,sp,-1712
8000fed0:	1a d8       	st.w	--sp,r8
8000fed2:	fa c8 fa b8 	sub	r8,sp,-1352
8000fed6:	04 9a       	mov	r10,r2
8000fed8:	1a d8       	st.w	--sp,r8
8000feda:	fa c8 fb b4 	sub	r8,sp,-1100
8000fede:	0c 9b       	mov	r11,r6
8000fee0:	1a d8       	st.w	--sp,r8
8000fee2:	0a 9c       	mov	r12,r5
8000fee4:	fa c8 f9 40 	sub	r8,sp,-1728
8000fee8:	fa c9 ff b4 	sub	r9,sp,-76
8000feec:	fe b0 f8 a2 	rcall	8000f030 <get_arg>
8000fef0:	2f dd       	sub	sp,-12
8000fef2:	78 0a       	ld.w	r10,r12[0x0]
8000fef4:	c2 08       	rjmp	8000ff34 <_vfprintf_r+0xbd4>
8000fef6:	2f f7       	sub	r7,-1
8000fef8:	10 39       	cp.w	r9,r8
8000fefa:	c0 84       	brge	8000ff0a <_vfprintf_r+0xbaa>
8000fefc:	fa cb f9 44 	sub	r11,sp,-1724
8000ff00:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ff04:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ff08:	c1 68       	rjmp	8000ff34 <_vfprintf_r+0xbd4>
8000ff0a:	41 09       	lddsp	r9,sp[0x40]
8000ff0c:	59 f8       	cp.w	r8,31
8000ff0e:	e0 89 00 10 	brgt	8000ff2e <_vfprintf_r+0xbce>
8000ff12:	f2 ca ff fc 	sub	r10,r9,-4
8000ff16:	51 0a       	stdsp	sp[0x40],r10
8000ff18:	fa c6 f9 44 	sub	r6,sp,-1724
8000ff1c:	72 0a       	ld.w	r10,r9[0x0]
8000ff1e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ff22:	f3 4a fd 88 	st.w	r9[-632],r10
8000ff26:	2f f8       	sub	r8,-1
8000ff28:	fb 48 06 b4 	st.w	sp[1716],r8
8000ff2c:	c0 48       	rjmp	8000ff34 <_vfprintf_r+0xbd4>
8000ff2e:	72 0a       	ld.w	r10,r9[0x0]
8000ff30:	2f c9       	sub	r9,-4
8000ff32:	51 09       	stdsp	sp[0x40],r9
8000ff34:	40 be       	lddsp	lr,sp[0x2c]
8000ff36:	1c 98       	mov	r8,lr
8000ff38:	95 1e       	st.w	r10[0x4],lr
8000ff3a:	bf 58       	asr	r8,0x1f
8000ff3c:	95 08       	st.w	r10[0x0],r8
8000ff3e:	fe 9f fa 9e 	bral	8000f47a <_vfprintf_r+0x11a>
8000ff42:	ed b3 00 04 	bld	r3,0x4
8000ff46:	c4 80       	breq	8000ffd6 <_vfprintf_r+0xc76>
8000ff48:	e2 13 00 40 	andl	r3,0x40,COH
8000ff4c:	c4 50       	breq	8000ffd6 <_vfprintf_r+0xc76>
8000ff4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ff52:	40 3c       	lddsp	r12,sp[0xc]
8000ff54:	58 0c       	cp.w	r12,0
8000ff56:	c1 d0       	breq	8000ff90 <_vfprintf_r+0xc30>
8000ff58:	10 36       	cp.w	r6,r8
8000ff5a:	c0 64       	brge	8000ff66 <_vfprintf_r+0xc06>
8000ff5c:	fa cb f9 44 	sub	r11,sp,-1724
8000ff60:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ff64:	c1 d8       	rjmp	8000ff9e <_vfprintf_r+0xc3e>
8000ff66:	fa c8 f9 50 	sub	r8,sp,-1712
8000ff6a:	1a d8       	st.w	--sp,r8
8000ff6c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ff70:	04 9a       	mov	r10,r2
8000ff72:	1a d8       	st.w	--sp,r8
8000ff74:	fa c8 fb b4 	sub	r8,sp,-1100
8000ff78:	0c 9b       	mov	r11,r6
8000ff7a:	1a d8       	st.w	--sp,r8
8000ff7c:	0a 9c       	mov	r12,r5
8000ff7e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ff82:	fa c9 ff b4 	sub	r9,sp,-76
8000ff86:	fe b0 f8 55 	rcall	8000f030 <get_arg>
8000ff8a:	2f dd       	sub	sp,-12
8000ff8c:	78 0a       	ld.w	r10,r12[0x0]
8000ff8e:	c2 08       	rjmp	8000ffce <_vfprintf_r+0xc6e>
8000ff90:	2f f7       	sub	r7,-1
8000ff92:	10 39       	cp.w	r9,r8
8000ff94:	c0 84       	brge	8000ffa4 <_vfprintf_r+0xc44>
8000ff96:	fa ca f9 44 	sub	r10,sp,-1724
8000ff9a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ff9e:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ffa2:	c1 68       	rjmp	8000ffce <_vfprintf_r+0xc6e>
8000ffa4:	41 09       	lddsp	r9,sp[0x40]
8000ffa6:	59 f8       	cp.w	r8,31
8000ffa8:	e0 89 00 10 	brgt	8000ffc8 <_vfprintf_r+0xc68>
8000ffac:	f2 ca ff fc 	sub	r10,r9,-4
8000ffb0:	51 0a       	stdsp	sp[0x40],r10
8000ffb2:	fa c6 f9 44 	sub	r6,sp,-1724
8000ffb6:	72 0a       	ld.w	r10,r9[0x0]
8000ffb8:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ffbc:	f3 4a fd 88 	st.w	r9[-632],r10
8000ffc0:	2f f8       	sub	r8,-1
8000ffc2:	fb 48 06 b4 	st.w	sp[1716],r8
8000ffc6:	c0 48       	rjmp	8000ffce <_vfprintf_r+0xc6e>
8000ffc8:	72 0a       	ld.w	r10,r9[0x0]
8000ffca:	2f c9       	sub	r9,-4
8000ffcc:	51 09       	stdsp	sp[0x40],r9
8000ffce:	40 be       	lddsp	lr,sp[0x2c]
8000ffd0:	b4 0e       	st.h	r10[0x0],lr
8000ffd2:	fe 9f fa 54 	bral	8000f47a <_vfprintf_r+0x11a>
8000ffd6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ffda:	40 3c       	lddsp	r12,sp[0xc]
8000ffdc:	58 0c       	cp.w	r12,0
8000ffde:	c1 d0       	breq	80010018 <_vfprintf_r+0xcb8>
8000ffe0:	10 36       	cp.w	r6,r8
8000ffe2:	c0 64       	brge	8000ffee <_vfprintf_r+0xc8e>
8000ffe4:	fa cb f9 44 	sub	r11,sp,-1724
8000ffe8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ffec:	c1 d8       	rjmp	80010026 <_vfprintf_r+0xcc6>
8000ffee:	fa c8 f9 50 	sub	r8,sp,-1712
8000fff2:	1a d8       	st.w	--sp,r8
8000fff4:	fa c8 fa b8 	sub	r8,sp,-1352
8000fff8:	04 9a       	mov	r10,r2
8000fffa:	1a d8       	st.w	--sp,r8
8000fffc:	fa c8 fb b4 	sub	r8,sp,-1100
80010000:	0c 9b       	mov	r11,r6
80010002:	1a d8       	st.w	--sp,r8
80010004:	0a 9c       	mov	r12,r5
80010006:	fa c8 f9 40 	sub	r8,sp,-1728
8001000a:	fa c9 ff b4 	sub	r9,sp,-76
8001000e:	fe b0 f8 11 	rcall	8000f030 <get_arg>
80010012:	2f dd       	sub	sp,-12
80010014:	78 0a       	ld.w	r10,r12[0x0]
80010016:	c2 08       	rjmp	80010056 <_vfprintf_r+0xcf6>
80010018:	2f f7       	sub	r7,-1
8001001a:	10 39       	cp.w	r9,r8
8001001c:	c0 84       	brge	8001002c <_vfprintf_r+0xccc>
8001001e:	fa ca f9 44 	sub	r10,sp,-1724
80010022:	f4 06 00 36 	add	r6,r10,r6<<0x3
80010026:	ec fa fd 88 	ld.w	r10,r6[-632]
8001002a:	c1 68       	rjmp	80010056 <_vfprintf_r+0xcf6>
8001002c:	41 09       	lddsp	r9,sp[0x40]
8001002e:	59 f8       	cp.w	r8,31
80010030:	e0 89 00 10 	brgt	80010050 <_vfprintf_r+0xcf0>
80010034:	f2 ca ff fc 	sub	r10,r9,-4
80010038:	51 0a       	stdsp	sp[0x40],r10
8001003a:	fa c6 f9 44 	sub	r6,sp,-1724
8001003e:	72 0a       	ld.w	r10,r9[0x0]
80010040:	ec 08 00 39 	add	r9,r6,r8<<0x3
80010044:	f3 4a fd 88 	st.w	r9[-632],r10
80010048:	2f f8       	sub	r8,-1
8001004a:	fb 48 06 b4 	st.w	sp[1716],r8
8001004e:	c0 48       	rjmp	80010056 <_vfprintf_r+0xcf6>
80010050:	72 0a       	ld.w	r10,r9[0x0]
80010052:	2f c9       	sub	r9,-4
80010054:	51 09       	stdsp	sp[0x40],r9
80010056:	40 be       	lddsp	lr,sp[0x2c]
80010058:	95 0e       	st.w	r10[0x0],lr
8001005a:	fe 9f fa 10 	bral	8000f47a <_vfprintf_r+0x11a>
8001005e:	50 a7       	stdsp	sp[0x28],r7
80010060:	50 80       	stdsp	sp[0x20],r0
80010062:	0c 97       	mov	r7,r6
80010064:	04 95       	mov	r5,r2
80010066:	08 96       	mov	r6,r4
80010068:	02 92       	mov	r2,r1
8001006a:	40 94       	lddsp	r4,sp[0x24]
8001006c:	10 90       	mov	r0,r8
8001006e:	40 41       	lddsp	r1,sp[0x10]
80010070:	a5 a3       	sbr	r3,0x4
80010072:	c0 a8       	rjmp	80010086 <_vfprintf_r+0xd26>
80010074:	50 a7       	stdsp	sp[0x28],r7
80010076:	50 80       	stdsp	sp[0x20],r0
80010078:	0c 97       	mov	r7,r6
8001007a:	04 95       	mov	r5,r2
8001007c:	08 96       	mov	r6,r4
8001007e:	02 92       	mov	r2,r1
80010080:	40 94       	lddsp	r4,sp[0x24]
80010082:	10 90       	mov	r0,r8
80010084:	40 41       	lddsp	r1,sp[0x10]
80010086:	ed b3 00 05 	bld	r3,0x5
8001008a:	c5 d1       	brne	80010144 <_vfprintf_r+0xde4>
8001008c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010090:	40 3c       	lddsp	r12,sp[0xc]
80010092:	58 0c       	cp.w	r12,0
80010094:	c2 60       	breq	800100e0 <_vfprintf_r+0xd80>
80010096:	10 36       	cp.w	r6,r8
80010098:	c0 a4       	brge	800100ac <_vfprintf_r+0xd4c>
8001009a:	fa cb f9 44 	sub	r11,sp,-1724
8001009e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800100a2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800100a6:	fa e9 00 00 	st.d	sp[0],r8
800100aa:	c1 88       	rjmp	800100da <_vfprintf_r+0xd7a>
800100ac:	fa c8 f9 50 	sub	r8,sp,-1712
800100b0:	1a d8       	st.w	--sp,r8
800100b2:	fa c8 fa b8 	sub	r8,sp,-1352
800100b6:	04 9a       	mov	r10,r2
800100b8:	1a d8       	st.w	--sp,r8
800100ba:	0c 9b       	mov	r11,r6
800100bc:	fa c8 fb b4 	sub	r8,sp,-1100
800100c0:	0a 9c       	mov	r12,r5
800100c2:	1a d8       	st.w	--sp,r8
800100c4:	fa c8 f9 40 	sub	r8,sp,-1728
800100c8:	fa c9 ff b4 	sub	r9,sp,-76
800100cc:	fe b0 f7 b2 	rcall	8000f030 <get_arg>
800100d0:	2f dd       	sub	sp,-12
800100d2:	f8 ea 00 00 	ld.d	r10,r12[0]
800100d6:	fa eb 00 00 	st.d	sp[0],r10
800100da:	30 08       	mov	r8,0
800100dc:	e0 8f 03 db 	bral	80010892 <_vfprintf_r+0x1532>
800100e0:	ee ca ff ff 	sub	r10,r7,-1
800100e4:	10 37       	cp.w	r7,r8
800100e6:	c0 b4       	brge	800100fc <_vfprintf_r+0xd9c>
800100e8:	fa c9 f9 44 	sub	r9,sp,-1724
800100ec:	14 97       	mov	r7,r10
800100ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800100f2:	ec ea fd 88 	ld.d	r10,r6[-632]
800100f6:	fa eb 00 00 	st.d	sp[0],r10
800100fa:	c1 88       	rjmp	8001012a <_vfprintf_r+0xdca>
800100fc:	41 09       	lddsp	r9,sp[0x40]
800100fe:	59 f8       	cp.w	r8,31
80010100:	e0 89 00 18 	brgt	80010130 <_vfprintf_r+0xdd0>
80010104:	f2 e6 00 00 	ld.d	r6,r9[0]
80010108:	f2 cb ff f8 	sub	r11,r9,-8
8001010c:	fa e7 00 00 	st.d	sp[0],r6
80010110:	51 0b       	stdsp	sp[0x40],r11
80010112:	fa c6 f9 44 	sub	r6,sp,-1724
80010116:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001011a:	fa e6 00 00 	ld.d	r6,sp[0]
8001011e:	f2 e7 fd 88 	st.d	r9[-632],r6
80010122:	2f f8       	sub	r8,-1
80010124:	14 97       	mov	r7,r10
80010126:	fb 48 06 b4 	st.w	sp[1716],r8
8001012a:	40 38       	lddsp	r8,sp[0xc]
8001012c:	e0 8f 03 b3 	bral	80010892 <_vfprintf_r+0x1532>
80010130:	f2 e6 00 00 	ld.d	r6,r9[0]
80010134:	40 38       	lddsp	r8,sp[0xc]
80010136:	fa e7 00 00 	st.d	sp[0],r6
8001013a:	2f 89       	sub	r9,-8
8001013c:	14 97       	mov	r7,r10
8001013e:	51 09       	stdsp	sp[0x40],r9
80010140:	e0 8f 03 a9 	bral	80010892 <_vfprintf_r+0x1532>
80010144:	ed b3 00 04 	bld	r3,0x4
80010148:	c1 61       	brne	80010174 <_vfprintf_r+0xe14>
8001014a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001014e:	40 3e       	lddsp	lr,sp[0xc]
80010150:	58 0e       	cp.w	lr,0
80010152:	c0 80       	breq	80010162 <_vfprintf_r+0xe02>
80010154:	10 36       	cp.w	r6,r8
80010156:	c6 74       	brge	80010224 <_vfprintf_r+0xec4>
80010158:	fa cc f9 44 	sub	r12,sp,-1724
8001015c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80010160:	c8 08       	rjmp	80010260 <_vfprintf_r+0xf00>
80010162:	ee ca ff ff 	sub	r10,r7,-1
80010166:	10 37       	cp.w	r7,r8
80010168:	c7 f4       	brge	80010266 <_vfprintf_r+0xf06>
8001016a:	fa cb f9 44 	sub	r11,sp,-1724
8001016e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80010172:	c7 68       	rjmp	8001025e <_vfprintf_r+0xefe>
80010174:	ed b3 00 06 	bld	r3,0x6
80010178:	c4 a1       	brne	8001020c <_vfprintf_r+0xeac>
8001017a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001017e:	40 3c       	lddsp	r12,sp[0xc]
80010180:	58 0c       	cp.w	r12,0
80010182:	c1 d0       	breq	800101bc <_vfprintf_r+0xe5c>
80010184:	10 36       	cp.w	r6,r8
80010186:	c0 64       	brge	80010192 <_vfprintf_r+0xe32>
80010188:	fa cb f9 44 	sub	r11,sp,-1724
8001018c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80010190:	c1 f8       	rjmp	800101ce <_vfprintf_r+0xe6e>
80010192:	fa c8 f9 50 	sub	r8,sp,-1712
80010196:	1a d8       	st.w	--sp,r8
80010198:	fa c8 fa b8 	sub	r8,sp,-1352
8001019c:	1a d8       	st.w	--sp,r8
8001019e:	fa c8 fb b4 	sub	r8,sp,-1100
800101a2:	1a d8       	st.w	--sp,r8
800101a4:	fa c8 f9 40 	sub	r8,sp,-1728
800101a8:	fa c9 ff b4 	sub	r9,sp,-76
800101ac:	04 9a       	mov	r10,r2
800101ae:	0c 9b       	mov	r11,r6
800101b0:	0a 9c       	mov	r12,r5
800101b2:	fe b0 f7 3f 	rcall	8000f030 <get_arg>
800101b6:	2f dd       	sub	sp,-12
800101b8:	98 18       	ld.sh	r8,r12[0x2]
800101ba:	c2 68       	rjmp	80010206 <_vfprintf_r+0xea6>
800101bc:	ee ca ff ff 	sub	r10,r7,-1
800101c0:	10 37       	cp.w	r7,r8
800101c2:	c0 94       	brge	800101d4 <_vfprintf_r+0xe74>
800101c4:	fa c9 f9 44 	sub	r9,sp,-1724
800101c8:	14 97       	mov	r7,r10
800101ca:	f2 06 00 36 	add	r6,r9,r6<<0x3
800101ce:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800101d2:	c1 a8       	rjmp	80010206 <_vfprintf_r+0xea6>
800101d4:	41 09       	lddsp	r9,sp[0x40]
800101d6:	59 f8       	cp.w	r8,31
800101d8:	e0 89 00 13 	brgt	800101fe <_vfprintf_r+0xe9e>
800101dc:	f2 cb ff fc 	sub	r11,r9,-4
800101e0:	51 0b       	stdsp	sp[0x40],r11
800101e2:	72 09       	ld.w	r9,r9[0x0]
800101e4:	fa c6 f9 44 	sub	r6,sp,-1724
800101e8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800101ec:	2f f8       	sub	r8,-1
800101ee:	f7 49 fd 88 	st.w	r11[-632],r9
800101f2:	fb 48 06 b4 	st.w	sp[1716],r8
800101f6:	14 97       	mov	r7,r10
800101f8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800101fc:	c0 58       	rjmp	80010206 <_vfprintf_r+0xea6>
800101fe:	92 18       	ld.sh	r8,r9[0x2]
80010200:	14 97       	mov	r7,r10
80010202:	2f c9       	sub	r9,-4
80010204:	51 09       	stdsp	sp[0x40],r9
80010206:	5c 78       	castu.h	r8
80010208:	50 18       	stdsp	sp[0x4],r8
8001020a:	c4 68       	rjmp	80010296 <_vfprintf_r+0xf36>
8001020c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010210:	40 3c       	lddsp	r12,sp[0xc]
80010212:	58 0c       	cp.w	r12,0
80010214:	c1 d0       	breq	8001024e <_vfprintf_r+0xeee>
80010216:	10 36       	cp.w	r6,r8
80010218:	c0 64       	brge	80010224 <_vfprintf_r+0xec4>
8001021a:	fa cb f9 44 	sub	r11,sp,-1724
8001021e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80010222:	c1 f8       	rjmp	80010260 <_vfprintf_r+0xf00>
80010224:	fa c8 f9 50 	sub	r8,sp,-1712
80010228:	1a d8       	st.w	--sp,r8
8001022a:	fa c8 fa b8 	sub	r8,sp,-1352
8001022e:	0c 9b       	mov	r11,r6
80010230:	1a d8       	st.w	--sp,r8
80010232:	fa c8 fb b4 	sub	r8,sp,-1100
80010236:	04 9a       	mov	r10,r2
80010238:	1a d8       	st.w	--sp,r8
8001023a:	0a 9c       	mov	r12,r5
8001023c:	fa c8 f9 40 	sub	r8,sp,-1728
80010240:	fa c9 ff b4 	sub	r9,sp,-76
80010244:	fe b0 f6 f6 	rcall	8000f030 <get_arg>
80010248:	2f dd       	sub	sp,-12
8001024a:	78 0b       	ld.w	r11,r12[0x0]
8001024c:	c2 48       	rjmp	80010294 <_vfprintf_r+0xf34>
8001024e:	ee ca ff ff 	sub	r10,r7,-1
80010252:	10 37       	cp.w	r7,r8
80010254:	c0 94       	brge	80010266 <_vfprintf_r+0xf06>
80010256:	fa c9 f9 44 	sub	r9,sp,-1724
8001025a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001025e:	14 97       	mov	r7,r10
80010260:	ec fb fd 88 	ld.w	r11,r6[-632]
80010264:	c1 88       	rjmp	80010294 <_vfprintf_r+0xf34>
80010266:	41 09       	lddsp	r9,sp[0x40]
80010268:	59 f8       	cp.w	r8,31
8001026a:	e0 89 00 11 	brgt	8001028c <_vfprintf_r+0xf2c>
8001026e:	f2 cb ff fc 	sub	r11,r9,-4
80010272:	51 0b       	stdsp	sp[0x40],r11
80010274:	fa c6 f9 44 	sub	r6,sp,-1724
80010278:	72 0b       	ld.w	r11,r9[0x0]
8001027a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001027e:	f3 4b fd 88 	st.w	r9[-632],r11
80010282:	2f f8       	sub	r8,-1
80010284:	14 97       	mov	r7,r10
80010286:	fb 48 06 b4 	st.w	sp[1716],r8
8001028a:	c0 58       	rjmp	80010294 <_vfprintf_r+0xf34>
8001028c:	72 0b       	ld.w	r11,r9[0x0]
8001028e:	14 97       	mov	r7,r10
80010290:	2f c9       	sub	r9,-4
80010292:	51 09       	stdsp	sp[0x40],r9
80010294:	50 1b       	stdsp	sp[0x4],r11
80010296:	30 0e       	mov	lr,0
80010298:	50 0e       	stdsp	sp[0x0],lr
8001029a:	1c 98       	mov	r8,lr
8001029c:	e0 8f 02 fb 	bral	80010892 <_vfprintf_r+0x1532>
800102a0:	50 a7       	stdsp	sp[0x28],r7
800102a2:	50 80       	stdsp	sp[0x20],r0
800102a4:	0c 97       	mov	r7,r6
800102a6:	04 95       	mov	r5,r2
800102a8:	08 96       	mov	r6,r4
800102aa:	02 92       	mov	r2,r1
800102ac:	40 94       	lddsp	r4,sp[0x24]
800102ae:	40 41       	lddsp	r1,sp[0x10]
800102b0:	0e 99       	mov	r9,r7
800102b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800102b6:	40 3c       	lddsp	r12,sp[0xc]
800102b8:	58 0c       	cp.w	r12,0
800102ba:	c1 d0       	breq	800102f4 <_vfprintf_r+0xf94>
800102bc:	10 36       	cp.w	r6,r8
800102be:	c0 64       	brge	800102ca <_vfprintf_r+0xf6a>
800102c0:	fa cb f9 44 	sub	r11,sp,-1724
800102c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800102c8:	c1 d8       	rjmp	80010302 <_vfprintf_r+0xfa2>
800102ca:	fa c8 f9 50 	sub	r8,sp,-1712
800102ce:	1a d8       	st.w	--sp,r8
800102d0:	fa c8 fa b8 	sub	r8,sp,-1352
800102d4:	1a d8       	st.w	--sp,r8
800102d6:	fa c8 fb b4 	sub	r8,sp,-1100
800102da:	1a d8       	st.w	--sp,r8
800102dc:	fa c9 ff b4 	sub	r9,sp,-76
800102e0:	fa c8 f9 40 	sub	r8,sp,-1728
800102e4:	04 9a       	mov	r10,r2
800102e6:	0c 9b       	mov	r11,r6
800102e8:	0a 9c       	mov	r12,r5
800102ea:	fe b0 f6 a3 	rcall	8000f030 <get_arg>
800102ee:	2f dd       	sub	sp,-12
800102f0:	78 09       	ld.w	r9,r12[0x0]
800102f2:	c2 18       	rjmp	80010334 <_vfprintf_r+0xfd4>
800102f4:	2f f7       	sub	r7,-1
800102f6:	10 39       	cp.w	r9,r8
800102f8:	c0 84       	brge	80010308 <_vfprintf_r+0xfa8>
800102fa:	fa ca f9 44 	sub	r10,sp,-1724
800102fe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80010302:	ec f9 fd 88 	ld.w	r9,r6[-632]
80010306:	c1 78       	rjmp	80010334 <_vfprintf_r+0xfd4>
80010308:	41 09       	lddsp	r9,sp[0x40]
8001030a:	59 f8       	cp.w	r8,31
8001030c:	e0 89 00 10 	brgt	8001032c <_vfprintf_r+0xfcc>
80010310:	f2 ca ff fc 	sub	r10,r9,-4
80010314:	51 0a       	stdsp	sp[0x40],r10
80010316:	fa c6 f9 44 	sub	r6,sp,-1724
8001031a:	72 09       	ld.w	r9,r9[0x0]
8001031c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80010320:	f5 49 fd 88 	st.w	r10[-632],r9
80010324:	2f f8       	sub	r8,-1
80010326:	fb 48 06 b4 	st.w	sp[1716],r8
8001032a:	c0 58       	rjmp	80010334 <_vfprintf_r+0xfd4>
8001032c:	f2 c8 ff fc 	sub	r8,r9,-4
80010330:	51 08       	stdsp	sp[0x40],r8
80010332:	72 09       	ld.w	r9,r9[0x0]
80010334:	33 08       	mov	r8,48
80010336:	fb 68 06 b8 	st.b	sp[1720],r8
8001033a:	37 88       	mov	r8,120
8001033c:	30 0e       	mov	lr,0
8001033e:	fb 68 06 b9 	st.b	sp[1721],r8
80010342:	fe cc b0 7a 	sub	r12,pc,-20358
80010346:	50 19       	stdsp	sp[0x4],r9
80010348:	a1 b3       	sbr	r3,0x1
8001034a:	50 0e       	stdsp	sp[0x0],lr
8001034c:	50 dc       	stdsp	sp[0x34],r12
8001034e:	30 28       	mov	r8,2
80010350:	37 80       	mov	r0,120
80010352:	e0 8f 02 a0 	bral	80010892 <_vfprintf_r+0x1532>
80010356:	50 a7       	stdsp	sp[0x28],r7
80010358:	50 80       	stdsp	sp[0x20],r0
8001035a:	10 90       	mov	r0,r8
8001035c:	30 08       	mov	r8,0
8001035e:	fb 68 06 bb 	st.b	sp[1723],r8
80010362:	0c 97       	mov	r7,r6
80010364:	04 95       	mov	r5,r2
80010366:	08 96       	mov	r6,r4
80010368:	02 92       	mov	r2,r1
8001036a:	40 94       	lddsp	r4,sp[0x24]
8001036c:	40 41       	lddsp	r1,sp[0x10]
8001036e:	0e 99       	mov	r9,r7
80010370:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010374:	40 3b       	lddsp	r11,sp[0xc]
80010376:	58 0b       	cp.w	r11,0
80010378:	c1 d0       	breq	800103b2 <_vfprintf_r+0x1052>
8001037a:	10 36       	cp.w	r6,r8
8001037c:	c0 64       	brge	80010388 <_vfprintf_r+0x1028>
8001037e:	fa ca f9 44 	sub	r10,sp,-1724
80010382:	f4 06 00 36 	add	r6,r10,r6<<0x3
80010386:	c1 d8       	rjmp	800103c0 <_vfprintf_r+0x1060>
80010388:	fa c8 f9 50 	sub	r8,sp,-1712
8001038c:	1a d8       	st.w	--sp,r8
8001038e:	fa c8 fa b8 	sub	r8,sp,-1352
80010392:	1a d8       	st.w	--sp,r8
80010394:	fa c8 fb b4 	sub	r8,sp,-1100
80010398:	0c 9b       	mov	r11,r6
8001039a:	1a d8       	st.w	--sp,r8
8001039c:	04 9a       	mov	r10,r2
8001039e:	fa c8 f9 40 	sub	r8,sp,-1728
800103a2:	fa c9 ff b4 	sub	r9,sp,-76
800103a6:	0a 9c       	mov	r12,r5
800103a8:	fe b0 f6 44 	rcall	8000f030 <get_arg>
800103ac:	2f dd       	sub	sp,-12
800103ae:	78 06       	ld.w	r6,r12[0x0]
800103b0:	c2 08       	rjmp	800103f0 <_vfprintf_r+0x1090>
800103b2:	2f f7       	sub	r7,-1
800103b4:	10 39       	cp.w	r9,r8
800103b6:	c0 84       	brge	800103c6 <_vfprintf_r+0x1066>
800103b8:	fa c9 f9 44 	sub	r9,sp,-1724
800103bc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800103c0:	ec f6 fd 88 	ld.w	r6,r6[-632]
800103c4:	c1 68       	rjmp	800103f0 <_vfprintf_r+0x1090>
800103c6:	41 09       	lddsp	r9,sp[0x40]
800103c8:	59 f8       	cp.w	r8,31
800103ca:	e0 89 00 10 	brgt	800103ea <_vfprintf_r+0x108a>
800103ce:	f2 ca ff fc 	sub	r10,r9,-4
800103d2:	51 0a       	stdsp	sp[0x40],r10
800103d4:	72 06       	ld.w	r6,r9[0x0]
800103d6:	fa ce f9 44 	sub	lr,sp,-1724
800103da:	fc 08 00 39 	add	r9,lr,r8<<0x3
800103de:	f3 46 fd 88 	st.w	r9[-632],r6
800103e2:	2f f8       	sub	r8,-1
800103e4:	fb 48 06 b4 	st.w	sp[1716],r8
800103e8:	c0 48       	rjmp	800103f0 <_vfprintf_r+0x1090>
800103ea:	72 06       	ld.w	r6,r9[0x0]
800103ec:	2f c9       	sub	r9,-4
800103ee:	51 09       	stdsp	sp[0x40],r9
800103f0:	40 2c       	lddsp	r12,sp[0x8]
800103f2:	58 0c       	cp.w	r12,0
800103f4:	c1 05       	brlt	80010414 <_vfprintf_r+0x10b4>
800103f6:	18 9a       	mov	r10,r12
800103f8:	30 0b       	mov	r11,0
800103fa:	0c 9c       	mov	r12,r6
800103fc:	e0 a0 0f b4 	rcall	80012364 <memchr>
80010400:	e0 80 02 dc 	breq	800109b8 <_vfprintf_r+0x1658>
80010404:	f8 06 01 02 	sub	r2,r12,r6
80010408:	40 2b       	lddsp	r11,sp[0x8]
8001040a:	16 32       	cp.w	r2,r11
8001040c:	e0 89 02 d6 	brgt	800109b8 <_vfprintf_r+0x1658>
80010410:	e0 8f 02 d1 	bral	800109b2 <_vfprintf_r+0x1652>
80010414:	30 0a       	mov	r10,0
80010416:	0c 9c       	mov	r12,r6
80010418:	50 2a       	stdsp	sp[0x8],r10
8001041a:	fe b0 f5 48 	rcall	8000eeaa <strlen>
8001041e:	18 92       	mov	r2,r12
80010420:	e0 8f 02 cf 	bral	800109be <_vfprintf_r+0x165e>
80010424:	50 a7       	stdsp	sp[0x28],r7
80010426:	50 80       	stdsp	sp[0x20],r0
80010428:	0c 97       	mov	r7,r6
8001042a:	04 95       	mov	r5,r2
8001042c:	08 96       	mov	r6,r4
8001042e:	02 92       	mov	r2,r1
80010430:	40 94       	lddsp	r4,sp[0x24]
80010432:	10 90       	mov	r0,r8
80010434:	40 41       	lddsp	r1,sp[0x10]
80010436:	a5 a3       	sbr	r3,0x4
80010438:	c0 a8       	rjmp	8001044c <_vfprintf_r+0x10ec>
8001043a:	50 a7       	stdsp	sp[0x28],r7
8001043c:	50 80       	stdsp	sp[0x20],r0
8001043e:	0c 97       	mov	r7,r6
80010440:	04 95       	mov	r5,r2
80010442:	08 96       	mov	r6,r4
80010444:	02 92       	mov	r2,r1
80010446:	40 94       	lddsp	r4,sp[0x24]
80010448:	10 90       	mov	r0,r8
8001044a:	40 41       	lddsp	r1,sp[0x10]
8001044c:	ed b3 00 05 	bld	r3,0x5
80010450:	c5 61       	brne	800104fc <_vfprintf_r+0x119c>
80010452:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010456:	40 39       	lddsp	r9,sp[0xc]
80010458:	58 09       	cp.w	r9,0
8001045a:	c2 10       	breq	8001049c <_vfprintf_r+0x113c>
8001045c:	10 36       	cp.w	r6,r8
8001045e:	c0 74       	brge	8001046c <_vfprintf_r+0x110c>
80010460:	fa c8 f9 44 	sub	r8,sp,-1724
80010464:	f0 06 00 36 	add	r6,r8,r6<<0x3
80010468:	c2 38       	rjmp	800104ae <_vfprintf_r+0x114e>
8001046a:	d7 03       	nop
8001046c:	fa c8 f9 50 	sub	r8,sp,-1712
80010470:	1a d8       	st.w	--sp,r8
80010472:	fa c8 fa b8 	sub	r8,sp,-1352
80010476:	1a d8       	st.w	--sp,r8
80010478:	fa c8 fb b4 	sub	r8,sp,-1100
8001047c:	1a d8       	st.w	--sp,r8
8001047e:	fa c8 f9 40 	sub	r8,sp,-1728
80010482:	fa c9 ff b4 	sub	r9,sp,-76
80010486:	04 9a       	mov	r10,r2
80010488:	0c 9b       	mov	r11,r6
8001048a:	0a 9c       	mov	r12,r5
8001048c:	fe b0 f5 d2 	rcall	8000f030 <get_arg>
80010490:	2f dd       	sub	sp,-12
80010492:	f8 e8 00 00 	ld.d	r8,r12[0]
80010496:	fa e9 00 00 	st.d	sp[0],r8
8001049a:	c2 e8       	rjmp	800104f6 <_vfprintf_r+0x1196>
8001049c:	ee ca ff ff 	sub	r10,r7,-1
800104a0:	10 37       	cp.w	r7,r8
800104a2:	c0 b4       	brge	800104b8 <_vfprintf_r+0x1158>
800104a4:	fa c8 f9 44 	sub	r8,sp,-1724
800104a8:	14 97       	mov	r7,r10
800104aa:	f0 06 00 36 	add	r6,r8,r6<<0x3
800104ae:	ec ea fd 88 	ld.d	r10,r6[-632]
800104b2:	fa eb 00 00 	st.d	sp[0],r10
800104b6:	c2 08       	rjmp	800104f6 <_vfprintf_r+0x1196>
800104b8:	41 09       	lddsp	r9,sp[0x40]
800104ba:	59 f8       	cp.w	r8,31
800104bc:	e0 89 00 16 	brgt	800104e8 <_vfprintf_r+0x1188>
800104c0:	f2 e6 00 00 	ld.d	r6,r9[0]
800104c4:	f2 cb ff f8 	sub	r11,r9,-8
800104c8:	fa e7 00 00 	st.d	sp[0],r6
800104cc:	51 0b       	stdsp	sp[0x40],r11
800104ce:	fa c6 f9 44 	sub	r6,sp,-1724
800104d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800104d6:	fa e6 00 00 	ld.d	r6,sp[0]
800104da:	f2 e7 fd 88 	st.d	r9[-632],r6
800104de:	2f f8       	sub	r8,-1
800104e0:	14 97       	mov	r7,r10
800104e2:	fb 48 06 b4 	st.w	sp[1716],r8
800104e6:	c0 88       	rjmp	800104f6 <_vfprintf_r+0x1196>
800104e8:	f2 e6 00 00 	ld.d	r6,r9[0]
800104ec:	2f 89       	sub	r9,-8
800104ee:	fa e7 00 00 	st.d	sp[0],r6
800104f2:	51 09       	stdsp	sp[0x40],r9
800104f4:	14 97       	mov	r7,r10
800104f6:	30 18       	mov	r8,1
800104f8:	e0 8f 01 cd 	bral	80010892 <_vfprintf_r+0x1532>
800104fc:	ed b3 00 04 	bld	r3,0x4
80010500:	c1 61       	brne	8001052c <_vfprintf_r+0x11cc>
80010502:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010506:	40 3e       	lddsp	lr,sp[0xc]
80010508:	58 0e       	cp.w	lr,0
8001050a:	c0 80       	breq	8001051a <_vfprintf_r+0x11ba>
8001050c:	10 36       	cp.w	r6,r8
8001050e:	c6 74       	brge	800105dc <_vfprintf_r+0x127c>
80010510:	fa cc f9 44 	sub	r12,sp,-1724
80010514:	f8 06 00 36 	add	r6,r12,r6<<0x3
80010518:	c8 08       	rjmp	80010618 <_vfprintf_r+0x12b8>
8001051a:	ee ca ff ff 	sub	r10,r7,-1
8001051e:	10 37       	cp.w	r7,r8
80010520:	c7 f4       	brge	8001061e <_vfprintf_r+0x12be>
80010522:	fa cb f9 44 	sub	r11,sp,-1724
80010526:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001052a:	c7 68       	rjmp	80010616 <_vfprintf_r+0x12b6>
8001052c:	ed b3 00 06 	bld	r3,0x6
80010530:	c4 a1       	brne	800105c4 <_vfprintf_r+0x1264>
80010532:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010536:	40 3c       	lddsp	r12,sp[0xc]
80010538:	58 0c       	cp.w	r12,0
8001053a:	c1 d0       	breq	80010574 <_vfprintf_r+0x1214>
8001053c:	10 36       	cp.w	r6,r8
8001053e:	c0 64       	brge	8001054a <_vfprintf_r+0x11ea>
80010540:	fa cb f9 44 	sub	r11,sp,-1724
80010544:	f6 06 00 36 	add	r6,r11,r6<<0x3
80010548:	c1 f8       	rjmp	80010586 <_vfprintf_r+0x1226>
8001054a:	fa c8 f9 50 	sub	r8,sp,-1712
8001054e:	1a d8       	st.w	--sp,r8
80010550:	fa c8 fa b8 	sub	r8,sp,-1352
80010554:	1a d8       	st.w	--sp,r8
80010556:	fa c8 fb b4 	sub	r8,sp,-1100
8001055a:	1a d8       	st.w	--sp,r8
8001055c:	fa c8 f9 40 	sub	r8,sp,-1728
80010560:	fa c9 ff b4 	sub	r9,sp,-76
80010564:	04 9a       	mov	r10,r2
80010566:	0c 9b       	mov	r11,r6
80010568:	0a 9c       	mov	r12,r5
8001056a:	fe b0 f5 63 	rcall	8000f030 <get_arg>
8001056e:	2f dd       	sub	sp,-12
80010570:	98 18       	ld.sh	r8,r12[0x2]
80010572:	c2 68       	rjmp	800105be <_vfprintf_r+0x125e>
80010574:	ee ca ff ff 	sub	r10,r7,-1
80010578:	10 37       	cp.w	r7,r8
8001057a:	c0 94       	brge	8001058c <_vfprintf_r+0x122c>
8001057c:	fa c9 f9 44 	sub	r9,sp,-1724
80010580:	14 97       	mov	r7,r10
80010582:	f2 06 00 36 	add	r6,r9,r6<<0x3
80010586:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8001058a:	c1 a8       	rjmp	800105be <_vfprintf_r+0x125e>
8001058c:	41 09       	lddsp	r9,sp[0x40]
8001058e:	59 f8       	cp.w	r8,31
80010590:	e0 89 00 13 	brgt	800105b6 <_vfprintf_r+0x1256>
80010594:	f2 cb ff fc 	sub	r11,r9,-4
80010598:	51 0b       	stdsp	sp[0x40],r11
8001059a:	72 09       	ld.w	r9,r9[0x0]
8001059c:	fa c6 f9 44 	sub	r6,sp,-1724
800105a0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800105a4:	2f f8       	sub	r8,-1
800105a6:	f7 49 fd 88 	st.w	r11[-632],r9
800105aa:	fb 48 06 b4 	st.w	sp[1716],r8
800105ae:	14 97       	mov	r7,r10
800105b0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800105b4:	c0 58       	rjmp	800105be <_vfprintf_r+0x125e>
800105b6:	92 18       	ld.sh	r8,r9[0x2]
800105b8:	14 97       	mov	r7,r10
800105ba:	2f c9       	sub	r9,-4
800105bc:	51 09       	stdsp	sp[0x40],r9
800105be:	5c 78       	castu.h	r8
800105c0:	50 18       	stdsp	sp[0x4],r8
800105c2:	c4 68       	rjmp	8001064e <_vfprintf_r+0x12ee>
800105c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800105c8:	40 3c       	lddsp	r12,sp[0xc]
800105ca:	58 0c       	cp.w	r12,0
800105cc:	c1 d0       	breq	80010606 <_vfprintf_r+0x12a6>
800105ce:	10 36       	cp.w	r6,r8
800105d0:	c0 64       	brge	800105dc <_vfprintf_r+0x127c>
800105d2:	fa cb f9 44 	sub	r11,sp,-1724
800105d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800105da:	c1 f8       	rjmp	80010618 <_vfprintf_r+0x12b8>
800105dc:	fa c8 f9 50 	sub	r8,sp,-1712
800105e0:	1a d8       	st.w	--sp,r8
800105e2:	fa c8 fa b8 	sub	r8,sp,-1352
800105e6:	0c 9b       	mov	r11,r6
800105e8:	1a d8       	st.w	--sp,r8
800105ea:	fa c8 fb b4 	sub	r8,sp,-1100
800105ee:	04 9a       	mov	r10,r2
800105f0:	1a d8       	st.w	--sp,r8
800105f2:	0a 9c       	mov	r12,r5
800105f4:	fa c8 f9 40 	sub	r8,sp,-1728
800105f8:	fa c9 ff b4 	sub	r9,sp,-76
800105fc:	fe b0 f5 1a 	rcall	8000f030 <get_arg>
80010600:	2f dd       	sub	sp,-12
80010602:	78 0b       	ld.w	r11,r12[0x0]
80010604:	c2 48       	rjmp	8001064c <_vfprintf_r+0x12ec>
80010606:	ee ca ff ff 	sub	r10,r7,-1
8001060a:	10 37       	cp.w	r7,r8
8001060c:	c0 94       	brge	8001061e <_vfprintf_r+0x12be>
8001060e:	fa c9 f9 44 	sub	r9,sp,-1724
80010612:	f2 06 00 36 	add	r6,r9,r6<<0x3
80010616:	14 97       	mov	r7,r10
80010618:	ec fb fd 88 	ld.w	r11,r6[-632]
8001061c:	c1 88       	rjmp	8001064c <_vfprintf_r+0x12ec>
8001061e:	41 09       	lddsp	r9,sp[0x40]
80010620:	59 f8       	cp.w	r8,31
80010622:	e0 89 00 11 	brgt	80010644 <_vfprintf_r+0x12e4>
80010626:	f2 cb ff fc 	sub	r11,r9,-4
8001062a:	51 0b       	stdsp	sp[0x40],r11
8001062c:	fa c6 f9 44 	sub	r6,sp,-1724
80010630:	72 0b       	ld.w	r11,r9[0x0]
80010632:	ec 08 00 39 	add	r9,r6,r8<<0x3
80010636:	f3 4b fd 88 	st.w	r9[-632],r11
8001063a:	2f f8       	sub	r8,-1
8001063c:	14 97       	mov	r7,r10
8001063e:	fb 48 06 b4 	st.w	sp[1716],r8
80010642:	c0 58       	rjmp	8001064c <_vfprintf_r+0x12ec>
80010644:	72 0b       	ld.w	r11,r9[0x0]
80010646:	14 97       	mov	r7,r10
80010648:	2f c9       	sub	r9,-4
8001064a:	51 09       	stdsp	sp[0x40],r9
8001064c:	50 1b       	stdsp	sp[0x4],r11
8001064e:	30 0e       	mov	lr,0
80010650:	30 18       	mov	r8,1
80010652:	50 0e       	stdsp	sp[0x0],lr
80010654:	c1 f9       	rjmp	80010892 <_vfprintf_r+0x1532>
80010656:	50 a7       	stdsp	sp[0x28],r7
80010658:	50 80       	stdsp	sp[0x20],r0
8001065a:	0c 97       	mov	r7,r6
8001065c:	04 95       	mov	r5,r2
8001065e:	08 96       	mov	r6,r4
80010660:	02 92       	mov	r2,r1
80010662:	fe cc b3 9a 	sub	r12,pc,-19558
80010666:	40 94       	lddsp	r4,sp[0x24]
80010668:	10 90       	mov	r0,r8
8001066a:	40 41       	lddsp	r1,sp[0x10]
8001066c:	50 dc       	stdsp	sp[0x34],r12
8001066e:	ed b3 00 05 	bld	r3,0x5
80010672:	c5 51       	brne	8001071c <_vfprintf_r+0x13bc>
80010674:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010678:	40 3b       	lddsp	r11,sp[0xc]
8001067a:	58 0b       	cp.w	r11,0
8001067c:	c2 20       	breq	800106c0 <_vfprintf_r+0x1360>
8001067e:	10 36       	cp.w	r6,r8
80010680:	c0 a4       	brge	80010694 <_vfprintf_r+0x1334>
80010682:	fa ca f9 44 	sub	r10,sp,-1724
80010686:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001068a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8001068e:	fa e9 00 00 	st.d	sp[0],r8
80010692:	cf 28       	rjmp	80010876 <_vfprintf_r+0x1516>
80010694:	fa c8 f9 50 	sub	r8,sp,-1712
80010698:	1a d8       	st.w	--sp,r8
8001069a:	fa c8 fa b8 	sub	r8,sp,-1352
8001069e:	04 9a       	mov	r10,r2
800106a0:	1a d8       	st.w	--sp,r8
800106a2:	0c 9b       	mov	r11,r6
800106a4:	fa c8 fb b4 	sub	r8,sp,-1100
800106a8:	0a 9c       	mov	r12,r5
800106aa:	1a d8       	st.w	--sp,r8
800106ac:	fa c8 f9 40 	sub	r8,sp,-1728
800106b0:	fa c9 ff b4 	sub	r9,sp,-76
800106b4:	fe b0 f4 be 	rcall	8000f030 <get_arg>
800106b8:	2f dd       	sub	sp,-12
800106ba:	f8 ea 00 00 	ld.d	r10,r12[0]
800106be:	c0 c8       	rjmp	800106d6 <_vfprintf_r+0x1376>
800106c0:	ee ca ff ff 	sub	r10,r7,-1
800106c4:	10 37       	cp.w	r7,r8
800106c6:	c0 b4       	brge	800106dc <_vfprintf_r+0x137c>
800106c8:	fa c9 f9 44 	sub	r9,sp,-1724
800106cc:	14 97       	mov	r7,r10
800106ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
800106d2:	ec ea fd 88 	ld.d	r10,r6[-632]
800106d6:	fa eb 00 00 	st.d	sp[0],r10
800106da:	cc e8       	rjmp	80010876 <_vfprintf_r+0x1516>
800106dc:	41 09       	lddsp	r9,sp[0x40]
800106de:	59 f8       	cp.w	r8,31
800106e0:	e0 89 00 16 	brgt	8001070c <_vfprintf_r+0x13ac>
800106e4:	f2 e6 00 00 	ld.d	r6,r9[0]
800106e8:	f2 cb ff f8 	sub	r11,r9,-8
800106ec:	fa e7 00 00 	st.d	sp[0],r6
800106f0:	51 0b       	stdsp	sp[0x40],r11
800106f2:	fa c6 f9 44 	sub	r6,sp,-1724
800106f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800106fa:	fa e6 00 00 	ld.d	r6,sp[0]
800106fe:	f2 e7 fd 88 	st.d	r9[-632],r6
80010702:	2f f8       	sub	r8,-1
80010704:	14 97       	mov	r7,r10
80010706:	fb 48 06 b4 	st.w	sp[1716],r8
8001070a:	cb 68       	rjmp	80010876 <_vfprintf_r+0x1516>
8001070c:	f2 e6 00 00 	ld.d	r6,r9[0]
80010710:	2f 89       	sub	r9,-8
80010712:	fa e7 00 00 	st.d	sp[0],r6
80010716:	51 09       	stdsp	sp[0x40],r9
80010718:	14 97       	mov	r7,r10
8001071a:	ca e8       	rjmp	80010876 <_vfprintf_r+0x1516>
8001071c:	ed b3 00 04 	bld	r3,0x4
80010720:	c1 71       	brne	8001074e <_vfprintf_r+0x13ee>
80010722:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010726:	40 3e       	lddsp	lr,sp[0xc]
80010728:	58 0e       	cp.w	lr,0
8001072a:	c0 80       	breq	8001073a <_vfprintf_r+0x13da>
8001072c:	10 36       	cp.w	r6,r8
8001072e:	c6 94       	brge	80010800 <_vfprintf_r+0x14a0>
80010730:	fa cc f9 44 	sub	r12,sp,-1724
80010734:	f8 06 00 36 	add	r6,r12,r6<<0x3
80010738:	c8 28       	rjmp	8001083c <_vfprintf_r+0x14dc>
8001073a:	ee ca ff ff 	sub	r10,r7,-1
8001073e:	10 37       	cp.w	r7,r8
80010740:	e0 84 00 81 	brge	80010842 <_vfprintf_r+0x14e2>
80010744:	fa cb f9 44 	sub	r11,sp,-1724
80010748:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001074c:	c7 78       	rjmp	8001083a <_vfprintf_r+0x14da>
8001074e:	ed b3 00 06 	bld	r3,0x6
80010752:	c4 b1       	brne	800107e8 <_vfprintf_r+0x1488>
80010754:	fa f8 06 b4 	ld.w	r8,sp[1716]
80010758:	40 3c       	lddsp	r12,sp[0xc]
8001075a:	58 0c       	cp.w	r12,0
8001075c:	c1 d0       	breq	80010796 <_vfprintf_r+0x1436>
8001075e:	10 36       	cp.w	r6,r8
80010760:	c0 64       	brge	8001076c <_vfprintf_r+0x140c>
80010762:	fa cb f9 44 	sub	r11,sp,-1724
80010766:	f6 06 00 36 	add	r6,r11,r6<<0x3
8001076a:	c1 f8       	rjmp	800107a8 <_vfprintf_r+0x1448>
8001076c:	fa c8 f9 50 	sub	r8,sp,-1712
80010770:	1a d8       	st.w	--sp,r8
80010772:	fa c8 fa b8 	sub	r8,sp,-1352
80010776:	1a d8       	st.w	--sp,r8
80010778:	fa c8 fb b4 	sub	r8,sp,-1100
8001077c:	1a d8       	st.w	--sp,r8
8001077e:	fa c8 f9 40 	sub	r8,sp,-1728
80010782:	fa c9 ff b4 	sub	r9,sp,-76
80010786:	04 9a       	mov	r10,r2
80010788:	0c 9b       	mov	r11,r6
8001078a:	0a 9c       	mov	r12,r5
8001078c:	fe b0 f4 52 	rcall	8000f030 <get_arg>
80010790:	2f dd       	sub	sp,-12
80010792:	98 18       	ld.sh	r8,r12[0x2]
80010794:	c2 78       	rjmp	800107e2 <_vfprintf_r+0x1482>
80010796:	ee ca ff ff 	sub	r10,r7,-1
8001079a:	10 37       	cp.w	r7,r8
8001079c:	c0 a4       	brge	800107b0 <_vfprintf_r+0x1450>
8001079e:	fa c9 f9 44 	sub	r9,sp,-1724
800107a2:	14 97       	mov	r7,r10
800107a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800107a8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800107ac:	c1 b8       	rjmp	800107e2 <_vfprintf_r+0x1482>
800107ae:	d7 03       	nop
800107b0:	41 09       	lddsp	r9,sp[0x40]
800107b2:	59 f8       	cp.w	r8,31
800107b4:	e0 89 00 13 	brgt	800107da <_vfprintf_r+0x147a>
800107b8:	f2 cb ff fc 	sub	r11,r9,-4
800107bc:	51 0b       	stdsp	sp[0x40],r11
800107be:	72 09       	ld.w	r9,r9[0x0]
800107c0:	fa c6 f9 44 	sub	r6,sp,-1724
800107c4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800107c8:	2f f8       	sub	r8,-1
800107ca:	f7 49 fd 88 	st.w	r11[-632],r9
800107ce:	fb 48 06 b4 	st.w	sp[1716],r8
800107d2:	14 97       	mov	r7,r10
800107d4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800107d8:	c0 58       	rjmp	800107e2 <_vfprintf_r+0x1482>
800107da:	92 18       	ld.sh	r8,r9[0x2]
800107dc:	14 97       	mov	r7,r10
800107de:	2f c9       	sub	r9,-4
800107e0:	51 09       	stdsp	sp[0x40],r9
800107e2:	5c 78       	castu.h	r8
800107e4:	50 18       	stdsp	sp[0x4],r8
800107e6:	c4 68       	rjmp	80010872 <_vfprintf_r+0x1512>
800107e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800107ec:	40 3c       	lddsp	r12,sp[0xc]
800107ee:	58 0c       	cp.w	r12,0
800107f0:	c1 d0       	breq	8001082a <_vfprintf_r+0x14ca>
800107f2:	10 36       	cp.w	r6,r8
800107f4:	c0 64       	brge	80010800 <_vfprintf_r+0x14a0>
800107f6:	fa cb f9 44 	sub	r11,sp,-1724
800107fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800107fe:	c1 f8       	rjmp	8001083c <_vfprintf_r+0x14dc>
80010800:	fa c8 f9 50 	sub	r8,sp,-1712
80010804:	1a d8       	st.w	--sp,r8
80010806:	fa c8 fa b8 	sub	r8,sp,-1352
8001080a:	0c 9b       	mov	r11,r6
8001080c:	1a d8       	st.w	--sp,r8
8001080e:	fa c8 fb b4 	sub	r8,sp,-1100
80010812:	04 9a       	mov	r10,r2
80010814:	1a d8       	st.w	--sp,r8
80010816:	0a 9c       	mov	r12,r5
80010818:	fa c8 f9 40 	sub	r8,sp,-1728
8001081c:	fa c9 ff b4 	sub	r9,sp,-76
80010820:	fe b0 f4 08 	rcall	8000f030 <get_arg>
80010824:	2f dd       	sub	sp,-12
80010826:	78 0b       	ld.w	r11,r12[0x0]
80010828:	c2 48       	rjmp	80010870 <_vfprintf_r+0x1510>
8001082a:	ee ca ff ff 	sub	r10,r7,-1
8001082e:	10 37       	cp.w	r7,r8
80010830:	c0 94       	brge	80010842 <_vfprintf_r+0x14e2>
80010832:	fa c9 f9 44 	sub	r9,sp,-1724
80010836:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001083a:	14 97       	mov	r7,r10
8001083c:	ec fb fd 88 	ld.w	r11,r6[-632]
80010840:	c1 88       	rjmp	80010870 <_vfprintf_r+0x1510>
80010842:	41 09       	lddsp	r9,sp[0x40]
80010844:	59 f8       	cp.w	r8,31
80010846:	e0 89 00 11 	brgt	80010868 <_vfprintf_r+0x1508>
8001084a:	f2 cb ff fc 	sub	r11,r9,-4
8001084e:	51 0b       	stdsp	sp[0x40],r11
80010850:	fa c6 f9 44 	sub	r6,sp,-1724
80010854:	72 0b       	ld.w	r11,r9[0x0]
80010856:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001085a:	f3 4b fd 88 	st.w	r9[-632],r11
8001085e:	2f f8       	sub	r8,-1
80010860:	14 97       	mov	r7,r10
80010862:	fb 48 06 b4 	st.w	sp[1716],r8
80010866:	c0 58       	rjmp	80010870 <_vfprintf_r+0x1510>
80010868:	72 0b       	ld.w	r11,r9[0x0]
8001086a:	14 97       	mov	r7,r10
8001086c:	2f c9       	sub	r9,-4
8001086e:	51 09       	stdsp	sp[0x40],r9
80010870:	50 1b       	stdsp	sp[0x4],r11
80010872:	30 0e       	mov	lr,0
80010874:	50 0e       	stdsp	sp[0x0],lr
80010876:	40 08       	lddsp	r8,sp[0x0]
80010878:	40 1c       	lddsp	r12,sp[0x4]
8001087a:	18 48       	or	r8,r12
8001087c:	5f 18       	srne	r8
8001087e:	e7 e8 00 08 	and	r8,r3,r8
80010882:	c0 70       	breq	80010890 <_vfprintf_r+0x1530>
80010884:	33 08       	mov	r8,48
80010886:	fb 60 06 b9 	st.b	sp[1721],r0
8001088a:	a1 b3       	sbr	r3,0x1
8001088c:	fb 68 06 b8 	st.b	sp[1720],r8
80010890:	30 28       	mov	r8,2
80010892:	30 09       	mov	r9,0
80010894:	fb 69 06 bb 	st.b	sp[1723],r9
80010898:	40 2b       	lddsp	r11,sp[0x8]
8001089a:	58 0b       	cp.w	r11,0
8001089c:	c0 25       	brlt	800108a0 <_vfprintf_r+0x1540>
8001089e:	a7 d3       	cbr	r3,0x7
800108a0:	40 2a       	lddsp	r10,sp[0x8]
800108a2:	40 09       	lddsp	r9,sp[0x0]
800108a4:	58 0a       	cp.w	r10,0
800108a6:	5f 1a       	srne	r10
800108a8:	40 16       	lddsp	r6,sp[0x4]
800108aa:	fa c2 f9 78 	sub	r2,sp,-1672
800108ae:	0c 49       	or	r9,r6
800108b0:	5f 19       	srne	r9
800108b2:	f5 e9 10 09 	or	r9,r10,r9
800108b6:	c5 c0       	breq	8001096e <_vfprintf_r+0x160e>
800108b8:	30 19       	mov	r9,1
800108ba:	f2 08 18 00 	cp.b	r8,r9
800108be:	c0 60       	breq	800108ca <_vfprintf_r+0x156a>
800108c0:	30 29       	mov	r9,2
800108c2:	f2 08 18 00 	cp.b	r8,r9
800108c6:	c0 41       	brne	800108ce <_vfprintf_r+0x156e>
800108c8:	c3 c8       	rjmp	80010940 <_vfprintf_r+0x15e0>
800108ca:	04 96       	mov	r6,r2
800108cc:	c3 08       	rjmp	8001092c <_vfprintf_r+0x15cc>
800108ce:	04 96       	mov	r6,r2
800108d0:	fa e8 00 00 	ld.d	r8,sp[0]
800108d4:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800108d8:	2d 0a       	sub	r10,-48
800108da:	0c fa       	st.b	--r6,r10
800108dc:	f0 0b 16 03 	lsr	r11,r8,0x3
800108e0:	f2 0c 16 03 	lsr	r12,r9,0x3
800108e4:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800108e8:	18 99       	mov	r9,r12
800108ea:	16 98       	mov	r8,r11
800108ec:	58 08       	cp.w	r8,0
800108ee:	5c 29       	cpc	r9
800108f0:	cf 21       	brne	800108d4 <_vfprintf_r+0x1574>
800108f2:	fa e9 00 00 	st.d	sp[0],r8
800108f6:	ed b3 00 00 	bld	r3,0x0
800108fa:	c4 51       	brne	80010984 <_vfprintf_r+0x1624>
800108fc:	33 09       	mov	r9,48
800108fe:	f2 0a 18 00 	cp.b	r10,r9
80010902:	c4 10       	breq	80010984 <_vfprintf_r+0x1624>
80010904:	0c f9       	st.b	--r6,r9
80010906:	c3 f8       	rjmp	80010984 <_vfprintf_r+0x1624>
80010908:	fa ea 00 00 	ld.d	r10,sp[0]
8001090c:	30 a8       	mov	r8,10
8001090e:	30 09       	mov	r9,0
80010910:	e0 a0 16 d6 	rcall	800136bc <__avr32_umod64>
80010914:	30 a8       	mov	r8,10
80010916:	2d 0a       	sub	r10,-48
80010918:	30 09       	mov	r9,0
8001091a:	ac 8a       	st.b	r6[0x0],r10
8001091c:	fa ea 00 00 	ld.d	r10,sp[0]
80010920:	fe b0 ea b5 	rcall	8000de8a <__avr32_udiv64>
80010924:	16 99       	mov	r9,r11
80010926:	14 98       	mov	r8,r10
80010928:	fa e9 00 00 	st.d	sp[0],r8
8001092c:	20 16       	sub	r6,1
8001092e:	fa ea 00 00 	ld.d	r10,sp[0]
80010932:	58 9a       	cp.w	r10,9
80010934:	5c 2b       	cpc	r11
80010936:	fe 9b ff e9 	brhi	80010908 <_vfprintf_r+0x15a8>
8001093a:	1b f8       	ld.ub	r8,sp[0x7]
8001093c:	2d 08       	sub	r8,-48
8001093e:	c2 08       	rjmp	8001097e <_vfprintf_r+0x161e>
80010940:	04 96       	mov	r6,r2
80010942:	fa e8 00 00 	ld.d	r8,sp[0]
80010946:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8001094a:	40 de       	lddsp	lr,sp[0x34]
8001094c:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80010950:	0c fa       	st.b	--r6,r10
80010952:	f2 0b 16 04 	lsr	r11,r9,0x4
80010956:	f0 0a 16 04 	lsr	r10,r8,0x4
8001095a:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8001095e:	16 99       	mov	r9,r11
80010960:	14 98       	mov	r8,r10
80010962:	58 08       	cp.w	r8,0
80010964:	5c 29       	cpc	r9
80010966:	cf 01       	brne	80010946 <_vfprintf_r+0x15e6>
80010968:	fa e9 00 00 	st.d	sp[0],r8
8001096c:	c0 c8       	rjmp	80010984 <_vfprintf_r+0x1624>
8001096e:	58 08       	cp.w	r8,0
80010970:	c0 91       	brne	80010982 <_vfprintf_r+0x1622>
80010972:	ed b3 00 00 	bld	r3,0x0
80010976:	c0 61       	brne	80010982 <_vfprintf_r+0x1622>
80010978:	fa c6 f9 79 	sub	r6,sp,-1671
8001097c:	33 08       	mov	r8,48
8001097e:	ac 88       	st.b	r6[0x0],r8
80010980:	c0 28       	rjmp	80010984 <_vfprintf_r+0x1624>
80010982:	04 96       	mov	r6,r2
80010984:	0c 12       	sub	r2,r6
80010986:	c1 c8       	rjmp	800109be <_vfprintf_r+0x165e>
80010988:	50 a7       	stdsp	sp[0x28],r7
8001098a:	50 80       	stdsp	sp[0x20],r0
8001098c:	40 94       	lddsp	r4,sp[0x24]
8001098e:	0c 97       	mov	r7,r6
80010990:	10 90       	mov	r0,r8
80010992:	04 95       	mov	r5,r2
80010994:	40 41       	lddsp	r1,sp[0x10]
80010996:	58 08       	cp.w	r8,0
80010998:	e0 80 04 50 	breq	80011238 <_vfprintf_r+0x1ed8>
8001099c:	fb 68 06 60 	st.b	sp[1632],r8
800109a0:	30 0c       	mov	r12,0
800109a2:	30 08       	mov	r8,0
800109a4:	30 12       	mov	r2,1
800109a6:	fb 68 06 bb 	st.b	sp[1723],r8
800109aa:	50 2c       	stdsp	sp[0x8],r12
800109ac:	fa c6 f9 a0 	sub	r6,sp,-1632
800109b0:	c0 78       	rjmp	800109be <_vfprintf_r+0x165e>
800109b2:	30 0b       	mov	r11,0
800109b4:	50 2b       	stdsp	sp[0x8],r11
800109b6:	c0 48       	rjmp	800109be <_vfprintf_r+0x165e>
800109b8:	40 22       	lddsp	r2,sp[0x8]
800109ba:	30 0a       	mov	r10,0
800109bc:	50 2a       	stdsp	sp[0x8],r10
800109be:	40 29       	lddsp	r9,sp[0x8]
800109c0:	e4 09 0c 49 	max	r9,r2,r9
800109c4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800109c8:	50 39       	stdsp	sp[0xc],r9
800109ca:	06 9e       	mov	lr,r3
800109cc:	30 09       	mov	r9,0
800109ce:	e2 1e 00 02 	andl	lr,0x2,COH
800109d2:	f2 08 18 00 	cp.b	r8,r9
800109d6:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800109da:	f7 b8 01 ff 	subne	r8,-1
800109de:	fb f8 1a 03 	st.wne	sp[0xc],r8
800109e2:	06 9b       	mov	r11,r3
800109e4:	58 0e       	cp.w	lr,0
800109e6:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800109ea:	f7 bc 01 fe 	subne	r12,-2
800109ee:	fb fc 1a 03 	st.wne	sp[0xc],r12
800109f2:	e2 1b 00 84 	andl	r11,0x84,COH
800109f6:	50 fe       	stdsp	sp[0x3c],lr
800109f8:	50 9b       	stdsp	sp[0x24],r11
800109fa:	c4 71       	brne	80010a88 <_vfprintf_r+0x1728>
800109fc:	40 8a       	lddsp	r10,sp[0x20]
800109fe:	40 39       	lddsp	r9,sp[0xc]
80010a00:	12 1a       	sub	r10,r9
80010a02:	50 4a       	stdsp	sp[0x10],r10
80010a04:	58 0a       	cp.w	r10,0
80010a06:	e0 89 00 20 	brgt	80010a46 <_vfprintf_r+0x16e6>
80010a0a:	c3 f8       	rjmp	80010a88 <_vfprintf_r+0x1728>
80010a0c:	2f 09       	sub	r9,-16
80010a0e:	2f f8       	sub	r8,-1
80010a10:	fe ce b7 30 	sub	lr,pc,-18640
80010a14:	31 0c       	mov	r12,16
80010a16:	fb 49 06 90 	st.w	sp[1680],r9
80010a1a:	89 0e       	st.w	r4[0x0],lr
80010a1c:	89 1c       	st.w	r4[0x4],r12
80010a1e:	fb 48 06 8c 	st.w	sp[1676],r8
80010a22:	58 78       	cp.w	r8,7
80010a24:	e0 89 00 04 	brgt	80010a2c <_vfprintf_r+0x16cc>
80010a28:	2f 84       	sub	r4,-8
80010a2a:	c0 b8       	rjmp	80010a40 <_vfprintf_r+0x16e0>
80010a2c:	fa ca f9 78 	sub	r10,sp,-1672
80010a30:	02 9b       	mov	r11,r1
80010a32:	0a 9c       	mov	r12,r5
80010a34:	fe b0 f4 88 	rcall	8000f344 <__sprint_r>
80010a38:	e0 81 04 10 	brne	80011258 <_vfprintf_r+0x1ef8>
80010a3c:	fa c4 f9 e0 	sub	r4,sp,-1568
80010a40:	40 4b       	lddsp	r11,sp[0x10]
80010a42:	21 0b       	sub	r11,16
80010a44:	50 4b       	stdsp	sp[0x10],r11
80010a46:	fa f9 06 90 	ld.w	r9,sp[1680]
80010a4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010a4e:	fe ca b7 6e 	sub	r10,pc,-18578
80010a52:	40 4e       	lddsp	lr,sp[0x10]
80010a54:	59 0e       	cp.w	lr,16
80010a56:	fe 99 ff db 	brgt	80010a0c <_vfprintf_r+0x16ac>
80010a5a:	1c 09       	add	r9,lr
80010a5c:	2f f8       	sub	r8,-1
80010a5e:	89 0a       	st.w	r4[0x0],r10
80010a60:	fb 49 06 90 	st.w	sp[1680],r9
80010a64:	89 1e       	st.w	r4[0x4],lr
80010a66:	fb 48 06 8c 	st.w	sp[1676],r8
80010a6a:	58 78       	cp.w	r8,7
80010a6c:	e0 89 00 04 	brgt	80010a74 <_vfprintf_r+0x1714>
80010a70:	2f 84       	sub	r4,-8
80010a72:	c0 b8       	rjmp	80010a88 <_vfprintf_r+0x1728>
80010a74:	fa ca f9 78 	sub	r10,sp,-1672
80010a78:	02 9b       	mov	r11,r1
80010a7a:	0a 9c       	mov	r12,r5
80010a7c:	fe b0 f4 64 	rcall	8000f344 <__sprint_r>
80010a80:	e0 81 03 ec 	brne	80011258 <_vfprintf_r+0x1ef8>
80010a84:	fa c4 f9 e0 	sub	r4,sp,-1568
80010a88:	30 09       	mov	r9,0
80010a8a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80010a8e:	f2 08 18 00 	cp.b	r8,r9
80010a92:	c1 f0       	breq	80010ad0 <_vfprintf_r+0x1770>
80010a94:	fa f8 06 90 	ld.w	r8,sp[1680]
80010a98:	fa c9 f9 45 	sub	r9,sp,-1723
80010a9c:	2f f8       	sub	r8,-1
80010a9e:	89 09       	st.w	r4[0x0],r9
80010aa0:	fb 48 06 90 	st.w	sp[1680],r8
80010aa4:	30 19       	mov	r9,1
80010aa6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010aaa:	89 19       	st.w	r4[0x4],r9
80010aac:	2f f8       	sub	r8,-1
80010aae:	fb 48 06 8c 	st.w	sp[1676],r8
80010ab2:	58 78       	cp.w	r8,7
80010ab4:	e0 89 00 04 	brgt	80010abc <_vfprintf_r+0x175c>
80010ab8:	2f 84       	sub	r4,-8
80010aba:	c0 b8       	rjmp	80010ad0 <_vfprintf_r+0x1770>
80010abc:	fa ca f9 78 	sub	r10,sp,-1672
80010ac0:	02 9b       	mov	r11,r1
80010ac2:	0a 9c       	mov	r12,r5
80010ac4:	fe b0 f4 40 	rcall	8000f344 <__sprint_r>
80010ac8:	e0 81 03 c8 	brne	80011258 <_vfprintf_r+0x1ef8>
80010acc:	fa c4 f9 e0 	sub	r4,sp,-1568
80010ad0:	40 fc       	lddsp	r12,sp[0x3c]
80010ad2:	58 0c       	cp.w	r12,0
80010ad4:	c1 f0       	breq	80010b12 <_vfprintf_r+0x17b2>
80010ad6:	fa f8 06 90 	ld.w	r8,sp[1680]
80010ada:	fa c9 f9 48 	sub	r9,sp,-1720
80010ade:	2f e8       	sub	r8,-2
80010ae0:	89 09       	st.w	r4[0x0],r9
80010ae2:	fb 48 06 90 	st.w	sp[1680],r8
80010ae6:	30 29       	mov	r9,2
80010ae8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010aec:	89 19       	st.w	r4[0x4],r9
80010aee:	2f f8       	sub	r8,-1
80010af0:	fb 48 06 8c 	st.w	sp[1676],r8
80010af4:	58 78       	cp.w	r8,7
80010af6:	e0 89 00 04 	brgt	80010afe <_vfprintf_r+0x179e>
80010afa:	2f 84       	sub	r4,-8
80010afc:	c0 b8       	rjmp	80010b12 <_vfprintf_r+0x17b2>
80010afe:	fa ca f9 78 	sub	r10,sp,-1672
80010b02:	02 9b       	mov	r11,r1
80010b04:	0a 9c       	mov	r12,r5
80010b06:	fe b0 f4 1f 	rcall	8000f344 <__sprint_r>
80010b0a:	e0 81 03 a7 	brne	80011258 <_vfprintf_r+0x1ef8>
80010b0e:	fa c4 f9 e0 	sub	r4,sp,-1568
80010b12:	40 9b       	lddsp	r11,sp[0x24]
80010b14:	e0 4b 00 80 	cp.w	r11,128
80010b18:	c4 81       	brne	80010ba8 <_vfprintf_r+0x1848>
80010b1a:	40 8a       	lddsp	r10,sp[0x20]
80010b1c:	40 39       	lddsp	r9,sp[0xc]
80010b1e:	12 1a       	sub	r10,r9
80010b20:	50 4a       	stdsp	sp[0x10],r10
80010b22:	58 0a       	cp.w	r10,0
80010b24:	e0 89 00 21 	brgt	80010b66 <_vfprintf_r+0x1806>
80010b28:	c4 08       	rjmp	80010ba8 <_vfprintf_r+0x1848>
80010b2a:	2f 09       	sub	r9,-16
80010b2c:	2f f8       	sub	r8,-1
80010b2e:	fe ce b8 3e 	sub	lr,pc,-18370
80010b32:	31 0c       	mov	r12,16
80010b34:	fb 49 06 90 	st.w	sp[1680],r9
80010b38:	89 0e       	st.w	r4[0x0],lr
80010b3a:	89 1c       	st.w	r4[0x4],r12
80010b3c:	fb 48 06 8c 	st.w	sp[1676],r8
80010b40:	58 78       	cp.w	r8,7
80010b42:	e0 89 00 05 	brgt	80010b4c <_vfprintf_r+0x17ec>
80010b46:	2f 84       	sub	r4,-8
80010b48:	c0 c8       	rjmp	80010b60 <_vfprintf_r+0x1800>
80010b4a:	d7 03       	nop
80010b4c:	fa ca f9 78 	sub	r10,sp,-1672
80010b50:	02 9b       	mov	r11,r1
80010b52:	0a 9c       	mov	r12,r5
80010b54:	fe b0 f3 f8 	rcall	8000f344 <__sprint_r>
80010b58:	e0 81 03 80 	brne	80011258 <_vfprintf_r+0x1ef8>
80010b5c:	fa c4 f9 e0 	sub	r4,sp,-1568
80010b60:	40 4b       	lddsp	r11,sp[0x10]
80010b62:	21 0b       	sub	r11,16
80010b64:	50 4b       	stdsp	sp[0x10],r11
80010b66:	fa f9 06 90 	ld.w	r9,sp[1680]
80010b6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010b6e:	fe ca b8 7e 	sub	r10,pc,-18306
80010b72:	40 4e       	lddsp	lr,sp[0x10]
80010b74:	59 0e       	cp.w	lr,16
80010b76:	fe 99 ff da 	brgt	80010b2a <_vfprintf_r+0x17ca>
80010b7a:	1c 09       	add	r9,lr
80010b7c:	2f f8       	sub	r8,-1
80010b7e:	89 0a       	st.w	r4[0x0],r10
80010b80:	fb 49 06 90 	st.w	sp[1680],r9
80010b84:	89 1e       	st.w	r4[0x4],lr
80010b86:	fb 48 06 8c 	st.w	sp[1676],r8
80010b8a:	58 78       	cp.w	r8,7
80010b8c:	e0 89 00 04 	brgt	80010b94 <_vfprintf_r+0x1834>
80010b90:	2f 84       	sub	r4,-8
80010b92:	c0 b8       	rjmp	80010ba8 <_vfprintf_r+0x1848>
80010b94:	fa ca f9 78 	sub	r10,sp,-1672
80010b98:	02 9b       	mov	r11,r1
80010b9a:	0a 9c       	mov	r12,r5
80010b9c:	fe b0 f3 d4 	rcall	8000f344 <__sprint_r>
80010ba0:	e0 81 03 5c 	brne	80011258 <_vfprintf_r+0x1ef8>
80010ba4:	fa c4 f9 e0 	sub	r4,sp,-1568
80010ba8:	40 2c       	lddsp	r12,sp[0x8]
80010baa:	04 1c       	sub	r12,r2
80010bac:	50 2c       	stdsp	sp[0x8],r12
80010bae:	58 0c       	cp.w	r12,0
80010bb0:	e0 89 00 20 	brgt	80010bf0 <_vfprintf_r+0x1890>
80010bb4:	c3 f8       	rjmp	80010c32 <_vfprintf_r+0x18d2>
80010bb6:	2f 09       	sub	r9,-16
80010bb8:	2f f8       	sub	r8,-1
80010bba:	fe cb b8 ca 	sub	r11,pc,-18230
80010bbe:	31 0a       	mov	r10,16
80010bc0:	fb 49 06 90 	st.w	sp[1680],r9
80010bc4:	89 0b       	st.w	r4[0x0],r11
80010bc6:	89 1a       	st.w	r4[0x4],r10
80010bc8:	fb 48 06 8c 	st.w	sp[1676],r8
80010bcc:	58 78       	cp.w	r8,7
80010bce:	e0 89 00 04 	brgt	80010bd6 <_vfprintf_r+0x1876>
80010bd2:	2f 84       	sub	r4,-8
80010bd4:	c0 b8       	rjmp	80010bea <_vfprintf_r+0x188a>
80010bd6:	fa ca f9 78 	sub	r10,sp,-1672
80010bda:	02 9b       	mov	r11,r1
80010bdc:	0a 9c       	mov	r12,r5
80010bde:	fe b0 f3 b3 	rcall	8000f344 <__sprint_r>
80010be2:	e0 81 03 3b 	brne	80011258 <_vfprintf_r+0x1ef8>
80010be6:	fa c4 f9 e0 	sub	r4,sp,-1568
80010bea:	40 29       	lddsp	r9,sp[0x8]
80010bec:	21 09       	sub	r9,16
80010bee:	50 29       	stdsp	sp[0x8],r9
80010bf0:	fa f9 06 90 	ld.w	r9,sp[1680]
80010bf4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010bf8:	fe ca b9 08 	sub	r10,pc,-18168
80010bfc:	40 2e       	lddsp	lr,sp[0x8]
80010bfe:	59 0e       	cp.w	lr,16
80010c00:	fe 99 ff db 	brgt	80010bb6 <_vfprintf_r+0x1856>
80010c04:	1c 09       	add	r9,lr
80010c06:	2f f8       	sub	r8,-1
80010c08:	89 0a       	st.w	r4[0x0],r10
80010c0a:	fb 49 06 90 	st.w	sp[1680],r9
80010c0e:	89 1e       	st.w	r4[0x4],lr
80010c10:	fb 48 06 8c 	st.w	sp[1676],r8
80010c14:	58 78       	cp.w	r8,7
80010c16:	e0 89 00 04 	brgt	80010c1e <_vfprintf_r+0x18be>
80010c1a:	2f 84       	sub	r4,-8
80010c1c:	c0 b8       	rjmp	80010c32 <_vfprintf_r+0x18d2>
80010c1e:	fa ca f9 78 	sub	r10,sp,-1672
80010c22:	02 9b       	mov	r11,r1
80010c24:	0a 9c       	mov	r12,r5
80010c26:	fe b0 f3 8f 	rcall	8000f344 <__sprint_r>
80010c2a:	e0 81 03 17 	brne	80011258 <_vfprintf_r+0x1ef8>
80010c2e:	fa c4 f9 e0 	sub	r4,sp,-1568
80010c32:	ed b3 00 08 	bld	r3,0x8
80010c36:	c0 b0       	breq	80010c4c <_vfprintf_r+0x18ec>
80010c38:	fa f8 06 90 	ld.w	r8,sp[1680]
80010c3c:	89 12       	st.w	r4[0x4],r2
80010c3e:	89 06       	st.w	r4[0x0],r6
80010c40:	f0 02 00 02 	add	r2,r8,r2
80010c44:	fb 42 06 90 	st.w	sp[1680],r2
80010c48:	e0 8f 01 d4 	bral	80010ff0 <_vfprintf_r+0x1c90>
80010c4c:	e0 40 00 65 	cp.w	r0,101
80010c50:	e0 8a 01 d6 	brle	80010ffc <_vfprintf_r+0x1c9c>
80010c54:	30 08       	mov	r8,0
80010c56:	30 09       	mov	r9,0
80010c58:	40 5b       	lddsp	r11,sp[0x14]
80010c5a:	40 7a       	lddsp	r10,sp[0x1c]
80010c5c:	e0 a0 13 29 	rcall	800132ae <__avr32_f64_cmp_eq>
80010c60:	c7 90       	breq	80010d52 <_vfprintf_r+0x19f2>
80010c62:	fa f8 06 90 	ld.w	r8,sp[1680]
80010c66:	fe c9 b9 8a 	sub	r9,pc,-18038
80010c6a:	2f f8       	sub	r8,-1
80010c6c:	89 09       	st.w	r4[0x0],r9
80010c6e:	fb 48 06 90 	st.w	sp[1680],r8
80010c72:	30 19       	mov	r9,1
80010c74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010c78:	89 19       	st.w	r4[0x4],r9
80010c7a:	2f f8       	sub	r8,-1
80010c7c:	fb 48 06 8c 	st.w	sp[1676],r8
80010c80:	58 78       	cp.w	r8,7
80010c82:	e0 89 00 05 	brgt	80010c8c <_vfprintf_r+0x192c>
80010c86:	2f 84       	sub	r4,-8
80010c88:	c0 c8       	rjmp	80010ca0 <_vfprintf_r+0x1940>
80010c8a:	d7 03       	nop
80010c8c:	fa ca f9 78 	sub	r10,sp,-1672
80010c90:	02 9b       	mov	r11,r1
80010c92:	0a 9c       	mov	r12,r5
80010c94:	fe b0 f3 58 	rcall	8000f344 <__sprint_r>
80010c98:	e0 81 02 e0 	brne	80011258 <_vfprintf_r+0x1ef8>
80010c9c:	fa c4 f9 e0 	sub	r4,sp,-1568
80010ca0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80010ca4:	40 6c       	lddsp	r12,sp[0x18]
80010ca6:	18 38       	cp.w	r8,r12
80010ca8:	c0 55       	brlt	80010cb2 <_vfprintf_r+0x1952>
80010caa:	ed b3 00 00 	bld	r3,0x0
80010cae:	e0 81 02 6b 	brne	80011184 <_vfprintf_r+0x1e24>
80010cb2:	fa f8 06 90 	ld.w	r8,sp[1680]
80010cb6:	2f f8       	sub	r8,-1
80010cb8:	40 cb       	lddsp	r11,sp[0x30]
80010cba:	fb 48 06 90 	st.w	sp[1680],r8
80010cbe:	30 19       	mov	r9,1
80010cc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010cc4:	89 0b       	st.w	r4[0x0],r11
80010cc6:	2f f8       	sub	r8,-1
80010cc8:	89 19       	st.w	r4[0x4],r9
80010cca:	fb 48 06 8c 	st.w	sp[1676],r8
80010cce:	58 78       	cp.w	r8,7
80010cd0:	e0 89 00 04 	brgt	80010cd8 <_vfprintf_r+0x1978>
80010cd4:	2f 84       	sub	r4,-8
80010cd6:	c0 b8       	rjmp	80010cec <_vfprintf_r+0x198c>
80010cd8:	fa ca f9 78 	sub	r10,sp,-1672
80010cdc:	02 9b       	mov	r11,r1
80010cde:	0a 9c       	mov	r12,r5
80010ce0:	fe b0 f3 32 	rcall	8000f344 <__sprint_r>
80010ce4:	e0 81 02 ba 	brne	80011258 <_vfprintf_r+0x1ef8>
80010ce8:	fa c4 f9 e0 	sub	r4,sp,-1568
80010cec:	40 66       	lddsp	r6,sp[0x18]
80010cee:	20 16       	sub	r6,1
80010cf0:	58 06       	cp.w	r6,0
80010cf2:	e0 89 00 1d 	brgt	80010d2c <_vfprintf_r+0x19cc>
80010cf6:	e0 8f 02 47 	bral	80011184 <_vfprintf_r+0x1e24>
80010cfa:	2f 09       	sub	r9,-16
80010cfc:	2f f8       	sub	r8,-1
80010cfe:	fb 49 06 90 	st.w	sp[1680],r9
80010d02:	89 02       	st.w	r4[0x0],r2
80010d04:	89 10       	st.w	r4[0x4],r0
80010d06:	fb 48 06 8c 	st.w	sp[1676],r8
80010d0a:	58 78       	cp.w	r8,7
80010d0c:	e0 89 00 04 	brgt	80010d14 <_vfprintf_r+0x19b4>
80010d10:	2f 84       	sub	r4,-8
80010d12:	c0 b8       	rjmp	80010d28 <_vfprintf_r+0x19c8>
80010d14:	fa ca f9 78 	sub	r10,sp,-1672
80010d18:	02 9b       	mov	r11,r1
80010d1a:	0a 9c       	mov	r12,r5
80010d1c:	fe b0 f3 14 	rcall	8000f344 <__sprint_r>
80010d20:	e0 81 02 9c 	brne	80011258 <_vfprintf_r+0x1ef8>
80010d24:	fa c4 f9 e0 	sub	r4,sp,-1568
80010d28:	21 06       	sub	r6,16
80010d2a:	c0 48       	rjmp	80010d32 <_vfprintf_r+0x19d2>
80010d2c:	fe c2 ba 3c 	sub	r2,pc,-17860
80010d30:	31 00       	mov	r0,16
80010d32:	fa f9 06 90 	ld.w	r9,sp[1680]
80010d36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010d3a:	fe ca ba 4a 	sub	r10,pc,-17846
80010d3e:	59 06       	cp.w	r6,16
80010d40:	fe 99 ff dd 	brgt	80010cfa <_vfprintf_r+0x199a>
80010d44:	0c 09       	add	r9,r6
80010d46:	89 0a       	st.w	r4[0x0],r10
80010d48:	fb 49 06 90 	st.w	sp[1680],r9
80010d4c:	2f f8       	sub	r8,-1
80010d4e:	89 16       	st.w	r4[0x4],r6
80010d50:	c5 39       	rjmp	80010ff6 <_vfprintf_r+0x1c96>
80010d52:	fa fa 06 ac 	ld.w	r10,sp[1708]
80010d56:	58 0a       	cp.w	r10,0
80010d58:	e0 89 00 92 	brgt	80010e7c <_vfprintf_r+0x1b1c>
80010d5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80010d60:	fe c9 ba 84 	sub	r9,pc,-17788
80010d64:	2f f8       	sub	r8,-1
80010d66:	89 09       	st.w	r4[0x0],r9
80010d68:	fb 48 06 90 	st.w	sp[1680],r8
80010d6c:	30 19       	mov	r9,1
80010d6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010d72:	89 19       	st.w	r4[0x4],r9
80010d74:	2f f8       	sub	r8,-1
80010d76:	fb 48 06 8c 	st.w	sp[1676],r8
80010d7a:	58 78       	cp.w	r8,7
80010d7c:	e0 89 00 04 	brgt	80010d84 <_vfprintf_r+0x1a24>
80010d80:	2f 84       	sub	r4,-8
80010d82:	c0 b8       	rjmp	80010d98 <_vfprintf_r+0x1a38>
80010d84:	fa ca f9 78 	sub	r10,sp,-1672
80010d88:	02 9b       	mov	r11,r1
80010d8a:	0a 9c       	mov	r12,r5
80010d8c:	fe b0 f2 dc 	rcall	8000f344 <__sprint_r>
80010d90:	e0 81 02 64 	brne	80011258 <_vfprintf_r+0x1ef8>
80010d94:	fa c4 f9 e0 	sub	r4,sp,-1568
80010d98:	fa f8 06 ac 	ld.w	r8,sp[1708]
80010d9c:	58 08       	cp.w	r8,0
80010d9e:	c0 81       	brne	80010dae <_vfprintf_r+0x1a4e>
80010da0:	40 6a       	lddsp	r10,sp[0x18]
80010da2:	58 0a       	cp.w	r10,0
80010da4:	c0 51       	brne	80010dae <_vfprintf_r+0x1a4e>
80010da6:	ed b3 00 00 	bld	r3,0x0
80010daa:	e0 81 01 ed 	brne	80011184 <_vfprintf_r+0x1e24>
80010dae:	40 c9       	lddsp	r9,sp[0x30]
80010db0:	fa f8 06 90 	ld.w	r8,sp[1680]
80010db4:	2f f8       	sub	r8,-1
80010db6:	89 09       	st.w	r4[0x0],r9
80010db8:	fb 48 06 90 	st.w	sp[1680],r8
80010dbc:	30 19       	mov	r9,1
80010dbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010dc2:	89 19       	st.w	r4[0x4],r9
80010dc4:	2f f8       	sub	r8,-1
80010dc6:	fb 48 06 8c 	st.w	sp[1676],r8
80010dca:	58 78       	cp.w	r8,7
80010dcc:	e0 89 00 04 	brgt	80010dd4 <_vfprintf_r+0x1a74>
80010dd0:	2f 84       	sub	r4,-8
80010dd2:	c0 b8       	rjmp	80010de8 <_vfprintf_r+0x1a88>
80010dd4:	fa ca f9 78 	sub	r10,sp,-1672
80010dd8:	02 9b       	mov	r11,r1
80010dda:	0a 9c       	mov	r12,r5
80010ddc:	fe b0 f2 b4 	rcall	8000f344 <__sprint_r>
80010de0:	e0 81 02 3c 	brne	80011258 <_vfprintf_r+0x1ef8>
80010de4:	fa c4 f9 e0 	sub	r4,sp,-1568
80010de8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80010dec:	5c 32       	neg	r2
80010dee:	58 02       	cp.w	r2,0
80010df0:	e0 89 00 1d 	brgt	80010e2a <_vfprintf_r+0x1aca>
80010df4:	c3 d8       	rjmp	80010e6e <_vfprintf_r+0x1b0e>
80010df6:	2f 09       	sub	r9,-16
80010df8:	2f f8       	sub	r8,-1
80010dfa:	31 0e       	mov	lr,16
80010dfc:	fb 49 06 90 	st.w	sp[1680],r9
80010e00:	89 00       	st.w	r4[0x0],r0
80010e02:	89 1e       	st.w	r4[0x4],lr
80010e04:	fb 48 06 8c 	st.w	sp[1676],r8
80010e08:	58 78       	cp.w	r8,7
80010e0a:	e0 89 00 04 	brgt	80010e12 <_vfprintf_r+0x1ab2>
80010e0e:	2f 84       	sub	r4,-8
80010e10:	c0 b8       	rjmp	80010e26 <_vfprintf_r+0x1ac6>
80010e12:	fa ca f9 78 	sub	r10,sp,-1672
80010e16:	02 9b       	mov	r11,r1
80010e18:	0a 9c       	mov	r12,r5
80010e1a:	fe b0 f2 95 	rcall	8000f344 <__sprint_r>
80010e1e:	e0 81 02 1d 	brne	80011258 <_vfprintf_r+0x1ef8>
80010e22:	fa c4 f9 e0 	sub	r4,sp,-1568
80010e26:	21 02       	sub	r2,16
80010e28:	c0 38       	rjmp	80010e2e <_vfprintf_r+0x1ace>
80010e2a:	fe c0 bb 3a 	sub	r0,pc,-17606
80010e2e:	fa f9 06 90 	ld.w	r9,sp[1680]
80010e32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010e36:	fe ca bb 46 	sub	r10,pc,-17594
80010e3a:	59 02       	cp.w	r2,16
80010e3c:	fe 99 ff dd 	brgt	80010df6 <_vfprintf_r+0x1a96>
80010e40:	04 09       	add	r9,r2
80010e42:	2f f8       	sub	r8,-1
80010e44:	89 0a       	st.w	r4[0x0],r10
80010e46:	fb 49 06 90 	st.w	sp[1680],r9
80010e4a:	89 12       	st.w	r4[0x4],r2
80010e4c:	fb 48 06 8c 	st.w	sp[1676],r8
80010e50:	58 78       	cp.w	r8,7
80010e52:	e0 89 00 04 	brgt	80010e5a <_vfprintf_r+0x1afa>
80010e56:	2f 84       	sub	r4,-8
80010e58:	c0 b8       	rjmp	80010e6e <_vfprintf_r+0x1b0e>
80010e5a:	fa ca f9 78 	sub	r10,sp,-1672
80010e5e:	02 9b       	mov	r11,r1
80010e60:	0a 9c       	mov	r12,r5
80010e62:	fe b0 f2 71 	rcall	8000f344 <__sprint_r>
80010e66:	e0 81 01 f9 	brne	80011258 <_vfprintf_r+0x1ef8>
80010e6a:	fa c4 f9 e0 	sub	r4,sp,-1568
80010e6e:	40 6c       	lddsp	r12,sp[0x18]
80010e70:	fa f8 06 90 	ld.w	r8,sp[1680]
80010e74:	89 06       	st.w	r4[0x0],r6
80010e76:	89 1c       	st.w	r4[0x4],r12
80010e78:	18 08       	add	r8,r12
80010e7a:	cb 98       	rjmp	80010fec <_vfprintf_r+0x1c8c>
80010e7c:	fa f9 06 90 	ld.w	r9,sp[1680]
80010e80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010e84:	40 6b       	lddsp	r11,sp[0x18]
80010e86:	16 3a       	cp.w	r10,r11
80010e88:	c6 f5       	brlt	80010f66 <_vfprintf_r+0x1c06>
80010e8a:	16 09       	add	r9,r11
80010e8c:	2f f8       	sub	r8,-1
80010e8e:	89 06       	st.w	r4[0x0],r6
80010e90:	fb 49 06 90 	st.w	sp[1680],r9
80010e94:	89 1b       	st.w	r4[0x4],r11
80010e96:	fb 48 06 8c 	st.w	sp[1676],r8
80010e9a:	58 78       	cp.w	r8,7
80010e9c:	e0 89 00 04 	brgt	80010ea4 <_vfprintf_r+0x1b44>
80010ea0:	2f 84       	sub	r4,-8
80010ea2:	c0 b8       	rjmp	80010eb8 <_vfprintf_r+0x1b58>
80010ea4:	fa ca f9 78 	sub	r10,sp,-1672
80010ea8:	02 9b       	mov	r11,r1
80010eaa:	0a 9c       	mov	r12,r5
80010eac:	fe b0 f2 4c 	rcall	8000f344 <__sprint_r>
80010eb0:	e0 81 01 d4 	brne	80011258 <_vfprintf_r+0x1ef8>
80010eb4:	fa c4 f9 e0 	sub	r4,sp,-1568
80010eb8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80010ebc:	40 6a       	lddsp	r10,sp[0x18]
80010ebe:	14 16       	sub	r6,r10
80010ec0:	58 06       	cp.w	r6,0
80010ec2:	e0 89 00 1c 	brgt	80010efa <_vfprintf_r+0x1b9a>
80010ec6:	c3 d8       	rjmp	80010f40 <_vfprintf_r+0x1be0>
80010ec8:	2f 09       	sub	r9,-16
80010eca:	2f f8       	sub	r8,-1
80010ecc:	fb 49 06 90 	st.w	sp[1680],r9
80010ed0:	89 02       	st.w	r4[0x0],r2
80010ed2:	89 10       	st.w	r4[0x4],r0
80010ed4:	fb 48 06 8c 	st.w	sp[1676],r8
80010ed8:	58 78       	cp.w	r8,7
80010eda:	e0 89 00 04 	brgt	80010ee2 <_vfprintf_r+0x1b82>
80010ede:	2f 84       	sub	r4,-8
80010ee0:	c0 b8       	rjmp	80010ef6 <_vfprintf_r+0x1b96>
80010ee2:	fa ca f9 78 	sub	r10,sp,-1672
80010ee6:	02 9b       	mov	r11,r1
80010ee8:	0a 9c       	mov	r12,r5
80010eea:	fe b0 f2 2d 	rcall	8000f344 <__sprint_r>
80010eee:	e0 81 01 b5 	brne	80011258 <_vfprintf_r+0x1ef8>
80010ef2:	fa c4 f9 e0 	sub	r4,sp,-1568
80010ef6:	21 06       	sub	r6,16
80010ef8:	c0 48       	rjmp	80010f00 <_vfprintf_r+0x1ba0>
80010efa:	fe c2 bc 0a 	sub	r2,pc,-17398
80010efe:	31 00       	mov	r0,16
80010f00:	fa f9 06 90 	ld.w	r9,sp[1680]
80010f04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010f08:	fe ca bc 18 	sub	r10,pc,-17384
80010f0c:	59 06       	cp.w	r6,16
80010f0e:	fe 99 ff dd 	brgt	80010ec8 <_vfprintf_r+0x1b68>
80010f12:	0c 09       	add	r9,r6
80010f14:	2f f8       	sub	r8,-1
80010f16:	89 0a       	st.w	r4[0x0],r10
80010f18:	fb 49 06 90 	st.w	sp[1680],r9
80010f1c:	89 16       	st.w	r4[0x4],r6
80010f1e:	fb 48 06 8c 	st.w	sp[1676],r8
80010f22:	58 78       	cp.w	r8,7
80010f24:	e0 89 00 04 	brgt	80010f2c <_vfprintf_r+0x1bcc>
80010f28:	2f 84       	sub	r4,-8
80010f2a:	c0 b8       	rjmp	80010f40 <_vfprintf_r+0x1be0>
80010f2c:	fa ca f9 78 	sub	r10,sp,-1672
80010f30:	02 9b       	mov	r11,r1
80010f32:	0a 9c       	mov	r12,r5
80010f34:	fe b0 f2 08 	rcall	8000f344 <__sprint_r>
80010f38:	e0 81 01 90 	brne	80011258 <_vfprintf_r+0x1ef8>
80010f3c:	fa c4 f9 e0 	sub	r4,sp,-1568
80010f40:	ed b3 00 00 	bld	r3,0x0
80010f44:	e0 81 01 20 	brne	80011184 <_vfprintf_r+0x1e24>
80010f48:	40 c9       	lddsp	r9,sp[0x30]
80010f4a:	fa f8 06 90 	ld.w	r8,sp[1680]
80010f4e:	2f f8       	sub	r8,-1
80010f50:	89 09       	st.w	r4[0x0],r9
80010f52:	fb 48 06 90 	st.w	sp[1680],r8
80010f56:	30 19       	mov	r9,1
80010f58:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010f5c:	89 19       	st.w	r4[0x4],r9
80010f5e:	2f f8       	sub	r8,-1
80010f60:	fb 48 06 8c 	st.w	sp[1676],r8
80010f64:	c0 29       	rjmp	80011168 <_vfprintf_r+0x1e08>
80010f66:	14 09       	add	r9,r10
80010f68:	2f f8       	sub	r8,-1
80010f6a:	fb 49 06 90 	st.w	sp[1680],r9
80010f6e:	89 06       	st.w	r4[0x0],r6
80010f70:	89 1a       	st.w	r4[0x4],r10
80010f72:	fb 48 06 8c 	st.w	sp[1676],r8
80010f76:	58 78       	cp.w	r8,7
80010f78:	e0 89 00 04 	brgt	80010f80 <_vfprintf_r+0x1c20>
80010f7c:	2f 84       	sub	r4,-8
80010f7e:	c0 b8       	rjmp	80010f94 <_vfprintf_r+0x1c34>
80010f80:	fa ca f9 78 	sub	r10,sp,-1672
80010f84:	02 9b       	mov	r11,r1
80010f86:	0a 9c       	mov	r12,r5
80010f88:	fe b0 f1 de 	rcall	8000f344 <__sprint_r>
80010f8c:	e0 81 01 66 	brne	80011258 <_vfprintf_r+0x1ef8>
80010f90:	fa c4 f9 e0 	sub	r4,sp,-1568
80010f94:	40 c8       	lddsp	r8,sp[0x30]
80010f96:	89 08       	st.w	r4[0x0],r8
80010f98:	fa f8 06 90 	ld.w	r8,sp[1680]
80010f9c:	2f f8       	sub	r8,-1
80010f9e:	30 19       	mov	r9,1
80010fa0:	fb 48 06 90 	st.w	sp[1680],r8
80010fa4:	89 19       	st.w	r4[0x4],r9
80010fa6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010faa:	2f f8       	sub	r8,-1
80010fac:	fb 48 06 8c 	st.w	sp[1676],r8
80010fb0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80010fb4:	58 78       	cp.w	r8,7
80010fb6:	e0 89 00 04 	brgt	80010fbe <_vfprintf_r+0x1c5e>
80010fba:	2f 84       	sub	r4,-8
80010fbc:	c0 b8       	rjmp	80010fd2 <_vfprintf_r+0x1c72>
80010fbe:	fa ca f9 78 	sub	r10,sp,-1672
80010fc2:	02 9b       	mov	r11,r1
80010fc4:	0a 9c       	mov	r12,r5
80010fc6:	fe b0 f1 bf 	rcall	8000f344 <__sprint_r>
80010fca:	e0 81 01 47 	brne	80011258 <_vfprintf_r+0x1ef8>
80010fce:	fa c4 f9 e0 	sub	r4,sp,-1568
80010fd2:	04 06       	add	r6,r2
80010fd4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80010fd8:	89 06       	st.w	r4[0x0],r6
80010fda:	fa f9 06 90 	ld.w	r9,sp[1680]
80010fde:	40 66       	lddsp	r6,sp[0x18]
80010fe0:	40 6e       	lddsp	lr,sp[0x18]
80010fe2:	10 16       	sub	r6,r8
80010fe4:	f2 08 01 08 	sub	r8,r9,r8
80010fe8:	89 16       	st.w	r4[0x4],r6
80010fea:	1c 08       	add	r8,lr
80010fec:	fb 48 06 90 	st.w	sp[1680],r8
80010ff0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80010ff4:	2f f8       	sub	r8,-1
80010ff6:	fb 48 06 8c 	st.w	sp[1676],r8
80010ffa:	cb 78       	rjmp	80011168 <_vfprintf_r+0x1e08>
80010ffc:	40 6c       	lddsp	r12,sp[0x18]
80010ffe:	58 1c       	cp.w	r12,1
80011000:	e0 89 00 06 	brgt	8001100c <_vfprintf_r+0x1cac>
80011004:	ed b3 00 00 	bld	r3,0x0
80011008:	e0 81 00 85 	brne	80011112 <_vfprintf_r+0x1db2>
8001100c:	fa f8 06 90 	ld.w	r8,sp[1680]
80011010:	2f f8       	sub	r8,-1
80011012:	30 19       	mov	r9,1
80011014:	fb 48 06 90 	st.w	sp[1680],r8
80011018:	89 06       	st.w	r4[0x0],r6
8001101a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001101e:	89 19       	st.w	r4[0x4],r9
80011020:	2f f8       	sub	r8,-1
80011022:	fb 48 06 8c 	st.w	sp[1676],r8
80011026:	58 78       	cp.w	r8,7
80011028:	e0 89 00 04 	brgt	80011030 <_vfprintf_r+0x1cd0>
8001102c:	2f 84       	sub	r4,-8
8001102e:	c0 b8       	rjmp	80011044 <_vfprintf_r+0x1ce4>
80011030:	fa ca f9 78 	sub	r10,sp,-1672
80011034:	02 9b       	mov	r11,r1
80011036:	0a 9c       	mov	r12,r5
80011038:	fe b0 f1 86 	rcall	8000f344 <__sprint_r>
8001103c:	e0 81 01 0e 	brne	80011258 <_vfprintf_r+0x1ef8>
80011040:	fa c4 f9 e0 	sub	r4,sp,-1568
80011044:	fa f8 06 90 	ld.w	r8,sp[1680]
80011048:	2f f8       	sub	r8,-1
8001104a:	40 cb       	lddsp	r11,sp[0x30]
8001104c:	fb 48 06 90 	st.w	sp[1680],r8
80011050:	30 19       	mov	r9,1
80011052:	fa f8 06 8c 	ld.w	r8,sp[1676]
80011056:	89 0b       	st.w	r4[0x0],r11
80011058:	2f f8       	sub	r8,-1
8001105a:	89 19       	st.w	r4[0x4],r9
8001105c:	fb 48 06 8c 	st.w	sp[1676],r8
80011060:	58 78       	cp.w	r8,7
80011062:	e0 89 00 05 	brgt	8001106c <_vfprintf_r+0x1d0c>
80011066:	2f 84       	sub	r4,-8
80011068:	c0 c8       	rjmp	80011080 <_vfprintf_r+0x1d20>
8001106a:	d7 03       	nop
8001106c:	fa ca f9 78 	sub	r10,sp,-1672
80011070:	02 9b       	mov	r11,r1
80011072:	0a 9c       	mov	r12,r5
80011074:	fe b0 f1 68 	rcall	8000f344 <__sprint_r>
80011078:	e0 81 00 f0 	brne	80011258 <_vfprintf_r+0x1ef8>
8001107c:	fa c4 f9 e0 	sub	r4,sp,-1568
80011080:	30 08       	mov	r8,0
80011082:	30 09       	mov	r9,0
80011084:	40 5b       	lddsp	r11,sp[0x14]
80011086:	40 7a       	lddsp	r10,sp[0x1c]
80011088:	e0 a0 11 13 	rcall	800132ae <__avr32_f64_cmp_eq>
8001108c:	40 68       	lddsp	r8,sp[0x18]
8001108e:	20 18       	sub	r8,1
80011090:	58 0c       	cp.w	r12,0
80011092:	c0 d1       	brne	800110ac <_vfprintf_r+0x1d4c>
80011094:	2f f6       	sub	r6,-1
80011096:	89 18       	st.w	r4[0x4],r8
80011098:	89 06       	st.w	r4[0x0],r6
8001109a:	fa f6 06 90 	ld.w	r6,sp[1680]
8001109e:	10 06       	add	r6,r8
800110a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800110a4:	fb 46 06 90 	st.w	sp[1680],r6
800110a8:	2f f8       	sub	r8,-1
800110aa:	c3 18       	rjmp	8001110c <_vfprintf_r+0x1dac>
800110ac:	10 96       	mov	r6,r8
800110ae:	58 08       	cp.w	r8,0
800110b0:	e0 89 00 1c 	brgt	800110e8 <_vfprintf_r+0x1d88>
800110b4:	c4 b8       	rjmp	8001114a <_vfprintf_r+0x1dea>
800110b6:	2f 09       	sub	r9,-16
800110b8:	2f f8       	sub	r8,-1
800110ba:	fb 49 06 90 	st.w	sp[1680],r9
800110be:	89 02       	st.w	r4[0x0],r2
800110c0:	89 10       	st.w	r4[0x4],r0
800110c2:	fb 48 06 8c 	st.w	sp[1676],r8
800110c6:	58 78       	cp.w	r8,7
800110c8:	e0 89 00 04 	brgt	800110d0 <_vfprintf_r+0x1d70>
800110cc:	2f 84       	sub	r4,-8
800110ce:	c0 b8       	rjmp	800110e4 <_vfprintf_r+0x1d84>
800110d0:	fa ca f9 78 	sub	r10,sp,-1672
800110d4:	02 9b       	mov	r11,r1
800110d6:	0a 9c       	mov	r12,r5
800110d8:	fe b0 f1 36 	rcall	8000f344 <__sprint_r>
800110dc:	e0 81 00 be 	brne	80011258 <_vfprintf_r+0x1ef8>
800110e0:	fa c4 f9 e0 	sub	r4,sp,-1568
800110e4:	21 06       	sub	r6,16
800110e6:	c0 48       	rjmp	800110ee <_vfprintf_r+0x1d8e>
800110e8:	fe c2 bd f8 	sub	r2,pc,-16904
800110ec:	31 00       	mov	r0,16
800110ee:	fa f9 06 90 	ld.w	r9,sp[1680]
800110f2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800110f6:	fe ca be 06 	sub	r10,pc,-16890
800110fa:	59 06       	cp.w	r6,16
800110fc:	fe 99 ff dd 	brgt	800110b6 <_vfprintf_r+0x1d56>
80011100:	0c 09       	add	r9,r6
80011102:	89 0a       	st.w	r4[0x0],r10
80011104:	fb 49 06 90 	st.w	sp[1680],r9
80011108:	2f f8       	sub	r8,-1
8001110a:	89 16       	st.w	r4[0x4],r6
8001110c:	fb 48 06 8c 	st.w	sp[1676],r8
80011110:	c0 e8       	rjmp	8001112c <_vfprintf_r+0x1dcc>
80011112:	fa f8 06 90 	ld.w	r8,sp[1680]
80011116:	2f f8       	sub	r8,-1
80011118:	30 19       	mov	r9,1
8001111a:	fb 48 06 90 	st.w	sp[1680],r8
8001111e:	89 06       	st.w	r4[0x0],r6
80011120:	fa f8 06 8c 	ld.w	r8,sp[1676]
80011124:	89 19       	st.w	r4[0x4],r9
80011126:	2f f8       	sub	r8,-1
80011128:	fb 48 06 8c 	st.w	sp[1676],r8
8001112c:	58 78       	cp.w	r8,7
8001112e:	e0 89 00 04 	brgt	80011136 <_vfprintf_r+0x1dd6>
80011132:	2f 84       	sub	r4,-8
80011134:	c0 b8       	rjmp	8001114a <_vfprintf_r+0x1dea>
80011136:	fa ca f9 78 	sub	r10,sp,-1672
8001113a:	02 9b       	mov	r11,r1
8001113c:	0a 9c       	mov	r12,r5
8001113e:	fe b0 f1 03 	rcall	8000f344 <__sprint_r>
80011142:	e0 81 00 8b 	brne	80011258 <_vfprintf_r+0x1ef8>
80011146:	fa c4 f9 e0 	sub	r4,sp,-1568
8001114a:	40 ea       	lddsp	r10,sp[0x38]
8001114c:	fa f8 06 90 	ld.w	r8,sp[1680]
80011150:	14 08       	add	r8,r10
80011152:	fa c9 f9 64 	sub	r9,sp,-1692
80011156:	fb 48 06 90 	st.w	sp[1680],r8
8001115a:	89 1a       	st.w	r4[0x4],r10
8001115c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80011160:	89 09       	st.w	r4[0x0],r9
80011162:	2f f8       	sub	r8,-1
80011164:	fb 48 06 8c 	st.w	sp[1676],r8
80011168:	58 78       	cp.w	r8,7
8001116a:	e0 89 00 04 	brgt	80011172 <_vfprintf_r+0x1e12>
8001116e:	2f 84       	sub	r4,-8
80011170:	c0 a8       	rjmp	80011184 <_vfprintf_r+0x1e24>
80011172:	fa ca f9 78 	sub	r10,sp,-1672
80011176:	02 9b       	mov	r11,r1
80011178:	0a 9c       	mov	r12,r5
8001117a:	fe b0 f0 e5 	rcall	8000f344 <__sprint_r>
8001117e:	c6 d1       	brne	80011258 <_vfprintf_r+0x1ef8>
80011180:	fa c4 f9 e0 	sub	r4,sp,-1568
80011184:	e2 13 00 04 	andl	r3,0x4,COH
80011188:	c3 f0       	breq	80011206 <_vfprintf_r+0x1ea6>
8001118a:	40 86       	lddsp	r6,sp[0x20]
8001118c:	40 39       	lddsp	r9,sp[0xc]
8001118e:	12 16       	sub	r6,r9
80011190:	58 06       	cp.w	r6,0
80011192:	e0 89 00 1a 	brgt	800111c6 <_vfprintf_r+0x1e66>
80011196:	c3 88       	rjmp	80011206 <_vfprintf_r+0x1ea6>
80011198:	2f 09       	sub	r9,-16
8001119a:	2f f8       	sub	r8,-1
8001119c:	fb 49 06 90 	st.w	sp[1680],r9
800111a0:	89 03       	st.w	r4[0x0],r3
800111a2:	89 12       	st.w	r4[0x4],r2
800111a4:	fb 48 06 8c 	st.w	sp[1676],r8
800111a8:	58 78       	cp.w	r8,7
800111aa:	e0 89 00 04 	brgt	800111b2 <_vfprintf_r+0x1e52>
800111ae:	2f 84       	sub	r4,-8
800111b0:	c0 98       	rjmp	800111c2 <_vfprintf_r+0x1e62>
800111b2:	00 9a       	mov	r10,r0
800111b4:	02 9b       	mov	r11,r1
800111b6:	0a 9c       	mov	r12,r5
800111b8:	fe b0 f0 c6 	rcall	8000f344 <__sprint_r>
800111bc:	c4 e1       	brne	80011258 <_vfprintf_r+0x1ef8>
800111be:	fa c4 f9 e0 	sub	r4,sp,-1568
800111c2:	21 06       	sub	r6,16
800111c4:	c0 68       	rjmp	800111d0 <_vfprintf_r+0x1e70>
800111c6:	fe c3 be e6 	sub	r3,pc,-16666
800111ca:	31 02       	mov	r2,16
800111cc:	fa c0 f9 78 	sub	r0,sp,-1672
800111d0:	fa f9 06 90 	ld.w	r9,sp[1680]
800111d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800111d8:	fe ca be f8 	sub	r10,pc,-16648
800111dc:	59 06       	cp.w	r6,16
800111de:	fe 99 ff dd 	brgt	80011198 <_vfprintf_r+0x1e38>
800111e2:	0c 09       	add	r9,r6
800111e4:	2f f8       	sub	r8,-1
800111e6:	89 0a       	st.w	r4[0x0],r10
800111e8:	89 16       	st.w	r4[0x4],r6
800111ea:	fb 49 06 90 	st.w	sp[1680],r9
800111ee:	fb 48 06 8c 	st.w	sp[1676],r8
800111f2:	58 78       	cp.w	r8,7
800111f4:	e0 8a 00 09 	brle	80011206 <_vfprintf_r+0x1ea6>
800111f8:	fa ca f9 78 	sub	r10,sp,-1672
800111fc:	02 9b       	mov	r11,r1
800111fe:	0a 9c       	mov	r12,r5
80011200:	fe b0 f0 a2 	rcall	8000f344 <__sprint_r>
80011204:	c2 a1       	brne	80011258 <_vfprintf_r+0x1ef8>
80011206:	40 bc       	lddsp	r12,sp[0x2c]
80011208:	40 36       	lddsp	r6,sp[0xc]
8001120a:	40 8e       	lddsp	lr,sp[0x20]
8001120c:	ec 0e 0c 48 	max	r8,r6,lr
80011210:	10 0c       	add	r12,r8
80011212:	50 bc       	stdsp	sp[0x2c],r12
80011214:	fa f8 06 90 	ld.w	r8,sp[1680]
80011218:	58 08       	cp.w	r8,0
8001121a:	c0 80       	breq	8001122a <_vfprintf_r+0x1eca>
8001121c:	fa ca f9 78 	sub	r10,sp,-1672
80011220:	02 9b       	mov	r11,r1
80011222:	0a 9c       	mov	r12,r5
80011224:	fe b0 f0 90 	rcall	8000f344 <__sprint_r>
80011228:	c1 81       	brne	80011258 <_vfprintf_r+0x1ef8>
8001122a:	30 0b       	mov	r11,0
8001122c:	fa c4 f9 e0 	sub	r4,sp,-1568
80011230:	fb 4b 06 8c 	st.w	sp[1676],r11
80011234:	fe 9f f1 23 	bral	8000f47a <_vfprintf_r+0x11a>
80011238:	fa f8 06 90 	ld.w	r8,sp[1680]
8001123c:	58 08       	cp.w	r8,0
8001123e:	c0 80       	breq	8001124e <_vfprintf_r+0x1eee>
80011240:	0a 9c       	mov	r12,r5
80011242:	fa ca f9 78 	sub	r10,sp,-1672
80011246:	02 9b       	mov	r11,r1
80011248:	fe b0 f0 7e 	rcall	8000f344 <__sprint_r>
8001124c:	c0 61       	brne	80011258 <_vfprintf_r+0x1ef8>
8001124e:	30 08       	mov	r8,0
80011250:	fb 48 06 8c 	st.w	sp[1676],r8
80011254:	c0 28       	rjmp	80011258 <_vfprintf_r+0x1ef8>
80011256:	40 41       	lddsp	r1,sp[0x10]
80011258:	82 68       	ld.sh	r8,r1[0xc]
8001125a:	ed b8 00 06 	bld	r8,0x6
8001125e:	c0 31       	brne	80011264 <_vfprintf_r+0x1f04>
80011260:	3f fa       	mov	r10,-1
80011262:	50 ba       	stdsp	sp[0x2c],r10
80011264:	40 bc       	lddsp	r12,sp[0x2c]
80011266:	fe 3d f9 44 	sub	sp,-1724
8001126a:	d8 32       	popm	r0-r7,pc

8001126c <_write_r>:
8001126c:	d4 21       	pushm	r4-r7,lr
8001126e:	16 98       	mov	r8,r11
80011270:	18 97       	mov	r7,r12
80011272:	10 9c       	mov	r12,r8
80011274:	30 08       	mov	r8,0
80011276:	14 9b       	mov	r11,r10
80011278:	e0 66 79 98 	mov	r6,31128
8001127c:	12 9a       	mov	r10,r9
8001127e:	8d 08       	st.w	r6[0x0],r8
80011280:	fe b0 ee 78 	rcall	8000ef70 <_write>
80011284:	5b fc       	cp.w	r12,-1
80011286:	c0 51       	brne	80011290 <_write_r+0x24>
80011288:	6c 08       	ld.w	r8,r6[0x0]
8001128a:	58 08       	cp.w	r8,0
8001128c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011290:	d8 22       	popm	r4-r7,pc
80011292:	d7 03       	nop

80011294 <__swsetup_r>:
80011294:	d4 21       	pushm	r4-r7,lr
80011296:	e0 68 01 60 	mov	r8,352
8001129a:	18 96       	mov	r6,r12
8001129c:	16 97       	mov	r7,r11
8001129e:	70 0c       	ld.w	r12,r8[0x0]
800112a0:	58 0c       	cp.w	r12,0
800112a2:	c0 60       	breq	800112ae <__swsetup_r+0x1a>
800112a4:	78 68       	ld.w	r8,r12[0x18]
800112a6:	58 08       	cp.w	r8,0
800112a8:	c0 31       	brne	800112ae <__swsetup_r+0x1a>
800112aa:	fe b0 e8 6d 	rcall	8000e384 <__sinit>
800112ae:	fe c8 c2 d6 	sub	r8,pc,-15658
800112b2:	10 37       	cp.w	r7,r8
800112b4:	c0 61       	brne	800112c0 <__swsetup_r+0x2c>
800112b6:	e0 68 01 60 	mov	r8,352
800112ba:	70 08       	ld.w	r8,r8[0x0]
800112bc:	70 07       	ld.w	r7,r8[0x0]
800112be:	c1 28       	rjmp	800112e2 <__swsetup_r+0x4e>
800112c0:	fe c8 c2 c8 	sub	r8,pc,-15672
800112c4:	10 37       	cp.w	r7,r8
800112c6:	c0 61       	brne	800112d2 <__swsetup_r+0x3e>
800112c8:	e0 68 01 60 	mov	r8,352
800112cc:	70 08       	ld.w	r8,r8[0x0]
800112ce:	70 17       	ld.w	r7,r8[0x4]
800112d0:	c0 98       	rjmp	800112e2 <__swsetup_r+0x4e>
800112d2:	fe c8 c2 ba 	sub	r8,pc,-15686
800112d6:	10 37       	cp.w	r7,r8
800112d8:	c0 51       	brne	800112e2 <__swsetup_r+0x4e>
800112da:	e0 68 01 60 	mov	r8,352
800112de:	70 08       	ld.w	r8,r8[0x0]
800112e0:	70 27       	ld.w	r7,r8[0x8]
800112e2:	8e 68       	ld.sh	r8,r7[0xc]
800112e4:	ed b8 00 03 	bld	r8,0x3
800112e8:	c1 e0       	breq	80011324 <__swsetup_r+0x90>
800112ea:	ed b8 00 04 	bld	r8,0x4
800112ee:	c3 e1       	brne	8001136a <__swsetup_r+0xd6>
800112f0:	ed b8 00 02 	bld	r8,0x2
800112f4:	c1 51       	brne	8001131e <__swsetup_r+0x8a>
800112f6:	6e db       	ld.w	r11,r7[0x34]
800112f8:	58 0b       	cp.w	r11,0
800112fa:	c0 a0       	breq	8001130e <__swsetup_r+0x7a>
800112fc:	ee c8 ff bc 	sub	r8,r7,-68
80011300:	10 3b       	cp.w	r11,r8
80011302:	c0 40       	breq	8001130a <__swsetup_r+0x76>
80011304:	0c 9c       	mov	r12,r6
80011306:	fe b0 e8 d9 	rcall	8000e4b8 <_free_r>
8001130a:	30 08       	mov	r8,0
8001130c:	8f d8       	st.w	r7[0x34],r8
8001130e:	8e 68       	ld.sh	r8,r7[0xc]
80011310:	e0 18 ff db 	andl	r8,0xffdb
80011314:	ae 68       	st.h	r7[0xc],r8
80011316:	30 08       	mov	r8,0
80011318:	8f 18       	st.w	r7[0x4],r8
8001131a:	6e 48       	ld.w	r8,r7[0x10]
8001131c:	8f 08       	st.w	r7[0x0],r8
8001131e:	8e 68       	ld.sh	r8,r7[0xc]
80011320:	a3 b8       	sbr	r8,0x3
80011322:	ae 68       	st.h	r7[0xc],r8
80011324:	6e 48       	ld.w	r8,r7[0x10]
80011326:	58 08       	cp.w	r8,0
80011328:	c0 b1       	brne	8001133e <__swsetup_r+0xaa>
8001132a:	8e 68       	ld.sh	r8,r7[0xc]
8001132c:	e2 18 02 80 	andl	r8,0x280,COH
80011330:	e0 48 02 00 	cp.w	r8,512
80011334:	c0 50       	breq	8001133e <__swsetup_r+0xaa>
80011336:	0c 9c       	mov	r12,r6
80011338:	0e 9b       	mov	r11,r7
8001133a:	fe b0 e9 bb 	rcall	8000e6b0 <__smakebuf_r>
8001133e:	8e 69       	ld.sh	r9,r7[0xc]
80011340:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80011344:	c0 70       	breq	80011352 <__swsetup_r+0xbe>
80011346:	30 08       	mov	r8,0
80011348:	8f 28       	st.w	r7[0x8],r8
8001134a:	6e 58       	ld.w	r8,r7[0x14]
8001134c:	5c 38       	neg	r8
8001134e:	8f 68       	st.w	r7[0x18],r8
80011350:	c0 68       	rjmp	8001135c <__swsetup_r+0xc8>
80011352:	ed b9 00 01 	bld	r9,0x1
80011356:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8001135a:	8f 28       	st.w	r7[0x8],r8
8001135c:	6e 48       	ld.w	r8,r7[0x10]
8001135e:	58 08       	cp.w	r8,0
80011360:	c0 61       	brne	8001136c <__swsetup_r+0xd8>
80011362:	8e 68       	ld.sh	r8,r7[0xc]
80011364:	ed b8 00 07 	bld	r8,0x7
80011368:	c0 21       	brne	8001136c <__swsetup_r+0xd8>
8001136a:	dc 2a       	popm	r4-r7,pc,r12=-1
8001136c:	d8 2a       	popm	r4-r7,pc,r12=0
8001136e:	d7 03       	nop

80011370 <_close_r>:
80011370:	d4 21       	pushm	r4-r7,lr
80011372:	30 08       	mov	r8,0
80011374:	18 97       	mov	r7,r12
80011376:	e0 66 79 98 	mov	r6,31128
8001137a:	16 9c       	mov	r12,r11
8001137c:	8d 08       	st.w	r6[0x0],r8
8001137e:	fe b0 ed db 	rcall	8000ef34 <_close>
80011382:	5b fc       	cp.w	r12,-1
80011384:	c0 51       	brne	8001138e <_close_r+0x1e>
80011386:	6c 08       	ld.w	r8,r6[0x0]
80011388:	58 08       	cp.w	r8,0
8001138a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001138e:	d8 22       	popm	r4-r7,pc

80011390 <quorem>:
80011390:	d4 31       	pushm	r0-r7,lr
80011392:	20 2d       	sub	sp,8
80011394:	18 97       	mov	r7,r12
80011396:	78 48       	ld.w	r8,r12[0x10]
80011398:	76 46       	ld.w	r6,r11[0x10]
8001139a:	0c 38       	cp.w	r8,r6
8001139c:	c0 34       	brge	800113a2 <quorem+0x12>
8001139e:	30 0c       	mov	r12,0
800113a0:	c8 58       	rjmp	800114aa <quorem+0x11a>
800113a2:	ec c2 ff fc 	sub	r2,r6,-4
800113a6:	f6 c3 ff ec 	sub	r3,r11,-20
800113aa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800113ae:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800113b2:	2f f9       	sub	r9,-1
800113b4:	20 16       	sub	r6,1
800113b6:	f8 09 0d 08 	divu	r8,r12,r9
800113ba:	f6 02 00 22 	add	r2,r11,r2<<0x2
800113be:	ee c4 ff ec 	sub	r4,r7,-20
800113c2:	10 95       	mov	r5,r8
800113c4:	58 08       	cp.w	r8,0
800113c6:	c4 10       	breq	80011448 <quorem+0xb8>
800113c8:	30 09       	mov	r9,0
800113ca:	06 9a       	mov	r10,r3
800113cc:	08 98       	mov	r8,r4
800113ce:	12 91       	mov	r1,r9
800113d0:	50 0b       	stdsp	sp[0x0],r11
800113d2:	70 0e       	ld.w	lr,r8[0x0]
800113d4:	b1 8e       	lsr	lr,0x10
800113d6:	50 1e       	stdsp	sp[0x4],lr
800113d8:	15 0e       	ld.w	lr,r10++
800113da:	fc 00 16 10 	lsr	r0,lr,0x10
800113de:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800113e2:	ea 0e 03 41 	mac	r1,r5,lr
800113e6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800113ea:	b1 81       	lsr	r1,0x10
800113ec:	40 1b       	lddsp	r11,sp[0x4]
800113ee:	ea 00 02 40 	mul	r0,r5,r0
800113f2:	e2 00 00 00 	add	r0,r1,r0
800113f6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800113fa:	02 1b       	sub	r11,r1
800113fc:	50 1b       	stdsp	sp[0x4],r11
800113fe:	70 0b       	ld.w	r11,r8[0x0]
80011400:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80011404:	02 09       	add	r9,r1
80011406:	f2 0e 01 0e 	sub	lr,r9,lr
8001140a:	b0 1e       	st.h	r8[0x2],lr
8001140c:	fc 09 14 10 	asr	r9,lr,0x10
80011410:	40 1e       	lddsp	lr,sp[0x4]
80011412:	fc 09 00 09 	add	r9,lr,r9
80011416:	b0 09       	st.h	r8[0x0],r9
80011418:	e0 01 16 10 	lsr	r1,r0,0x10
8001141c:	2f c8       	sub	r8,-4
8001141e:	b1 49       	asr	r9,0x10
80011420:	04 3a       	cp.w	r10,r2
80011422:	fe 98 ff d8 	brls	800113d2 <quorem+0x42>
80011426:	40 0b       	lddsp	r11,sp[0x0]
80011428:	58 0c       	cp.w	r12,0
8001142a:	c0 f1       	brne	80011448 <quorem+0xb8>
8001142c:	ec c8 ff fb 	sub	r8,r6,-5
80011430:	ee 08 00 28 	add	r8,r7,r8<<0x2
80011434:	c0 28       	rjmp	80011438 <quorem+0xa8>
80011436:	20 16       	sub	r6,1
80011438:	20 48       	sub	r8,4
8001143a:	08 38       	cp.w	r8,r4
8001143c:	e0 88 00 05 	brls	80011446 <quorem+0xb6>
80011440:	70 09       	ld.w	r9,r8[0x0]
80011442:	58 09       	cp.w	r9,0
80011444:	cf 90       	breq	80011436 <quorem+0xa6>
80011446:	8f 46       	st.w	r7[0x10],r6
80011448:	0e 9c       	mov	r12,r7
8001144a:	e0 a0 08 2e 	rcall	800124a6 <__mcmp>
8001144e:	c2 d5       	brlt	800114a8 <quorem+0x118>
80011450:	2f f5       	sub	r5,-1
80011452:	08 98       	mov	r8,r4
80011454:	30 09       	mov	r9,0
80011456:	07 0b       	ld.w	r11,r3++
80011458:	f6 0a 16 10 	lsr	r10,r11,0x10
8001145c:	70 0c       	ld.w	r12,r8[0x0]
8001145e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80011462:	f8 0e 16 10 	lsr	lr,r12,0x10
80011466:	14 1e       	sub	lr,r10
80011468:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8001146c:	16 1a       	sub	r10,r11
8001146e:	12 0a       	add	r10,r9
80011470:	b0 1a       	st.h	r8[0x2],r10
80011472:	b1 4a       	asr	r10,0x10
80011474:	fc 0a 00 09 	add	r9,lr,r10
80011478:	b0 09       	st.h	r8[0x0],r9
8001147a:	2f c8       	sub	r8,-4
8001147c:	b1 49       	asr	r9,0x10
8001147e:	04 33       	cp.w	r3,r2
80011480:	fe 98 ff eb 	brls	80011456 <quorem+0xc6>
80011484:	ec c8 ff fb 	sub	r8,r6,-5
80011488:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8001148c:	58 09       	cp.w	r9,0
8001148e:	c0 d1       	brne	800114a8 <quorem+0x118>
80011490:	ee 08 00 28 	add	r8,r7,r8<<0x2
80011494:	c0 28       	rjmp	80011498 <quorem+0x108>
80011496:	20 16       	sub	r6,1
80011498:	20 48       	sub	r8,4
8001149a:	08 38       	cp.w	r8,r4
8001149c:	e0 88 00 05 	brls	800114a6 <quorem+0x116>
800114a0:	70 09       	ld.w	r9,r8[0x0]
800114a2:	58 09       	cp.w	r9,0
800114a4:	cf 90       	breq	80011496 <quorem+0x106>
800114a6:	8f 46       	st.w	r7[0x10],r6
800114a8:	0a 9c       	mov	r12,r5
800114aa:	2f ed       	sub	sp,-8
800114ac:	d8 32       	popm	r0-r7,pc
800114ae:	d7 03       	nop

800114b0 <_dtoa_r>:
800114b0:	d4 31       	pushm	r0-r7,lr
800114b2:	21 ad       	sub	sp,104
800114b4:	fa c4 ff 74 	sub	r4,sp,-140
800114b8:	18 97       	mov	r7,r12
800114ba:	16 95       	mov	r5,r11
800114bc:	68 2c       	ld.w	r12,r4[0x8]
800114be:	50 c9       	stdsp	sp[0x30],r9
800114c0:	68 16       	ld.w	r6,r4[0x4]
800114c2:	68 09       	ld.w	r9,r4[0x0]
800114c4:	50 e8       	stdsp	sp[0x38],r8
800114c6:	14 94       	mov	r4,r10
800114c8:	51 2c       	stdsp	sp[0x48],r12
800114ca:	fa e5 00 08 	st.d	sp[8],r4
800114ce:	51 59       	stdsp	sp[0x54],r9
800114d0:	6e 95       	ld.w	r5,r7[0x24]
800114d2:	58 05       	cp.w	r5,0
800114d4:	c0 91       	brne	800114e6 <_dtoa_r+0x36>
800114d6:	31 0c       	mov	r12,16
800114d8:	fe b0 e9 54 	rcall	8000e780 <malloc>
800114dc:	99 35       	st.w	r12[0xc],r5
800114de:	8f 9c       	st.w	r7[0x24],r12
800114e0:	99 15       	st.w	r12[0x4],r5
800114e2:	99 25       	st.w	r12[0x8],r5
800114e4:	99 05       	st.w	r12[0x0],r5
800114e6:	6e 99       	ld.w	r9,r7[0x24]
800114e8:	72 08       	ld.w	r8,r9[0x0]
800114ea:	58 08       	cp.w	r8,0
800114ec:	c0 f0       	breq	8001150a <_dtoa_r+0x5a>
800114ee:	72 1a       	ld.w	r10,r9[0x4]
800114f0:	91 1a       	st.w	r8[0x4],r10
800114f2:	30 1a       	mov	r10,1
800114f4:	72 19       	ld.w	r9,r9[0x4]
800114f6:	f4 09 09 49 	lsl	r9,r10,r9
800114fa:	10 9b       	mov	r11,r8
800114fc:	91 29       	st.w	r8[0x8],r9
800114fe:	0e 9c       	mov	r12,r7
80011500:	e0 a0 07 ec 	rcall	800124d8 <_Bfree>
80011504:	6e 98       	ld.w	r8,r7[0x24]
80011506:	30 09       	mov	r9,0
80011508:	91 09       	st.w	r8[0x0],r9
8001150a:	40 28       	lddsp	r8,sp[0x8]
8001150c:	10 94       	mov	r4,r8
8001150e:	58 08       	cp.w	r8,0
80011510:	c0 64       	brge	8001151c <_dtoa_r+0x6c>
80011512:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80011516:	50 28       	stdsp	sp[0x8],r8
80011518:	30 18       	mov	r8,1
8001151a:	c0 28       	rjmp	8001151e <_dtoa_r+0x6e>
8001151c:	30 08       	mov	r8,0
8001151e:	8d 08       	st.w	r6[0x0],r8
80011520:	fc 1c 7f f0 	movh	r12,0x7ff0
80011524:	40 26       	lddsp	r6,sp[0x8]
80011526:	0c 98       	mov	r8,r6
80011528:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001152c:	18 38       	cp.w	r8,r12
8001152e:	c1 e1       	brne	8001156a <_dtoa_r+0xba>
80011530:	e0 68 27 0f 	mov	r8,9999
80011534:	41 5b       	lddsp	r11,sp[0x54]
80011536:	97 08       	st.w	r11[0x0],r8
80011538:	40 3a       	lddsp	r10,sp[0xc]
8001153a:	58 0a       	cp.w	r10,0
8001153c:	c0 71       	brne	8001154a <_dtoa_r+0x9a>
8001153e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80011542:	c0 41       	brne	8001154a <_dtoa_r+0x9a>
80011544:	fe cc c1 44 	sub	r12,pc,-16060
80011548:	c0 38       	rjmp	8001154e <_dtoa_r+0x9e>
8001154a:	fe cc c1 3e 	sub	r12,pc,-16066
8001154e:	41 29       	lddsp	r9,sp[0x48]
80011550:	58 09       	cp.w	r9,0
80011552:	e0 80 05 9a 	breq	80012086 <_dtoa_r+0xbd6>
80011556:	f8 c8 ff fd 	sub	r8,r12,-3
8001155a:	30 09       	mov	r9,0
8001155c:	11 8a       	ld.ub	r10,r8[0x0]
8001155e:	f2 0a 18 00 	cp.b	r10,r9
80011562:	c1 a0       	breq	80011596 <_dtoa_r+0xe6>
80011564:	f8 c8 ff f8 	sub	r8,r12,-8
80011568:	c1 78       	rjmp	80011596 <_dtoa_r+0xe6>
8001156a:	fa ea 00 08 	ld.d	r10,sp[8]
8001156e:	30 08       	mov	r8,0
80011570:	fa eb 00 3c 	st.d	sp[60],r10
80011574:	30 09       	mov	r9,0
80011576:	e0 a0 0e 9c 	rcall	800132ae <__avr32_f64_cmp_eq>
8001157a:	c1 20       	breq	8001159e <_dtoa_r+0xee>
8001157c:	30 18       	mov	r8,1
8001157e:	41 5a       	lddsp	r10,sp[0x54]
80011580:	95 08       	st.w	r10[0x0],r8
80011582:	41 29       	lddsp	r9,sp[0x48]
80011584:	fe c8 c2 a8 	sub	r8,pc,-15704
80011588:	58 09       	cp.w	r9,0
8001158a:	c0 41       	brne	80011592 <_dtoa_r+0xe2>
8001158c:	10 9c       	mov	r12,r8
8001158e:	e0 8f 05 7c 	bral	80012086 <_dtoa_r+0xbd6>
80011592:	10 9c       	mov	r12,r8
80011594:	2f f8       	sub	r8,-1
80011596:	41 25       	lddsp	r5,sp[0x48]
80011598:	8b 08       	st.w	r5[0x0],r8
8001159a:	e0 8f 05 76 	bral	80012086 <_dtoa_r+0xbd6>
8001159e:	fa c8 ff 9c 	sub	r8,sp,-100
800115a2:	fa c9 ff a0 	sub	r9,sp,-96
800115a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800115aa:	0e 9c       	mov	r12,r7
800115ac:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800115b0:	e0 a0 07 e6 	rcall	8001257c <__d2b>
800115b4:	18 93       	mov	r3,r12
800115b6:	58 05       	cp.w	r5,0
800115b8:	c0 d0       	breq	800115d2 <_dtoa_r+0x122>
800115ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800115be:	30 04       	mov	r4,0
800115c0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800115c4:	ea c5 03 ff 	sub	r5,r5,1023
800115c8:	10 9b       	mov	r11,r8
800115ca:	51 74       	stdsp	sp[0x5c],r4
800115cc:	ea 1b 3f f0 	orh	r11,0x3ff0
800115d0:	c2 58       	rjmp	8001161a <_dtoa_r+0x16a>
800115d2:	41 88       	lddsp	r8,sp[0x60]
800115d4:	41 9c       	lddsp	r12,sp[0x64]
800115d6:	10 0c       	add	r12,r8
800115d8:	f8 c5 fb ce 	sub	r5,r12,-1074
800115dc:	e0 45 00 20 	cp.w	r5,32
800115e0:	e0 8a 00 0e 	brle	800115fc <_dtoa_r+0x14c>
800115e4:	f8 cc fb ee 	sub	r12,r12,-1042
800115e8:	40 3b       	lddsp	r11,sp[0xc]
800115ea:	ea 08 11 40 	rsub	r8,r5,64
800115ee:	f6 0c 0a 4c 	lsr	r12,r11,r12
800115f2:	ec 08 09 46 	lsl	r6,r6,r8
800115f6:	0c 4c       	or	r12,r6
800115f8:	c0 78       	rjmp	80011606 <_dtoa_r+0x156>
800115fa:	d7 03       	nop
800115fc:	ea 0c 11 20 	rsub	r12,r5,32
80011600:	40 3a       	lddsp	r10,sp[0xc]
80011602:	f4 0c 09 4c 	lsl	r12,r10,r12
80011606:	e0 a0 0d e0 	rcall	800131c6 <__avr32_u32_to_f64>
8001160a:	fc 18 fe 10 	movh	r8,0xfe10
8001160e:	30 19       	mov	r9,1
80011610:	ea c5 04 33 	sub	r5,r5,1075
80011614:	f0 0b 00 0b 	add	r11,r8,r11
80011618:	51 79       	stdsp	sp[0x5c],r9
8001161a:	30 08       	mov	r8,0
8001161c:	fc 19 3f f8 	movh	r9,0x3ff8
80011620:	e0 a0 0c 6c 	rcall	80012ef8 <__avr32_f64_sub>
80011624:	e0 68 43 61 	mov	r8,17249
80011628:	ea 18 63 6f 	orh	r8,0x636f
8001162c:	e0 69 87 a7 	mov	r9,34727
80011630:	ea 19 3f d2 	orh	r9,0x3fd2
80011634:	e0 a0 0b 76 	rcall	80012d20 <__avr32_f64_mul>
80011638:	e0 68 c8 b3 	mov	r8,51379
8001163c:	ea 18 8b 60 	orh	r8,0x8b60
80011640:	e0 69 8a 28 	mov	r9,35368
80011644:	ea 19 3f c6 	orh	r9,0x3fc6
80011648:	e0 a0 0d 26 	rcall	80013094 <__avr32_f64_add>
8001164c:	0a 9c       	mov	r12,r5
8001164e:	14 90       	mov	r0,r10
80011650:	16 91       	mov	r1,r11
80011652:	e0 a0 0d be 	rcall	800131ce <__avr32_s32_to_f64>
80011656:	e0 68 79 fb 	mov	r8,31227
8001165a:	ea 18 50 9f 	orh	r8,0x509f
8001165e:	e0 69 44 13 	mov	r9,17427
80011662:	ea 19 3f d3 	orh	r9,0x3fd3
80011666:	e0 a0 0b 5d 	rcall	80012d20 <__avr32_f64_mul>
8001166a:	14 98       	mov	r8,r10
8001166c:	16 99       	mov	r9,r11
8001166e:	00 9a       	mov	r10,r0
80011670:	02 9b       	mov	r11,r1
80011672:	e0 a0 0d 11 	rcall	80013094 <__avr32_f64_add>
80011676:	14 90       	mov	r0,r10
80011678:	16 91       	mov	r1,r11
8001167a:	e0 a0 0d 93 	rcall	800131a0 <__avr32_f64_to_s32>
8001167e:	30 08       	mov	r8,0
80011680:	18 96       	mov	r6,r12
80011682:	30 09       	mov	r9,0
80011684:	00 9a       	mov	r10,r0
80011686:	02 9b       	mov	r11,r1
80011688:	e0 a0 0e 5a 	rcall	8001333c <__avr32_f64_cmp_lt>
8001168c:	c0 c0       	breq	800116a4 <_dtoa_r+0x1f4>
8001168e:	0c 9c       	mov	r12,r6
80011690:	e0 a0 0d 9f 	rcall	800131ce <__avr32_s32_to_f64>
80011694:	14 98       	mov	r8,r10
80011696:	16 99       	mov	r9,r11
80011698:	00 9a       	mov	r10,r0
8001169a:	02 9b       	mov	r11,r1
8001169c:	e0 a0 0e 09 	rcall	800132ae <__avr32_f64_cmp_eq>
800116a0:	f7 b6 00 01 	subeq	r6,1
800116a4:	59 66       	cp.w	r6,22
800116a6:	e0 88 00 05 	brls	800116b0 <_dtoa_r+0x200>
800116aa:	30 18       	mov	r8,1
800116ac:	51 48       	stdsp	sp[0x50],r8
800116ae:	c1 38       	rjmp	800116d4 <_dtoa_r+0x224>
800116b0:	fe c8 c2 58 	sub	r8,pc,-15784
800116b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800116b8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800116bc:	e0 a0 0e 40 	rcall	8001333c <__avr32_f64_cmp_lt>
800116c0:	f9 b4 00 00 	moveq	r4,0
800116c4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800116c8:	f7 b6 01 01 	subne	r6,1
800116cc:	f9 bc 01 00 	movne	r12,0
800116d0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800116d4:	41 90       	lddsp	r0,sp[0x64]
800116d6:	20 10       	sub	r0,1
800116d8:	0a 10       	sub	r0,r5
800116da:	c0 46       	brmi	800116e2 <_dtoa_r+0x232>
800116dc:	50 40       	stdsp	sp[0x10],r0
800116de:	30 00       	mov	r0,0
800116e0:	c0 48       	rjmp	800116e8 <_dtoa_r+0x238>
800116e2:	30 0b       	mov	r11,0
800116e4:	5c 30       	neg	r0
800116e6:	50 4b       	stdsp	sp[0x10],r11
800116e8:	ec 02 11 00 	rsub	r2,r6,0
800116ec:	58 06       	cp.w	r6,0
800116ee:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800116f2:	f5 d6 e4 0a 	addge	r10,r10,r6
800116f6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800116fa:	fb f6 4a 11 	st.wge	sp[0x44],r6
800116fe:	f9 b2 04 00 	movge	r2,0
80011702:	e1 d6 e5 10 	sublt	r0,r0,r6
80011706:	f9 b9 05 00 	movlt	r9,0
8001170a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8001170e:	40 c8       	lddsp	r8,sp[0x30]
80011710:	58 98       	cp.w	r8,9
80011712:	e0 8b 00 20 	brhi	80011752 <_dtoa_r+0x2a2>
80011716:	58 58       	cp.w	r8,5
80011718:	f9 b4 0a 01 	movle	r4,1
8001171c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80011720:	f7 b5 09 04 	subgt	r5,4
80011724:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80011728:	f9 b4 09 00 	movgt	r4,0
8001172c:	40 cc       	lddsp	r12,sp[0x30]
8001172e:	58 3c       	cp.w	r12,3
80011730:	c2 d0       	breq	8001178a <_dtoa_r+0x2da>
80011732:	e0 89 00 05 	brgt	8001173c <_dtoa_r+0x28c>
80011736:	58 2c       	cp.w	r12,2
80011738:	c1 01       	brne	80011758 <_dtoa_r+0x2a8>
8001173a:	c1 88       	rjmp	8001176a <_dtoa_r+0x2ba>
8001173c:	40 cb       	lddsp	r11,sp[0x30]
8001173e:	58 4b       	cp.w	r11,4
80011740:	c0 60       	breq	8001174c <_dtoa_r+0x29c>
80011742:	58 5b       	cp.w	r11,5
80011744:	c0 a1       	brne	80011758 <_dtoa_r+0x2a8>
80011746:	30 1a       	mov	r10,1
80011748:	50 da       	stdsp	sp[0x34],r10
8001174a:	c2 28       	rjmp	8001178e <_dtoa_r+0x2de>
8001174c:	30 19       	mov	r9,1
8001174e:	50 d9       	stdsp	sp[0x34],r9
80011750:	c0 f8       	rjmp	8001176e <_dtoa_r+0x2be>
80011752:	30 08       	mov	r8,0
80011754:	30 14       	mov	r4,1
80011756:	50 c8       	stdsp	sp[0x30],r8
80011758:	3f f5       	mov	r5,-1
8001175a:	30 1c       	mov	r12,1
8001175c:	30 0b       	mov	r11,0
8001175e:	50 95       	stdsp	sp[0x24],r5
80011760:	50 dc       	stdsp	sp[0x34],r12
80011762:	0a 91       	mov	r1,r5
80011764:	31 28       	mov	r8,18
80011766:	50 eb       	stdsp	sp[0x38],r11
80011768:	c2 08       	rjmp	800117a8 <_dtoa_r+0x2f8>
8001176a:	30 0a       	mov	r10,0
8001176c:	50 da       	stdsp	sp[0x34],r10
8001176e:	40 e9       	lddsp	r9,sp[0x38]
80011770:	58 09       	cp.w	r9,0
80011772:	e0 89 00 07 	brgt	80011780 <_dtoa_r+0x2d0>
80011776:	30 18       	mov	r8,1
80011778:	50 98       	stdsp	sp[0x24],r8
8001177a:	10 91       	mov	r1,r8
8001177c:	50 e8       	stdsp	sp[0x38],r8
8001177e:	c1 58       	rjmp	800117a8 <_dtoa_r+0x2f8>
80011780:	40 e5       	lddsp	r5,sp[0x38]
80011782:	50 95       	stdsp	sp[0x24],r5
80011784:	0a 91       	mov	r1,r5
80011786:	0a 98       	mov	r8,r5
80011788:	c1 08       	rjmp	800117a8 <_dtoa_r+0x2f8>
8001178a:	30 0c       	mov	r12,0
8001178c:	50 dc       	stdsp	sp[0x34],r12
8001178e:	40 eb       	lddsp	r11,sp[0x38]
80011790:	ec 0b 00 0b 	add	r11,r6,r11
80011794:	50 9b       	stdsp	sp[0x24],r11
80011796:	16 98       	mov	r8,r11
80011798:	2f f8       	sub	r8,-1
8001179a:	58 08       	cp.w	r8,0
8001179c:	e0 89 00 05 	brgt	800117a6 <_dtoa_r+0x2f6>
800117a0:	10 91       	mov	r1,r8
800117a2:	30 18       	mov	r8,1
800117a4:	c0 28       	rjmp	800117a8 <_dtoa_r+0x2f8>
800117a6:	10 91       	mov	r1,r8
800117a8:	30 09       	mov	r9,0
800117aa:	6e 9a       	ld.w	r10,r7[0x24]
800117ac:	95 19       	st.w	r10[0x4],r9
800117ae:	30 49       	mov	r9,4
800117b0:	c0 68       	rjmp	800117bc <_dtoa_r+0x30c>
800117b2:	d7 03       	nop
800117b4:	6a 1a       	ld.w	r10,r5[0x4]
800117b6:	a1 79       	lsl	r9,0x1
800117b8:	2f fa       	sub	r10,-1
800117ba:	8b 1a       	st.w	r5[0x4],r10
800117bc:	6e 95       	ld.w	r5,r7[0x24]
800117be:	f2 ca ff ec 	sub	r10,r9,-20
800117c2:	10 3a       	cp.w	r10,r8
800117c4:	fe 98 ff f8 	brls	800117b4 <_dtoa_r+0x304>
800117c8:	6a 1b       	ld.w	r11,r5[0x4]
800117ca:	0e 9c       	mov	r12,r7
800117cc:	e0 a0 06 a0 	rcall	8001250c <_Balloc>
800117d0:	58 e1       	cp.w	r1,14
800117d2:	5f 88       	srls	r8
800117d4:	8b 0c       	st.w	r5[0x0],r12
800117d6:	f1 e4 00 04 	and	r4,r8,r4
800117da:	6e 98       	ld.w	r8,r7[0x24]
800117dc:	70 08       	ld.w	r8,r8[0x0]
800117de:	50 88       	stdsp	sp[0x20],r8
800117e0:	e0 80 01 82 	breq	80011ae4 <_dtoa_r+0x634>
800117e4:	58 06       	cp.w	r6,0
800117e6:	e0 8a 00 43 	brle	8001186c <_dtoa_r+0x3bc>
800117ea:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800117ee:	fe c8 c3 96 	sub	r8,pc,-15466
800117f2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800117f6:	fa e5 00 18 	st.d	sp[24],r4
800117fa:	ec 04 14 04 	asr	r4,r6,0x4
800117fe:	ed b4 00 04 	bld	r4,0x4
80011802:	c0 30       	breq	80011808 <_dtoa_r+0x358>
80011804:	30 25       	mov	r5,2
80011806:	c1 08       	rjmp	80011826 <_dtoa_r+0x376>
80011808:	fe c8 c2 e8 	sub	r8,pc,-15640
8001180c:	f0 e8 00 20 	ld.d	r8,r8[32]
80011810:	fa ea 00 3c 	ld.d	r10,sp[60]
80011814:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80011818:	e0 a0 0d c6 	rcall	800133a4 <__avr32_f64_div>
8001181c:	30 35       	mov	r5,3
8001181e:	14 98       	mov	r8,r10
80011820:	16 99       	mov	r9,r11
80011822:	fa e9 00 08 	st.d	sp[8],r8
80011826:	fe cc c3 06 	sub	r12,pc,-15610
8001182a:	50 a3       	stdsp	sp[0x28],r3
8001182c:	0c 93       	mov	r3,r6
8001182e:	18 96       	mov	r6,r12
80011830:	c0 f8       	rjmp	8001184e <_dtoa_r+0x39e>
80011832:	fa ea 00 18 	ld.d	r10,sp[24]
80011836:	ed b4 00 00 	bld	r4,0x0
8001183a:	c0 81       	brne	8001184a <_dtoa_r+0x39a>
8001183c:	ec e8 00 00 	ld.d	r8,r6[0]
80011840:	2f f5       	sub	r5,-1
80011842:	e0 a0 0a 6f 	rcall	80012d20 <__avr32_f64_mul>
80011846:	fa eb 00 18 	st.d	sp[24],r10
8001184a:	a1 54       	asr	r4,0x1
8001184c:	2f 86       	sub	r6,-8
8001184e:	58 04       	cp.w	r4,0
80011850:	cf 11       	brne	80011832 <_dtoa_r+0x382>
80011852:	fa e8 00 18 	ld.d	r8,sp[24]
80011856:	fa ea 00 08 	ld.d	r10,sp[8]
8001185a:	06 96       	mov	r6,r3
8001185c:	e0 a0 0d a4 	rcall	800133a4 <__avr32_f64_div>
80011860:	40 a3       	lddsp	r3,sp[0x28]
80011862:	14 98       	mov	r8,r10
80011864:	16 99       	mov	r9,r11
80011866:	fa e9 00 08 	st.d	sp[8],r8
8001186a:	c2 f8       	rjmp	800118c8 <_dtoa_r+0x418>
8001186c:	ec 08 11 00 	rsub	r8,r6,0
80011870:	c0 31       	brne	80011876 <_dtoa_r+0x3c6>
80011872:	30 25       	mov	r5,2
80011874:	c2 a8       	rjmp	800118c8 <_dtoa_r+0x418>
80011876:	fe cc c3 56 	sub	r12,pc,-15530
8001187a:	f0 04 14 04 	asr	r4,r8,0x4
8001187e:	50 1c       	stdsp	sp[0x4],r12
80011880:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80011884:	fe c9 c4 2c 	sub	r9,pc,-15316
80011888:	fa ea 00 3c 	ld.d	r10,sp[60]
8001188c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80011890:	e0 a0 0a 48 	rcall	80012d20 <__avr32_f64_mul>
80011894:	40 1c       	lddsp	r12,sp[0x4]
80011896:	50 63       	stdsp	sp[0x18],r3
80011898:	30 25       	mov	r5,2
8001189a:	0c 93       	mov	r3,r6
8001189c:	fa eb 00 08 	st.d	sp[8],r10
800118a0:	18 96       	mov	r6,r12
800118a2:	c0 f8       	rjmp	800118c0 <_dtoa_r+0x410>
800118a4:	fa ea 00 08 	ld.d	r10,sp[8]
800118a8:	ed b4 00 00 	bld	r4,0x0
800118ac:	c0 81       	brne	800118bc <_dtoa_r+0x40c>
800118ae:	ec e8 00 00 	ld.d	r8,r6[0]
800118b2:	2f f5       	sub	r5,-1
800118b4:	e0 a0 0a 36 	rcall	80012d20 <__avr32_f64_mul>
800118b8:	fa eb 00 08 	st.d	sp[8],r10
800118bc:	a1 54       	asr	r4,0x1
800118be:	2f 86       	sub	r6,-8
800118c0:	58 04       	cp.w	r4,0
800118c2:	cf 11       	brne	800118a4 <_dtoa_r+0x3f4>
800118c4:	06 96       	mov	r6,r3
800118c6:	40 63       	lddsp	r3,sp[0x18]
800118c8:	41 4a       	lddsp	r10,sp[0x50]
800118ca:	58 0a       	cp.w	r10,0
800118cc:	c2 a0       	breq	80011920 <_dtoa_r+0x470>
800118ce:	fa e8 00 08 	ld.d	r8,sp[8]
800118d2:	58 01       	cp.w	r1,0
800118d4:	5f 94       	srgt	r4
800118d6:	fa e9 00 18 	st.d	sp[24],r8
800118da:	30 08       	mov	r8,0
800118dc:	fc 19 3f f0 	movh	r9,0x3ff0
800118e0:	fa ea 00 18 	ld.d	r10,sp[24]
800118e4:	e0 a0 0d 2c 	rcall	8001333c <__avr32_f64_cmp_lt>
800118e8:	f9 bc 00 00 	moveq	r12,0
800118ec:	f9 bc 01 01 	movne	r12,1
800118f0:	e9 ec 00 0c 	and	r12,r4,r12
800118f4:	c1 60       	breq	80011920 <_dtoa_r+0x470>
800118f6:	40 98       	lddsp	r8,sp[0x24]
800118f8:	58 08       	cp.w	r8,0
800118fa:	e0 8a 00 f1 	brle	80011adc <_dtoa_r+0x62c>
800118fe:	30 08       	mov	r8,0
80011900:	fc 19 40 24 	movh	r9,0x4024
80011904:	ec c4 00 01 	sub	r4,r6,1
80011908:	fa ea 00 18 	ld.d	r10,sp[24]
8001190c:	2f f5       	sub	r5,-1
8001190e:	50 64       	stdsp	sp[0x18],r4
80011910:	e0 a0 0a 08 	rcall	80012d20 <__avr32_f64_mul>
80011914:	40 94       	lddsp	r4,sp[0x24]
80011916:	14 98       	mov	r8,r10
80011918:	16 99       	mov	r9,r11
8001191a:	fa e9 00 08 	st.d	sp[8],r8
8001191e:	c0 38       	rjmp	80011924 <_dtoa_r+0x474>
80011920:	50 66       	stdsp	sp[0x18],r6
80011922:	02 94       	mov	r4,r1
80011924:	0a 9c       	mov	r12,r5
80011926:	e0 a0 0c 54 	rcall	800131ce <__avr32_s32_to_f64>
8001192a:	fa e8 00 08 	ld.d	r8,sp[8]
8001192e:	e0 a0 09 f9 	rcall	80012d20 <__avr32_f64_mul>
80011932:	30 08       	mov	r8,0
80011934:	fc 19 40 1c 	movh	r9,0x401c
80011938:	e0 a0 0b ae 	rcall	80013094 <__avr32_f64_add>
8001193c:	14 98       	mov	r8,r10
8001193e:	16 99       	mov	r9,r11
80011940:	fa e9 00 28 	st.d	sp[40],r8
80011944:	fc 18 fc c0 	movh	r8,0xfcc0
80011948:	40 a5       	lddsp	r5,sp[0x28]
8001194a:	10 05       	add	r5,r8
8001194c:	50 a5       	stdsp	sp[0x28],r5
8001194e:	58 04       	cp.w	r4,0
80011950:	c2 11       	brne	80011992 <_dtoa_r+0x4e2>
80011952:	fa ea 00 08 	ld.d	r10,sp[8]
80011956:	30 08       	mov	r8,0
80011958:	fc 19 40 14 	movh	r9,0x4014
8001195c:	e0 a0 0a ce 	rcall	80012ef8 <__avr32_f64_sub>
80011960:	40 bc       	lddsp	r12,sp[0x2c]
80011962:	fa eb 00 08 	st.d	sp[8],r10
80011966:	14 98       	mov	r8,r10
80011968:	16 99       	mov	r9,r11
8001196a:	18 9a       	mov	r10,r12
8001196c:	0a 9b       	mov	r11,r5
8001196e:	e0 a0 0c e7 	rcall	8001333c <__avr32_f64_cmp_lt>
80011972:	e0 81 02 54 	brne	80011e1a <_dtoa_r+0x96a>
80011976:	0a 98       	mov	r8,r5
80011978:	40 b9       	lddsp	r9,sp[0x2c]
8001197a:	ee 18 80 00 	eorh	r8,0x8000
8001197e:	fa ea 00 08 	ld.d	r10,sp[8]
80011982:	10 95       	mov	r5,r8
80011984:	12 98       	mov	r8,r9
80011986:	0a 99       	mov	r9,r5
80011988:	e0 a0 0c da 	rcall	8001333c <__avr32_f64_cmp_lt>
8001198c:	e0 81 02 3e 	brne	80011e08 <_dtoa_r+0x958>
80011990:	ca 68       	rjmp	80011adc <_dtoa_r+0x62c>
80011992:	fe c9 c5 3a 	sub	r9,pc,-15046
80011996:	e8 c8 00 01 	sub	r8,r4,1
8001199a:	40 d5       	lddsp	r5,sp[0x34]
8001199c:	58 05       	cp.w	r5,0
8001199e:	c4 f0       	breq	80011a3c <_dtoa_r+0x58c>
800119a0:	30 0c       	mov	r12,0
800119a2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800119a6:	51 3c       	stdsp	sp[0x4c],r12
800119a8:	30 0a       	mov	r10,0
800119aa:	fc 1b 3f e0 	movh	r11,0x3fe0
800119ae:	e0 a0 0c fb 	rcall	800133a4 <__avr32_f64_div>
800119b2:	fa e8 00 28 	ld.d	r8,sp[40]
800119b6:	40 85       	lddsp	r5,sp[0x20]
800119b8:	e0 a0 0a a0 	rcall	80012ef8 <__avr32_f64_sub>
800119bc:	fa eb 00 28 	st.d	sp[40],r10
800119c0:	fa ea 00 08 	ld.d	r10,sp[8]
800119c4:	e0 a0 0b ee 	rcall	800131a0 <__avr32_f64_to_s32>
800119c8:	51 6c       	stdsp	sp[0x58],r12
800119ca:	e0 a0 0c 02 	rcall	800131ce <__avr32_s32_to_f64>
800119ce:	14 98       	mov	r8,r10
800119d0:	16 99       	mov	r9,r11
800119d2:	fa ea 00 08 	ld.d	r10,sp[8]
800119d6:	e0 a0 0a 91 	rcall	80012ef8 <__avr32_f64_sub>
800119da:	fa eb 00 08 	st.d	sp[8],r10
800119de:	41 68       	lddsp	r8,sp[0x58]
800119e0:	2d 08       	sub	r8,-48
800119e2:	0a c8       	st.b	r5++,r8
800119e4:	41 39       	lddsp	r9,sp[0x4c]
800119e6:	2f f9       	sub	r9,-1
800119e8:	51 39       	stdsp	sp[0x4c],r9
800119ea:	fa e8 00 28 	ld.d	r8,sp[40]
800119ee:	e0 a0 0c a7 	rcall	8001333c <__avr32_f64_cmp_lt>
800119f2:	e0 81 03 39 	brne	80012064 <_dtoa_r+0xbb4>
800119f6:	fa e8 00 08 	ld.d	r8,sp[8]
800119fa:	30 0a       	mov	r10,0
800119fc:	fc 1b 3f f0 	movh	r11,0x3ff0
80011a00:	e0 a0 0a 7c 	rcall	80012ef8 <__avr32_f64_sub>
80011a04:	fa e8 00 28 	ld.d	r8,sp[40]
80011a08:	e0 a0 0c 9a 	rcall	8001333c <__avr32_f64_cmp_lt>
80011a0c:	fa ea 00 28 	ld.d	r10,sp[40]
80011a10:	30 08       	mov	r8,0
80011a12:	fc 19 40 24 	movh	r9,0x4024
80011a16:	e0 81 00 da 	brne	80011bca <_dtoa_r+0x71a>
80011a1a:	41 3c       	lddsp	r12,sp[0x4c]
80011a1c:	08 3c       	cp.w	r12,r4
80011a1e:	c5 f4       	brge	80011adc <_dtoa_r+0x62c>
80011a20:	e0 a0 09 80 	rcall	80012d20 <__avr32_f64_mul>
80011a24:	30 08       	mov	r8,0
80011a26:	fa eb 00 28 	st.d	sp[40],r10
80011a2a:	fc 19 40 24 	movh	r9,0x4024
80011a2e:	fa ea 00 08 	ld.d	r10,sp[8]
80011a32:	e0 a0 09 77 	rcall	80012d20 <__avr32_f64_mul>
80011a36:	fa eb 00 08 	st.d	sp[8],r10
80011a3a:	cc 3b       	rjmp	800119c0 <_dtoa_r+0x510>
80011a3c:	40 85       	lddsp	r5,sp[0x20]
80011a3e:	08 05       	add	r5,r4
80011a40:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80011a44:	51 35       	stdsp	sp[0x4c],r5
80011a46:	fa e8 00 28 	ld.d	r8,sp[40]
80011a4a:	40 85       	lddsp	r5,sp[0x20]
80011a4c:	e0 a0 09 6a 	rcall	80012d20 <__avr32_f64_mul>
80011a50:	fa eb 00 28 	st.d	sp[40],r10
80011a54:	fa ea 00 08 	ld.d	r10,sp[8]
80011a58:	e0 a0 0b a4 	rcall	800131a0 <__avr32_f64_to_s32>
80011a5c:	51 6c       	stdsp	sp[0x58],r12
80011a5e:	e0 a0 0b b8 	rcall	800131ce <__avr32_s32_to_f64>
80011a62:	14 98       	mov	r8,r10
80011a64:	16 99       	mov	r9,r11
80011a66:	fa ea 00 08 	ld.d	r10,sp[8]
80011a6a:	e0 a0 0a 47 	rcall	80012ef8 <__avr32_f64_sub>
80011a6e:	fa eb 00 08 	st.d	sp[8],r10
80011a72:	41 68       	lddsp	r8,sp[0x58]
80011a74:	2d 08       	sub	r8,-48
80011a76:	0a c8       	st.b	r5++,r8
80011a78:	41 3c       	lddsp	r12,sp[0x4c]
80011a7a:	18 35       	cp.w	r5,r12
80011a7c:	c2 81       	brne	80011acc <_dtoa_r+0x61c>
80011a7e:	30 08       	mov	r8,0
80011a80:	fc 19 3f e0 	movh	r9,0x3fe0
80011a84:	fa ea 00 28 	ld.d	r10,sp[40]
80011a88:	e0 a0 0b 06 	rcall	80013094 <__avr32_f64_add>
80011a8c:	40 85       	lddsp	r5,sp[0x20]
80011a8e:	fa e8 00 08 	ld.d	r8,sp[8]
80011a92:	08 05       	add	r5,r4
80011a94:	e0 a0 0c 54 	rcall	8001333c <__avr32_f64_cmp_lt>
80011a98:	e0 81 00 99 	brne	80011bca <_dtoa_r+0x71a>
80011a9c:	fa e8 00 28 	ld.d	r8,sp[40]
80011aa0:	30 0a       	mov	r10,0
80011aa2:	fc 1b 3f e0 	movh	r11,0x3fe0
80011aa6:	e0 a0 0a 29 	rcall	80012ef8 <__avr32_f64_sub>
80011aaa:	14 98       	mov	r8,r10
80011aac:	16 99       	mov	r9,r11
80011aae:	fa ea 00 08 	ld.d	r10,sp[8]
80011ab2:	e0 a0 0c 45 	rcall	8001333c <__avr32_f64_cmp_lt>
80011ab6:	c1 30       	breq	80011adc <_dtoa_r+0x62c>
80011ab8:	33 09       	mov	r9,48
80011aba:	0a 98       	mov	r8,r5
80011abc:	11 7a       	ld.ub	r10,--r8
80011abe:	f2 0a 18 00 	cp.b	r10,r9
80011ac2:	e0 81 02 d1 	brne	80012064 <_dtoa_r+0xbb4>
80011ac6:	10 95       	mov	r5,r8
80011ac8:	cf 9b       	rjmp	80011aba <_dtoa_r+0x60a>
80011aca:	d7 03       	nop
80011acc:	30 08       	mov	r8,0
80011ace:	fc 19 40 24 	movh	r9,0x4024
80011ad2:	e0 a0 09 27 	rcall	80012d20 <__avr32_f64_mul>
80011ad6:	fa eb 00 08 	st.d	sp[8],r10
80011ada:	cb db       	rjmp	80011a54 <_dtoa_r+0x5a4>
80011adc:	fa ea 00 3c 	ld.d	r10,sp[60]
80011ae0:	fa eb 00 08 	st.d	sp[8],r10
80011ae4:	58 e6       	cp.w	r6,14
80011ae6:	5f ab       	srle	r11
80011ae8:	41 8a       	lddsp	r10,sp[0x60]
80011aea:	30 08       	mov	r8,0
80011aec:	f4 09 11 ff 	rsub	r9,r10,-1
80011af0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80011af4:	f0 09 18 00 	cp.b	r9,r8
80011af8:	e0 80 00 82 	breq	80011bfc <_dtoa_r+0x74c>
80011afc:	40 ea       	lddsp	r10,sp[0x38]
80011afe:	58 01       	cp.w	r1,0
80011b00:	5f a9       	srle	r9
80011b02:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80011b06:	fe ca c6 ae 	sub	r10,pc,-14674
80011b0a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80011b0e:	fa e5 00 10 	st.d	sp[16],r4
80011b12:	f0 09 18 00 	cp.b	r9,r8
80011b16:	c1 40       	breq	80011b3e <_dtoa_r+0x68e>
80011b18:	58 01       	cp.w	r1,0
80011b1a:	e0 81 01 77 	brne	80011e08 <_dtoa_r+0x958>
80011b1e:	30 08       	mov	r8,0
80011b20:	fc 19 40 14 	movh	r9,0x4014
80011b24:	08 9a       	mov	r10,r4
80011b26:	0a 9b       	mov	r11,r5
80011b28:	e0 a0 08 fc 	rcall	80012d20 <__avr32_f64_mul>
80011b2c:	fa e8 00 08 	ld.d	r8,sp[8]
80011b30:	e0 a0 0b d2 	rcall	800132d4 <__avr32_f64_cmp_ge>
80011b34:	e0 81 01 6a 	brne	80011e08 <_dtoa_r+0x958>
80011b38:	02 92       	mov	r2,r1
80011b3a:	e0 8f 01 72 	bral	80011e1e <_dtoa_r+0x96e>
80011b3e:	40 85       	lddsp	r5,sp[0x20]
80011b40:	30 14       	mov	r4,1
80011b42:	fa e8 00 10 	ld.d	r8,sp[16]
80011b46:	fa ea 00 08 	ld.d	r10,sp[8]
80011b4a:	e0 a0 0c 2d 	rcall	800133a4 <__avr32_f64_div>
80011b4e:	e0 a0 0b 29 	rcall	800131a0 <__avr32_f64_to_s32>
80011b52:	18 92       	mov	r2,r12
80011b54:	e0 a0 0b 3d 	rcall	800131ce <__avr32_s32_to_f64>
80011b58:	fa e8 00 10 	ld.d	r8,sp[16]
80011b5c:	e0 a0 08 e2 	rcall	80012d20 <__avr32_f64_mul>
80011b60:	14 98       	mov	r8,r10
80011b62:	16 99       	mov	r9,r11
80011b64:	fa ea 00 08 	ld.d	r10,sp[8]
80011b68:	e0 a0 09 c8 	rcall	80012ef8 <__avr32_f64_sub>
80011b6c:	fa eb 00 08 	st.d	sp[8],r10
80011b70:	e4 c8 ff d0 	sub	r8,r2,-48
80011b74:	0a c8       	st.b	r5++,r8
80011b76:	fc 19 40 24 	movh	r9,0x4024
80011b7a:	30 08       	mov	r8,0
80011b7c:	02 34       	cp.w	r4,r1
80011b7e:	c3 31       	brne	80011be4 <_dtoa_r+0x734>
80011b80:	fa e8 00 08 	ld.d	r8,sp[8]
80011b84:	e0 a0 0a 88 	rcall	80013094 <__avr32_f64_add>
80011b88:	16 91       	mov	r1,r11
80011b8a:	14 90       	mov	r0,r10
80011b8c:	14 98       	mov	r8,r10
80011b8e:	02 99       	mov	r9,r1
80011b90:	fa ea 00 10 	ld.d	r10,sp[16]
80011b94:	e0 a0 0b d4 	rcall	8001333c <__avr32_f64_cmp_lt>
80011b98:	c1 a1       	brne	80011bcc <_dtoa_r+0x71c>
80011b9a:	fa e8 00 10 	ld.d	r8,sp[16]
80011b9e:	00 9a       	mov	r10,r0
80011ba0:	02 9b       	mov	r11,r1
80011ba2:	e0 a0 0b 86 	rcall	800132ae <__avr32_f64_cmp_eq>
80011ba6:	e0 80 02 5e 	breq	80012062 <_dtoa_r+0xbb2>
80011baa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80011bae:	c0 f1       	brne	80011bcc <_dtoa_r+0x71c>
80011bb0:	e0 8f 02 59 	bral	80012062 <_dtoa_r+0xbb2>
80011bb4:	40 8a       	lddsp	r10,sp[0x20]
80011bb6:	14 38       	cp.w	r8,r10
80011bb8:	c0 30       	breq	80011bbe <_dtoa_r+0x70e>
80011bba:	10 95       	mov	r5,r8
80011bbc:	c0 98       	rjmp	80011bce <_dtoa_r+0x71e>
80011bbe:	33 08       	mov	r8,48
80011bc0:	40 89       	lddsp	r9,sp[0x20]
80011bc2:	2f f6       	sub	r6,-1
80011bc4:	b2 88       	st.b	r9[0x0],r8
80011bc6:	40 88       	lddsp	r8,sp[0x20]
80011bc8:	c0 88       	rjmp	80011bd8 <_dtoa_r+0x728>
80011bca:	40 66       	lddsp	r6,sp[0x18]
80011bcc:	33 99       	mov	r9,57
80011bce:	0a 98       	mov	r8,r5
80011bd0:	11 7a       	ld.ub	r10,--r8
80011bd2:	f2 0a 18 00 	cp.b	r10,r9
80011bd6:	ce f0       	breq	80011bb4 <_dtoa_r+0x704>
80011bd8:	50 66       	stdsp	sp[0x18],r6
80011bda:	11 89       	ld.ub	r9,r8[0x0]
80011bdc:	2f f9       	sub	r9,-1
80011bde:	b0 89       	st.b	r8[0x0],r9
80011be0:	e0 8f 02 42 	bral	80012064 <_dtoa_r+0xbb4>
80011be4:	e0 a0 08 9e 	rcall	80012d20 <__avr32_f64_mul>
80011be8:	2f f4       	sub	r4,-1
80011bea:	fa eb 00 08 	st.d	sp[8],r10
80011bee:	30 08       	mov	r8,0
80011bf0:	30 09       	mov	r9,0
80011bf2:	e0 a0 0b 5e 	rcall	800132ae <__avr32_f64_cmp_eq>
80011bf6:	ca 60       	breq	80011b42 <_dtoa_r+0x692>
80011bf8:	e0 8f 02 35 	bral	80012062 <_dtoa_r+0xbb2>
80011bfc:	40 d8       	lddsp	r8,sp[0x34]
80011bfe:	58 08       	cp.w	r8,0
80011c00:	c0 51       	brne	80011c0a <_dtoa_r+0x75a>
80011c02:	04 98       	mov	r8,r2
80011c04:	00 95       	mov	r5,r0
80011c06:	40 d4       	lddsp	r4,sp[0x34]
80011c08:	c3 78       	rjmp	80011c76 <_dtoa_r+0x7c6>
80011c0a:	40 c5       	lddsp	r5,sp[0x30]
80011c0c:	58 15       	cp.w	r5,1
80011c0e:	e0 89 00 0f 	brgt	80011c2c <_dtoa_r+0x77c>
80011c12:	41 74       	lddsp	r4,sp[0x5c]
80011c14:	58 04       	cp.w	r4,0
80011c16:	c0 40       	breq	80011c1e <_dtoa_r+0x76e>
80011c18:	f4 c9 fb cd 	sub	r9,r10,-1075
80011c1c:	c0 48       	rjmp	80011c24 <_dtoa_r+0x774>
80011c1e:	41 99       	lddsp	r9,sp[0x64]
80011c20:	f2 09 11 36 	rsub	r9,r9,54
80011c24:	04 98       	mov	r8,r2
80011c26:	00 95       	mov	r5,r0
80011c28:	c1 c8       	rjmp	80011c60 <_dtoa_r+0x7b0>
80011c2a:	d7 03       	nop
80011c2c:	e2 c8 00 01 	sub	r8,r1,1
80011c30:	58 01       	cp.w	r1,0
80011c32:	e0 05 17 40 	movge	r5,r0
80011c36:	e2 09 17 40 	movge	r9,r1
80011c3a:	e1 d1 e5 15 	sublt	r5,r0,r1
80011c3e:	f9 b9 05 00 	movlt	r9,0
80011c42:	10 32       	cp.w	r2,r8
80011c44:	e5 d8 e4 18 	subge	r8,r2,r8
80011c48:	f1 d2 e5 18 	sublt	r8,r8,r2
80011c4c:	e5 d8 e5 02 	addlt	r2,r2,r8
80011c50:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80011c54:	f9 d8 e5 0c 	addlt	r12,r12,r8
80011c58:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80011c5c:	f9 b8 05 00 	movlt	r8,0
80011c60:	40 4b       	lddsp	r11,sp[0x10]
80011c62:	12 0b       	add	r11,r9
80011c64:	50 08       	stdsp	sp[0x0],r8
80011c66:	50 4b       	stdsp	sp[0x10],r11
80011c68:	12 00       	add	r0,r9
80011c6a:	30 1b       	mov	r11,1
80011c6c:	0e 9c       	mov	r12,r7
80011c6e:	e0 a0 06 07 	rcall	8001287c <__i2b>
80011c72:	40 08       	lddsp	r8,sp[0x0]
80011c74:	18 94       	mov	r4,r12
80011c76:	40 4a       	lddsp	r10,sp[0x10]
80011c78:	58 05       	cp.w	r5,0
80011c7a:	5f 99       	srgt	r9
80011c7c:	58 0a       	cp.w	r10,0
80011c7e:	5f 9a       	srgt	r10
80011c80:	f5 e9 00 09 	and	r9,r10,r9
80011c84:	c0 80       	breq	80011c94 <_dtoa_r+0x7e4>
80011c86:	40 4c       	lddsp	r12,sp[0x10]
80011c88:	f8 05 0d 49 	min	r9,r12,r5
80011c8c:	12 1c       	sub	r12,r9
80011c8e:	12 10       	sub	r0,r9
80011c90:	50 4c       	stdsp	sp[0x10],r12
80011c92:	12 15       	sub	r5,r9
80011c94:	58 02       	cp.w	r2,0
80011c96:	e0 8a 00 27 	brle	80011ce4 <_dtoa_r+0x834>
80011c9a:	40 db       	lddsp	r11,sp[0x34]
80011c9c:	58 0b       	cp.w	r11,0
80011c9e:	c1 d0       	breq	80011cd8 <_dtoa_r+0x828>
80011ca0:	58 08       	cp.w	r8,0
80011ca2:	e0 8a 00 17 	brle	80011cd0 <_dtoa_r+0x820>
80011ca6:	10 9a       	mov	r10,r8
80011ca8:	50 08       	stdsp	sp[0x0],r8
80011caa:	08 9b       	mov	r11,r4
80011cac:	0e 9c       	mov	r12,r7
80011cae:	e0 a0 06 2d 	rcall	80012908 <__pow5mult>
80011cb2:	06 9a       	mov	r10,r3
80011cb4:	18 9b       	mov	r11,r12
80011cb6:	18 94       	mov	r4,r12
80011cb8:	0e 9c       	mov	r12,r7
80011cba:	e0 a0 05 61 	rcall	8001277c <__multiply>
80011cbe:	18 99       	mov	r9,r12
80011cc0:	06 9b       	mov	r11,r3
80011cc2:	50 19       	stdsp	sp[0x4],r9
80011cc4:	0e 9c       	mov	r12,r7
80011cc6:	e0 a0 04 09 	rcall	800124d8 <_Bfree>
80011cca:	40 19       	lddsp	r9,sp[0x4]
80011ccc:	40 08       	lddsp	r8,sp[0x0]
80011cce:	12 93       	mov	r3,r9
80011cd0:	e4 08 01 0a 	sub	r10,r2,r8
80011cd4:	c0 80       	breq	80011ce4 <_dtoa_r+0x834>
80011cd6:	c0 28       	rjmp	80011cda <_dtoa_r+0x82a>
80011cd8:	04 9a       	mov	r10,r2
80011cda:	06 9b       	mov	r11,r3
80011cdc:	0e 9c       	mov	r12,r7
80011cde:	e0 a0 06 15 	rcall	80012908 <__pow5mult>
80011ce2:	18 93       	mov	r3,r12
80011ce4:	30 1b       	mov	r11,1
80011ce6:	0e 9c       	mov	r12,r7
80011ce8:	e0 a0 05 ca 	rcall	8001287c <__i2b>
80011cec:	41 1a       	lddsp	r10,sp[0x44]
80011cee:	18 92       	mov	r2,r12
80011cf0:	58 0a       	cp.w	r10,0
80011cf2:	e0 8a 00 07 	brle	80011d00 <_dtoa_r+0x850>
80011cf6:	18 9b       	mov	r11,r12
80011cf8:	0e 9c       	mov	r12,r7
80011cfa:	e0 a0 06 07 	rcall	80012908 <__pow5mult>
80011cfe:	18 92       	mov	r2,r12
80011d00:	40 c9       	lddsp	r9,sp[0x30]
80011d02:	58 19       	cp.w	r9,1
80011d04:	e0 89 00 14 	brgt	80011d2c <_dtoa_r+0x87c>
80011d08:	40 38       	lddsp	r8,sp[0xc]
80011d0a:	58 08       	cp.w	r8,0
80011d0c:	c1 01       	brne	80011d2c <_dtoa_r+0x87c>
80011d0e:	40 29       	lddsp	r9,sp[0x8]
80011d10:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80011d14:	c0 c1       	brne	80011d2c <_dtoa_r+0x87c>
80011d16:	12 98       	mov	r8,r9
80011d18:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80011d1c:	c0 80       	breq	80011d2c <_dtoa_r+0x87c>
80011d1e:	40 4c       	lddsp	r12,sp[0x10]
80011d20:	30 1b       	mov	r11,1
80011d22:	2f fc       	sub	r12,-1
80011d24:	2f f0       	sub	r0,-1
80011d26:	50 4c       	stdsp	sp[0x10],r12
80011d28:	50 6b       	stdsp	sp[0x18],r11
80011d2a:	c0 38       	rjmp	80011d30 <_dtoa_r+0x880>
80011d2c:	30 0a       	mov	r10,0
80011d2e:	50 6a       	stdsp	sp[0x18],r10
80011d30:	41 19       	lddsp	r9,sp[0x44]
80011d32:	58 09       	cp.w	r9,0
80011d34:	c0 31       	brne	80011d3a <_dtoa_r+0x88a>
80011d36:	30 1c       	mov	r12,1
80011d38:	c0 98       	rjmp	80011d4a <_dtoa_r+0x89a>
80011d3a:	64 48       	ld.w	r8,r2[0x10]
80011d3c:	2f c8       	sub	r8,-4
80011d3e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80011d42:	e0 a0 03 3b 	rcall	800123b8 <__hi0bits>
80011d46:	f8 0c 11 20 	rsub	r12,r12,32
80011d4a:	40 4b       	lddsp	r11,sp[0x10]
80011d4c:	f8 0b 00 08 	add	r8,r12,r11
80011d50:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80011d54:	c0 c0       	breq	80011d6c <_dtoa_r+0x8bc>
80011d56:	f0 08 11 20 	rsub	r8,r8,32
80011d5a:	58 48       	cp.w	r8,4
80011d5c:	e0 8a 00 06 	brle	80011d68 <_dtoa_r+0x8b8>
80011d60:	20 48       	sub	r8,4
80011d62:	10 0b       	add	r11,r8
80011d64:	50 4b       	stdsp	sp[0x10],r11
80011d66:	c0 78       	rjmp	80011d74 <_dtoa_r+0x8c4>
80011d68:	58 48       	cp.w	r8,4
80011d6a:	c0 70       	breq	80011d78 <_dtoa_r+0x8c8>
80011d6c:	40 4a       	lddsp	r10,sp[0x10]
80011d6e:	2e 48       	sub	r8,-28
80011d70:	10 0a       	add	r10,r8
80011d72:	50 4a       	stdsp	sp[0x10],r10
80011d74:	10 00       	add	r0,r8
80011d76:	10 05       	add	r5,r8
80011d78:	58 00       	cp.w	r0,0
80011d7a:	e0 8a 00 08 	brle	80011d8a <_dtoa_r+0x8da>
80011d7e:	06 9b       	mov	r11,r3
80011d80:	00 9a       	mov	r10,r0
80011d82:	0e 9c       	mov	r12,r7
80011d84:	e0 a0 04 b8 	rcall	800126f4 <__lshift>
80011d88:	18 93       	mov	r3,r12
80011d8a:	40 49       	lddsp	r9,sp[0x10]
80011d8c:	58 09       	cp.w	r9,0
80011d8e:	e0 8a 00 08 	brle	80011d9e <_dtoa_r+0x8ee>
80011d92:	04 9b       	mov	r11,r2
80011d94:	12 9a       	mov	r10,r9
80011d96:	0e 9c       	mov	r12,r7
80011d98:	e0 a0 04 ae 	rcall	800126f4 <__lshift>
80011d9c:	18 92       	mov	r2,r12
80011d9e:	41 48       	lddsp	r8,sp[0x50]
80011da0:	58 08       	cp.w	r8,0
80011da2:	c1 b0       	breq	80011dd8 <_dtoa_r+0x928>
80011da4:	04 9b       	mov	r11,r2
80011da6:	06 9c       	mov	r12,r3
80011da8:	e0 a0 03 7f 	rcall	800124a6 <__mcmp>
80011dac:	c1 64       	brge	80011dd8 <_dtoa_r+0x928>
80011dae:	06 9b       	mov	r11,r3
80011db0:	30 09       	mov	r9,0
80011db2:	30 aa       	mov	r10,10
80011db4:	0e 9c       	mov	r12,r7
80011db6:	e0 a0 05 6b 	rcall	8001288c <__multadd>
80011dba:	20 16       	sub	r6,1
80011dbc:	18 93       	mov	r3,r12
80011dbe:	40 dc       	lddsp	r12,sp[0x34]
80011dc0:	58 0c       	cp.w	r12,0
80011dc2:	c0 31       	brne	80011dc8 <_dtoa_r+0x918>
80011dc4:	40 91       	lddsp	r1,sp[0x24]
80011dc6:	c0 98       	rjmp	80011dd8 <_dtoa_r+0x928>
80011dc8:	08 9b       	mov	r11,r4
80011dca:	40 91       	lddsp	r1,sp[0x24]
80011dcc:	30 09       	mov	r9,0
80011dce:	30 aa       	mov	r10,10
80011dd0:	0e 9c       	mov	r12,r7
80011dd2:	e0 a0 05 5d 	rcall	8001288c <__multadd>
80011dd6:	18 94       	mov	r4,r12
80011dd8:	58 01       	cp.w	r1,0
80011dda:	5f a9       	srle	r9
80011ddc:	40 cb       	lddsp	r11,sp[0x30]
80011dde:	58 2b       	cp.w	r11,2
80011de0:	5f 98       	srgt	r8
80011de2:	f3 e8 00 08 	and	r8,r9,r8
80011de6:	c2 50       	breq	80011e30 <_dtoa_r+0x980>
80011de8:	58 01       	cp.w	r1,0
80011dea:	c1 11       	brne	80011e0c <_dtoa_r+0x95c>
80011dec:	04 9b       	mov	r11,r2
80011dee:	02 99       	mov	r9,r1
80011df0:	30 5a       	mov	r10,5
80011df2:	0e 9c       	mov	r12,r7
80011df4:	e0 a0 05 4c 	rcall	8001288c <__multadd>
80011df8:	18 92       	mov	r2,r12
80011dfa:	18 9b       	mov	r11,r12
80011dfc:	06 9c       	mov	r12,r3
80011dfe:	e0 a0 03 54 	rcall	800124a6 <__mcmp>
80011e02:	e0 89 00 0f 	brgt	80011e20 <_dtoa_r+0x970>
80011e06:	c0 38       	rjmp	80011e0c <_dtoa_r+0x95c>
80011e08:	30 02       	mov	r2,0
80011e0a:	04 94       	mov	r4,r2
80011e0c:	40 ea       	lddsp	r10,sp[0x38]
80011e0e:	30 09       	mov	r9,0
80011e10:	5c da       	com	r10
80011e12:	40 85       	lddsp	r5,sp[0x20]
80011e14:	50 6a       	stdsp	sp[0x18],r10
80011e16:	50 49       	stdsp	sp[0x10],r9
80011e18:	c0 f9       	rjmp	80012036 <_dtoa_r+0xb86>
80011e1a:	08 92       	mov	r2,r4
80011e1c:	40 66       	lddsp	r6,sp[0x18]
80011e1e:	04 94       	mov	r4,r2
80011e20:	2f f6       	sub	r6,-1
80011e22:	50 66       	stdsp	sp[0x18],r6
80011e24:	33 18       	mov	r8,49
80011e26:	40 85       	lddsp	r5,sp[0x20]
80011e28:	0a c8       	st.b	r5++,r8
80011e2a:	30 08       	mov	r8,0
80011e2c:	50 48       	stdsp	sp[0x10],r8
80011e2e:	c0 49       	rjmp	80012036 <_dtoa_r+0xb86>
80011e30:	40 dc       	lddsp	r12,sp[0x34]
80011e32:	58 0c       	cp.w	r12,0
80011e34:	e0 80 00 b5 	breq	80011f9e <_dtoa_r+0xaee>
80011e38:	58 05       	cp.w	r5,0
80011e3a:	e0 8a 00 08 	brle	80011e4a <_dtoa_r+0x99a>
80011e3e:	08 9b       	mov	r11,r4
80011e40:	0a 9a       	mov	r10,r5
80011e42:	0e 9c       	mov	r12,r7
80011e44:	e0 a0 04 58 	rcall	800126f4 <__lshift>
80011e48:	18 94       	mov	r4,r12
80011e4a:	40 6b       	lddsp	r11,sp[0x18]
80011e4c:	58 0b       	cp.w	r11,0
80011e4e:	c0 31       	brne	80011e54 <_dtoa_r+0x9a4>
80011e50:	08 9c       	mov	r12,r4
80011e52:	c1 38       	rjmp	80011e78 <_dtoa_r+0x9c8>
80011e54:	68 1b       	ld.w	r11,r4[0x4]
80011e56:	0e 9c       	mov	r12,r7
80011e58:	e0 a0 03 5a 	rcall	8001250c <_Balloc>
80011e5c:	68 4a       	ld.w	r10,r4[0x10]
80011e5e:	18 95       	mov	r5,r12
80011e60:	e8 cb ff f4 	sub	r11,r4,-12
80011e64:	2f ea       	sub	r10,-2
80011e66:	2f 4c       	sub	r12,-12
80011e68:	a3 6a       	lsl	r10,0x2
80011e6a:	fe b0 e6 ad 	rcall	8000ebc4 <memcpy>
80011e6e:	0a 9b       	mov	r11,r5
80011e70:	30 1a       	mov	r10,1
80011e72:	0e 9c       	mov	r12,r7
80011e74:	e0 a0 04 40 	rcall	800126f4 <__lshift>
80011e78:	50 44       	stdsp	sp[0x10],r4
80011e7a:	40 3a       	lddsp	r10,sp[0xc]
80011e7c:	30 19       	mov	r9,1
80011e7e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80011e82:	18 94       	mov	r4,r12
80011e84:	50 da       	stdsp	sp[0x34],r10
80011e86:	40 85       	lddsp	r5,sp[0x20]
80011e88:	50 99       	stdsp	sp[0x24],r9
80011e8a:	50 26       	stdsp	sp[0x8],r6
80011e8c:	50 e1       	stdsp	sp[0x38],r1
80011e8e:	04 9b       	mov	r11,r2
80011e90:	06 9c       	mov	r12,r3
80011e92:	fe b0 fa 7f 	rcall	80011390 <quorem>
80011e96:	40 4b       	lddsp	r11,sp[0x10]
80011e98:	f8 c0 ff d0 	sub	r0,r12,-48
80011e9c:	06 9c       	mov	r12,r3
80011e9e:	e0 a0 03 04 	rcall	800124a6 <__mcmp>
80011ea2:	08 9a       	mov	r10,r4
80011ea4:	50 6c       	stdsp	sp[0x18],r12
80011ea6:	04 9b       	mov	r11,r2
80011ea8:	0e 9c       	mov	r12,r7
80011eaa:	e0 a0 03 bd 	rcall	80012624 <__mdiff>
80011eae:	18 91       	mov	r1,r12
80011eb0:	78 38       	ld.w	r8,r12[0xc]
80011eb2:	58 08       	cp.w	r8,0
80011eb4:	c0 30       	breq	80011eba <_dtoa_r+0xa0a>
80011eb6:	30 16       	mov	r6,1
80011eb8:	c0 68       	rjmp	80011ec4 <_dtoa_r+0xa14>
80011eba:	18 9b       	mov	r11,r12
80011ebc:	06 9c       	mov	r12,r3
80011ebe:	e0 a0 02 f4 	rcall	800124a6 <__mcmp>
80011ec2:	18 96       	mov	r6,r12
80011ec4:	0e 9c       	mov	r12,r7
80011ec6:	02 9b       	mov	r11,r1
80011ec8:	e0 a0 03 08 	rcall	800124d8 <_Bfree>
80011ecc:	40 cc       	lddsp	r12,sp[0x30]
80011ece:	ed ec 10 08 	or	r8,r6,r12
80011ed2:	c0 d1       	brne	80011eec <_dtoa_r+0xa3c>
80011ed4:	40 db       	lddsp	r11,sp[0x34]
80011ed6:	58 0b       	cp.w	r11,0
80011ed8:	c0 a1       	brne	80011eec <_dtoa_r+0xa3c>
80011eda:	40 26       	lddsp	r6,sp[0x8]
80011edc:	e0 40 00 39 	cp.w	r0,57
80011ee0:	c3 00       	breq	80011f40 <_dtoa_r+0xa90>
80011ee2:	40 6a       	lddsp	r10,sp[0x18]
80011ee4:	58 0a       	cp.w	r10,0
80011ee6:	e0 89 00 24 	brgt	80011f2e <_dtoa_r+0xa7e>
80011eea:	c2 f8       	rjmp	80011f48 <_dtoa_r+0xa98>
80011eec:	40 69       	lddsp	r9,sp[0x18]
80011eee:	58 09       	cp.w	r9,0
80011ef0:	c0 85       	brlt	80011f00 <_dtoa_r+0xa50>
80011ef2:	12 98       	mov	r8,r9
80011ef4:	40 cc       	lddsp	r12,sp[0x30]
80011ef6:	18 48       	or	r8,r12
80011ef8:	c1 d1       	brne	80011f32 <_dtoa_r+0xa82>
80011efa:	40 db       	lddsp	r11,sp[0x34]
80011efc:	58 0b       	cp.w	r11,0
80011efe:	c1 a1       	brne	80011f32 <_dtoa_r+0xa82>
80011f00:	0c 99       	mov	r9,r6
80011f02:	40 26       	lddsp	r6,sp[0x8]
80011f04:	58 09       	cp.w	r9,0
80011f06:	e0 8a 00 21 	brle	80011f48 <_dtoa_r+0xa98>
80011f0a:	06 9b       	mov	r11,r3
80011f0c:	30 1a       	mov	r10,1
80011f0e:	0e 9c       	mov	r12,r7
80011f10:	e0 a0 03 f2 	rcall	800126f4 <__lshift>
80011f14:	04 9b       	mov	r11,r2
80011f16:	18 93       	mov	r3,r12
80011f18:	e0 a0 02 c7 	rcall	800124a6 <__mcmp>
80011f1c:	e0 89 00 06 	brgt	80011f28 <_dtoa_r+0xa78>
80011f20:	c1 41       	brne	80011f48 <_dtoa_r+0xa98>
80011f22:	ed b0 00 00 	bld	r0,0x0
80011f26:	c1 11       	brne	80011f48 <_dtoa_r+0xa98>
80011f28:	e0 40 00 39 	cp.w	r0,57
80011f2c:	c0 a0       	breq	80011f40 <_dtoa_r+0xa90>
80011f2e:	2f f0       	sub	r0,-1
80011f30:	c0 c8       	rjmp	80011f48 <_dtoa_r+0xa98>
80011f32:	58 06       	cp.w	r6,0
80011f34:	e0 8a 00 0c 	brle	80011f4c <_dtoa_r+0xa9c>
80011f38:	40 26       	lddsp	r6,sp[0x8]
80011f3a:	e0 40 00 39 	cp.w	r0,57
80011f3e:	c0 41       	brne	80011f46 <_dtoa_r+0xa96>
80011f40:	33 98       	mov	r8,57
80011f42:	0a c8       	st.b	r5++,r8
80011f44:	c6 78       	rjmp	80012012 <_dtoa_r+0xb62>
80011f46:	2f f0       	sub	r0,-1
80011f48:	0a c0       	st.b	r5++,r0
80011f4a:	c7 58       	rjmp	80012034 <_dtoa_r+0xb84>
80011f4c:	0a c0       	st.b	r5++,r0
80011f4e:	40 9a       	lddsp	r10,sp[0x24]
80011f50:	40 e9       	lddsp	r9,sp[0x38]
80011f52:	12 3a       	cp.w	r10,r9
80011f54:	c4 30       	breq	80011fda <_dtoa_r+0xb2a>
80011f56:	06 9b       	mov	r11,r3
80011f58:	30 09       	mov	r9,0
80011f5a:	30 aa       	mov	r10,10
80011f5c:	0e 9c       	mov	r12,r7
80011f5e:	e0 a0 04 97 	rcall	8001288c <__multadd>
80011f62:	40 48       	lddsp	r8,sp[0x10]
80011f64:	18 93       	mov	r3,r12
80011f66:	08 38       	cp.w	r8,r4
80011f68:	c0 91       	brne	80011f7a <_dtoa_r+0xaca>
80011f6a:	10 9b       	mov	r11,r8
80011f6c:	30 09       	mov	r9,0
80011f6e:	30 aa       	mov	r10,10
80011f70:	0e 9c       	mov	r12,r7
80011f72:	e0 a0 04 8d 	rcall	8001288c <__multadd>
80011f76:	50 4c       	stdsp	sp[0x10],r12
80011f78:	c0 e8       	rjmp	80011f94 <_dtoa_r+0xae4>
80011f7a:	40 4b       	lddsp	r11,sp[0x10]
80011f7c:	30 09       	mov	r9,0
80011f7e:	30 aa       	mov	r10,10
80011f80:	0e 9c       	mov	r12,r7
80011f82:	e0 a0 04 85 	rcall	8001288c <__multadd>
80011f86:	08 9b       	mov	r11,r4
80011f88:	50 4c       	stdsp	sp[0x10],r12
80011f8a:	30 09       	mov	r9,0
80011f8c:	30 aa       	mov	r10,10
80011f8e:	0e 9c       	mov	r12,r7
80011f90:	e0 a0 04 7e 	rcall	8001288c <__multadd>
80011f94:	18 94       	mov	r4,r12
80011f96:	40 9c       	lddsp	r12,sp[0x24]
80011f98:	2f fc       	sub	r12,-1
80011f9a:	50 9c       	stdsp	sp[0x24],r12
80011f9c:	c7 9b       	rjmp	80011e8e <_dtoa_r+0x9de>
80011f9e:	30 18       	mov	r8,1
80011fa0:	06 90       	mov	r0,r3
80011fa2:	40 85       	lddsp	r5,sp[0x20]
80011fa4:	08 93       	mov	r3,r4
80011fa6:	0c 94       	mov	r4,r6
80011fa8:	10 96       	mov	r6,r8
80011faa:	04 9b       	mov	r11,r2
80011fac:	00 9c       	mov	r12,r0
80011fae:	fe b0 f9 f1 	rcall	80011390 <quorem>
80011fb2:	2d 0c       	sub	r12,-48
80011fb4:	0a cc       	st.b	r5++,r12
80011fb6:	02 36       	cp.w	r6,r1
80011fb8:	c0 a4       	brge	80011fcc <_dtoa_r+0xb1c>
80011fba:	00 9b       	mov	r11,r0
80011fbc:	30 09       	mov	r9,0
80011fbe:	30 aa       	mov	r10,10
80011fc0:	0e 9c       	mov	r12,r7
80011fc2:	2f f6       	sub	r6,-1
80011fc4:	e0 a0 04 64 	rcall	8001288c <__multadd>
80011fc8:	18 90       	mov	r0,r12
80011fca:	cf 0b       	rjmp	80011faa <_dtoa_r+0xafa>
80011fcc:	08 96       	mov	r6,r4
80011fce:	30 0b       	mov	r11,0
80011fd0:	06 94       	mov	r4,r3
80011fd2:	50 4b       	stdsp	sp[0x10],r11
80011fd4:	00 93       	mov	r3,r0
80011fd6:	18 90       	mov	r0,r12
80011fd8:	c0 28       	rjmp	80011fdc <_dtoa_r+0xb2c>
80011fda:	40 26       	lddsp	r6,sp[0x8]
80011fdc:	06 9b       	mov	r11,r3
80011fde:	30 1a       	mov	r10,1
80011fe0:	0e 9c       	mov	r12,r7
80011fe2:	e0 a0 03 89 	rcall	800126f4 <__lshift>
80011fe6:	04 9b       	mov	r11,r2
80011fe8:	18 93       	mov	r3,r12
80011fea:	e0 a0 02 5e 	rcall	800124a6 <__mcmp>
80011fee:	e0 89 00 12 	brgt	80012012 <_dtoa_r+0xb62>
80011ff2:	c1 b1       	brne	80012028 <_dtoa_r+0xb78>
80011ff4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80011ff8:	c0 d1       	brne	80012012 <_dtoa_r+0xb62>
80011ffa:	c1 78       	rjmp	80012028 <_dtoa_r+0xb78>
80011ffc:	40 89       	lddsp	r9,sp[0x20]
80011ffe:	12 38       	cp.w	r8,r9
80012000:	c0 30       	breq	80012006 <_dtoa_r+0xb56>
80012002:	10 95       	mov	r5,r8
80012004:	c0 88       	rjmp	80012014 <_dtoa_r+0xb64>
80012006:	2f f6       	sub	r6,-1
80012008:	50 66       	stdsp	sp[0x18],r6
8001200a:	33 18       	mov	r8,49
8001200c:	40 8c       	lddsp	r12,sp[0x20]
8001200e:	b8 88       	st.b	r12[0x0],r8
80012010:	c1 38       	rjmp	80012036 <_dtoa_r+0xb86>
80012012:	33 9a       	mov	r10,57
80012014:	0a 98       	mov	r8,r5
80012016:	11 79       	ld.ub	r9,--r8
80012018:	f4 09 18 00 	cp.b	r9,r10
8001201c:	cf 00       	breq	80011ffc <_dtoa_r+0xb4c>
8001201e:	2f f9       	sub	r9,-1
80012020:	b0 89       	st.b	r8[0x0],r9
80012022:	c0 98       	rjmp	80012034 <_dtoa_r+0xb84>
80012024:	10 95       	mov	r5,r8
80012026:	c0 28       	rjmp	8001202a <_dtoa_r+0xb7a>
80012028:	33 09       	mov	r9,48
8001202a:	0a 98       	mov	r8,r5
8001202c:	11 7a       	ld.ub	r10,--r8
8001202e:	f2 0a 18 00 	cp.b	r10,r9
80012032:	cf 90       	breq	80012024 <_dtoa_r+0xb74>
80012034:	50 66       	stdsp	sp[0x18],r6
80012036:	04 9b       	mov	r11,r2
80012038:	0e 9c       	mov	r12,r7
8001203a:	e0 a0 02 4f 	rcall	800124d8 <_Bfree>
8001203e:	58 04       	cp.w	r4,0
80012040:	c1 20       	breq	80012064 <_dtoa_r+0xbb4>
80012042:	40 4b       	lddsp	r11,sp[0x10]
80012044:	08 3b       	cp.w	r11,r4
80012046:	5f 19       	srne	r9
80012048:	58 0b       	cp.w	r11,0
8001204a:	5f 18       	srne	r8
8001204c:	f3 e8 00 08 	and	r8,r9,r8
80012050:	c0 40       	breq	80012058 <_dtoa_r+0xba8>
80012052:	0e 9c       	mov	r12,r7
80012054:	e0 a0 02 42 	rcall	800124d8 <_Bfree>
80012058:	08 9b       	mov	r11,r4
8001205a:	0e 9c       	mov	r12,r7
8001205c:	e0 a0 02 3e 	rcall	800124d8 <_Bfree>
80012060:	c0 28       	rjmp	80012064 <_dtoa_r+0xbb4>
80012062:	50 66       	stdsp	sp[0x18],r6
80012064:	0e 9c       	mov	r12,r7
80012066:	06 9b       	mov	r11,r3
80012068:	e0 a0 02 38 	rcall	800124d8 <_Bfree>
8001206c:	30 08       	mov	r8,0
8001206e:	aa 88       	st.b	r5[0x0],r8
80012070:	40 68       	lddsp	r8,sp[0x18]
80012072:	41 5a       	lddsp	r10,sp[0x54]
80012074:	2f f8       	sub	r8,-1
80012076:	41 29       	lddsp	r9,sp[0x48]
80012078:	95 08       	st.w	r10[0x0],r8
8001207a:	40 8c       	lddsp	r12,sp[0x20]
8001207c:	58 09       	cp.w	r9,0
8001207e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80012082:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80012086:	2e 6d       	sub	sp,-104
80012088:	d8 32       	popm	r0-r7,pc
8001208a:	d7 03       	nop

8001208c <__errno>:
8001208c:	e0 68 01 60 	mov	r8,352
80012090:	70 0c       	ld.w	r12,r8[0x0]
80012092:	2f 4c       	sub	r12,-12
80012094:	5e fc       	retal	r12
80012096:	d7 03       	nop

80012098 <__sfvwrite_r>:
80012098:	d4 31       	pushm	r0-r7,lr
8001209a:	20 3d       	sub	sp,12
8001209c:	14 94       	mov	r4,r10
8001209e:	18 95       	mov	r5,r12
800120a0:	16 97       	mov	r7,r11
800120a2:	74 28       	ld.w	r8,r10[0x8]
800120a4:	58 08       	cp.w	r8,0
800120a6:	e0 80 01 44 	breq	8001232e <__sfvwrite_r+0x296>
800120aa:	96 68       	ld.sh	r8,r11[0xc]
800120ac:	ed b8 00 03 	bld	r8,0x3
800120b0:	c0 41       	brne	800120b8 <__sfvwrite_r+0x20>
800120b2:	76 48       	ld.w	r8,r11[0x10]
800120b4:	58 08       	cp.w	r8,0
800120b6:	c0 c1       	brne	800120ce <__sfvwrite_r+0x36>
800120b8:	0e 9b       	mov	r11,r7
800120ba:	0a 9c       	mov	r12,r5
800120bc:	fe b0 f8 ec 	rcall	80011294 <__swsetup_r>
800120c0:	c0 70       	breq	800120ce <__sfvwrite_r+0x36>
800120c2:	8e 68       	ld.sh	r8,r7[0xc]
800120c4:	a7 a8       	sbr	r8,0x6
800120c6:	ae 68       	st.h	r7[0xc],r8
800120c8:	30 98       	mov	r8,9
800120ca:	8b 38       	st.w	r5[0xc],r8
800120cc:	c2 f9       	rjmp	8001232a <__sfvwrite_r+0x292>
800120ce:	8e 63       	ld.sh	r3,r7[0xc]
800120d0:	68 00       	ld.w	r0,r4[0x0]
800120d2:	06 96       	mov	r6,r3
800120d4:	e2 16 00 02 	andl	r6,0x2,COH
800120d8:	c2 10       	breq	8001211a <__sfvwrite_r+0x82>
800120da:	30 03       	mov	r3,0
800120dc:	e0 62 04 00 	mov	r2,1024
800120e0:	06 96       	mov	r6,r3
800120e2:	c0 48       	rjmp	800120ea <__sfvwrite_r+0x52>
800120e4:	60 03       	ld.w	r3,r0[0x0]
800120e6:	60 16       	ld.w	r6,r0[0x4]
800120e8:	2f 80       	sub	r0,-8
800120ea:	58 06       	cp.w	r6,0
800120ec:	cf c0       	breq	800120e4 <__sfvwrite_r+0x4c>
800120ee:	e0 46 04 00 	cp.w	r6,1024
800120f2:	ec 09 17 80 	movls	r9,r6
800120f6:	e4 09 17 b0 	movhi	r9,r2
800120fa:	06 9a       	mov	r10,r3
800120fc:	6e a8       	ld.w	r8,r7[0x28]
800120fe:	6e 8b       	ld.w	r11,r7[0x20]
80012100:	0a 9c       	mov	r12,r5
80012102:	5d 18       	icall	r8
80012104:	18 16       	sub	r6,r12
80012106:	58 0c       	cp.w	r12,0
80012108:	e0 8a 01 0e 	brle	80012324 <__sfvwrite_r+0x28c>
8001210c:	68 28       	ld.w	r8,r4[0x8]
8001210e:	18 18       	sub	r8,r12
80012110:	89 28       	st.w	r4[0x8],r8
80012112:	e0 80 01 0e 	breq	8001232e <__sfvwrite_r+0x296>
80012116:	18 03       	add	r3,r12
80012118:	ce 9b       	rjmp	800120ea <__sfvwrite_r+0x52>
8001211a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8001211e:	c0 70       	breq	8001212c <__sfvwrite_r+0x94>
80012120:	50 06       	stdsp	sp[0x0],r6
80012122:	0c 93       	mov	r3,r6
80012124:	0c 91       	mov	r1,r6
80012126:	50 15       	stdsp	sp[0x4],r5
80012128:	08 92       	mov	r2,r4
8001212a:	c9 d8       	rjmp	80012264 <__sfvwrite_r+0x1cc>
8001212c:	06 96       	mov	r6,r3
8001212e:	08 91       	mov	r1,r4
80012130:	c0 48       	rjmp	80012138 <__sfvwrite_r+0xa0>
80012132:	60 03       	ld.w	r3,r0[0x0]
80012134:	60 16       	ld.w	r6,r0[0x4]
80012136:	2f 80       	sub	r0,-8
80012138:	58 06       	cp.w	r6,0
8001213a:	cf c0       	breq	80012132 <__sfvwrite_r+0x9a>
8001213c:	8e 68       	ld.sh	r8,r7[0xc]
8001213e:	6e 24       	ld.w	r4,r7[0x8]
80012140:	10 99       	mov	r9,r8
80012142:	e2 19 02 00 	andl	r9,0x200,COH
80012146:	c5 60       	breq	800121f2 <__sfvwrite_r+0x15a>
80012148:	08 36       	cp.w	r6,r4
8001214a:	c4 53       	brcs	800121d4 <__sfvwrite_r+0x13c>
8001214c:	10 99       	mov	r9,r8
8001214e:	e2 19 04 80 	andl	r9,0x480,COH
80012152:	c4 10       	breq	800121d4 <__sfvwrite_r+0x13c>
80012154:	6e 4b       	ld.w	r11,r7[0x10]
80012156:	6e 09       	ld.w	r9,r7[0x0]
80012158:	16 19       	sub	r9,r11
8001215a:	50 09       	stdsp	sp[0x0],r9
8001215c:	6e 59       	ld.w	r9,r7[0x14]
8001215e:	10 9c       	mov	r12,r8
80012160:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80012164:	30 28       	mov	r8,2
80012166:	f4 08 0c 08 	divs	r8,r10,r8
8001216a:	fa e9 00 04 	st.d	sp[4],r8
8001216e:	10 94       	mov	r4,r8
80012170:	40 09       	lddsp	r9,sp[0x0]
80012172:	e2 1c 04 00 	andl	r12,0x400,COH
80012176:	2f f9       	sub	r9,-1
80012178:	0c 09       	add	r9,r6
8001217a:	12 38       	cp.w	r8,r9
8001217c:	f2 04 17 30 	movlo	r4,r9
80012180:	58 0c       	cp.w	r12,0
80012182:	c1 10       	breq	800121a4 <__sfvwrite_r+0x10c>
80012184:	08 9b       	mov	r11,r4
80012186:	0a 9c       	mov	r12,r5
80012188:	fe b0 e3 04 	rcall	8000e790 <_malloc_r>
8001218c:	18 92       	mov	r2,r12
8001218e:	c1 50       	breq	800121b8 <__sfvwrite_r+0x120>
80012190:	40 0a       	lddsp	r10,sp[0x0]
80012192:	6e 4b       	ld.w	r11,r7[0x10]
80012194:	fe b0 e5 18 	rcall	8000ebc4 <memcpy>
80012198:	8e 68       	ld.sh	r8,r7[0xc]
8001219a:	e0 18 fb 7f 	andl	r8,0xfb7f
8001219e:	a7 b8       	sbr	r8,0x7
800121a0:	ae 68       	st.h	r7[0xc],r8
800121a2:	c0 e8       	rjmp	800121be <__sfvwrite_r+0x126>
800121a4:	08 9a       	mov	r10,r4
800121a6:	0a 9c       	mov	r12,r5
800121a8:	e0 a0 04 0a 	rcall	800129bc <_realloc_r>
800121ac:	18 92       	mov	r2,r12
800121ae:	c0 81       	brne	800121be <__sfvwrite_r+0x126>
800121b0:	6e 4b       	ld.w	r11,r7[0x10]
800121b2:	0a 9c       	mov	r12,r5
800121b4:	fe b0 e1 82 	rcall	8000e4b8 <_free_r>
800121b8:	30 c8       	mov	r8,12
800121ba:	8b 38       	st.w	r5[0xc],r8
800121bc:	cb 48       	rjmp	80012324 <__sfvwrite_r+0x28c>
800121be:	40 0a       	lddsp	r10,sp[0x0]
800121c0:	40 09       	lddsp	r9,sp[0x0]
800121c2:	e8 0a 01 0a 	sub	r10,r4,r10
800121c6:	e4 09 00 08 	add	r8,r2,r9
800121ca:	8f 54       	st.w	r7[0x14],r4
800121cc:	8f 2a       	st.w	r7[0x8],r10
800121ce:	8f 08       	st.w	r7[0x0],r8
800121d0:	8f 42       	st.w	r7[0x10],r2
800121d2:	0c 94       	mov	r4,r6
800121d4:	08 36       	cp.w	r6,r4
800121d6:	ec 04 17 30 	movlo	r4,r6
800121da:	06 9b       	mov	r11,r3
800121dc:	08 9a       	mov	r10,r4
800121de:	6e 0c       	ld.w	r12,r7[0x0]
800121e0:	cc dc       	rcall	8001237a <memmove>
800121e2:	6e 08       	ld.w	r8,r7[0x0]
800121e4:	08 08       	add	r8,r4
800121e6:	8f 08       	st.w	r7[0x0],r8
800121e8:	6e 28       	ld.w	r8,r7[0x8]
800121ea:	08 18       	sub	r8,r4
800121ec:	0c 94       	mov	r4,r6
800121ee:	8f 28       	st.w	r7[0x8],r8
800121f0:	c2 e8       	rjmp	8001224c <__sfvwrite_r+0x1b4>
800121f2:	08 36       	cp.w	r6,r4
800121f4:	5f ba       	srhi	r10
800121f6:	6e 0c       	ld.w	r12,r7[0x0]
800121f8:	6e 48       	ld.w	r8,r7[0x10]
800121fa:	10 3c       	cp.w	r12,r8
800121fc:	5f b8       	srhi	r8
800121fe:	f5 e8 00 08 	and	r8,r10,r8
80012202:	f2 08 18 00 	cp.b	r8,r9
80012206:	c0 d0       	breq	80012220 <__sfvwrite_r+0x188>
80012208:	06 9b       	mov	r11,r3
8001220a:	08 9a       	mov	r10,r4
8001220c:	cb 7c       	rcall	8001237a <memmove>
8001220e:	6e 08       	ld.w	r8,r7[0x0]
80012210:	08 08       	add	r8,r4
80012212:	0e 9b       	mov	r11,r7
80012214:	8f 08       	st.w	r7[0x0],r8
80012216:	0a 9c       	mov	r12,r5
80012218:	fe b0 df de 	rcall	8000e1d4 <_fflush_r>
8001221c:	c1 80       	breq	8001224c <__sfvwrite_r+0x1b4>
8001221e:	c8 38       	rjmp	80012324 <__sfvwrite_r+0x28c>
80012220:	6e 59       	ld.w	r9,r7[0x14]
80012222:	12 36       	cp.w	r6,r9
80012224:	c0 a3       	brcs	80012238 <__sfvwrite_r+0x1a0>
80012226:	6e a8       	ld.w	r8,r7[0x28]
80012228:	06 9a       	mov	r10,r3
8001222a:	6e 8b       	ld.w	r11,r7[0x20]
8001222c:	0a 9c       	mov	r12,r5
8001222e:	5d 18       	icall	r8
80012230:	18 94       	mov	r4,r12
80012232:	e0 89 00 0d 	brgt	8001224c <__sfvwrite_r+0x1b4>
80012236:	c7 78       	rjmp	80012324 <__sfvwrite_r+0x28c>
80012238:	0c 9a       	mov	r10,r6
8001223a:	06 9b       	mov	r11,r3
8001223c:	c9 fc       	rcall	8001237a <memmove>
8001223e:	6e 08       	ld.w	r8,r7[0x0]
80012240:	0c 08       	add	r8,r6
80012242:	0c 94       	mov	r4,r6
80012244:	8f 08       	st.w	r7[0x0],r8
80012246:	6e 28       	ld.w	r8,r7[0x8]
80012248:	0c 18       	sub	r8,r6
8001224a:	8f 28       	st.w	r7[0x8],r8
8001224c:	62 28       	ld.w	r8,r1[0x8]
8001224e:	08 18       	sub	r8,r4
80012250:	83 28       	st.w	r1[0x8],r8
80012252:	c6 e0       	breq	8001232e <__sfvwrite_r+0x296>
80012254:	08 16       	sub	r6,r4
80012256:	08 03       	add	r3,r4
80012258:	c7 0b       	rjmp	80012138 <__sfvwrite_r+0xa0>
8001225a:	60 03       	ld.w	r3,r0[0x0]
8001225c:	60 11       	ld.w	r1,r0[0x4]
8001225e:	30 08       	mov	r8,0
80012260:	2f 80       	sub	r0,-8
80012262:	50 08       	stdsp	sp[0x0],r8
80012264:	58 01       	cp.w	r1,0
80012266:	cf a0       	breq	8001225a <__sfvwrite_r+0x1c2>
80012268:	40 0a       	lddsp	r10,sp[0x0]
8001226a:	58 0a       	cp.w	r10,0
8001226c:	c1 71       	brne	8001229a <__sfvwrite_r+0x202>
8001226e:	02 9a       	mov	r10,r1
80012270:	30 ab       	mov	r11,10
80012272:	06 9c       	mov	r12,r3
80012274:	c7 8c       	rcall	80012364 <memchr>
80012276:	f9 b8 01 01 	movne	r8,1
8001227a:	f9 d8 e1 06 	addne	r6,r12,r8
8001227e:	ed d3 e1 16 	subne	r6,r6,r3
80012282:	f9 b9 01 01 	movne	r9,1
80012286:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001228a:	f9 b8 00 01 	moveq	r8,1
8001228e:	e3 d8 e0 06 	addeq	r6,r1,r8
80012292:	f9 b8 00 01 	moveq	r8,1
80012296:	fb f8 0a 00 	st.weq	sp[0x0],r8
8001229a:	02 36       	cp.w	r6,r1
8001229c:	ec 04 17 80 	movls	r4,r6
800122a0:	e2 04 17 b0 	movhi	r4,r1
800122a4:	6e 59       	ld.w	r9,r7[0x14]
800122a6:	6e 25       	ld.w	r5,r7[0x8]
800122a8:	f2 05 00 05 	add	r5,r9,r5
800122ac:	0a 34       	cp.w	r4,r5
800122ae:	5f 9a       	srgt	r10
800122b0:	6e 0c       	ld.w	r12,r7[0x0]
800122b2:	6e 48       	ld.w	r8,r7[0x10]
800122b4:	10 3c       	cp.w	r12,r8
800122b6:	5f b8       	srhi	r8
800122b8:	f5 e8 00 08 	and	r8,r10,r8
800122bc:	30 0a       	mov	r10,0
800122be:	f4 08 18 00 	cp.b	r8,r10
800122c2:	c0 d0       	breq	800122dc <__sfvwrite_r+0x244>
800122c4:	06 9b       	mov	r11,r3
800122c6:	0a 9a       	mov	r10,r5
800122c8:	c5 9c       	rcall	8001237a <memmove>
800122ca:	6e 08       	ld.w	r8,r7[0x0]
800122cc:	0a 08       	add	r8,r5
800122ce:	0e 9b       	mov	r11,r7
800122d0:	8f 08       	st.w	r7[0x0],r8
800122d2:	40 1c       	lddsp	r12,sp[0x4]
800122d4:	fe b0 df 80 	rcall	8000e1d4 <_fflush_r>
800122d8:	c1 70       	breq	80012306 <__sfvwrite_r+0x26e>
800122da:	c2 58       	rjmp	80012324 <__sfvwrite_r+0x28c>
800122dc:	12 34       	cp.w	r4,r9
800122de:	c0 a5       	brlt	800122f2 <__sfvwrite_r+0x25a>
800122e0:	6e a8       	ld.w	r8,r7[0x28]
800122e2:	06 9a       	mov	r10,r3
800122e4:	6e 8b       	ld.w	r11,r7[0x20]
800122e6:	40 1c       	lddsp	r12,sp[0x4]
800122e8:	5d 18       	icall	r8
800122ea:	18 95       	mov	r5,r12
800122ec:	e0 89 00 0d 	brgt	80012306 <__sfvwrite_r+0x26e>
800122f0:	c1 a8       	rjmp	80012324 <__sfvwrite_r+0x28c>
800122f2:	08 9a       	mov	r10,r4
800122f4:	06 9b       	mov	r11,r3
800122f6:	c4 2c       	rcall	8001237a <memmove>
800122f8:	6e 08       	ld.w	r8,r7[0x0]
800122fa:	08 08       	add	r8,r4
800122fc:	08 95       	mov	r5,r4
800122fe:	8f 08       	st.w	r7[0x0],r8
80012300:	6e 28       	ld.w	r8,r7[0x8]
80012302:	08 18       	sub	r8,r4
80012304:	8f 28       	st.w	r7[0x8],r8
80012306:	0a 16       	sub	r6,r5
80012308:	c0 71       	brne	80012316 <__sfvwrite_r+0x27e>
8001230a:	0e 9b       	mov	r11,r7
8001230c:	40 1c       	lddsp	r12,sp[0x4]
8001230e:	fe b0 df 63 	rcall	8000e1d4 <_fflush_r>
80012312:	c0 91       	brne	80012324 <__sfvwrite_r+0x28c>
80012314:	50 06       	stdsp	sp[0x0],r6
80012316:	64 28       	ld.w	r8,r2[0x8]
80012318:	0a 18       	sub	r8,r5
8001231a:	85 28       	st.w	r2[0x8],r8
8001231c:	c0 90       	breq	8001232e <__sfvwrite_r+0x296>
8001231e:	0a 11       	sub	r1,r5
80012320:	0a 03       	add	r3,r5
80012322:	ca 1b       	rjmp	80012264 <__sfvwrite_r+0x1cc>
80012324:	8e 68       	ld.sh	r8,r7[0xc]
80012326:	a7 a8       	sbr	r8,0x6
80012328:	ae 68       	st.h	r7[0xc],r8
8001232a:	3f fc       	mov	r12,-1
8001232c:	c0 28       	rjmp	80012330 <__sfvwrite_r+0x298>
8001232e:	30 0c       	mov	r12,0
80012330:	2f dd       	sub	sp,-12
80012332:	d8 32       	popm	r0-r7,pc

80012334 <_localeconv_r>:
80012334:	fe cc cf 24 	sub	r12,pc,-12508
80012338:	5e fc       	retal	r12
8001233a:	d7 03       	nop

8001233c <_lseek_r>:
8001233c:	d4 21       	pushm	r4-r7,lr
8001233e:	16 98       	mov	r8,r11
80012340:	18 97       	mov	r7,r12
80012342:	10 9c       	mov	r12,r8
80012344:	30 08       	mov	r8,0
80012346:	14 9b       	mov	r11,r10
80012348:	e0 66 79 98 	mov	r6,31128
8001234c:	12 9a       	mov	r10,r9
8001234e:	8d 08       	st.w	r6[0x0],r8
80012350:	fe b0 e5 fc 	rcall	8000ef48 <_lseek>
80012354:	5b fc       	cp.w	r12,-1
80012356:	c0 51       	brne	80012360 <_lseek_r+0x24>
80012358:	6c 08       	ld.w	r8,r6[0x0]
8001235a:	58 08       	cp.w	r8,0
8001235c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80012360:	d8 22       	popm	r4-r7,pc
80012362:	d7 03       	nop

80012364 <memchr>:
80012364:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80012368:	c0 68       	rjmp	80012374 <memchr+0x10>
8001236a:	20 1a       	sub	r10,1
8001236c:	19 88       	ld.ub	r8,r12[0x0]
8001236e:	16 38       	cp.w	r8,r11
80012370:	5e 0c       	reteq	r12
80012372:	2f fc       	sub	r12,-1
80012374:	58 0a       	cp.w	r10,0
80012376:	cf a1       	brne	8001236a <memchr+0x6>
80012378:	5e fa       	retal	r10

8001237a <memmove>:
8001237a:	d4 01       	pushm	lr
8001237c:	18 3b       	cp.w	r11,r12
8001237e:	c1 92       	brcc	800123b0 <memmove+0x36>
80012380:	f6 0a 00 09 	add	r9,r11,r10
80012384:	12 3c       	cp.w	r12,r9
80012386:	c1 52       	brcc	800123b0 <memmove+0x36>
80012388:	f8 0a 00 0b 	add	r11,r12,r10
8001238c:	30 08       	mov	r8,0
8001238e:	c0 68       	rjmp	8001239a <memmove+0x20>
80012390:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80012394:	20 1a       	sub	r10,1
80012396:	f6 08 0b 0e 	st.b	r11[r8],lr
8001239a:	20 18       	sub	r8,1
8001239c:	58 0a       	cp.w	r10,0
8001239e:	cf 91       	brne	80012390 <memmove+0x16>
800123a0:	d8 02       	popm	pc
800123a2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800123a6:	20 1a       	sub	r10,1
800123a8:	f8 08 0b 09 	st.b	r12[r8],r9
800123ac:	2f f8       	sub	r8,-1
800123ae:	c0 28       	rjmp	800123b2 <memmove+0x38>
800123b0:	30 08       	mov	r8,0
800123b2:	58 0a       	cp.w	r10,0
800123b4:	cf 71       	brne	800123a2 <memmove+0x28>
800123b6:	d8 02       	popm	pc

800123b8 <__hi0bits>:
800123b8:	18 98       	mov	r8,r12
800123ba:	e0 1c 00 00 	andl	r12,0x0
800123be:	f0 09 15 10 	lsl	r9,r8,0x10
800123c2:	58 0c       	cp.w	r12,0
800123c4:	f2 08 17 00 	moveq	r8,r9
800123c8:	f9 bc 00 10 	moveq	r12,16
800123cc:	f9 bc 01 00 	movne	r12,0
800123d0:	10 9a       	mov	r10,r8
800123d2:	f0 09 15 08 	lsl	r9,r8,0x8
800123d6:	e6 1a ff 00 	andh	r10,0xff00,COH
800123da:	f7 bc 00 f8 	subeq	r12,-8
800123de:	f2 08 17 00 	moveq	r8,r9
800123e2:	10 9a       	mov	r10,r8
800123e4:	f0 09 15 04 	lsl	r9,r8,0x4
800123e8:	e6 1a f0 00 	andh	r10,0xf000,COH
800123ec:	f7 bc 00 fc 	subeq	r12,-4
800123f0:	f2 08 17 00 	moveq	r8,r9
800123f4:	10 9a       	mov	r10,r8
800123f6:	f0 09 15 02 	lsl	r9,r8,0x2
800123fa:	e6 1a c0 00 	andh	r10,0xc000,COH
800123fe:	f7 bc 00 fe 	subeq	r12,-2
80012402:	f2 08 17 00 	moveq	r8,r9
80012406:	58 08       	cp.w	r8,0
80012408:	5e 5c       	retlt	r12
8001240a:	ed b8 00 1e 	bld	r8,0x1e
8001240e:	f9 bc 01 20 	movne	r12,32
80012412:	f7 bc 00 ff 	subeq	r12,-1
80012416:	5e fc       	retal	r12

80012418 <__lo0bits>:
80012418:	18 99       	mov	r9,r12
8001241a:	78 08       	ld.w	r8,r12[0x0]
8001241c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
80012420:	c1 50       	breq	8001244a <__lo0bits+0x32>
80012422:	ed b8 00 00 	bld	r8,0x0
80012426:	c0 21       	brne	8001242a <__lo0bits+0x12>
80012428:	5e fd       	retal	0
8001242a:	10 9b       	mov	r11,r8
8001242c:	f0 0a 16 01 	lsr	r10,r8,0x1
80012430:	e2 1b 00 02 	andl	r11,0x2,COH
80012434:	a3 88       	lsr	r8,0x2
80012436:	58 0b       	cp.w	r11,0
80012438:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8001243c:	f9 bc 01 01 	movne	r12,1
80012440:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80012444:	f9 bc 00 02 	moveq	r12,2
80012448:	5e fc       	retal	r12
8001244a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8001244e:	f0 0b 16 10 	lsr	r11,r8,0x10
80012452:	58 0a       	cp.w	r10,0
80012454:	f6 08 17 00 	moveq	r8,r11
80012458:	f9 bc 00 10 	moveq	r12,16
8001245c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80012460:	f0 0a 16 08 	lsr	r10,r8,0x8
80012464:	58 0b       	cp.w	r11,0
80012466:	f7 bc 00 f8 	subeq	r12,-8
8001246a:	f4 08 17 00 	moveq	r8,r10
8001246e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
80012472:	f0 0a 16 04 	lsr	r10,r8,0x4
80012476:	58 0b       	cp.w	r11,0
80012478:	f7 bc 00 fc 	subeq	r12,-4
8001247c:	f4 08 17 00 	moveq	r8,r10
80012480:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
80012484:	f0 0a 16 02 	lsr	r10,r8,0x2
80012488:	58 0b       	cp.w	r11,0
8001248a:	f7 bc 00 fe 	subeq	r12,-2
8001248e:	f4 08 17 00 	moveq	r8,r10
80012492:	ed b8 00 00 	bld	r8,0x0
80012496:	c0 60       	breq	800124a2 <__lo0bits+0x8a>
80012498:	a1 98       	lsr	r8,0x1
8001249a:	c0 31       	brne	800124a0 <__lo0bits+0x88>
8001249c:	32 0c       	mov	r12,32
8001249e:	5e fc       	retal	r12
800124a0:	2f fc       	sub	r12,-1
800124a2:	93 08       	st.w	r9[0x0],r8
800124a4:	5e fc       	retal	r12

800124a6 <__mcmp>:
800124a6:	d4 01       	pushm	lr
800124a8:	18 98       	mov	r8,r12
800124aa:	76 49       	ld.w	r9,r11[0x10]
800124ac:	78 4c       	ld.w	r12,r12[0x10]
800124ae:	12 1c       	sub	r12,r9
800124b0:	c1 31       	brne	800124d6 <__mcmp+0x30>
800124b2:	2f b9       	sub	r9,-5
800124b4:	a3 69       	lsl	r9,0x2
800124b6:	12 0b       	add	r11,r9
800124b8:	f0 09 00 09 	add	r9,r8,r9
800124bc:	2e c8       	sub	r8,-20
800124be:	13 4e       	ld.w	lr,--r9
800124c0:	17 4a       	ld.w	r10,--r11
800124c2:	14 3e       	cp.w	lr,r10
800124c4:	c0 60       	breq	800124d0 <__mcmp+0x2a>
800124c6:	f9 bc 03 ff 	movlo	r12,-1
800124ca:	f9 bc 02 01 	movhs	r12,1
800124ce:	d8 02       	popm	pc
800124d0:	10 39       	cp.w	r9,r8
800124d2:	fe 9b ff f6 	brhi	800124be <__mcmp+0x18>
800124d6:	d8 02       	popm	pc

800124d8 <_Bfree>:
800124d8:	d4 21       	pushm	r4-r7,lr
800124da:	18 97       	mov	r7,r12
800124dc:	16 95       	mov	r5,r11
800124de:	78 96       	ld.w	r6,r12[0x24]
800124e0:	58 06       	cp.w	r6,0
800124e2:	c0 91       	brne	800124f4 <_Bfree+0x1c>
800124e4:	31 0c       	mov	r12,16
800124e6:	fe b0 e1 4d 	rcall	8000e780 <malloc>
800124ea:	99 36       	st.w	r12[0xc],r6
800124ec:	8f 9c       	st.w	r7[0x24],r12
800124ee:	99 16       	st.w	r12[0x4],r6
800124f0:	99 26       	st.w	r12[0x8],r6
800124f2:	99 06       	st.w	r12[0x0],r6
800124f4:	58 05       	cp.w	r5,0
800124f6:	c0 90       	breq	80012508 <_Bfree+0x30>
800124f8:	6a 19       	ld.w	r9,r5[0x4]
800124fa:	6e 98       	ld.w	r8,r7[0x24]
800124fc:	70 38       	ld.w	r8,r8[0xc]
800124fe:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80012502:	8b 0a       	st.w	r5[0x0],r10
80012504:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
80012508:	d8 22       	popm	r4-r7,pc
8001250a:	d7 03       	nop

8001250c <_Balloc>:
8001250c:	d4 21       	pushm	r4-r7,lr
8001250e:	18 97       	mov	r7,r12
80012510:	16 96       	mov	r6,r11
80012512:	78 95       	ld.w	r5,r12[0x24]
80012514:	58 05       	cp.w	r5,0
80012516:	c0 91       	brne	80012528 <_Balloc+0x1c>
80012518:	31 0c       	mov	r12,16
8001251a:	fe b0 e1 33 	rcall	8000e780 <malloc>
8001251e:	99 35       	st.w	r12[0xc],r5
80012520:	8f 9c       	st.w	r7[0x24],r12
80012522:	99 15       	st.w	r12[0x4],r5
80012524:	99 25       	st.w	r12[0x8],r5
80012526:	99 05       	st.w	r12[0x0],r5
80012528:	6e 95       	ld.w	r5,r7[0x24]
8001252a:	6a 38       	ld.w	r8,r5[0xc]
8001252c:	58 08       	cp.w	r8,0
8001252e:	c0 b1       	brne	80012544 <_Balloc+0x38>
80012530:	31 0a       	mov	r10,16
80012532:	30 4b       	mov	r11,4
80012534:	0e 9c       	mov	r12,r7
80012536:	e0 a0 03 c9 	rcall	80012cc8 <_calloc_r>
8001253a:	8b 3c       	st.w	r5[0xc],r12
8001253c:	6e 98       	ld.w	r8,r7[0x24]
8001253e:	70 3c       	ld.w	r12,r8[0xc]
80012540:	58 0c       	cp.w	r12,0
80012542:	c1 b0       	breq	80012578 <_Balloc+0x6c>
80012544:	6e 98       	ld.w	r8,r7[0x24]
80012546:	70 38       	ld.w	r8,r8[0xc]
80012548:	f0 06 00 28 	add	r8,r8,r6<<0x2
8001254c:	70 0c       	ld.w	r12,r8[0x0]
8001254e:	58 0c       	cp.w	r12,0
80012550:	c0 40       	breq	80012558 <_Balloc+0x4c>
80012552:	78 09       	ld.w	r9,r12[0x0]
80012554:	91 09       	st.w	r8[0x0],r9
80012556:	c0 e8       	rjmp	80012572 <_Balloc+0x66>
80012558:	0e 9c       	mov	r12,r7
8001255a:	30 17       	mov	r7,1
8001255c:	0e 9b       	mov	r11,r7
8001255e:	ee 06 09 47 	lsl	r7,r7,r6
80012562:	ee ca ff fb 	sub	r10,r7,-5
80012566:	a3 6a       	lsl	r10,0x2
80012568:	e0 a0 03 b0 	rcall	80012cc8 <_calloc_r>
8001256c:	c0 60       	breq	80012578 <_Balloc+0x6c>
8001256e:	99 16       	st.w	r12[0x4],r6
80012570:	99 27       	st.w	r12[0x8],r7
80012572:	30 08       	mov	r8,0
80012574:	99 38       	st.w	r12[0xc],r8
80012576:	99 48       	st.w	r12[0x10],r8
80012578:	d8 22       	popm	r4-r7,pc
8001257a:	d7 03       	nop

8001257c <__d2b>:
8001257c:	d4 31       	pushm	r0-r7,lr
8001257e:	20 2d       	sub	sp,8
80012580:	16 93       	mov	r3,r11
80012582:	12 96       	mov	r6,r9
80012584:	10 95       	mov	r5,r8
80012586:	14 92       	mov	r2,r10
80012588:	30 1b       	mov	r11,1
8001258a:	cc 1f       	rcall	8001250c <_Balloc>
8001258c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
80012590:	50 09       	stdsp	sp[0x0],r9
80012592:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
80012596:	f0 01 16 14 	lsr	r1,r8,0x14
8001259a:	fc 1a 00 10 	movh	r10,0x10
8001259e:	f3 da e1 39 	orne	r9,r9,r10
800125a2:	fb f9 1a 00 	st.wne	sp[0x0],r9
800125a6:	18 94       	mov	r4,r12
800125a8:	58 02       	cp.w	r2,0
800125aa:	c1 d0       	breq	800125e4 <__d2b+0x68>
800125ac:	fa cc ff f8 	sub	r12,sp,-8
800125b0:	18 d2       	st.w	--r12,r2
800125b2:	c3 3f       	rcall	80012418 <__lo0bits>
800125b4:	40 18       	lddsp	r8,sp[0x4]
800125b6:	c0 d0       	breq	800125d0 <__d2b+0x54>
800125b8:	40 09       	lddsp	r9,sp[0x0]
800125ba:	f8 0a 11 20 	rsub	r10,r12,32
800125be:	f2 0a 09 4a 	lsl	r10,r9,r10
800125c2:	f5 e8 10 08 	or	r8,r10,r8
800125c6:	89 58       	st.w	r4[0x14],r8
800125c8:	f2 0c 0a 49 	lsr	r9,r9,r12
800125cc:	50 09       	stdsp	sp[0x0],r9
800125ce:	c0 28       	rjmp	800125d2 <__d2b+0x56>
800125d0:	89 58       	st.w	r4[0x14],r8
800125d2:	40 08       	lddsp	r8,sp[0x0]
800125d4:	58 08       	cp.w	r8,0
800125d6:	f9 b3 01 02 	movne	r3,2
800125da:	f9 b3 00 01 	moveq	r3,1
800125de:	89 68       	st.w	r4[0x18],r8
800125e0:	89 43       	st.w	r4[0x10],r3
800125e2:	c0 88       	rjmp	800125f2 <__d2b+0x76>
800125e4:	1a 9c       	mov	r12,sp
800125e6:	c1 9f       	rcall	80012418 <__lo0bits>
800125e8:	30 13       	mov	r3,1
800125ea:	40 08       	lddsp	r8,sp[0x0]
800125ec:	2e 0c       	sub	r12,-32
800125ee:	89 43       	st.w	r4[0x10],r3
800125f0:	89 58       	st.w	r4[0x14],r8
800125f2:	58 01       	cp.w	r1,0
800125f4:	c0 90       	breq	80012606 <__d2b+0x8a>
800125f6:	e2 c1 04 33 	sub	r1,r1,1075
800125fa:	18 01       	add	r1,r12
800125fc:	8d 01       	st.w	r6[0x0],r1
800125fe:	f8 0c 11 35 	rsub	r12,r12,53
80012602:	8b 0c       	st.w	r5[0x0],r12
80012604:	c0 c8       	rjmp	8001261c <__d2b+0xa0>
80012606:	e6 c8 ff fc 	sub	r8,r3,-4
8001260a:	f8 cc 04 32 	sub	r12,r12,1074
8001260e:	a5 73       	lsl	r3,0x5
80012610:	8d 0c       	st.w	r6[0x0],r12
80012612:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80012616:	cd 1e       	rcall	800123b8 <__hi0bits>
80012618:	18 13       	sub	r3,r12
8001261a:	8b 03       	st.w	r5[0x0],r3
8001261c:	08 9c       	mov	r12,r4
8001261e:	2f ed       	sub	sp,-8
80012620:	d8 32       	popm	r0-r7,pc
80012622:	d7 03       	nop

80012624 <__mdiff>:
80012624:	d4 31       	pushm	r0-r7,lr
80012626:	74 48       	ld.w	r8,r10[0x10]
80012628:	76 45       	ld.w	r5,r11[0x10]
8001262a:	16 97       	mov	r7,r11
8001262c:	14 96       	mov	r6,r10
8001262e:	10 15       	sub	r5,r8
80012630:	c1 31       	brne	80012656 <__mdiff+0x32>
80012632:	2f b8       	sub	r8,-5
80012634:	ee ce ff ec 	sub	lr,r7,-20
80012638:	a3 68       	lsl	r8,0x2
8001263a:	f4 08 00 0b 	add	r11,r10,r8
8001263e:	ee 08 00 08 	add	r8,r7,r8
80012642:	11 4a       	ld.w	r10,--r8
80012644:	17 49       	ld.w	r9,--r11
80012646:	12 3a       	cp.w	r10,r9
80012648:	c0 30       	breq	8001264e <__mdiff+0x2a>
8001264a:	c0 e2       	brcc	80012666 <__mdiff+0x42>
8001264c:	c0 78       	rjmp	8001265a <__mdiff+0x36>
8001264e:	1c 38       	cp.w	r8,lr
80012650:	fe 9b ff f9 	brhi	80012642 <__mdiff+0x1e>
80012654:	c4 98       	rjmp	800126e6 <__mdiff+0xc2>
80012656:	58 05       	cp.w	r5,0
80012658:	c0 64       	brge	80012664 <__mdiff+0x40>
8001265a:	0e 98       	mov	r8,r7
8001265c:	30 15       	mov	r5,1
8001265e:	0c 97       	mov	r7,r6
80012660:	10 96       	mov	r6,r8
80012662:	c0 28       	rjmp	80012666 <__mdiff+0x42>
80012664:	30 05       	mov	r5,0
80012666:	6e 1b       	ld.w	r11,r7[0x4]
80012668:	c5 2f       	rcall	8001250c <_Balloc>
8001266a:	6e 49       	ld.w	r9,r7[0x10]
8001266c:	6c 44       	ld.w	r4,r6[0x10]
8001266e:	99 35       	st.w	r12[0xc],r5
80012670:	2f b4       	sub	r4,-5
80012672:	f2 c5 ff fb 	sub	r5,r9,-5
80012676:	ec 04 00 24 	add	r4,r6,r4<<0x2
8001267a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8001267e:	2e c6       	sub	r6,-20
80012680:	2e c7       	sub	r7,-20
80012682:	f8 c8 ff ec 	sub	r8,r12,-20
80012686:	30 0a       	mov	r10,0
80012688:	0f 0e       	ld.w	lr,r7++
8001268a:	0d 0b       	ld.w	r11,r6++
8001268c:	fc 02 16 10 	lsr	r2,lr,0x10
80012690:	f6 03 16 10 	lsr	r3,r11,0x10
80012694:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80012698:	e4 03 01 03 	sub	r3,r2,r3
8001269c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800126a0:	fc 0b 01 0b 	sub	r11,lr,r11
800126a4:	f6 0a 00 0a 	add	r10,r11,r10
800126a8:	b0 1a       	st.h	r8[0x2],r10
800126aa:	b1 4a       	asr	r10,0x10
800126ac:	e6 0a 00 0a 	add	r10,r3,r10
800126b0:	b0 0a       	st.h	r8[0x0],r10
800126b2:	2f c8       	sub	r8,-4
800126b4:	b1 4a       	asr	r10,0x10
800126b6:	08 36       	cp.w	r6,r4
800126b8:	ce 83       	brcs	80012688 <__mdiff+0x64>
800126ba:	c0 d8       	rjmp	800126d4 <__mdiff+0xb0>
800126bc:	0f 0b       	ld.w	r11,r7++
800126be:	f6 0e 16 10 	lsr	lr,r11,0x10
800126c2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800126c6:	16 0a       	add	r10,r11
800126c8:	b0 1a       	st.h	r8[0x2],r10
800126ca:	b1 4a       	asr	r10,0x10
800126cc:	1c 0a       	add	r10,lr
800126ce:	b0 0a       	st.h	r8[0x0],r10
800126d0:	2f c8       	sub	r8,-4
800126d2:	b1 4a       	asr	r10,0x10
800126d4:	0a 37       	cp.w	r7,r5
800126d6:	cf 33       	brcs	800126bc <__mdiff+0x98>
800126d8:	c0 28       	rjmp	800126dc <__mdiff+0xb8>
800126da:	20 19       	sub	r9,1
800126dc:	11 4a       	ld.w	r10,--r8
800126de:	58 0a       	cp.w	r10,0
800126e0:	cf d0       	breq	800126da <__mdiff+0xb6>
800126e2:	99 49       	st.w	r12[0x10],r9
800126e4:	d8 32       	popm	r0-r7,pc
800126e6:	30 0b       	mov	r11,0
800126e8:	c1 2f       	rcall	8001250c <_Balloc>
800126ea:	30 18       	mov	r8,1
800126ec:	99 48       	st.w	r12[0x10],r8
800126ee:	30 08       	mov	r8,0
800126f0:	99 58       	st.w	r12[0x14],r8
800126f2:	d8 32       	popm	r0-r7,pc

800126f4 <__lshift>:
800126f4:	d4 31       	pushm	r0-r7,lr
800126f6:	16 97       	mov	r7,r11
800126f8:	76 46       	ld.w	r6,r11[0x10]
800126fa:	f4 02 14 05 	asr	r2,r10,0x5
800126fe:	2f f6       	sub	r6,-1
80012700:	14 93       	mov	r3,r10
80012702:	18 94       	mov	r4,r12
80012704:	04 06       	add	r6,r2
80012706:	76 1b       	ld.w	r11,r11[0x4]
80012708:	6e 28       	ld.w	r8,r7[0x8]
8001270a:	c0 38       	rjmp	80012710 <__lshift+0x1c>
8001270c:	2f fb       	sub	r11,-1
8001270e:	a1 78       	lsl	r8,0x1
80012710:	10 36       	cp.w	r6,r8
80012712:	fe 99 ff fd 	brgt	8001270c <__lshift+0x18>
80012716:	08 9c       	mov	r12,r4
80012718:	cf ae       	rcall	8001250c <_Balloc>
8001271a:	30 09       	mov	r9,0
8001271c:	18 95       	mov	r5,r12
8001271e:	f8 c8 ff ec 	sub	r8,r12,-20
80012722:	12 9a       	mov	r10,r9
80012724:	c0 38       	rjmp	8001272a <__lshift+0x36>
80012726:	10 aa       	st.w	r8++,r10
80012728:	2f f9       	sub	r9,-1
8001272a:	04 39       	cp.w	r9,r2
8001272c:	cf d5       	brlt	80012726 <__lshift+0x32>
8001272e:	6e 4b       	ld.w	r11,r7[0x10]
80012730:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
80012734:	2f bb       	sub	r11,-5
80012736:	ee c9 ff ec 	sub	r9,r7,-20
8001273a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8001273e:	58 03       	cp.w	r3,0
80012740:	c1 30       	breq	80012766 <__lshift+0x72>
80012742:	e6 0c 11 20 	rsub	r12,r3,32
80012746:	30 0a       	mov	r10,0
80012748:	72 02       	ld.w	r2,r9[0x0]
8001274a:	e4 03 09 42 	lsl	r2,r2,r3
8001274e:	04 4a       	or	r10,r2
80012750:	10 aa       	st.w	r8++,r10
80012752:	13 0a       	ld.w	r10,r9++
80012754:	f4 0c 0a 4a 	lsr	r10,r10,r12
80012758:	16 39       	cp.w	r9,r11
8001275a:	cf 73       	brcs	80012748 <__lshift+0x54>
8001275c:	91 0a       	st.w	r8[0x0],r10
8001275e:	58 0a       	cp.w	r10,0
80012760:	c0 70       	breq	8001276e <__lshift+0x7a>
80012762:	2f f6       	sub	r6,-1
80012764:	c0 58       	rjmp	8001276e <__lshift+0x7a>
80012766:	13 0a       	ld.w	r10,r9++
80012768:	10 aa       	st.w	r8++,r10
8001276a:	16 39       	cp.w	r9,r11
8001276c:	cf d3       	brcs	80012766 <__lshift+0x72>
8001276e:	08 9c       	mov	r12,r4
80012770:	20 16       	sub	r6,1
80012772:	0e 9b       	mov	r11,r7
80012774:	8b 46       	st.w	r5[0x10],r6
80012776:	cb 1e       	rcall	800124d8 <_Bfree>
80012778:	0a 9c       	mov	r12,r5
8001277a:	d8 32       	popm	r0-r7,pc

8001277c <__multiply>:
8001277c:	d4 31       	pushm	r0-r7,lr
8001277e:	20 2d       	sub	sp,8
80012780:	76 49       	ld.w	r9,r11[0x10]
80012782:	74 48       	ld.w	r8,r10[0x10]
80012784:	16 96       	mov	r6,r11
80012786:	14 95       	mov	r5,r10
80012788:	10 39       	cp.w	r9,r8
8001278a:	ec 08 17 50 	movlt	r8,r6
8001278e:	ea 06 17 50 	movlt	r6,r5
80012792:	f0 05 17 50 	movlt	r5,r8
80012796:	6c 28       	ld.w	r8,r6[0x8]
80012798:	76 43       	ld.w	r3,r11[0x10]
8001279a:	74 42       	ld.w	r2,r10[0x10]
8001279c:	76 1b       	ld.w	r11,r11[0x4]
8001279e:	e4 03 00 07 	add	r7,r2,r3
800127a2:	10 37       	cp.w	r7,r8
800127a4:	f7 bb 09 ff 	subgt	r11,-1
800127a8:	cb 2e       	rcall	8001250c <_Balloc>
800127aa:	ee c4 ff fb 	sub	r4,r7,-5
800127ae:	f8 c9 ff ec 	sub	r9,r12,-20
800127b2:	f8 04 00 24 	add	r4,r12,r4<<0x2
800127b6:	30 0a       	mov	r10,0
800127b8:	12 98       	mov	r8,r9
800127ba:	c0 28       	rjmp	800127be <__multiply+0x42>
800127bc:	10 aa       	st.w	r8++,r10
800127be:	08 38       	cp.w	r8,r4
800127c0:	cf e3       	brcs	800127bc <__multiply+0x40>
800127c2:	2f b3       	sub	r3,-5
800127c4:	2f b2       	sub	r2,-5
800127c6:	ec 03 00 23 	add	r3,r6,r3<<0x2
800127ca:	ea 02 00 22 	add	r2,r5,r2<<0x2
800127ce:	ec cb ff ec 	sub	r11,r6,-20
800127d2:	50 12       	stdsp	sp[0x4],r2
800127d4:	ea ca ff ec 	sub	r10,r5,-20
800127d8:	c4 48       	rjmp	80012860 <__multiply+0xe4>
800127da:	94 95       	ld.uh	r5,r10[0x2]
800127dc:	58 05       	cp.w	r5,0
800127de:	c2 00       	breq	8001281e <__multiply+0xa2>
800127e0:	12 98       	mov	r8,r9
800127e2:	16 96       	mov	r6,r11
800127e4:	30 0e       	mov	lr,0
800127e6:	50 09       	stdsp	sp[0x0],r9
800127e8:	0d 02       	ld.w	r2,r6++
800127ea:	e4 00 16 10 	lsr	r0,r2,0x10
800127ee:	70 01       	ld.w	r1,r8[0x0]
800127f0:	70 09       	ld.w	r9,r8[0x0]
800127f2:	b1 81       	lsr	r1,0x10
800127f4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
800127f8:	e0 05 03 41 	mac	r1,r0,r5
800127fc:	ab 32       	mul	r2,r5
800127fe:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
80012802:	00 02       	add	r2,r0
80012804:	e4 0e 00 0e 	add	lr,r2,lr
80012808:	b0 1e       	st.h	r8[0x2],lr
8001280a:	b1 8e       	lsr	lr,0x10
8001280c:	1c 01       	add	r1,lr
8001280e:	b0 01       	st.h	r8[0x0],r1
80012810:	e2 0e 16 10 	lsr	lr,r1,0x10
80012814:	2f c8       	sub	r8,-4
80012816:	06 36       	cp.w	r6,r3
80012818:	ce 83       	brcs	800127e8 <__multiply+0x6c>
8001281a:	40 09       	lddsp	r9,sp[0x0]
8001281c:	91 0e       	st.w	r8[0x0],lr
8001281e:	94 86       	ld.uh	r6,r10[0x0]
80012820:	58 06       	cp.w	r6,0
80012822:	c1 d0       	breq	8001285c <__multiply+0xe0>
80012824:	72 02       	ld.w	r2,r9[0x0]
80012826:	12 98       	mov	r8,r9
80012828:	16 9e       	mov	lr,r11
8001282a:	30 05       	mov	r5,0
8001282c:	b0 12       	st.h	r8[0x2],r2
8001282e:	1d 01       	ld.w	r1,lr++
80012830:	90 82       	ld.uh	r2,r8[0x0]
80012832:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80012836:	ad 30       	mul	r0,r6
80012838:	e0 02 00 02 	add	r2,r0,r2
8001283c:	e4 05 00 05 	add	r5,r2,r5
80012840:	b0 05       	st.h	r8[0x0],r5
80012842:	b1 85       	lsr	r5,0x10
80012844:	b1 81       	lsr	r1,0x10
80012846:	2f c8       	sub	r8,-4
80012848:	ad 31       	mul	r1,r6
8001284a:	90 92       	ld.uh	r2,r8[0x2]
8001284c:	e2 02 00 02 	add	r2,r1,r2
80012850:	0a 02       	add	r2,r5
80012852:	e4 05 16 10 	lsr	r5,r2,0x10
80012856:	06 3e       	cp.w	lr,r3
80012858:	ce a3       	brcs	8001282c <__multiply+0xb0>
8001285a:	91 02       	st.w	r8[0x0],r2
8001285c:	2f ca       	sub	r10,-4
8001285e:	2f c9       	sub	r9,-4
80012860:	40 18       	lddsp	r8,sp[0x4]
80012862:	10 3a       	cp.w	r10,r8
80012864:	cb b3       	brcs	800127da <__multiply+0x5e>
80012866:	c0 28       	rjmp	8001286a <__multiply+0xee>
80012868:	20 17       	sub	r7,1
8001286a:	58 07       	cp.w	r7,0
8001286c:	e0 8a 00 05 	brle	80012876 <__multiply+0xfa>
80012870:	09 48       	ld.w	r8,--r4
80012872:	58 08       	cp.w	r8,0
80012874:	cf a0       	breq	80012868 <__multiply+0xec>
80012876:	99 47       	st.w	r12[0x10],r7
80012878:	2f ed       	sub	sp,-8
8001287a:	d8 32       	popm	r0-r7,pc

8001287c <__i2b>:
8001287c:	d4 21       	pushm	r4-r7,lr
8001287e:	16 97       	mov	r7,r11
80012880:	30 1b       	mov	r11,1
80012882:	c4 5e       	rcall	8001250c <_Balloc>
80012884:	30 19       	mov	r9,1
80012886:	99 57       	st.w	r12[0x14],r7
80012888:	99 49       	st.w	r12[0x10],r9
8001288a:	d8 22       	popm	r4-r7,pc

8001288c <__multadd>:
8001288c:	d4 31       	pushm	r0-r7,lr
8001288e:	30 08       	mov	r8,0
80012890:	12 95       	mov	r5,r9
80012892:	16 97       	mov	r7,r11
80012894:	18 96       	mov	r6,r12
80012896:	76 44       	ld.w	r4,r11[0x10]
80012898:	f6 c9 ff ec 	sub	r9,r11,-20
8001289c:	72 0b       	ld.w	r11,r9[0x0]
8001289e:	f6 0c 16 10 	lsr	r12,r11,0x10
800128a2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800128a6:	f4 0c 02 4c 	mul	r12,r10,r12
800128aa:	f4 0b 03 45 	mac	r5,r10,r11
800128ae:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
800128b2:	b1 85       	lsr	r5,0x10
800128b4:	18 05       	add	r5,r12
800128b6:	ea 0c 15 10 	lsl	r12,r5,0x10
800128ba:	f8 0b 00 0b 	add	r11,r12,r11
800128be:	12 ab       	st.w	r9++,r11
800128c0:	2f f8       	sub	r8,-1
800128c2:	b1 85       	lsr	r5,0x10
800128c4:	08 38       	cp.w	r8,r4
800128c6:	ce b5       	brlt	8001289c <__multadd+0x10>
800128c8:	58 05       	cp.w	r5,0
800128ca:	c1 c0       	breq	80012902 <__multadd+0x76>
800128cc:	6e 28       	ld.w	r8,r7[0x8]
800128ce:	10 34       	cp.w	r4,r8
800128d0:	c1 35       	brlt	800128f6 <__multadd+0x6a>
800128d2:	6e 1b       	ld.w	r11,r7[0x4]
800128d4:	0c 9c       	mov	r12,r6
800128d6:	2f fb       	sub	r11,-1
800128d8:	c1 ae       	rcall	8001250c <_Balloc>
800128da:	6e 4a       	ld.w	r10,r7[0x10]
800128dc:	ee cb ff f4 	sub	r11,r7,-12
800128e0:	18 93       	mov	r3,r12
800128e2:	2f ea       	sub	r10,-2
800128e4:	2f 4c       	sub	r12,-12
800128e6:	a3 6a       	lsl	r10,0x2
800128e8:	fe b0 e1 6e 	rcall	8000ebc4 <memcpy>
800128ec:	0e 9b       	mov	r11,r7
800128ee:	0c 9c       	mov	r12,r6
800128f0:	fe b0 fd f4 	rcall	800124d8 <_Bfree>
800128f4:	06 97       	mov	r7,r3
800128f6:	e8 c8 ff ff 	sub	r8,r4,-1
800128fa:	2f b4       	sub	r4,-5
800128fc:	8f 48       	st.w	r7[0x10],r8
800128fe:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
80012902:	0e 9c       	mov	r12,r7
80012904:	d8 32       	popm	r0-r7,pc
80012906:	d7 03       	nop

80012908 <__pow5mult>:
80012908:	d4 31       	pushm	r0-r7,lr
8001290a:	14 96       	mov	r6,r10
8001290c:	18 97       	mov	r7,r12
8001290e:	16 94       	mov	r4,r11
80012910:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
80012914:	c0 90       	breq	80012926 <__pow5mult+0x1e>
80012916:	20 18       	sub	r8,1
80012918:	fe c9 d4 cc 	sub	r9,pc,-11060
8001291c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
80012920:	30 09       	mov	r9,0
80012922:	cb 5f       	rcall	8001288c <__multadd>
80012924:	18 94       	mov	r4,r12
80012926:	a3 46       	asr	r6,0x2
80012928:	c3 40       	breq	80012990 <__pow5mult+0x88>
8001292a:	6e 95       	ld.w	r5,r7[0x24]
8001292c:	58 05       	cp.w	r5,0
8001292e:	c0 91       	brne	80012940 <__pow5mult+0x38>
80012930:	31 0c       	mov	r12,16
80012932:	fe b0 df 27 	rcall	8000e780 <malloc>
80012936:	99 35       	st.w	r12[0xc],r5
80012938:	8f 9c       	st.w	r7[0x24],r12
8001293a:	99 15       	st.w	r12[0x4],r5
8001293c:	99 25       	st.w	r12[0x8],r5
8001293e:	99 05       	st.w	r12[0x0],r5
80012940:	6e 93       	ld.w	r3,r7[0x24]
80012942:	66 25       	ld.w	r5,r3[0x8]
80012944:	58 05       	cp.w	r5,0
80012946:	c0 c1       	brne	8001295e <__pow5mult+0x56>
80012948:	e0 6b 02 71 	mov	r11,625
8001294c:	0e 9c       	mov	r12,r7
8001294e:	c9 7f       	rcall	8001287c <__i2b>
80012950:	87 2c       	st.w	r3[0x8],r12
80012952:	30 08       	mov	r8,0
80012954:	18 95       	mov	r5,r12
80012956:	99 08       	st.w	r12[0x0],r8
80012958:	c0 38       	rjmp	8001295e <__pow5mult+0x56>
8001295a:	06 9c       	mov	r12,r3
8001295c:	18 95       	mov	r5,r12
8001295e:	ed b6 00 00 	bld	r6,0x0
80012962:	c0 b1       	brne	80012978 <__pow5mult+0x70>
80012964:	08 9b       	mov	r11,r4
80012966:	0a 9a       	mov	r10,r5
80012968:	0e 9c       	mov	r12,r7
8001296a:	c0 9f       	rcall	8001277c <__multiply>
8001296c:	08 9b       	mov	r11,r4
8001296e:	18 93       	mov	r3,r12
80012970:	0e 9c       	mov	r12,r7
80012972:	06 94       	mov	r4,r3
80012974:	fe b0 fd b2 	rcall	800124d8 <_Bfree>
80012978:	a1 56       	asr	r6,0x1
8001297a:	c0 b0       	breq	80012990 <__pow5mult+0x88>
8001297c:	6a 03       	ld.w	r3,r5[0x0]
8001297e:	58 03       	cp.w	r3,0
80012980:	ce d1       	brne	8001295a <__pow5mult+0x52>
80012982:	0a 9a       	mov	r10,r5
80012984:	0a 9b       	mov	r11,r5
80012986:	0e 9c       	mov	r12,r7
80012988:	cf ae       	rcall	8001277c <__multiply>
8001298a:	8b 0c       	st.w	r5[0x0],r12
8001298c:	99 03       	st.w	r12[0x0],r3
8001298e:	ce 7b       	rjmp	8001295c <__pow5mult+0x54>
80012990:	08 9c       	mov	r12,r4
80012992:	d8 32       	popm	r0-r7,pc

80012994 <_read_r>:
80012994:	d4 21       	pushm	r4-r7,lr
80012996:	16 98       	mov	r8,r11
80012998:	18 97       	mov	r7,r12
8001299a:	10 9c       	mov	r12,r8
8001299c:	30 08       	mov	r8,0
8001299e:	14 9b       	mov	r11,r10
800129a0:	e0 66 79 98 	mov	r6,31128
800129a4:	12 9a       	mov	r10,r9
800129a6:	8d 08       	st.w	r6[0x0],r8
800129a8:	fe b0 e2 da 	rcall	8000ef5c <_read>
800129ac:	5b fc       	cp.w	r12,-1
800129ae:	c0 51       	brne	800129b8 <_read_r+0x24>
800129b0:	6c 08       	ld.w	r8,r6[0x0]
800129b2:	58 08       	cp.w	r8,0
800129b4:	ef f8 1a 03 	st.wne	r7[0xc],r8
800129b8:	d8 22       	popm	r4-r7,pc
800129ba:	d7 03       	nop

800129bc <_realloc_r>:
800129bc:	d4 31       	pushm	r0-r7,lr
800129be:	20 1d       	sub	sp,4
800129c0:	16 94       	mov	r4,r11
800129c2:	18 92       	mov	r2,r12
800129c4:	14 9b       	mov	r11,r10
800129c6:	58 04       	cp.w	r4,0
800129c8:	c0 51       	brne	800129d2 <_realloc_r+0x16>
800129ca:	fe b0 de e3 	rcall	8000e790 <_malloc_r>
800129ce:	18 95       	mov	r5,r12
800129d0:	c5 59       	rjmp	80012c7a <_realloc_r+0x2be>
800129d2:	50 0a       	stdsp	sp[0x0],r10
800129d4:	fe b0 e1 a3 	rcall	8000ed1a <__malloc_lock>
800129d8:	40 0b       	lddsp	r11,sp[0x0]
800129da:	e8 c1 00 08 	sub	r1,r4,8
800129de:	f6 c6 ff f5 	sub	r6,r11,-11
800129e2:	62 1c       	ld.w	r12,r1[0x4]
800129e4:	59 66       	cp.w	r6,22
800129e6:	f9 b6 08 10 	movls	r6,16
800129ea:	f9 b8 0b f8 	movhi	r8,-8
800129ee:	ed d8 eb 26 	andhi	r6,r6,r8
800129f2:	16 36       	cp.w	r6,r11
800129f4:	5f 38       	srlo	r8
800129f6:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800129fa:	c0 50       	breq	80012a04 <_realloc_r+0x48>
800129fc:	30 c8       	mov	r8,12
800129fe:	30 05       	mov	r5,0
80012a00:	85 38       	st.w	r2[0xc],r8
80012a02:	c3 c9       	rjmp	80012c7a <_realloc_r+0x2be>
80012a04:	18 90       	mov	r0,r12
80012a06:	e0 10 ff fc 	andl	r0,0xfffc
80012a0a:	0c 30       	cp.w	r0,r6
80012a0c:	e0 84 01 0c 	brge	80012c24 <_realloc_r+0x268>
80012a10:	e0 68 01 64 	mov	r8,356
80012a14:	e2 00 00 09 	add	r9,r1,r0
80012a18:	70 25       	ld.w	r5,r8[0x8]
80012a1a:	0a 39       	cp.w	r9,r5
80012a1c:	c0 90       	breq	80012a2e <_realloc_r+0x72>
80012a1e:	72 1a       	ld.w	r10,r9[0x4]
80012a20:	a1 ca       	cbr	r10,0x0
80012a22:	f2 0a 00 0a 	add	r10,r9,r10
80012a26:	74 1a       	ld.w	r10,r10[0x4]
80012a28:	ed ba 00 00 	bld	r10,0x0
80012a2c:	c2 20       	breq	80012a70 <_realloc_r+0xb4>
80012a2e:	72 1a       	ld.w	r10,r9[0x4]
80012a30:	e0 1a ff fc 	andl	r10,0xfffc
80012a34:	f4 00 00 03 	add	r3,r10,r0
80012a38:	0a 39       	cp.w	r9,r5
80012a3a:	c1 31       	brne	80012a60 <_realloc_r+0xa4>
80012a3c:	ec c7 ff f0 	sub	r7,r6,-16
80012a40:	0e 33       	cp.w	r3,r7
80012a42:	c1 95       	brlt	80012a74 <_realloc_r+0xb8>
80012a44:	e2 06 00 09 	add	r9,r1,r6
80012a48:	0c 13       	sub	r3,r6
80012a4a:	a1 a3       	sbr	r3,0x0
80012a4c:	93 13       	st.w	r9[0x4],r3
80012a4e:	91 29       	st.w	r8[0x8],r9
80012a50:	04 9c       	mov	r12,r2
80012a52:	62 18       	ld.w	r8,r1[0x4]
80012a54:	08 95       	mov	r5,r4
80012a56:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012a5a:	10 46       	or	r6,r8
80012a5c:	83 16       	st.w	r1[0x4],r6
80012a5e:	c0 c9       	rjmp	80012c76 <_realloc_r+0x2ba>
80012a60:	0c 33       	cp.w	r3,r6
80012a62:	c0 95       	brlt	80012a74 <_realloc_r+0xb8>
80012a64:	72 28       	ld.w	r8,r9[0x8]
80012a66:	02 97       	mov	r7,r1
80012a68:	72 39       	ld.w	r9,r9[0xc]
80012a6a:	93 28       	st.w	r9[0x8],r8
80012a6c:	91 39       	st.w	r8[0xc],r9
80012a6e:	cd d8       	rjmp	80012c28 <_realloc_r+0x26c>
80012a70:	30 0a       	mov	r10,0
80012a72:	14 99       	mov	r9,r10
80012a74:	ed bc 00 00 	bld	r12,0x0
80012a78:	e0 80 00 96 	breq	80012ba4 <_realloc_r+0x1e8>
80012a7c:	62 07       	ld.w	r7,r1[0x0]
80012a7e:	e2 07 01 07 	sub	r7,r1,r7
80012a82:	6e 1c       	ld.w	r12,r7[0x4]
80012a84:	e0 1c ff fc 	andl	r12,0xfffc
80012a88:	58 09       	cp.w	r9,0
80012a8a:	c5 70       	breq	80012b38 <_realloc_r+0x17c>
80012a8c:	f8 00 00 03 	add	r3,r12,r0
80012a90:	0a 39       	cp.w	r9,r5
80012a92:	c4 81       	brne	80012b22 <_realloc_r+0x166>
80012a94:	14 03       	add	r3,r10
80012a96:	ec c9 ff f0 	sub	r9,r6,-16
80012a9a:	12 33       	cp.w	r3,r9
80012a9c:	c4 e5       	brlt	80012b38 <_realloc_r+0x17c>
80012a9e:	6e 3a       	ld.w	r10,r7[0xc]
80012aa0:	6e 29       	ld.w	r9,r7[0x8]
80012aa2:	95 29       	st.w	r10[0x8],r9
80012aa4:	93 3a       	st.w	r9[0xc],r10
80012aa6:	ee c5 ff f8 	sub	r5,r7,-8
80012aaa:	e0 ca 00 04 	sub	r10,r0,4
80012aae:	e0 4a 00 24 	cp.w	r10,36
80012ab2:	e0 8b 00 25 	brhi	80012afc <_realloc_r+0x140>
80012ab6:	0a 99       	mov	r9,r5
80012ab8:	59 3a       	cp.w	r10,19
80012aba:	e0 88 00 1a 	brls	80012aee <_realloc_r+0x132>
80012abe:	09 09       	ld.w	r9,r4++
80012ac0:	8b 09       	st.w	r5[0x0],r9
80012ac2:	09 09       	ld.w	r9,r4++
80012ac4:	8f 39       	st.w	r7[0xc],r9
80012ac6:	ee c9 ff f0 	sub	r9,r7,-16
80012aca:	59 ba       	cp.w	r10,27
80012acc:	e0 88 00 11 	brls	80012aee <_realloc_r+0x132>
80012ad0:	09 0b       	ld.w	r11,r4++
80012ad2:	93 0b       	st.w	r9[0x0],r11
80012ad4:	09 09       	ld.w	r9,r4++
80012ad6:	8f 59       	st.w	r7[0x14],r9
80012ad8:	ee c9 ff e8 	sub	r9,r7,-24
80012adc:	e0 4a 00 24 	cp.w	r10,36
80012ae0:	c0 71       	brne	80012aee <_realloc_r+0x132>
80012ae2:	09 0a       	ld.w	r10,r4++
80012ae4:	93 0a       	st.w	r9[0x0],r10
80012ae6:	ee c9 ff e0 	sub	r9,r7,-32
80012aea:	09 0a       	ld.w	r10,r4++
80012aec:	8f 7a       	st.w	r7[0x1c],r10
80012aee:	09 0a       	ld.w	r10,r4++
80012af0:	12 aa       	st.w	r9++,r10
80012af2:	68 0a       	ld.w	r10,r4[0x0]
80012af4:	93 0a       	st.w	r9[0x0],r10
80012af6:	68 1a       	ld.w	r10,r4[0x4]
80012af8:	93 1a       	st.w	r9[0x4],r10
80012afa:	c0 78       	rjmp	80012b08 <_realloc_r+0x14c>
80012afc:	50 08       	stdsp	sp[0x0],r8
80012afe:	08 9b       	mov	r11,r4
80012b00:	0a 9c       	mov	r12,r5
80012b02:	fe b0 fc 3c 	rcall	8001237a <memmove>
80012b06:	40 08       	lddsp	r8,sp[0x0]
80012b08:	ee 06 00 09 	add	r9,r7,r6
80012b0c:	0c 13       	sub	r3,r6
80012b0e:	a1 a3       	sbr	r3,0x0
80012b10:	93 13       	st.w	r9[0x4],r3
80012b12:	91 29       	st.w	r8[0x8],r9
80012b14:	04 9c       	mov	r12,r2
80012b16:	6e 18       	ld.w	r8,r7[0x4]
80012b18:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012b1c:	10 46       	or	r6,r8
80012b1e:	8f 16       	st.w	r7[0x4],r6
80012b20:	ca b8       	rjmp	80012c76 <_realloc_r+0x2ba>
80012b22:	14 03       	add	r3,r10
80012b24:	0c 33       	cp.w	r3,r6
80012b26:	c0 95       	brlt	80012b38 <_realloc_r+0x17c>
80012b28:	72 28       	ld.w	r8,r9[0x8]
80012b2a:	72 39       	ld.w	r9,r9[0xc]
80012b2c:	93 28       	st.w	r9[0x8],r8
80012b2e:	91 39       	st.w	r8[0xc],r9
80012b30:	6e 28       	ld.w	r8,r7[0x8]
80012b32:	6e 39       	ld.w	r9,r7[0xc]
80012b34:	c0 88       	rjmp	80012b44 <_realloc_r+0x188>
80012b36:	d7 03       	nop
80012b38:	f8 00 00 03 	add	r3,r12,r0
80012b3c:	0c 33       	cp.w	r3,r6
80012b3e:	c3 35       	brlt	80012ba4 <_realloc_r+0x1e8>
80012b40:	6e 39       	ld.w	r9,r7[0xc]
80012b42:	6e 28       	ld.w	r8,r7[0x8]
80012b44:	93 28       	st.w	r9[0x8],r8
80012b46:	91 39       	st.w	r8[0xc],r9
80012b48:	e0 ca 00 04 	sub	r10,r0,4
80012b4c:	ee cc ff f8 	sub	r12,r7,-8
80012b50:	e0 4a 00 24 	cp.w	r10,36
80012b54:	e0 8b 00 24 	brhi	80012b9c <_realloc_r+0x1e0>
80012b58:	59 3a       	cp.w	r10,19
80012b5a:	e0 88 00 1a 	brls	80012b8e <_realloc_r+0x1d2>
80012b5e:	09 08       	ld.w	r8,r4++
80012b60:	99 08       	st.w	r12[0x0],r8
80012b62:	09 08       	ld.w	r8,r4++
80012b64:	8f 38       	st.w	r7[0xc],r8
80012b66:	ee cc ff f0 	sub	r12,r7,-16
80012b6a:	59 ba       	cp.w	r10,27
80012b6c:	e0 88 00 11 	brls	80012b8e <_realloc_r+0x1d2>
80012b70:	09 08       	ld.w	r8,r4++
80012b72:	99 08       	st.w	r12[0x0],r8
80012b74:	09 08       	ld.w	r8,r4++
80012b76:	8f 58       	st.w	r7[0x14],r8
80012b78:	ee cc ff e8 	sub	r12,r7,-24
80012b7c:	e0 4a 00 24 	cp.w	r10,36
80012b80:	c0 71       	brne	80012b8e <_realloc_r+0x1d2>
80012b82:	09 08       	ld.w	r8,r4++
80012b84:	99 08       	st.w	r12[0x0],r8
80012b86:	ee cc ff e0 	sub	r12,r7,-32
80012b8a:	09 08       	ld.w	r8,r4++
80012b8c:	8f 78       	st.w	r7[0x1c],r8
80012b8e:	09 08       	ld.w	r8,r4++
80012b90:	18 a8       	st.w	r12++,r8
80012b92:	68 08       	ld.w	r8,r4[0x0]
80012b94:	99 08       	st.w	r12[0x0],r8
80012b96:	68 18       	ld.w	r8,r4[0x4]
80012b98:	99 18       	st.w	r12[0x4],r8
80012b9a:	c4 78       	rjmp	80012c28 <_realloc_r+0x26c>
80012b9c:	08 9b       	mov	r11,r4
80012b9e:	fe b0 fb ee 	rcall	8001237a <memmove>
80012ba2:	c4 38       	rjmp	80012c28 <_realloc_r+0x26c>
80012ba4:	04 9c       	mov	r12,r2
80012ba6:	fe b0 dd f5 	rcall	8000e790 <_malloc_r>
80012baa:	18 95       	mov	r5,r12
80012bac:	c3 a0       	breq	80012c20 <_realloc_r+0x264>
80012bae:	62 18       	ld.w	r8,r1[0x4]
80012bb0:	f8 c9 00 08 	sub	r9,r12,8
80012bb4:	a1 c8       	cbr	r8,0x0
80012bb6:	e2 08 00 08 	add	r8,r1,r8
80012bba:	10 39       	cp.w	r9,r8
80012bbc:	c0 71       	brne	80012bca <_realloc_r+0x20e>
80012bbe:	72 13       	ld.w	r3,r9[0x4]
80012bc0:	02 97       	mov	r7,r1
80012bc2:	e0 13 ff fc 	andl	r3,0xfffc
80012bc6:	00 03       	add	r3,r0
80012bc8:	c3 08       	rjmp	80012c28 <_realloc_r+0x26c>
80012bca:	e0 ca 00 04 	sub	r10,r0,4
80012bce:	e0 4a 00 24 	cp.w	r10,36
80012bd2:	e0 8b 00 20 	brhi	80012c12 <_realloc_r+0x256>
80012bd6:	08 99       	mov	r9,r4
80012bd8:	18 98       	mov	r8,r12
80012bda:	59 3a       	cp.w	r10,19
80012bdc:	e0 88 00 14 	brls	80012c04 <_realloc_r+0x248>
80012be0:	13 0b       	ld.w	r11,r9++
80012be2:	10 ab       	st.w	r8++,r11
80012be4:	13 0b       	ld.w	r11,r9++
80012be6:	10 ab       	st.w	r8++,r11
80012be8:	59 ba       	cp.w	r10,27
80012bea:	e0 88 00 0d 	brls	80012c04 <_realloc_r+0x248>
80012bee:	13 0b       	ld.w	r11,r9++
80012bf0:	10 ab       	st.w	r8++,r11
80012bf2:	13 0b       	ld.w	r11,r9++
80012bf4:	10 ab       	st.w	r8++,r11
80012bf6:	e0 4a 00 24 	cp.w	r10,36
80012bfa:	c0 51       	brne	80012c04 <_realloc_r+0x248>
80012bfc:	13 0a       	ld.w	r10,r9++
80012bfe:	10 aa       	st.w	r8++,r10
80012c00:	13 0a       	ld.w	r10,r9++
80012c02:	10 aa       	st.w	r8++,r10
80012c04:	13 0a       	ld.w	r10,r9++
80012c06:	10 aa       	st.w	r8++,r10
80012c08:	72 0a       	ld.w	r10,r9[0x0]
80012c0a:	91 0a       	st.w	r8[0x0],r10
80012c0c:	72 19       	ld.w	r9,r9[0x4]
80012c0e:	91 19       	st.w	r8[0x4],r9
80012c10:	c0 48       	rjmp	80012c18 <_realloc_r+0x25c>
80012c12:	08 9b       	mov	r11,r4
80012c14:	fe b0 fb b3 	rcall	8001237a <memmove>
80012c18:	08 9b       	mov	r11,r4
80012c1a:	04 9c       	mov	r12,r2
80012c1c:	fe b0 dc 4e 	rcall	8000e4b8 <_free_r>
80012c20:	04 9c       	mov	r12,r2
80012c22:	c2 a8       	rjmp	80012c76 <_realloc_r+0x2ba>
80012c24:	00 93       	mov	r3,r0
80012c26:	02 97       	mov	r7,r1
80012c28:	e6 06 01 09 	sub	r9,r3,r6
80012c2c:	6e 18       	ld.w	r8,r7[0x4]
80012c2e:	58 f9       	cp.w	r9,15
80012c30:	e0 88 00 16 	brls	80012c5c <_realloc_r+0x2a0>
80012c34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012c38:	ed e8 10 08 	or	r8,r6,r8
80012c3c:	8f 18       	st.w	r7[0x4],r8
80012c3e:	12 98       	mov	r8,r9
80012c40:	a1 a8       	sbr	r8,0x0
80012c42:	ee 06 00 0b 	add	r11,r7,r6
80012c46:	f6 09 00 09 	add	r9,r11,r9
80012c4a:	97 18       	st.w	r11[0x4],r8
80012c4c:	72 18       	ld.w	r8,r9[0x4]
80012c4e:	a1 a8       	sbr	r8,0x0
80012c50:	2f 8b       	sub	r11,-8
80012c52:	93 18       	st.w	r9[0x4],r8
80012c54:	04 9c       	mov	r12,r2
80012c56:	fe b0 dc 31 	rcall	8000e4b8 <_free_r>
80012c5a:	c0 b8       	rjmp	80012c70 <_realloc_r+0x2b4>
80012c5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80012c60:	e7 e8 10 08 	or	r8,r3,r8
80012c64:	8f 18       	st.w	r7[0x4],r8
80012c66:	ee 03 00 03 	add	r3,r7,r3
80012c6a:	66 18       	ld.w	r8,r3[0x4]
80012c6c:	a1 a8       	sbr	r8,0x0
80012c6e:	87 18       	st.w	r3[0x4],r8
80012c70:	04 9c       	mov	r12,r2
80012c72:	ee c5 ff f8 	sub	r5,r7,-8
80012c76:	fe b0 e0 53 	rcall	8000ed1c <__malloc_unlock>
80012c7a:	0a 9c       	mov	r12,r5
80012c7c:	2f fd       	sub	sp,-4
80012c7e:	d8 32       	popm	r0-r7,pc

80012c80 <__isinfd>:
80012c80:	14 98       	mov	r8,r10
80012c82:	fc 19 7f f0 	movh	r9,0x7ff0
80012c86:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80012c8a:	f0 0b 11 00 	rsub	r11,r8,0
80012c8e:	f7 e8 10 08 	or	r8,r11,r8
80012c92:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
80012c96:	f2 08 01 08 	sub	r8,r9,r8
80012c9a:	f0 0c 11 00 	rsub	r12,r8,0
80012c9e:	f9 e8 10 08 	or	r8,r12,r8
80012ca2:	f0 0c 14 1f 	asr	r12,r8,0x1f
80012ca6:	2f fc       	sub	r12,-1
80012ca8:	5e fc       	retal	r12

80012caa <__isnand>:
80012caa:	14 98       	mov	r8,r10
80012cac:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80012cb0:	f0 0c 11 00 	rsub	r12,r8,0
80012cb4:	10 4c       	or	r12,r8
80012cb6:	fc 18 7f f0 	movh	r8,0x7ff0
80012cba:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80012cbe:	f0 0c 01 0c 	sub	r12,r8,r12
80012cc2:	bf 9c       	lsr	r12,0x1f
80012cc4:	5e fc       	retal	r12
80012cc6:	d7 03       	nop

80012cc8 <_calloc_r>:
80012cc8:	d4 21       	pushm	r4-r7,lr
80012cca:	f4 0b 02 4b 	mul	r11,r10,r11
80012cce:	fe b0 dd 61 	rcall	8000e790 <_malloc_r>
80012cd2:	18 97       	mov	r7,r12
80012cd4:	c2 30       	breq	80012d1a <_calloc_r+0x52>
80012cd6:	f8 fa ff fc 	ld.w	r10,r12[-4]
80012cda:	e0 1a ff fc 	andl	r10,0xfffc
80012cde:	20 4a       	sub	r10,4
80012ce0:	e0 4a 00 24 	cp.w	r10,36
80012ce4:	e0 8b 00 18 	brhi	80012d14 <_calloc_r+0x4c>
80012ce8:	18 98       	mov	r8,r12
80012cea:	59 3a       	cp.w	r10,19
80012cec:	e0 88 00 0f 	brls	80012d0a <_calloc_r+0x42>
80012cf0:	30 09       	mov	r9,0
80012cf2:	10 a9       	st.w	r8++,r9
80012cf4:	10 a9       	st.w	r8++,r9
80012cf6:	59 ba       	cp.w	r10,27
80012cf8:	e0 88 00 09 	brls	80012d0a <_calloc_r+0x42>
80012cfc:	10 a9       	st.w	r8++,r9
80012cfe:	10 a9       	st.w	r8++,r9
80012d00:	e0 4a 00 24 	cp.w	r10,36
80012d04:	c0 31       	brne	80012d0a <_calloc_r+0x42>
80012d06:	10 a9       	st.w	r8++,r9
80012d08:	10 a9       	st.w	r8++,r9
80012d0a:	30 09       	mov	r9,0
80012d0c:	10 a9       	st.w	r8++,r9
80012d0e:	91 19       	st.w	r8[0x4],r9
80012d10:	91 09       	st.w	r8[0x0],r9
80012d12:	c0 48       	rjmp	80012d1a <_calloc_r+0x52>
80012d14:	30 0b       	mov	r11,0
80012d16:	fe b0 df fb 	rcall	8000ed0c <memset>
80012d1a:	0e 9c       	mov	r12,r7
80012d1c:	d8 22       	popm	r4-r7,pc
80012d1e:	d7 03       	nop

80012d20 <__avr32_f64_mul>:
80012d20:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80012d24:	e0 80 00 dc 	breq	80012edc <__avr32_f64_mul_op1_zero>
80012d28:	d4 21       	pushm	r4-r7,lr
80012d2a:	f7 e9 20 0e 	eor	lr,r11,r9
80012d2e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80012d32:	30 15       	mov	r5,1
80012d34:	c4 30       	breq	80012dba <__avr32_f64_mul_op1_subnormal>
80012d36:	ab 6b       	lsl	r11,0xa
80012d38:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80012d3c:	ab 6a       	lsl	r10,0xa
80012d3e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80012d42:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80012d46:	c5 c0       	breq	80012dfe <__avr32_f64_mul_op2_subnormal>
80012d48:	a1 78       	lsl	r8,0x1
80012d4a:	5c f9       	rol	r9
80012d4c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80012d50:	e0 47 07 ff 	cp.w	r7,2047
80012d54:	c7 70       	breq	80012e42 <__avr32_f64_mul_op_nan_or_inf>
80012d56:	e0 46 07 ff 	cp.w	r6,2047
80012d5a:	c7 40       	breq	80012e42 <__avr32_f64_mul_op_nan_or_inf>
80012d5c:	ee 06 00 0c 	add	r12,r7,r6
80012d60:	e0 2c 03 fe 	sub	r12,1022
80012d64:	f6 08 06 44 	mulu.d	r4,r11,r8
80012d68:	f4 09 07 44 	macu.d	r4,r10,r9
80012d6c:	f4 08 06 46 	mulu.d	r6,r10,r8
80012d70:	f6 09 06 4a 	mulu.d	r10,r11,r9
80012d74:	08 07       	add	r7,r4
80012d76:	f4 05 00 4a 	adc	r10,r10,r5
80012d7a:	5c 0b       	acr	r11
80012d7c:	ed bb 00 14 	bld	r11,0x14
80012d80:	c0 50       	breq	80012d8a <__avr32_f64_mul+0x6a>
80012d82:	a1 77       	lsl	r7,0x1
80012d84:	5c fa       	rol	r10
80012d86:	5c fb       	rol	r11
80012d88:	20 1c       	sub	r12,1
80012d8a:	58 0c       	cp.w	r12,0
80012d8c:	e0 8a 00 6f 	brle	80012e6a <__avr32_f64_mul_res_subnormal>
80012d90:	e0 4c 07 ff 	cp.w	r12,2047
80012d94:	e0 84 00 9c 	brge	80012ecc <__avr32_f64_mul_res_inf>
80012d98:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80012d9c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80012da0:	ef e6 12 17 	or	r7,r7,r6>>0x1
80012da4:	ee 17 80 00 	eorh	r7,0x8000
80012da8:	f1 b7 04 20 	satu	r7,0x1
80012dac:	0e 0a       	add	r10,r7
80012dae:	5c 0b       	acr	r11
80012db0:	ed be 00 1f 	bld	lr,0x1f
80012db4:	ef bb 00 1f 	bst	r11,0x1f
80012db8:	d8 22       	popm	r4-r7,pc

80012dba <__avr32_f64_mul_op1_subnormal>:
80012dba:	e4 1b 00 0f 	andh	r11,0xf
80012dbe:	f4 0c 12 00 	clz	r12,r10
80012dc2:	f6 06 12 00 	clz	r6,r11
80012dc6:	f7 bc 03 e1 	sublo	r12,-31
80012dca:	f8 06 17 30 	movlo	r6,r12
80012dce:	f7 b6 02 01 	subhs	r6,1
80012dd2:	e0 46 00 20 	cp.w	r6,32
80012dd6:	c0 d4       	brge	80012df0 <__avr32_f64_mul_op1_subnormal+0x36>
80012dd8:	ec 0c 11 20 	rsub	r12,r6,32
80012ddc:	f6 06 09 4b 	lsl	r11,r11,r6
80012de0:	f4 0c 0a 4c 	lsr	r12,r10,r12
80012de4:	18 4b       	or	r11,r12
80012de6:	f4 06 09 4a 	lsl	r10,r10,r6
80012dea:	20 b6       	sub	r6,11
80012dec:	0c 17       	sub	r7,r6
80012dee:	ca ab       	rjmp	80012d42 <__avr32_f64_mul+0x22>
80012df0:	f4 06 09 4b 	lsl	r11,r10,r6
80012df4:	c6 40       	breq	80012ebc <__avr32_f64_mul_res_zero>
80012df6:	30 0a       	mov	r10,0
80012df8:	20 b6       	sub	r6,11
80012dfa:	0c 17       	sub	r7,r6
80012dfc:	ca 3b       	rjmp	80012d42 <__avr32_f64_mul+0x22>

80012dfe <__avr32_f64_mul_op2_subnormal>:
80012dfe:	e4 19 00 0f 	andh	r9,0xf
80012e02:	f0 0c 12 00 	clz	r12,r8
80012e06:	f2 05 12 00 	clz	r5,r9
80012e0a:	f7 bc 03 ea 	sublo	r12,-22
80012e0e:	f8 05 17 30 	movlo	r5,r12
80012e12:	f7 b5 02 0a 	subhs	r5,10
80012e16:	e0 45 00 20 	cp.w	r5,32
80012e1a:	c0 d4       	brge	80012e34 <__avr32_f64_mul_op2_subnormal+0x36>
80012e1c:	ea 0c 11 20 	rsub	r12,r5,32
80012e20:	f2 05 09 49 	lsl	r9,r9,r5
80012e24:	f0 0c 0a 4c 	lsr	r12,r8,r12
80012e28:	18 49       	or	r9,r12
80012e2a:	f0 05 09 48 	lsl	r8,r8,r5
80012e2e:	20 25       	sub	r5,2
80012e30:	0a 16       	sub	r6,r5
80012e32:	c8 fb       	rjmp	80012d50 <__avr32_f64_mul+0x30>
80012e34:	f0 05 09 49 	lsl	r9,r8,r5
80012e38:	c4 20       	breq	80012ebc <__avr32_f64_mul_res_zero>
80012e3a:	30 08       	mov	r8,0
80012e3c:	20 25       	sub	r5,2
80012e3e:	0a 16       	sub	r6,r5
80012e40:	c8 8b       	rjmp	80012d50 <__avr32_f64_mul+0x30>

80012e42 <__avr32_f64_mul_op_nan_or_inf>:
80012e42:	e4 19 00 0f 	andh	r9,0xf
80012e46:	e4 1b 00 0f 	andh	r11,0xf
80012e4a:	14 4b       	or	r11,r10
80012e4c:	10 49       	or	r9,r8
80012e4e:	e0 47 07 ff 	cp.w	r7,2047
80012e52:	c0 91       	brne	80012e64 <__avr32_f64_mul_op1_not_naninf>
80012e54:	58 0b       	cp.w	r11,0
80012e56:	c3 81       	brne	80012ec6 <__avr32_f64_mul_res_nan>
80012e58:	e0 46 07 ff 	cp.w	r6,2047
80012e5c:	c3 81       	brne	80012ecc <__avr32_f64_mul_res_inf>
80012e5e:	58 09       	cp.w	r9,0
80012e60:	c3 60       	breq	80012ecc <__avr32_f64_mul_res_inf>
80012e62:	c3 28       	rjmp	80012ec6 <__avr32_f64_mul_res_nan>

80012e64 <__avr32_f64_mul_op1_not_naninf>:
80012e64:	58 09       	cp.w	r9,0
80012e66:	c3 30       	breq	80012ecc <__avr32_f64_mul_res_inf>
80012e68:	c2 f8       	rjmp	80012ec6 <__avr32_f64_mul_res_nan>

80012e6a <__avr32_f64_mul_res_subnormal>:
80012e6a:	5c 3c       	neg	r12
80012e6c:	2f fc       	sub	r12,-1
80012e6e:	f1 bc 04 c0 	satu	r12,0x6
80012e72:	e0 4c 00 20 	cp.w	r12,32
80012e76:	c1 14       	brge	80012e98 <__avr32_f64_mul_res_subnormal+0x2e>
80012e78:	f8 08 11 20 	rsub	r8,r12,32
80012e7c:	0e 46       	or	r6,r7
80012e7e:	ee 0c 0a 47 	lsr	r7,r7,r12
80012e82:	f4 08 09 49 	lsl	r9,r10,r8
80012e86:	12 47       	or	r7,r9
80012e88:	f4 0c 0a 4a 	lsr	r10,r10,r12
80012e8c:	f6 08 09 49 	lsl	r9,r11,r8
80012e90:	12 4a       	or	r10,r9
80012e92:	f6 0c 0a 4b 	lsr	r11,r11,r12
80012e96:	c8 3b       	rjmp	80012d9c <__avr32_f64_mul+0x7c>
80012e98:	f8 08 11 20 	rsub	r8,r12,32
80012e9c:	f9 b9 00 00 	moveq	r9,0
80012ea0:	c0 30       	breq	80012ea6 <__avr32_f64_mul_res_subnormal+0x3c>
80012ea2:	f6 08 09 49 	lsl	r9,r11,r8
80012ea6:	0e 46       	or	r6,r7
80012ea8:	ed ea 10 16 	or	r6,r6,r10<<0x1
80012eac:	f4 0c 0a 4a 	lsr	r10,r10,r12
80012eb0:	f3 ea 10 07 	or	r7,r9,r10
80012eb4:	f6 0c 0a 4a 	lsr	r10,r11,r12
80012eb8:	30 0b       	mov	r11,0
80012eba:	c7 1b       	rjmp	80012d9c <__avr32_f64_mul+0x7c>

80012ebc <__avr32_f64_mul_res_zero>:
80012ebc:	1c 9b       	mov	r11,lr
80012ebe:	e6 1b 80 00 	andh	r11,0x8000,COH
80012ec2:	30 0a       	mov	r10,0
80012ec4:	d8 22       	popm	r4-r7,pc

80012ec6 <__avr32_f64_mul_res_nan>:
80012ec6:	3f fb       	mov	r11,-1
80012ec8:	3f fa       	mov	r10,-1
80012eca:	d8 22       	popm	r4-r7,pc

80012ecc <__avr32_f64_mul_res_inf>:
80012ecc:	f0 6b 00 00 	mov	r11,-1048576
80012ed0:	ed be 00 1f 	bld	lr,0x1f
80012ed4:	ef bb 00 1f 	bst	r11,0x1f
80012ed8:	30 0a       	mov	r10,0
80012eda:	d8 22       	popm	r4-r7,pc

80012edc <__avr32_f64_mul_op1_zero>:
80012edc:	f7 e9 20 0b 	eor	r11,r11,r9
80012ee0:	e6 1b 80 00 	andh	r11,0x8000,COH
80012ee4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80012ee8:	e0 4c 07 ff 	cp.w	r12,2047
80012eec:	5e 1c       	retne	r12
80012eee:	3f fa       	mov	r10,-1
80012ef0:	3f fb       	mov	r11,-1
80012ef2:	5e fc       	retal	r12

80012ef4 <__avr32_f64_sub_from_add>:
80012ef4:	ee 19 80 00 	eorh	r9,0x8000

80012ef8 <__avr32_f64_sub>:
80012ef8:	f7 e9 20 0c 	eor	r12,r11,r9
80012efc:	e0 86 00 ca 	brmi	80013090 <__avr32_f64_add_from_sub>
80012f00:	eb cd 40 e0 	pushm	r5-r7,lr
80012f04:	16 9c       	mov	r12,r11
80012f06:	e6 1c 80 00 	andh	r12,0x8000,COH
80012f0a:	bf db       	cbr	r11,0x1f
80012f0c:	bf d9       	cbr	r9,0x1f
80012f0e:	10 3a       	cp.w	r10,r8
80012f10:	f2 0b 13 00 	cpc	r11,r9
80012f14:	c0 92       	brcc	80012f26 <__avr32_f64_sub+0x2e>
80012f16:	16 97       	mov	r7,r11
80012f18:	12 9b       	mov	r11,r9
80012f1a:	0e 99       	mov	r9,r7
80012f1c:	14 97       	mov	r7,r10
80012f1e:	10 9a       	mov	r10,r8
80012f20:	0e 98       	mov	r8,r7
80012f22:	ee 1c 80 00 	eorh	r12,0x8000
80012f26:	f6 07 16 14 	lsr	r7,r11,0x14
80012f2a:	ab 7b       	lsl	r11,0xb
80012f2c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80012f30:	ab 7a       	lsl	r10,0xb
80012f32:	bf bb       	sbr	r11,0x1f
80012f34:	f2 06 16 14 	lsr	r6,r9,0x14
80012f38:	c4 40       	breq	80012fc0 <__avr32_f64_sub_opL_subnormal>
80012f3a:	ab 79       	lsl	r9,0xb
80012f3c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80012f40:	ab 78       	lsl	r8,0xb
80012f42:	bf b9       	sbr	r9,0x1f

80012f44 <__avr32_f64_sub_opL_subnormal_done>:
80012f44:	e0 47 07 ff 	cp.w	r7,2047
80012f48:	c4 f0       	breq	80012fe6 <__avr32_f64_sub_opH_nan_or_inf>
80012f4a:	0e 26       	rsub	r6,r7
80012f4c:	c1 20       	breq	80012f70 <__avr32_f64_sub_shift_done>
80012f4e:	ec 05 11 20 	rsub	r5,r6,32
80012f52:	e0 46 00 20 	cp.w	r6,32
80012f56:	c7 c2       	brcc	8001304e <__avr32_f64_sub_longshift>
80012f58:	f0 05 09 4e 	lsl	lr,r8,r5
80012f5c:	f2 05 09 45 	lsl	r5,r9,r5
80012f60:	f0 06 0a 48 	lsr	r8,r8,r6
80012f64:	f2 06 0a 49 	lsr	r9,r9,r6
80012f68:	0a 48       	or	r8,r5
80012f6a:	58 0e       	cp.w	lr,0
80012f6c:	5f 1e       	srne	lr
80012f6e:	1c 48       	or	r8,lr

80012f70 <__avr32_f64_sub_shift_done>:
80012f70:	10 1a       	sub	r10,r8
80012f72:	f6 09 01 4b 	sbc	r11,r11,r9
80012f76:	f6 06 12 00 	clz	r6,r11
80012f7a:	c0 e0       	breq	80012f96 <__avr32_f64_sub_longnormalize_done>
80012f7c:	c7 83       	brcs	8001306c <__avr32_f64_sub_longnormalize>
80012f7e:	ec 0e 11 20 	rsub	lr,r6,32
80012f82:	f6 06 09 4b 	lsl	r11,r11,r6
80012f86:	f4 0e 0a 4e 	lsr	lr,r10,lr
80012f8a:	1c 4b       	or	r11,lr
80012f8c:	f4 06 09 4a 	lsl	r10,r10,r6
80012f90:	0c 17       	sub	r7,r6
80012f92:	e0 8a 00 39 	brle	80013004 <__avr32_f64_sub_subnormal_result>

80012f96 <__avr32_f64_sub_longnormalize_done>:
80012f96:	f4 09 15 15 	lsl	r9,r10,0x15
80012f9a:	ab 9a       	lsr	r10,0xb
80012f9c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80012fa0:	ab 9b       	lsr	r11,0xb
80012fa2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80012fa6:	18 4b       	or	r11,r12

80012fa8 <__avr32_f64_sub_round>:
80012fa8:	fc 17 80 00 	movh	r7,0x8000
80012fac:	ed ba 00 00 	bld	r10,0x0
80012fb0:	f7 b7 01 ff 	subne	r7,-1
80012fb4:	0e 39       	cp.w	r9,r7
80012fb6:	5f 29       	srhs	r9
80012fb8:	12 0a       	add	r10,r9
80012fba:	5c 0b       	acr	r11
80012fbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80012fc0 <__avr32_f64_sub_opL_subnormal>:
80012fc0:	ab 79       	lsl	r9,0xb
80012fc2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80012fc6:	ab 78       	lsl	r8,0xb
80012fc8:	f3 e8 10 0e 	or	lr,r9,r8
80012fcc:	f9 b6 01 01 	movne	r6,1
80012fd0:	ee 0e 11 00 	rsub	lr,r7,0
80012fd4:	f9 b7 00 01 	moveq	r7,1
80012fd8:	ef bb 00 1f 	bst	r11,0x1f
80012fdc:	f7 ea 10 0e 	or	lr,r11,r10
80012fe0:	f9 b7 00 00 	moveq	r7,0
80012fe4:	cb 0b       	rjmp	80012f44 <__avr32_f64_sub_opL_subnormal_done>

80012fe6 <__avr32_f64_sub_opH_nan_or_inf>:
80012fe6:	bf db       	cbr	r11,0x1f
80012fe8:	f7 ea 10 0e 	or	lr,r11,r10
80012fec:	c0 81       	brne	80012ffc <__avr32_f64_sub_return_nan>
80012fee:	e0 46 07 ff 	cp.w	r6,2047
80012ff2:	c0 50       	breq	80012ffc <__avr32_f64_sub_return_nan>
80012ff4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80012ff8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80012ffc <__avr32_f64_sub_return_nan>:
80012ffc:	3f fa       	mov	r10,-1
80012ffe:	3f fb       	mov	r11,-1
80013000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80013004 <__avr32_f64_sub_subnormal_result>:
80013004:	5c 37       	neg	r7
80013006:	2f f7       	sub	r7,-1
80013008:	f1 b7 04 c0 	satu	r7,0x6
8001300c:	e0 47 00 20 	cp.w	r7,32
80013010:	c1 14       	brge	80013032 <__avr32_f64_sub_subnormal_result+0x2e>
80013012:	ee 08 11 20 	rsub	r8,r7,32
80013016:	f4 08 09 49 	lsl	r9,r10,r8
8001301a:	5f 16       	srne	r6
8001301c:	f4 07 0a 4a 	lsr	r10,r10,r7
80013020:	0c 4a       	or	r10,r6
80013022:	f6 08 09 49 	lsl	r9,r11,r8
80013026:	f5 e9 10 0a 	or	r10,r10,r9
8001302a:	f4 07 0a 4b 	lsr	r11,r10,r7
8001302e:	30 07       	mov	r7,0
80013030:	cb 3b       	rjmp	80012f96 <__avr32_f64_sub_longnormalize_done>
80013032:	ee 08 11 40 	rsub	r8,r7,64
80013036:	f6 08 09 49 	lsl	r9,r11,r8
8001303a:	14 49       	or	r9,r10
8001303c:	5f 16       	srne	r6
8001303e:	f6 07 0a 4a 	lsr	r10,r11,r7
80013042:	0c 4a       	or	r10,r6
80013044:	30 0b       	mov	r11,0
80013046:	30 07       	mov	r7,0
80013048:	ca 7b       	rjmp	80012f96 <__avr32_f64_sub_longnormalize_done>
8001304a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001304e <__avr32_f64_sub_longshift>:
8001304e:	f1 b6 04 c0 	satu	r6,0x6
80013052:	f0 0e 17 00 	moveq	lr,r8
80013056:	c0 40       	breq	8001305e <__avr32_f64_sub_longshift+0x10>
80013058:	f2 05 09 4e 	lsl	lr,r9,r5
8001305c:	10 4e       	or	lr,r8
8001305e:	f2 06 0a 48 	lsr	r8,r9,r6
80013062:	30 09       	mov	r9,0
80013064:	58 0e       	cp.w	lr,0
80013066:	5f 1e       	srne	lr
80013068:	1c 48       	or	r8,lr
8001306a:	c8 3b       	rjmp	80012f70 <__avr32_f64_sub_shift_done>

8001306c <__avr32_f64_sub_longnormalize>:
8001306c:	f4 06 12 00 	clz	r6,r10
80013070:	f9 b7 03 00 	movlo	r7,0
80013074:	f9 b6 03 00 	movlo	r6,0
80013078:	f9 bc 03 00 	movlo	r12,0
8001307c:	f7 b6 02 e0 	subhs	r6,-32
80013080:	f4 06 09 4b 	lsl	r11,r10,r6
80013084:	30 0a       	mov	r10,0
80013086:	0c 17       	sub	r7,r6
80013088:	fe 9a ff be 	brle	80013004 <__avr32_f64_sub_subnormal_result>
8001308c:	c8 5b       	rjmp	80012f96 <__avr32_f64_sub_longnormalize_done>
8001308e:	d7 03       	nop

80013090 <__avr32_f64_add_from_sub>:
80013090:	ee 19 80 00 	eorh	r9,0x8000

80013094 <__avr32_f64_add>:
80013094:	f7 e9 20 0c 	eor	r12,r11,r9
80013098:	fe 96 ff 2e 	brmi	80012ef4 <__avr32_f64_sub_from_add>
8001309c:	eb cd 40 e0 	pushm	r5-r7,lr
800130a0:	16 9c       	mov	r12,r11
800130a2:	e6 1c 80 00 	andh	r12,0x8000,COH
800130a6:	bf db       	cbr	r11,0x1f
800130a8:	bf d9       	cbr	r9,0x1f
800130aa:	12 3b       	cp.w	r11,r9
800130ac:	c0 72       	brcc	800130ba <__avr32_f64_add+0x26>
800130ae:	16 97       	mov	r7,r11
800130b0:	12 9b       	mov	r11,r9
800130b2:	0e 99       	mov	r9,r7
800130b4:	14 97       	mov	r7,r10
800130b6:	10 9a       	mov	r10,r8
800130b8:	0e 98       	mov	r8,r7
800130ba:	30 0e       	mov	lr,0
800130bc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
800130c0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
800130c4:	b5 ab       	sbr	r11,0x14
800130c6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
800130ca:	c5 f0       	breq	80013188 <__avr32_f64_add_op2_subnormal>
800130cc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
800130d0:	b5 a9       	sbr	r9,0x14
800130d2:	e0 47 07 ff 	cp.w	r7,2047
800130d6:	c2 50       	breq	80013120 <__avr32_f64_add_opH_nan_or_inf>
800130d8:	0e 26       	rsub	r6,r7
800130da:	c0 f0       	breq	800130f8 <__avr32_f64_add_shift_done>
800130dc:	ec 05 11 20 	rsub	r5,r6,32
800130e0:	e0 46 00 20 	cp.w	r6,32
800130e4:	c3 52       	brcc	8001314e <__avr32_f64_add_longshift>
800130e6:	f0 05 09 4e 	lsl	lr,r8,r5
800130ea:	f2 05 09 45 	lsl	r5,r9,r5
800130ee:	f0 06 0a 48 	lsr	r8,r8,r6
800130f2:	f2 06 0a 49 	lsr	r9,r9,r6
800130f6:	0a 48       	or	r8,r5

800130f8 <__avr32_f64_add_shift_done>:
800130f8:	10 0a       	add	r10,r8
800130fa:	f6 09 00 4b 	adc	r11,r11,r9
800130fe:	ed bb 00 15 	bld	r11,0x15
80013102:	c3 40       	breq	8001316a <__avr32_f64_add_res_of>

80013104 <__avr32_f64_add_res_of_done>:
80013104:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80013108:	18 4b       	or	r11,r12

8001310a <__avr32_f64_add_round>:
8001310a:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8001310e:	18 4e       	or	lr,r12
80013110:	ee 1e 80 00 	eorh	lr,0x8000
80013114:	f1 be 04 20 	satu	lr,0x1
80013118:	1c 0a       	add	r10,lr
8001311a:	5c 0b       	acr	r11
8001311c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80013120 <__avr32_f64_add_opH_nan_or_inf>:
80013120:	b5 cb       	cbr	r11,0x14
80013122:	f7 ea 10 0e 	or	lr,r11,r10
80013126:	c1 01       	brne	80013146 <__avr32_f64_add_return_nan>
80013128:	e0 46 07 ff 	cp.w	r6,2047
8001312c:	c0 30       	breq	80013132 <__avr32_f64_add_opL_nan_or_inf>
8001312e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80013132 <__avr32_f64_add_opL_nan_or_inf>:
80013132:	b5 c9       	cbr	r9,0x14
80013134:	f3 e8 10 0e 	or	lr,r9,r8
80013138:	c0 71       	brne	80013146 <__avr32_f64_add_return_nan>
8001313a:	30 0a       	mov	r10,0
8001313c:	fc 1b 7f f0 	movh	r11,0x7ff0
80013140:	18 4b       	or	r11,r12
80013142:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80013146 <__avr32_f64_add_return_nan>:
80013146:	3f fa       	mov	r10,-1
80013148:	3f fb       	mov	r11,-1
8001314a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001314e <__avr32_f64_add_longshift>:
8001314e:	f1 b6 04 c0 	satu	r6,0x6
80013152:	f0 0e 17 00 	moveq	lr,r8
80013156:	c0 60       	breq	80013162 <__avr32_f64_add_longshift+0x14>
80013158:	f2 05 09 4e 	lsl	lr,r9,r5
8001315c:	58 08       	cp.w	r8,0
8001315e:	5f 18       	srne	r8
80013160:	10 4e       	or	lr,r8
80013162:	f2 06 0a 48 	lsr	r8,r9,r6
80013166:	30 09       	mov	r9,0
80013168:	cc 8b       	rjmp	800130f8 <__avr32_f64_add_shift_done>

8001316a <__avr32_f64_add_res_of>:
8001316a:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8001316e:	a1 9b       	lsr	r11,0x1
80013170:	5d 0a       	ror	r10
80013172:	5d 0e       	ror	lr
80013174:	2f f7       	sub	r7,-1
80013176:	e0 47 07 ff 	cp.w	r7,2047
8001317a:	f9 ba 00 00 	moveq	r10,0
8001317e:	f9 bb 00 00 	moveq	r11,0
80013182:	f9 be 00 00 	moveq	lr,0
80013186:	cb fb       	rjmp	80013104 <__avr32_f64_add_res_of_done>

80013188 <__avr32_f64_add_op2_subnormal>:
80013188:	30 16       	mov	r6,1
8001318a:	58 07       	cp.w	r7,0
8001318c:	ca 31       	brne	800130d2 <__avr32_f64_add+0x3e>
8001318e:	b5 cb       	cbr	r11,0x14
80013190:	10 0a       	add	r10,r8
80013192:	f6 09 00 4b 	adc	r11,r11,r9
80013196:	18 4b       	or	r11,r12
80013198:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001319c <__avr32_f64_to_u32>:
8001319c:	58 0b       	cp.w	r11,0
8001319e:	5e 6d       	retmi	0

800131a0 <__avr32_f64_to_s32>:
800131a0:	f6 0c 15 01 	lsl	r12,r11,0x1
800131a4:	b5 9c       	lsr	r12,0x15
800131a6:	e0 2c 03 ff 	sub	r12,1023
800131aa:	5e 3d       	retlo	0
800131ac:	f8 0c 11 1f 	rsub	r12,r12,31
800131b0:	16 99       	mov	r9,r11
800131b2:	ab 7b       	lsl	r11,0xb
800131b4:	bf bb       	sbr	r11,0x1f
800131b6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
800131ba:	f6 0c 0a 4b 	lsr	r11,r11,r12
800131be:	a1 79       	lsl	r9,0x1
800131c0:	5e 2b       	reths	r11
800131c2:	5c 3b       	neg	r11
800131c4:	5e fb       	retal	r11

800131c6 <__avr32_u32_to_f64>:
800131c6:	f8 cb 00 00 	sub	r11,r12,0
800131ca:	30 0c       	mov	r12,0
800131cc:	c0 38       	rjmp	800131d2 <__avr32_s32_to_f64+0x4>

800131ce <__avr32_s32_to_f64>:
800131ce:	18 9b       	mov	r11,r12
800131d0:	5c 4b       	abs	r11
800131d2:	30 0a       	mov	r10,0
800131d4:	5e 0b       	reteq	r11
800131d6:	d4 01       	pushm	lr
800131d8:	e0 69 04 1e 	mov	r9,1054
800131dc:	f6 08 12 00 	clz	r8,r11
800131e0:	c1 70       	breq	8001320e <__avr32_s32_to_f64+0x40>
800131e2:	c0 c3       	brcs	800131fa <__avr32_s32_to_f64+0x2c>
800131e4:	f0 0e 11 20 	rsub	lr,r8,32
800131e8:	f6 08 09 4b 	lsl	r11,r11,r8
800131ec:	f4 0e 0a 4e 	lsr	lr,r10,lr
800131f0:	1c 4b       	or	r11,lr
800131f2:	f4 08 09 4a 	lsl	r10,r10,r8
800131f6:	10 19       	sub	r9,r8
800131f8:	c0 b8       	rjmp	8001320e <__avr32_s32_to_f64+0x40>
800131fa:	f4 08 12 00 	clz	r8,r10
800131fe:	f9 b8 03 00 	movlo	r8,0
80013202:	f7 b8 02 e0 	subhs	r8,-32
80013206:	f4 08 09 4b 	lsl	r11,r10,r8
8001320a:	30 0a       	mov	r10,0
8001320c:	10 19       	sub	r9,r8
8001320e:	58 09       	cp.w	r9,0
80013210:	e0 89 00 30 	brgt	80013270 <__avr32_s32_to_f64+0xa2>
80013214:	5c 39       	neg	r9
80013216:	2f f9       	sub	r9,-1
80013218:	e0 49 00 36 	cp.w	r9,54
8001321c:	c0 43       	brcs	80013224 <__avr32_s32_to_f64+0x56>
8001321e:	30 0b       	mov	r11,0
80013220:	30 0a       	mov	r10,0
80013222:	c2 68       	rjmp	8001326e <__avr32_s32_to_f64+0xa0>
80013224:	2f 69       	sub	r9,-10
80013226:	f2 08 11 20 	rsub	r8,r9,32
8001322a:	e0 49 00 20 	cp.w	r9,32
8001322e:	c0 b2       	brcc	80013244 <__avr32_s32_to_f64+0x76>
80013230:	f4 08 09 4e 	lsl	lr,r10,r8
80013234:	f6 08 09 48 	lsl	r8,r11,r8
80013238:	f4 09 0a 4a 	lsr	r10,r10,r9
8001323c:	f6 09 0a 4b 	lsr	r11,r11,r9
80013240:	10 4b       	or	r11,r8
80013242:	c0 88       	rjmp	80013252 <__avr32_s32_to_f64+0x84>
80013244:	f6 08 09 4e 	lsl	lr,r11,r8
80013248:	14 4e       	or	lr,r10
8001324a:	16 9a       	mov	r10,r11
8001324c:	30 0b       	mov	r11,0
8001324e:	f4 09 0a 4a 	lsr	r10,r10,r9
80013252:	ed ba 00 00 	bld	r10,0x0
80013256:	c0 92       	brcc	80013268 <__avr32_s32_to_f64+0x9a>
80013258:	1c 7e       	tst	lr,lr
8001325a:	c0 41       	brne	80013262 <__avr32_s32_to_f64+0x94>
8001325c:	ed ba 00 01 	bld	r10,0x1
80013260:	c0 42       	brcc	80013268 <__avr32_s32_to_f64+0x9a>
80013262:	2f fa       	sub	r10,-1
80013264:	f7 bb 02 ff 	subhs	r11,-1
80013268:	5c fc       	rol	r12
8001326a:	5d 0b       	ror	r11
8001326c:	5d 0a       	ror	r10
8001326e:	d8 02       	popm	pc
80013270:	e0 68 03 ff 	mov	r8,1023
80013274:	ed ba 00 0b 	bld	r10,0xb
80013278:	f7 b8 00 ff 	subeq	r8,-1
8001327c:	10 0a       	add	r10,r8
8001327e:	5c 0b       	acr	r11
80013280:	f7 b9 03 fe 	sublo	r9,-2
80013284:	e0 49 07 ff 	cp.w	r9,2047
80013288:	c0 55       	brlt	80013292 <__avr32_s32_to_f64+0xc4>
8001328a:	30 0a       	mov	r10,0
8001328c:	fc 1b ff e0 	movh	r11,0xffe0
80013290:	c0 c8       	rjmp	800132a8 <__floatsidf_return_op1>
80013292:	ed bb 00 1f 	bld	r11,0x1f
80013296:	f7 b9 01 01 	subne	r9,1
8001329a:	ab 9a       	lsr	r10,0xb
8001329c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800132a0:	a1 7b       	lsl	r11,0x1
800132a2:	ab 9b       	lsr	r11,0xb
800132a4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

800132a8 <__floatsidf_return_op1>:
800132a8:	a1 7c       	lsl	r12,0x1
800132aa:	5d 0b       	ror	r11
800132ac:	d8 02       	popm	pc

800132ae <__avr32_f64_cmp_eq>:
800132ae:	10 3a       	cp.w	r10,r8
800132b0:	f2 0b 13 00 	cpc	r11,r9
800132b4:	c0 80       	breq	800132c4 <__avr32_f64_cmp_eq+0x16>
800132b6:	a1 7b       	lsl	r11,0x1
800132b8:	a1 79       	lsl	r9,0x1
800132ba:	14 4b       	or	r11,r10
800132bc:	12 4b       	or	r11,r9
800132be:	10 4b       	or	r11,r8
800132c0:	5e 0f       	reteq	1
800132c2:	5e fd       	retal	0
800132c4:	a1 7b       	lsl	r11,0x1
800132c6:	fc 1c ff e0 	movh	r12,0xffe0
800132ca:	58 0a       	cp.w	r10,0
800132cc:	f8 0b 13 00 	cpc	r11,r12
800132d0:	5e 8f       	retls	1
800132d2:	5e fd       	retal	0

800132d4 <__avr32_f64_cmp_ge>:
800132d4:	1a de       	st.w	--sp,lr
800132d6:	1a d7       	st.w	--sp,r7
800132d8:	a1 7b       	lsl	r11,0x1
800132da:	5f 3c       	srlo	r12
800132dc:	a1 79       	lsl	r9,0x1
800132de:	5f 37       	srlo	r7
800132e0:	5c fc       	rol	r12
800132e2:	fc 1e ff e0 	movh	lr,0xffe0
800132e6:	58 0a       	cp.w	r10,0
800132e8:	fc 0b 13 00 	cpc	r11,lr
800132ec:	e0 8b 00 1d 	brhi	80013326 <__avr32_f64_cmp_ge+0x52>
800132f0:	58 08       	cp.w	r8,0
800132f2:	fc 09 13 00 	cpc	r9,lr
800132f6:	e0 8b 00 18 	brhi	80013326 <__avr32_f64_cmp_ge+0x52>
800132fa:	58 0b       	cp.w	r11,0
800132fc:	f5 ba 00 00 	subfeq	r10,0
80013300:	c1 50       	breq	8001332a <__avr32_f64_cmp_ge+0x56>
80013302:	1b 07       	ld.w	r7,sp++
80013304:	1b 0e       	ld.w	lr,sp++
80013306:	58 3c       	cp.w	r12,3
80013308:	c0 a0       	breq	8001331c <__avr32_f64_cmp_ge+0x48>
8001330a:	58 1c       	cp.w	r12,1
8001330c:	c0 33       	brcs	80013312 <__avr32_f64_cmp_ge+0x3e>
8001330e:	5e 0f       	reteq	1
80013310:	5e 1d       	retne	0
80013312:	10 3a       	cp.w	r10,r8
80013314:	f2 0b 13 00 	cpc	r11,r9
80013318:	5e 2f       	reths	1
8001331a:	5e 3d       	retlo	0
8001331c:	14 38       	cp.w	r8,r10
8001331e:	f6 09 13 00 	cpc	r9,r11
80013322:	5e 2f       	reths	1
80013324:	5e 3d       	retlo	0
80013326:	1b 07       	ld.w	r7,sp++
80013328:	d8 0a       	popm	pc,r12=0
8001332a:	58 17       	cp.w	r7,1
8001332c:	5f 0c       	sreq	r12
8001332e:	58 09       	cp.w	r9,0
80013330:	f5 b8 00 00 	subfeq	r8,0
80013334:	1b 07       	ld.w	r7,sp++
80013336:	1b 0e       	ld.w	lr,sp++
80013338:	5e 0f       	reteq	1
8001333a:	5e fc       	retal	r12

8001333c <__avr32_f64_cmp_lt>:
8001333c:	1a de       	st.w	--sp,lr
8001333e:	1a d7       	st.w	--sp,r7
80013340:	a1 7b       	lsl	r11,0x1
80013342:	5f 3c       	srlo	r12
80013344:	a1 79       	lsl	r9,0x1
80013346:	5f 37       	srlo	r7
80013348:	5c fc       	rol	r12
8001334a:	fc 1e ff e0 	movh	lr,0xffe0
8001334e:	58 0a       	cp.w	r10,0
80013350:	fc 0b 13 00 	cpc	r11,lr
80013354:	e0 8b 00 1d 	brhi	8001338e <__avr32_f64_cmp_lt+0x52>
80013358:	58 08       	cp.w	r8,0
8001335a:	fc 09 13 00 	cpc	r9,lr
8001335e:	e0 8b 00 18 	brhi	8001338e <__avr32_f64_cmp_lt+0x52>
80013362:	58 0b       	cp.w	r11,0
80013364:	f5 ba 00 00 	subfeq	r10,0
80013368:	c1 50       	breq	80013392 <__avr32_f64_cmp_lt+0x56>
8001336a:	1b 07       	ld.w	r7,sp++
8001336c:	1b 0e       	ld.w	lr,sp++
8001336e:	58 3c       	cp.w	r12,3
80013370:	c0 a0       	breq	80013384 <__avr32_f64_cmp_lt+0x48>
80013372:	58 1c       	cp.w	r12,1
80013374:	c0 33       	brcs	8001337a <__avr32_f64_cmp_lt+0x3e>
80013376:	5e 0d       	reteq	0
80013378:	5e 1f       	retne	1
8001337a:	10 3a       	cp.w	r10,r8
8001337c:	f2 0b 13 00 	cpc	r11,r9
80013380:	5e 2d       	reths	0
80013382:	5e 3f       	retlo	1
80013384:	14 38       	cp.w	r8,r10
80013386:	f6 09 13 00 	cpc	r9,r11
8001338a:	5e 2d       	reths	0
8001338c:	5e 3f       	retlo	1
8001338e:	1b 07       	ld.w	r7,sp++
80013390:	d8 0a       	popm	pc,r12=0
80013392:	58 17       	cp.w	r7,1
80013394:	5f 1c       	srne	r12
80013396:	58 09       	cp.w	r9,0
80013398:	f5 b8 00 00 	subfeq	r8,0
8001339c:	1b 07       	ld.w	r7,sp++
8001339e:	1b 0e       	ld.w	lr,sp++
800133a0:	5e 0d       	reteq	0
800133a2:	5e fc       	retal	r12

800133a4 <__avr32_f64_div>:
800133a4:	eb cd 40 ff 	pushm	r0-r7,lr
800133a8:	f7 e9 20 0e 	eor	lr,r11,r9
800133ac:	f6 07 16 14 	lsr	r7,r11,0x14
800133b0:	a9 7b       	lsl	r11,0x9
800133b2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
800133b6:	a9 7a       	lsl	r10,0x9
800133b8:	bd bb       	sbr	r11,0x1d
800133ba:	e4 1b 3f ff 	andh	r11,0x3fff
800133be:	ab d7       	cbr	r7,0xb
800133c0:	e0 80 00 cc 	breq	80013558 <__avr32_f64_div_round_subnormal+0x54>
800133c4:	e0 47 07 ff 	cp.w	r7,2047
800133c8:	e0 84 00 b5 	brge	80013532 <__avr32_f64_div_round_subnormal+0x2e>
800133cc:	f2 06 16 14 	lsr	r6,r9,0x14
800133d0:	a9 79       	lsl	r9,0x9
800133d2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800133d6:	a9 78       	lsl	r8,0x9
800133d8:	bd b9       	sbr	r9,0x1d
800133da:	e4 19 3f ff 	andh	r9,0x3fff
800133de:	ab d6       	cbr	r6,0xb
800133e0:	e0 80 00 e2 	breq	800135a4 <__avr32_f64_div_round_subnormal+0xa0>
800133e4:	e0 46 07 ff 	cp.w	r6,2047
800133e8:	e0 84 00 b2 	brge	8001354c <__avr32_f64_div_round_subnormal+0x48>
800133ec:	0c 17       	sub	r7,r6
800133ee:	fe 37 fc 01 	sub	r7,-1023
800133f2:	fc 1c 80 00 	movh	r12,0x8000
800133f6:	f8 03 16 01 	lsr	r3,r12,0x1
800133fa:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800133fe:	5c d4       	com	r4
80013400:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80013404:	e6 09 06 44 	mulu.d	r4,r3,r9
80013408:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001340c:	e6 05 06 44 	mulu.d	r4,r3,r5
80013410:	ea 03 15 02 	lsl	r3,r5,0x2
80013414:	e6 09 06 44 	mulu.d	r4,r3,r9
80013418:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001341c:	e6 05 06 44 	mulu.d	r4,r3,r5
80013420:	ea 03 15 02 	lsl	r3,r5,0x2
80013424:	e6 09 06 44 	mulu.d	r4,r3,r9
80013428:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001342c:	e6 05 06 44 	mulu.d	r4,r3,r5
80013430:	ea 03 15 02 	lsl	r3,r5,0x2
80013434:	e6 08 06 40 	mulu.d	r0,r3,r8
80013438:	e4 09 07 40 	macu.d	r0,r2,r9
8001343c:	e6 09 06 44 	mulu.d	r4,r3,r9
80013440:	02 04       	add	r4,r1
80013442:	5c 05       	acr	r5
80013444:	a3 65       	lsl	r5,0x2
80013446:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001344a:	a3 64       	lsl	r4,0x2
8001344c:	5c 34       	neg	r4
8001344e:	f8 05 01 45 	sbc	r5,r12,r5
80013452:	e6 04 06 40 	mulu.d	r0,r3,r4
80013456:	e4 05 07 40 	macu.d	r0,r2,r5
8001345a:	e6 05 06 44 	mulu.d	r4,r3,r5
8001345e:	02 04       	add	r4,r1
80013460:	5c 05       	acr	r5
80013462:	ea 03 15 02 	lsl	r3,r5,0x2
80013466:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001346a:	e8 02 15 02 	lsl	r2,r4,0x2
8001346e:	e6 08 06 40 	mulu.d	r0,r3,r8
80013472:	e4 09 07 40 	macu.d	r0,r2,r9
80013476:	e6 09 06 44 	mulu.d	r4,r3,r9
8001347a:	02 04       	add	r4,r1
8001347c:	5c 05       	acr	r5
8001347e:	a3 65       	lsl	r5,0x2
80013480:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80013484:	a3 64       	lsl	r4,0x2
80013486:	5c 34       	neg	r4
80013488:	f8 05 01 45 	sbc	r5,r12,r5
8001348c:	e6 04 06 40 	mulu.d	r0,r3,r4
80013490:	e4 05 07 40 	macu.d	r0,r2,r5
80013494:	e6 05 06 44 	mulu.d	r4,r3,r5
80013498:	02 04       	add	r4,r1
8001349a:	5c 05       	acr	r5
8001349c:	ea 03 15 02 	lsl	r3,r5,0x2
800134a0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
800134a4:	e8 02 15 02 	lsl	r2,r4,0x2
800134a8:	e6 0a 06 40 	mulu.d	r0,r3,r10
800134ac:	e4 0b 07 40 	macu.d	r0,r2,r11
800134b0:	e6 0b 06 42 	mulu.d	r2,r3,r11
800134b4:	02 02       	add	r2,r1
800134b6:	5c 03       	acr	r3
800134b8:	ed b3 00 1c 	bld	r3,0x1c
800134bc:	c0 90       	breq	800134ce <__avr32_f64_div+0x12a>
800134be:	a1 72       	lsl	r2,0x1
800134c0:	5c f3       	rol	r3
800134c2:	20 17       	sub	r7,1
800134c4:	a3 9a       	lsr	r10,0x3
800134c6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800134ca:	a3 9b       	lsr	r11,0x3
800134cc:	c0 58       	rjmp	800134d6 <__avr32_f64_div+0x132>
800134ce:	a5 8a       	lsr	r10,0x4
800134d0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800134d4:	a5 8b       	lsr	r11,0x4
800134d6:	58 07       	cp.w	r7,0
800134d8:	e0 8a 00 8b 	brle	800135ee <__avr32_f64_div_res_subnormal>
800134dc:	e0 12 ff 00 	andl	r2,0xff00
800134e0:	e8 12 00 80 	orl	r2,0x80
800134e4:	e6 08 06 40 	mulu.d	r0,r3,r8
800134e8:	e4 09 07 40 	macu.d	r0,r2,r9
800134ec:	e4 08 06 44 	mulu.d	r4,r2,r8
800134f0:	e6 09 06 48 	mulu.d	r8,r3,r9
800134f4:	00 05       	add	r5,r0
800134f6:	f0 01 00 48 	adc	r8,r8,r1
800134fa:	5c 09       	acr	r9
800134fc:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80013500:	58 04       	cp.w	r4,0
80013502:	5c 25       	cpc	r5

80013504 <__avr32_f64_div_round_subnormal>:
80013504:	f4 08 13 00 	cpc	r8,r10
80013508:	f6 09 13 00 	cpc	r9,r11
8001350c:	5f 36       	srlo	r6
8001350e:	f8 06 17 00 	moveq	r6,r12
80013512:	e4 0a 16 08 	lsr	r10,r2,0x8
80013516:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8001351a:	e6 0b 16 08 	lsr	r11,r3,0x8
8001351e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80013522:	ed be 00 1f 	bld	lr,0x1f
80013526:	ef bb 00 1f 	bst	r11,0x1f
8001352a:	0c 0a       	add	r10,r6
8001352c:	5c 0b       	acr	r11
8001352e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80013532:	e4 1b 00 0f 	andh	r11,0xf
80013536:	14 4b       	or	r11,r10
80013538:	e0 81 00 a7 	brne	80013686 <__avr32_f64_div_res_subnormal+0x98>
8001353c:	f2 06 16 14 	lsr	r6,r9,0x14
80013540:	ab d6       	cbr	r6,0xb
80013542:	e0 46 07 ff 	cp.w	r6,2047
80013546:	e0 81 00 a4 	brne	8001368e <__avr32_f64_div_res_subnormal+0xa0>
8001354a:	c9 e8       	rjmp	80013686 <__avr32_f64_div_res_subnormal+0x98>
8001354c:	e4 19 00 0f 	andh	r9,0xf
80013550:	10 49       	or	r9,r8
80013552:	e0 81 00 9a 	brne	80013686 <__avr32_f64_div_res_subnormal+0x98>
80013556:	c9 28       	rjmp	8001367a <__avr32_f64_div_res_subnormal+0x8c>
80013558:	a3 7b       	lsl	r11,0x3
8001355a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8001355e:	a3 7a       	lsl	r10,0x3
80013560:	f5 eb 10 04 	or	r4,r10,r11
80013564:	e0 80 00 a0 	breq	800136a4 <__avr32_f64_div_op1_zero>
80013568:	f6 04 12 00 	clz	r4,r11
8001356c:	c1 70       	breq	8001359a <__avr32_f64_div_round_subnormal+0x96>
8001356e:	c0 c3       	brcs	80013586 <__avr32_f64_div_round_subnormal+0x82>
80013570:	e8 05 11 20 	rsub	r5,r4,32
80013574:	f6 04 09 4b 	lsl	r11,r11,r4
80013578:	f4 05 0a 45 	lsr	r5,r10,r5
8001357c:	0a 4b       	or	r11,r5
8001357e:	f4 04 09 4a 	lsl	r10,r10,r4
80013582:	08 17       	sub	r7,r4
80013584:	c0 b8       	rjmp	8001359a <__avr32_f64_div_round_subnormal+0x96>
80013586:	f4 04 12 00 	clz	r4,r10
8001358a:	f9 b4 03 00 	movlo	r4,0
8001358e:	f7 b4 02 e0 	subhs	r4,-32
80013592:	f4 04 09 4b 	lsl	r11,r10,r4
80013596:	30 0a       	mov	r10,0
80013598:	08 17       	sub	r7,r4
8001359a:	a3 8a       	lsr	r10,0x2
8001359c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
800135a0:	a3 8b       	lsr	r11,0x2
800135a2:	c1 1b       	rjmp	800133c4 <__avr32_f64_div+0x20>
800135a4:	a3 79       	lsl	r9,0x3
800135a6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
800135aa:	a3 78       	lsl	r8,0x3
800135ac:	f3 e8 10 04 	or	r4,r9,r8
800135b0:	c6 f0       	breq	8001368e <__avr32_f64_div_res_subnormal+0xa0>
800135b2:	f2 04 12 00 	clz	r4,r9
800135b6:	c1 70       	breq	800135e4 <__avr32_f64_div_round_subnormal+0xe0>
800135b8:	c0 c3       	brcs	800135d0 <__avr32_f64_div_round_subnormal+0xcc>
800135ba:	e8 05 11 20 	rsub	r5,r4,32
800135be:	f2 04 09 49 	lsl	r9,r9,r4
800135c2:	f0 05 0a 45 	lsr	r5,r8,r5
800135c6:	0a 49       	or	r9,r5
800135c8:	f0 04 09 48 	lsl	r8,r8,r4
800135cc:	08 16       	sub	r6,r4
800135ce:	c0 b8       	rjmp	800135e4 <__avr32_f64_div_round_subnormal+0xe0>
800135d0:	f0 04 12 00 	clz	r4,r8
800135d4:	f9 b4 03 00 	movlo	r4,0
800135d8:	f7 b4 02 e0 	subhs	r4,-32
800135dc:	f0 04 09 49 	lsl	r9,r8,r4
800135e0:	30 08       	mov	r8,0
800135e2:	08 16       	sub	r6,r4
800135e4:	a3 88       	lsr	r8,0x2
800135e6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800135ea:	a3 89       	lsr	r9,0x2
800135ec:	cf ca       	rjmp	800133e4 <__avr32_f64_div+0x40>

800135ee <__avr32_f64_div_res_subnormal>:
800135ee:	5c 37       	neg	r7
800135f0:	2f f7       	sub	r7,-1
800135f2:	f1 b7 04 c0 	satu	r7,0x6
800135f6:	e0 47 00 20 	cp.w	r7,32
800135fa:	c1 54       	brge	80013624 <__avr32_f64_div_res_subnormal+0x36>
800135fc:	ee 06 11 20 	rsub	r6,r7,32
80013600:	e4 07 0a 42 	lsr	r2,r2,r7
80013604:	e6 06 09 4c 	lsl	r12,r3,r6
80013608:	18 42       	or	r2,r12
8001360a:	e6 07 0a 43 	lsr	r3,r3,r7
8001360e:	f4 06 09 41 	lsl	r1,r10,r6
80013612:	f4 07 0a 4a 	lsr	r10,r10,r7
80013616:	f6 06 09 4c 	lsl	r12,r11,r6
8001361a:	18 4a       	or	r10,r12
8001361c:	f6 07 0a 4b 	lsr	r11,r11,r7
80013620:	30 00       	mov	r0,0
80013622:	c1 58       	rjmp	8001364c <__avr32_f64_div_res_subnormal+0x5e>
80013624:	ee 06 11 20 	rsub	r6,r7,32
80013628:	f9 b0 00 00 	moveq	r0,0
8001362c:	f9 bc 00 00 	moveq	r12,0
80013630:	c0 50       	breq	8001363a <__avr32_f64_div_res_subnormal+0x4c>
80013632:	f4 06 09 40 	lsl	r0,r10,r6
80013636:	f6 06 09 4c 	lsl	r12,r11,r6
8001363a:	e6 07 0a 42 	lsr	r2,r3,r7
8001363e:	30 03       	mov	r3,0
80013640:	f4 07 0a 41 	lsr	r1,r10,r7
80013644:	18 41       	or	r1,r12
80013646:	f6 07 0a 4a 	lsr	r10,r11,r7
8001364a:	30 0b       	mov	r11,0
8001364c:	e0 12 ff 00 	andl	r2,0xff00
80013650:	e8 12 00 80 	orl	r2,0x80
80013654:	e6 08 06 46 	mulu.d	r6,r3,r8
80013658:	e4 09 07 46 	macu.d	r6,r2,r9
8001365c:	e4 08 06 44 	mulu.d	r4,r2,r8
80013660:	e6 09 06 48 	mulu.d	r8,r3,r9
80013664:	0c 05       	add	r5,r6
80013666:	f0 07 00 48 	adc	r8,r8,r7
8001366a:	5c 09       	acr	r9
8001366c:	30 07       	mov	r7,0
8001366e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80013672:	00 34       	cp.w	r4,r0
80013674:	e2 05 13 00 	cpc	r5,r1
80013678:	c4 6b       	rjmp	80013504 <__avr32_f64_div_round_subnormal>
8001367a:	1c 9b       	mov	r11,lr
8001367c:	e6 1b 80 00 	andh	r11,0x8000,COH
80013680:	30 0a       	mov	r10,0
80013682:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80013686:	3f fb       	mov	r11,-1
80013688:	30 0a       	mov	r10,0
8001368a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001368e:	f5 eb 10 04 	or	r4,r10,r11
80013692:	c0 90       	breq	800136a4 <__avr32_f64_div_op1_zero>
80013694:	1c 9b       	mov	r11,lr
80013696:	e6 1b 80 00 	andh	r11,0x8000,COH
8001369a:	ea 1b 7f f0 	orh	r11,0x7ff0
8001369e:	30 0a       	mov	r10,0
800136a0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

800136a4 <__avr32_f64_div_op1_zero>:
800136a4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
800136a8:	ce f0       	breq	80013686 <__avr32_f64_div_res_subnormal+0x98>
800136aa:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
800136ae:	e0 44 07 ff 	cp.w	r4,2047
800136b2:	ce 41       	brne	8001367a <__avr32_f64_div_res_subnormal+0x8c>
800136b4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
800136b8:	ce 10       	breq	8001367a <__avr32_f64_div_res_subnormal+0x8c>
800136ba:	ce 6b       	rjmp	80013686 <__avr32_f64_div_res_subnormal+0x98>

800136bc <__avr32_umod64>:
800136bc:	d4 31       	pushm	r0-r7,lr
800136be:	1a 97       	mov	r7,sp
800136c0:	20 2d       	sub	sp,8
800136c2:	10 9c       	mov	r12,r8
800136c4:	12 95       	mov	r5,r9
800136c6:	14 9e       	mov	lr,r10
800136c8:	16 93       	mov	r3,r11
800136ca:	16 96       	mov	r6,r11
800136cc:	58 09       	cp.w	r9,0
800136ce:	c4 41       	brne	80013756 <__avr32_umod64+0x9a>
800136d0:	16 38       	cp.w	r8,r11
800136d2:	e0 88 00 5a 	brls	80013786 <__avr32_umod64+0xca>
800136d6:	f0 08 12 00 	clz	r8,r8
800136da:	c0 d0       	breq	800136f4 <__avr32_umod64+0x38>
800136dc:	f6 08 09 46 	lsl	r6,r11,r8
800136e0:	f8 08 09 4c 	lsl	r12,r12,r8
800136e4:	f0 0b 11 20 	rsub	r11,r8,32
800136e8:	f4 08 09 4e 	lsl	lr,r10,r8
800136ec:	f4 0b 0a 4b 	lsr	r11,r10,r11
800136f0:	f7 e6 10 06 	or	r6,r11,r6
800136f4:	f8 0a 16 10 	lsr	r10,r12,0x10
800136f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800136fc:	ec 0a 0d 02 	divu	r2,r6,r10
80013700:	fc 09 16 10 	lsr	r9,lr,0x10
80013704:	ea 02 02 4b 	mul	r11,r5,r2
80013708:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8001370c:	12 3b       	cp.w	r11,r9
8001370e:	e0 88 00 09 	brls	80013720 <__avr32_umod64+0x64>
80013712:	18 09       	add	r9,r12
80013714:	12 3c       	cp.w	r12,r9
80013716:	e0 8b 00 05 	brhi	80013720 <__avr32_umod64+0x64>
8001371a:	12 3b       	cp.w	r11,r9
8001371c:	f3 dc eb 09 	addhi	r9,r9,r12
80013720:	f2 0b 01 0b 	sub	r11,r9,r11
80013724:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80013728:	f6 0a 0d 0a 	divu	r10,r11,r10
8001372c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
80013730:	ea 0a 02 4a 	mul	r10,r5,r10
80013734:	1c 3a       	cp.w	r10,lr
80013736:	e0 88 00 09 	brls	80013748 <__avr32_umod64+0x8c>
8001373a:	18 0e       	add	lr,r12
8001373c:	1c 3c       	cp.w	r12,lr
8001373e:	e0 8b 00 05 	brhi	80013748 <__avr32_umod64+0x8c>
80013742:	1c 3a       	cp.w	r10,lr
80013744:	fd dc eb 0e 	addhi	lr,lr,r12
80013748:	fc 0a 01 0a 	sub	r10,lr,r10
8001374c:	30 0b       	mov	r11,0
8001374e:	f4 08 0a 4a 	lsr	r10,r10,r8
80013752:	2f ed       	sub	sp,-8
80013754:	d8 32       	popm	r0-r7,pc
80013756:	16 39       	cp.w	r9,r11
80013758:	fe 9b ff fd 	brhi	80013752 <__avr32_umod64+0x96>
8001375c:	f2 09 12 00 	clz	r9,r9
80013760:	c4 61       	brne	800137ec <__avr32_umod64+0x130>
80013762:	14 38       	cp.w	r8,r10
80013764:	5f 8b       	srls	r11
80013766:	06 35       	cp.w	r5,r3
80013768:	5f 3a       	srlo	r10
8001376a:	f7 ea 10 0a 	or	r10,r11,r10
8001376e:	f2 0a 18 00 	cp.b	r10,r9
80013772:	c0 60       	breq	8001377e <__avr32_umod64+0xc2>
80013774:	fc 08 01 0a 	sub	r10,lr,r8
80013778:	e6 05 01 46 	sbc	r6,r3,r5
8001377c:	14 9e       	mov	lr,r10
8001377e:	0c 9b       	mov	r11,r6
80013780:	1c 9a       	mov	r10,lr
80013782:	2f ed       	sub	sp,-8
80013784:	d8 32       	popm	r0-r7,pc
80013786:	58 08       	cp.w	r8,0
80013788:	c0 51       	brne	80013792 <__avr32_umod64+0xd6>
8001378a:	30 19       	mov	r9,1
8001378c:	f2 08 0d 08 	divu	r8,r9,r8
80013790:	10 9c       	mov	r12,r8
80013792:	f8 08 12 00 	clz	r8,r12
80013796:	e0 81 00 84 	brne	8001389e <__avr32_umod64+0x1e2>
8001379a:	ec 0c 01 0b 	sub	r11,r6,r12
8001379e:	f8 03 16 10 	lsr	r3,r12,0x10
800137a2:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800137a6:	f6 03 0d 0a 	divu	r10,r11,r3
800137aa:	fc 09 16 10 	lsr	r9,lr,0x10
800137ae:	ea 0a 02 4a 	mul	r10,r5,r10
800137b2:	f3 eb 11 09 	or	r9,r9,r11<<0x10
800137b6:	12 3a       	cp.w	r10,r9
800137b8:	e0 88 00 09 	brls	800137ca <__avr32_umod64+0x10e>
800137bc:	18 09       	add	r9,r12
800137be:	12 3c       	cp.w	r12,r9
800137c0:	e0 8b 00 05 	brhi	800137ca <__avr32_umod64+0x10e>
800137c4:	12 3a       	cp.w	r10,r9
800137c6:	f3 dc eb 09 	addhi	r9,r9,r12
800137ca:	14 19       	sub	r9,r10
800137cc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800137d0:	f2 03 0d 02 	divu	r2,r9,r3
800137d4:	fd e3 11 0e 	or	lr,lr,r3<<0x10
800137d8:	ea 02 02 4a 	mul	r10,r5,r2
800137dc:	1c 3a       	cp.w	r10,lr
800137de:	fe 98 ff b5 	brls	80013748 <__avr32_umod64+0x8c>
800137e2:	18 0e       	add	lr,r12
800137e4:	1c 3c       	cp.w	r12,lr
800137e6:	fe 9b ff b1 	brhi	80013748 <__avr32_umod64+0x8c>
800137ea:	ca cb       	rjmp	80013742 <__avr32_umod64+0x86>
800137ec:	f2 0e 11 20 	rsub	lr,r9,32
800137f0:	ea 09 09 45 	lsl	r5,r5,r9
800137f4:	f6 09 09 4b 	lsl	r11,r11,r9
800137f8:	e6 0e 0a 43 	lsr	r3,r3,lr
800137fc:	f0 09 09 41 	lsl	r1,r8,r9
80013800:	f4 09 09 42 	lsl	r2,r10,r9
80013804:	f0 0e 0a 48 	lsr	r8,r8,lr
80013808:	f4 0e 0a 4a 	lsr	r10,r10,lr
8001380c:	0a 48       	or	r8,r5
8001380e:	16 4a       	or	r10,r11
80013810:	f0 06 16 10 	lsr	r6,r8,0x10
80013814:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80013818:	e6 06 0d 04 	divu	r4,r3,r6
8001381c:	f4 03 16 10 	lsr	r3,r10,0x10
80013820:	08 9b       	mov	r11,r4
80013822:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80013826:	e8 0c 02 45 	mul	r5,r4,r12
8001382a:	06 35       	cp.w	r5,r3
8001382c:	e0 88 00 07 	brls	8001383a <__avr32_umod64+0x17e>
80013830:	20 1b       	sub	r11,1
80013832:	10 03       	add	r3,r8
80013834:	06 38       	cp.w	r8,r3
80013836:	e0 88 00 72 	brls	8001391a <__avr32_umod64+0x25e>
8001383a:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8001383e:	0a 13       	sub	r3,r5
80013840:	e6 06 0d 04 	divu	r4,r3,r6
80013844:	f5 e5 11 06 	or	r6,r10,r5<<0x10
80013848:	e8 0c 02 4c 	mul	r12,r4,r12
8001384c:	08 9a       	mov	r10,r4
8001384e:	0c 3c       	cp.w	r12,r6
80013850:	e0 88 00 07 	brls	8001385e <__avr32_umod64+0x1a2>
80013854:	20 1a       	sub	r10,1
80013856:	10 06       	add	r6,r8
80013858:	0c 38       	cp.w	r8,r6
8001385a:	e0 88 00 5a 	brls	8001390e <__avr32_umod64+0x252>
8001385e:	f5 eb 11 0b 	or	r11,r10,r11<<0x10
80013862:	18 16       	sub	r6,r12
80013864:	f6 01 06 4a 	mulu.d	r10,r11,r1
80013868:	14 9c       	mov	r12,r10
8001386a:	16 36       	cp.w	r6,r11
8001386c:	c0 73       	brcs	8001387a <__avr32_umod64+0x1be>
8001386e:	5f 05       	sreq	r5
80013870:	14 32       	cp.w	r2,r10
80013872:	5f 3a       	srlo	r10
80013874:	eb ea 00 0a 	and	r10,r5,r10
80013878:	c0 60       	breq	80013884 <__avr32_umod64+0x1c8>
8001387a:	f8 01 01 04 	sub	r4,r12,r1
8001387e:	f6 08 01 4b 	sbc	r11,r11,r8
80013882:	08 9c       	mov	r12,r4
80013884:	e4 0c 01 0a 	sub	r10,r2,r12
80013888:	ec 0b 01 46 	sbc	r6,r6,r11
8001388c:	ec 09 0a 4b 	lsr	r11,r6,r9
80013890:	f4 09 0a 4a 	lsr	r10,r10,r9
80013894:	ec 0e 09 46 	lsl	r6,r6,lr
80013898:	0c 4a       	or	r10,r6
8001389a:	2f ed       	sub	sp,-8
8001389c:	d8 32       	popm	r0-r7,pc
8001389e:	f0 01 11 20 	rsub	r1,r8,32
800138a2:	f4 01 0a 4b 	lsr	r11,r10,r1
800138a6:	f8 08 09 4c 	lsl	r12,r12,r8
800138aa:	ec 08 09 49 	lsl	r9,r6,r8
800138ae:	ec 01 0a 41 	lsr	r1,r6,r1
800138b2:	f7 e9 10 09 	or	r9,r11,r9
800138b6:	f8 03 16 10 	lsr	r3,r12,0x10
800138ba:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800138be:	e2 03 0d 00 	divu	r0,r1,r3
800138c2:	f2 0b 16 10 	lsr	r11,r9,0x10
800138c6:	ea 00 02 4e 	mul	lr,r5,r0
800138ca:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800138ce:	16 3e       	cp.w	lr,r11
800138d0:	e0 88 00 06 	brls	800138dc <__avr32_umod64+0x220>
800138d4:	18 0b       	add	r11,r12
800138d6:	16 3c       	cp.w	r12,r11
800138d8:	e0 88 00 27 	brls	80013926 <__avr32_umod64+0x26a>
800138dc:	f6 0e 01 01 	sub	r1,r11,lr
800138e0:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
800138e4:	e2 03 0d 00 	divu	r0,r1,r3
800138e8:	f3 e1 11 09 	or	r9,r9,r1<<0x10
800138ec:	ea 00 02 4b 	mul	r11,r5,r0
800138f0:	12 3b       	cp.w	r11,r9
800138f2:	e0 88 00 09 	brls	80013904 <__avr32_umod64+0x248>
800138f6:	18 09       	add	r9,r12
800138f8:	12 3c       	cp.w	r12,r9
800138fa:	e0 8b 00 05 	brhi	80013904 <__avr32_umod64+0x248>
800138fe:	12 3b       	cp.w	r11,r9
80013900:	f3 dc eb 09 	addhi	r9,r9,r12
80013904:	f2 0b 01 0b 	sub	r11,r9,r11
80013908:	f4 08 09 4e 	lsl	lr,r10,r8
8001390c:	c4 db       	rjmp	800137a6 <__avr32_umod64+0xea>
8001390e:	0c 3c       	cp.w	r12,r6
80013910:	f7 ba 0b 01 	subhi	r10,1
80013914:	ed d8 eb 06 	addhi	r6,r6,r8
80013918:	ca 3b       	rjmp	8001385e <__avr32_umod64+0x1a2>
8001391a:	06 35       	cp.w	r5,r3
8001391c:	f7 bb 0b 01 	subhi	r11,1
80013920:	e7 d8 eb 03 	addhi	r3,r3,r8
80013924:	c8 bb       	rjmp	8001383a <__avr32_umod64+0x17e>
80013926:	16 3e       	cp.w	lr,r11
80013928:	f7 dc eb 0b 	addhi	r11,r11,r12
8001392c:	cd 8b       	rjmp	800138dc <__avr32_umod64+0x220>

Disassembly of section .exception:

80013a00 <_evba>:
80013a00:	c0 08       	rjmp	80013a00 <_evba>
	...

80013a04 <_handle_TLB_Multiple_Hit>:
80013a04:	c0 08       	rjmp	80013a04 <_handle_TLB_Multiple_Hit>
	...

80013a08 <_handle_Bus_Error_Data_Fetch>:
80013a08:	c0 08       	rjmp	80013a08 <_handle_Bus_Error_Data_Fetch>
	...

80013a0c <_handle_Bus_Error_Instruction_Fetch>:
80013a0c:	c0 08       	rjmp	80013a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80013a10 <_handle_NMI>:
80013a10:	c0 08       	rjmp	80013a10 <_handle_NMI>
	...

80013a14 <_handle_Instruction_Address>:
80013a14:	c0 08       	rjmp	80013a14 <_handle_Instruction_Address>
	...

80013a18 <_handle_ITLB_Protection>:
80013a18:	c0 08       	rjmp	80013a18 <_handle_ITLB_Protection>
	...

80013a1c <_handle_Breakpoint>:
80013a1c:	c0 08       	rjmp	80013a1c <_handle_Breakpoint>
	...

80013a20 <_handle_Illegal_Opcode>:
80013a20:	c0 08       	rjmp	80013a20 <_handle_Illegal_Opcode>
	...

80013a24 <_handle_Unimplemented_Instruction>:
80013a24:	c0 08       	rjmp	80013a24 <_handle_Unimplemented_Instruction>
	...

80013a28 <_handle_Privilege_Violation>:
80013a28:	c0 08       	rjmp	80013a28 <_handle_Privilege_Violation>
	...

80013a2c <_handle_Floating_Point>:
80013a2c:	c0 08       	rjmp	80013a2c <_handle_Floating_Point>
	...

80013a30 <_handle_Coprocessor_Absent>:
80013a30:	c0 08       	rjmp	80013a30 <_handle_Coprocessor_Absent>
	...

80013a34 <_handle_Data_Address_Read>:
80013a34:	c0 08       	rjmp	80013a34 <_handle_Data_Address_Read>
	...

80013a38 <_handle_Data_Address_Write>:
80013a38:	c0 08       	rjmp	80013a38 <_handle_Data_Address_Write>
	...

80013a3c <_handle_DTLB_Protection_Read>:
80013a3c:	c0 08       	rjmp	80013a3c <_handle_DTLB_Protection_Read>
	...

80013a40 <_handle_DTLB_Protection_Write>:
80013a40:	c0 08       	rjmp	80013a40 <_handle_DTLB_Protection_Write>
	...

80013a44 <_handle_DTLB_Modified>:
80013a44:	c0 08       	rjmp	80013a44 <_handle_DTLB_Modified>
	...

80013a50 <_handle_ITLB_Miss>:
80013a50:	c0 08       	rjmp	80013a50 <_handle_ITLB_Miss>
	...

80013a60 <_handle_DTLB_Miss_Read>:
80013a60:	c0 08       	rjmp	80013a60 <_handle_DTLB_Miss_Read>
	...

80013a70 <_handle_DTLB_Miss_Write>:
80013a70:	c0 08       	rjmp	80013a70 <_handle_DTLB_Miss_Write>
	...

80013b00 <_handle_Supervisor_Call>:
80013b00:	c0 08       	rjmp	80013b00 <_handle_Supervisor_Call>
80013b02:	d7 03       	nop

80013b04 <_int0>:
80013b04:	30 0c       	mov	r12,0
80013b06:	fe b0 74 0d 	rcall	80002320 <_get_interrupt_handler>
80013b0a:	58 0c       	cp.w	r12,0
80013b0c:	f8 0f 17 10 	movne	pc,r12
80013b10:	d6 03       	rete

80013b12 <_int1>:
80013b12:	30 1c       	mov	r12,1
80013b14:	fe b0 74 06 	rcall	80002320 <_get_interrupt_handler>
80013b18:	58 0c       	cp.w	r12,0
80013b1a:	f8 0f 17 10 	movne	pc,r12
80013b1e:	d6 03       	rete

80013b20 <_int2>:
80013b20:	30 2c       	mov	r12,2
80013b22:	fe b0 73 ff 	rcall	80002320 <_get_interrupt_handler>
80013b26:	58 0c       	cp.w	r12,0
80013b28:	f8 0f 17 10 	movne	pc,r12
80013b2c:	d6 03       	rete

80013b2e <_int3>:
80013b2e:	30 3c       	mov	r12,3
80013b30:	fe b0 73 f8 	rcall	80002320 <_get_interrupt_handler>
80013b34:	58 0c       	cp.w	r12,0
80013b36:	f8 0f 17 10 	movne	pc,r12
80013b3a:	d6 03       	rete
80013b3c:	d7 03       	nop
80013b3e:	d7 03       	nop
80013b40:	d7 03       	nop
80013b42:	d7 03       	nop
80013b44:	d7 03       	nop
80013b46:	d7 03       	nop
80013b48:	d7 03       	nop
80013b4a:	d7 03       	nop
80013b4c:	d7 03       	nop
80013b4e:	d7 03       	nop
80013b50:	d7 03       	nop
80013b52:	d7 03       	nop
80013b54:	d7 03       	nop
80013b56:	d7 03       	nop
80013b58:	d7 03       	nop
80013b5a:	d7 03       	nop
80013b5c:	d7 03       	nop
80013b5e:	d7 03       	nop
80013b60:	d7 03       	nop
80013b62:	d7 03       	nop
80013b64:	d7 03       	nop
80013b66:	d7 03       	nop
80013b68:	d7 03       	nop
80013b6a:	d7 03       	nop
80013b6c:	d7 03       	nop
80013b6e:	d7 03       	nop
80013b70:	d7 03       	nop
80013b72:	d7 03       	nop
80013b74:	d7 03       	nop
80013b76:	d7 03       	nop
80013b78:	d7 03       	nop
80013b7a:	d7 03       	nop
80013b7c:	d7 03       	nop
80013b7e:	d7 03       	nop
80013b80:	d7 03       	nop
80013b82:	d7 03       	nop
80013b84:	d7 03       	nop
80013b86:	d7 03       	nop
80013b88:	d7 03       	nop
80013b8a:	d7 03       	nop
80013b8c:	d7 03       	nop
80013b8e:	d7 03       	nop
80013b90:	d7 03       	nop
80013b92:	d7 03       	nop
80013b94:	d7 03       	nop
80013b96:	d7 03       	nop
80013b98:	d7 03       	nop
80013b9a:	d7 03       	nop
80013b9c:	d7 03       	nop
80013b9e:	d7 03       	nop
80013ba0:	d7 03       	nop
80013ba2:	d7 03       	nop
80013ba4:	d7 03       	nop
80013ba6:	d7 03       	nop
80013ba8:	d7 03       	nop
80013baa:	d7 03       	nop
80013bac:	d7 03       	nop
80013bae:	d7 03       	nop
80013bb0:	d7 03       	nop
80013bb2:	d7 03       	nop
80013bb4:	d7 03       	nop
80013bb6:	d7 03       	nop
80013bb8:	d7 03       	nop
80013bba:	d7 03       	nop
80013bbc:	d7 03       	nop
80013bbe:	d7 03       	nop
80013bc0:	d7 03       	nop
80013bc2:	d7 03       	nop
80013bc4:	d7 03       	nop
80013bc6:	d7 03       	nop
80013bc8:	d7 03       	nop
80013bca:	d7 03       	nop
80013bcc:	d7 03       	nop
80013bce:	d7 03       	nop
80013bd0:	d7 03       	nop
80013bd2:	d7 03       	nop
80013bd4:	d7 03       	nop
80013bd6:	d7 03       	nop
80013bd8:	d7 03       	nop
80013bda:	d7 03       	nop
80013bdc:	d7 03       	nop
80013bde:	d7 03       	nop
80013be0:	d7 03       	nop
80013be2:	d7 03       	nop
80013be4:	d7 03       	nop
80013be6:	d7 03       	nop
80013be8:	d7 03       	nop
80013bea:	d7 03       	nop
80013bec:	d7 03       	nop
80013bee:	d7 03       	nop
80013bf0:	d7 03       	nop
80013bf2:	d7 03       	nop
80013bf4:	d7 03       	nop
80013bf6:	d7 03       	nop
80013bf8:	d7 03       	nop
80013bfa:	d7 03       	nop
80013bfc:	d7 03       	nop
80013bfe:	d7 03       	nop


aleph-flry.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80010000  80010000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80012008  80012008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00011b60  80012008  80012008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80023c00  80023c00  00014000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00002058  80023e00  80023e00  00014200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000058c  00000008  80025e58  00016408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000594  800263e4  00016994  2**0
                  ALLOC
  8 .bss          00002db0  00000598  00000598  00000000  2**2
                  ALLOC
  9 .heap         0000bcb8  00003348  00003348  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00016994  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000015b0  00000000  00000000  000169c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000330e  00000000  00000000  00017f74  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00035826  00000000  00000000  0001b282  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007894  00000000  00000000  00050aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0002de80  00000000  00000000  0005833c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003d98  00000000  00000000  000861bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000a7c7  00000000  00000000  00089f54  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000e0b5  00000000  00000000  0009471b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 02d50d2a  00000000  00000000  000a27d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .flash_nvram  00010048  80040000  800263e4  00016c00  2**2
                  ALLOC
 22 .debug_ranges 00007e08  00000000  00000000  02df34fa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80010000 <_trampoline>:
80010000:	e0 8f 10 00 	bral	80012000 <program_start>
	...

80012000 <program_start>:
80012000:	fe ff 00 04 	ld.w	pc,pc[4]
80012004:	80 01       	ld.sh	r1,r0[0x0]
80012006:	fe e4 91 21 	ld.d	r4,pc[0]

Disassembly of section .text:

80012008 <smc_get_cs_size>:

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
}

unsigned char smc_get_cs_size(unsigned char cs)
{
80012008:	e0 68 05 98 	mov	r8,1432
  return smc_tab_cs_size[cs];
}
8001200c:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80012010:	5e fc       	retal	r12
80012012:	d7 03       	nop

80012014 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80012014:	eb cd 40 c0 	pushm	r6-r7,lr
  // Enable SM mode for CS1 if necessary.
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
80012018:	fe 68 10 00 	mov	r8,-126976
8001201c:	f0 f9 01 24 	ld.w	r9,r8[292]
80012020:	a1 d9       	cbr	r9,0x1
80012022:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80012026:	30 09       	mov	r9,0
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80012028:	f0 f8 01 24 	ld.w	r8,r8[292]
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
8001202c:	fe 68 1c 00 	mov	r8,-123904
80012030:	91 49       	st.w	r8[0x10],r9
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80012032:	ee 79 42 3f 	mov	r9,999999
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80012036:	e0 6e 4d d3 	mov	lr,19923
8001203a:	ea 1e 10 62 	orh	lr,0x1062
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8001203e:	f8 09 00 0b 	add	r11,r12,r9
80012042:	e0 69 de 83 	mov	r9,56963
80012046:	ea 19 43 1b 	orh	r9,0x431b
8001204a:	f6 09 06 4a 	mulu.d	r10,r11,r9
8001204e:	b3 8b       	lsr	r11,0x12
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80012050:	f6 07 10 52 	mul	r7,r11,82
80012054:	ee c7 fc 19 	sub	r7,r7,-999
80012058:	ee 0e 06 46 	mulu.d	r6,r7,lr
8001205c:	0e 99       	mov	r9,r7
8001205e:	e0 67 00 a4 	mov	r7,164
80012062:	a7 89       	lsr	r9,0x6
80012064:	f6 07 02 47 	mul	r7,r11,r7
80012068:	f2 0a 15 10 	lsl	r10,r9,0x10
8001206c:	ee c7 fc 19 	sub	r7,r7,-999
80012070:	f5 e9 10 8c 	or	r12,r10,r9<<0x8
80012074:	ee 0e 06 46 	mulu.d	r6,r7,lr
80012078:	12 4c       	or	r12,r9
8001207a:	0e 9b       	mov	r11,r7
8001207c:	f9 e9 11 8c 	or	r12,r12,r9<<0x18
80012080:	a7 8b       	lsr	r11,0x6
80012082:	91 5c       	st.w	r8[0x14],r12
80012084:	12 3b       	cp.w	r11,r9
80012086:	f6 09 17 20 	movhs	r9,r11
8001208a:	12 4a       	or	r10,r9
8001208c:	e0 69 10 03 	mov	r9,4099
80012090:	91 6a       	st.w	r8[0x18],r10
80012092:	91 79       	st.w	r8[0x1c],r9
80012094:	31 49       	mov	r9,20
80012096:	e0 68 05 98 	mov	r8,1432
8001209a:	32 9b       	mov	r11,41
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
8001209c:	b0 99       	st.b	r8[0x1],r9
8001209e:	48 3c       	lddpc	r12,800120a8 <smc_init+0x94>
800120a0:	e0 a0 03 8e 	rcall	800127bc <gpio_enable_module>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
800120a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800120a8:	80 02       	ld.sh	r2,r0[0x0]
800120aa:	3e 00       	mov	r0,-32

800120ac <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800120ac:	fe 68 14 00 	mov	r8,-125952
800120b0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800120b2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800120b6:	91 09       	st.w	r8[0x0],r9
}
800120b8:	5e fc       	retal	r12

800120ba <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
800120ba:	e0 68 8a 3f 	mov	r8,35391
800120be:	ea 18 01 f7 	orh	r8,0x1f7
800120c2:	10 3c       	cp.w	r12,r8
800120c4:	e0 8b 00 0a 	brhi	800120d8 <flashc_set_bus_freq+0x1e>
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800120c8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800120cc:	30 0a       	mov	r10,0
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800120ce:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800120d0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800120d4:	91 09       	st.w	r8[0x0],r9
800120d6:	5e fc       	retal	r12
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800120d8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800120dc:	30 1a       	mov	r10,1
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800120de:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800120e0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800120e4:	91 09       	st.w	r8[0x0],r9
800120e6:	5e fc       	retal	r12

800120e8 <flashc_default_wait_until_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
800120e8:	fe 6a 14 00 	mov	r10,-125952
}


void flashc_default_wait_until_ready(void)
{
	while (!flashc_is_ready());
800120ec:	30 09       	mov	r9,0
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
800120ee:	74 28       	ld.w	r8,r10[0x8]
}


void flashc_default_wait_until_ready(void)
{
	while (!flashc_is_ready());
800120f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800120f4:	f2 08 18 00 	cp.b	r8,r9
800120f8:	cf b0       	breq	800120ee <flashc_default_wait_until_ready+0x6>
}
800120fa:	5e fc       	retal	r12

800120fc <flashc_memcpy>:
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
800120fc:	d4 31       	pushm	r0-r7,lr
800120fe:	20 cd       	sub	sp,48
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
80012100:	e0 68 ff ff 	mov	r8,65535
80012104:	ea 18 80 7f 	orh	r8,0x807f
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80012108:	50 1c       	stdsp	sp[0x4],r12
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
8001210a:	10 3c       	cp.w	r12,r8
8001210c:	5f b1       	srhi	r1
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
8001210e:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
80012110:	50 31       	stdsp	sp[0xc],r1
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80012112:	14 97       	mov	r7,r10

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80012114:	58 0a       	cp.w	r10,0
80012116:	e0 80 01 34 	breq	8001237e <flashc_memcpy+0x282>
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
8001211a:	30 08       	mov	r8,0
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
8001211c:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
8001211e:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
80012120:	0c 93       	mov	r3,r6
80012122:	e0 61 05 a0 	mov	r1,1440
80012126:	e0 13 fe 00 	andl	r3,0xfe00
void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8001212a:	fe 62 14 00 	mov	r2,-125952
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8001212e:	10 95       	mov	r5,r8

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80012130:	30 80       	mov	r0,8
80012132:	60 09       	ld.w	r9,r0[0x0]
80012134:	50 08       	stdsp	sp[0x0],r8
80012136:	5d 19       	icall	r9
80012138:	64 19       	ld.w	r9,r2[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8001213a:	30 3c       	mov	r12,3
	u_avr32_flashc_fcmd.FCMD.cmd = command;
8001213c:	f3 dc d0 06 	bfins	r9,r12,0x0,0x6
80012140:	50 b9       	stdsp	sp[0x2c],r9
80012142:	3a 5a       	mov	r10,-91
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80012144:	fb 6a 00 2c 	st.b	sp[44],r10
80012148:	40 b9       	lddsp	r9,sp[0x2c]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
8001214a:	85 19       	st.w	r2[0x4],r9
8001214c:	64 29       	ld.w	r9,r2[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
8001214e:	e2 19 00 0c 	andl	r9,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
80012152:	83 09       	st.w	r1[0x0],r9
80012154:	60 09       	ld.w	r9,r0[0x0]
	flashc_wait_until_ready();
80012156:	5d 19       	icall	r9
80012158:	62 0a       	ld.w	r10,r1[0x0]
	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8001215a:	40 08       	lddsp	r8,sp[0x0]
8001215c:	14 48       	or	r8,r10
8001215e:	06 99       	mov	r9,r3
80012160:	50 28       	stdsp	sp[0x8],r8
80012162:	e6 cb fd ff 	sub	r11,r3,-513
	// Return the initial destination pointer as the standard memset function does.
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
80012166:	e6 c8 ff ff 	sub	r8,r3,-1
	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8001216a:	02 9e       	mov	lr,r1
	// Return the initial destination pointer as the standard memset function does.
	return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
8001216c:	c3 e8       	rjmp	800121e8 <flashc_memcpy+0xec>
8001216e:	0c 38       	cp.w	r8,r6
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80012170:	5f 0c       	sreq	r12
80012172:	14 6c       	and	r12,r10
80012174:	ea 0c 18 00 	cp.b	r12,r5
80012178:	c5 01       	brne	80012218 <flashc_memcpy+0x11c>
8001217a:	f0 c3 ff ff 	sub	r3,r8,-1
8001217e:	06 36       	cp.w	r6,r3
80012180:	5f 0c       	sreq	r12
80012182:	14 6c       	and	r12,r10
80012184:	ea 0c 18 00 	cp.b	r12,r5
80012188:	c5 61       	brne	80012234 <flashc_memcpy+0x138>
8001218a:	2f f3       	sub	r3,-1
8001218c:	06 36       	cp.w	r6,r3
8001218e:	5f 0c       	sreq	r12
80012190:	14 6c       	and	r12,r10
80012192:	ea 0c 18 00 	cp.b	r12,r5
80012196:	c5 c1       	brne	8001224e <flashc_memcpy+0x152>
80012198:	2f f3       	sub	r3,-1
8001219a:	06 36       	cp.w	r6,r3
8001219c:	5f 0c       	sreq	r12
8001219e:	14 6c       	and	r12,r10
800121a0:	ea 0c 18 00 	cp.b	r12,r5
800121a4:	c6 21       	brne	80012268 <flashc_memcpy+0x16c>
800121a6:	2f f3       	sub	r3,-1
800121a8:	06 36       	cp.w	r6,r3
800121aa:	5f 0c       	sreq	r12
800121ac:	14 6c       	and	r12,r10
800121ae:	ea 0c 18 00 	cp.b	r12,r5
800121b2:	c6 81       	brne	80012282 <flashc_memcpy+0x186>
800121b4:	2f f3       	sub	r3,-1
800121b6:	06 36       	cp.w	r6,r3
800121b8:	5f 0c       	sreq	r12
800121ba:	14 6c       	and	r12,r10
800121bc:	ea 0c 18 00 	cp.b	r12,r5
800121c0:	c6 e1       	brne	8001229c <flashc_memcpy+0x1a0>
800121c2:	2f f3       	sub	r3,-1
800121c4:	06 36       	cp.w	r6,r3
800121c6:	5f 0c       	sreq	r12
800121c8:	f9 ea 00 0a 	and	r10,r12,r10
800121cc:	ea 0a 18 00 	cp.b	r10,r5
800121d0:	c7 41       	brne	800122b8 <flashc_memcpy+0x1bc>
800121d2:	2f f3       	sub	r3,-1
800121d4:	e6 ca 00 08 	sub	r10,r3,8
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
800121d8:	fa e0 00 14 	ld.d	r0,sp[20]
800121dc:	f4 e1 00 00 	st.d	r10[0],r0
800121e0:	2f 89       	sub	r9,-8
800121e2:	2f 88       	sub	r8,-8
800121e4:	16 38       	cp.w	r8,r11
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
800121e6:	c7 10       	breq	800122c8 <flashc_memcpy+0x1cc>
800121e8:	f2 e0 00 00 	ld.d	r0,r9[0]
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
800121ec:	fa e1 00 14 	st.d	sp[20],r0
800121f0:	58 07       	cp.w	r7,0

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
800121f2:	5f 1a       	srne	r10
800121f4:	12 36       	cp.w	r6,r9
800121f6:	5f 0c       	sreq	r12
800121f8:	f5 ec 00 0c 	and	r12,r10,r12
800121fc:	ea 0c 18 00 	cp.b	r12,r5
80012200:	cb 70       	breq	8001216e <flashc_memcpy+0x72>
80012202:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80012204:	fb 6c 00 14 	st.b	sp[20],r12
80012208:	20 17       	sub	r7,1
					dest_add++;
					nbytes--;
8001220a:	30 1c       	mov	r12,1
8001220c:	5f 1a       	srne	r10
8001220e:	10 96       	mov	r6,r8

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80012210:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80012212:	ea 0c 18 00 	cp.b	r12,r5
80012216:	cb 20       	breq	8001217a <flashc_memcpy+0x7e>
80012218:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8001221a:	fb 6c 00 15 	st.b	sp[21],r12
8001221e:	20 17       	sub	r7,1
					dest_add++;
					nbytes--;
80012220:	f0 c6 ff ff 	sub	r6,r8,-1
			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
					dest_add++;
80012224:	58 07       	cp.w	r7,0
					nbytes--;
80012226:	5f 1a       	srne	r10
80012228:	30 1c       	mov	r12,1
8001222a:	0c 93       	mov	r3,r6
8001222c:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8001222e:	ea 0c 18 00 	cp.b	r12,r5
80012232:	ca c0       	breq	8001218a <flashc_memcpy+0x8e>
80012234:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80012236:	fb 6c 00 16 	st.b	sp[22],r12
8001223a:	e6 c6 ff ff 	sub	r6,r3,-1
					dest_add++;
8001223e:	20 17       	sub	r7,1
					nbytes--;
80012240:	30 1c       	mov	r12,1
80012242:	5f 1a       	srne	r10
80012244:	0c 93       	mov	r3,r6
80012246:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80012248:	ea 0c 18 00 	cp.b	r12,r5
8001224c:	ca 60       	breq	80012198 <flashc_memcpy+0x9c>
8001224e:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80012250:	fb 6c 00 17 	st.b	sp[23],r12
80012254:	e6 c6 ff ff 	sub	r6,r3,-1
					dest_add++;
80012258:	20 17       	sub	r7,1
					nbytes--;
8001225a:	30 1c       	mov	r12,1
8001225c:	5f 1a       	srne	r10
8001225e:	0c 93       	mov	r3,r6
80012260:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80012262:	ea 0c 18 00 	cp.b	r12,r5
80012266:	ca 00       	breq	800121a6 <flashc_memcpy+0xaa>
80012268:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8001226a:	fb 6c 00 18 	st.b	sp[24],r12
8001226e:	e6 c6 ff ff 	sub	r6,r3,-1
					dest_add++;
80012272:	20 17       	sub	r7,1
					nbytes--;
80012274:	30 1c       	mov	r12,1
80012276:	5f 1a       	srne	r10
80012278:	0c 93       	mov	r3,r6
8001227a:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8001227c:	ea 0c 18 00 	cp.b	r12,r5
80012280:	c9 a0       	breq	800121b4 <flashc_memcpy+0xb8>
80012282:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80012284:	fb 6c 00 19 	st.b	sp[25],r12
80012288:	e6 c6 ff ff 	sub	r6,r3,-1
					dest_add++;
8001228c:	20 17       	sub	r7,1
					nbytes--;
8001228e:	30 1c       	mov	r12,1
80012290:	5f 1a       	srne	r10
80012292:	0c 93       	mov	r3,r6
80012294:	14 6c       	and	r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80012296:	ea 0c 18 00 	cp.b	r12,r5
8001229a:	c9 40       	breq	800121c2 <flashc_memcpy+0xc6>
8001229c:	09 3c       	ld.ub	r12,r4++
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8001229e:	fb 6c 00 1a 	st.b	sp[26],r12
800122a2:	e6 c6 ff ff 	sub	r6,r3,-1
					dest_add++;
800122a6:	20 17       	sub	r7,1
					nbytes--;
800122a8:	30 1c       	mov	r12,1
800122aa:	5f 1a       	srne	r10
800122ac:	0c 93       	mov	r3,r6
800122ae:	f9 ea 00 0a 	and	r10,r12,r10
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
800122b2:	ea 0a 18 00 	cp.b	r10,r5
800122b6:	c8 e0       	breq	800121d2 <flashc_memcpy+0xd6>
800122b8:	e6 c6 ff ff 	sub	r6,r3,-1
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
					dest_add++;
800122bc:	09 3a       	ld.ub	r10,r4++

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
800122be:	20 17       	sub	r7,1
					dest_add++;
					nbytes--;
800122c0:	fb 6a 00 1b 	st.b	sp[27],r10

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
800122c4:	0c 93       	mov	r3,r6
					dest_add++;
					nbytes--;
800122c6:	c8 7b       	rjmp	800121d4 <flashc_memcpy+0xd8>
800122c8:	1c 91       	mov	r1,lr
800122ca:	40 40       	lddsp	r0,sp[0x10]
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
800122cc:	58 00       	cp.w	r0,0
800122ce:	c1 c0       	breq	80012306 <flashc_memcpy+0x20a>
800122d0:	40 3c       	lddsp	r12,sp[0xc]
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
800122d2:	58 0c       	cp.w	r12,0
800122d4:	c4 80       	breq	80012364 <flashc_memcpy+0x268>
800122d6:	30 8a       	mov	r10,8

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
800122d8:	74 08       	ld.w	r8,r10[0x0]
800122da:	5d 18       	icall	r8
800122dc:	64 18       	ld.w	r8,r2[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
800122de:	30 e9       	mov	r9,14
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800122e0:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
800122e4:	50 a8       	stdsp	sp[0x28],r8
800122e6:	3a 58       	mov	r8,-91
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800122e8:	fb 68 00 28 	st.b	sp[40],r8
800122ec:	40 a8       	lddsp	r8,sp[0x28]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800122ee:	85 18       	st.w	r2[0x4],r8
800122f0:	64 28       	ld.w	r8,r2[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800122f2:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800122f6:	30 80       	mov	r0,8
	flashc_wait_until_ready();
800122f8:	83 08       	st.w	r1[0x0],r8
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800122fa:	60 08       	ld.w	r8,r0[0x0]
	flashc_wait_until_ready();
800122fc:	5d 18       	icall	r8
800122fe:	40 2c       	lddsp	r12,sp[0x8]
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
			error_status |= flashc_error_status;
80012300:	62 08       	ld.w	r8,r1[0x0]
80012302:	10 4c       	or	r12,r8
80012304:	50 2c       	stdsp	sp[0x8],r12
80012306:	40 3a       	lddsp	r10,sp[0xc]
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
80012308:	58 0a       	cp.w	r10,0
8001230a:	c2 00       	breq	8001234a <flashc_memcpy+0x24e>
8001230c:	30 89       	mov	r9,8

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
8001230e:	72 08       	ld.w	r8,r9[0x0]
80012310:	5d 18       	icall	r8
80012312:	64 18       	ld.w	r8,r2[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80012314:	30 d9       	mov	r9,13
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80012316:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
8001231a:	50 88       	stdsp	sp[0x20],r8
8001231c:	3a 58       	mov	r8,-91
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
8001231e:	fb 68 00 20 	st.b	sp[32],r8
80012322:	40 88       	lddsp	r8,sp[0x20]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80012324:	85 18       	st.w	r2[0x4],r8
80012326:	64 28       	ld.w	r8,r2[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80012328:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8001232c:	30 80       	mov	r0,8
	flashc_wait_until_ready();
8001232e:	83 08       	st.w	r1[0x0],r8
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
80012330:	60 08       	ld.w	r8,r0[0x0]
	flashc_wait_until_ready();
80012332:	5d 18       	icall	r8
80012334:	62 08       	ld.w	r8,r1[0x0]
			error_status |= flashc_error_status;
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
80012336:	40 2c       	lddsp	r12,sp[0x8]
80012338:	f9 e8 10 08 	or	r8,r12,r8
8001233c:	58 07       	cp.w	r7,0

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
8001233e:	fe 91 fe f9 	brne	80012130 <flashc_memcpy+0x34>
80012342:	83 08       	st.w	r1[0x0],r8
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
80012344:	40 1c       	lddsp	r12,sp[0x4]

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
80012346:	2f 4d       	sub	sp,-48
80012348:	d8 32       	popm	r0-r7,pc
8001234a:	30 8c       	mov	r12,8

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
8001234c:	78 08       	ld.w	r8,r12[0x0]
8001234e:	5d 18       	icall	r8
80012350:	64 18       	ld.w	r8,r2[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80012352:	30 1a       	mov	r10,1
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80012354:	f1 da d0 06 	bfins	r8,r10,0x0,0x6
80012358:	50 78       	stdsp	sp[0x1c],r8
8001235a:	3a 59       	mov	r9,-91
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
8001235c:	fb 69 00 1c 	st.b	sp[28],r9
80012360:	40 78       	lddsp	r8,sp[0x1c]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80012362:	ce 1b       	rjmp	80012324 <flashc_memcpy+0x228>
80012364:	30 8c       	mov	r12,8

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80012366:	78 08       	ld.w	r8,r12[0x0]
80012368:	5d 18       	icall	r8
8001236a:	64 18       	ld.w	r8,r2[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8001236c:	30 2a       	mov	r10,2
	u_avr32_flashc_fcmd.FCMD.cmd = command;
8001236e:	f1 da d0 06 	bfins	r8,r10,0x0,0x6
80012372:	50 98       	stdsp	sp[0x24],r8
80012374:	3a 59       	mov	r9,-91
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80012376:	fb 69 00 24 	st.b	sp[36],r9
8001237a:	40 98       	lddsp	r8,sp[0x24]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
8001237c:	cb 9b       	rjmp	800122ee <flashc_memcpy+0x1f2>
8001237e:	14 98       	mov	r8,r10

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80012380:	e0 61 05 a0 	mov	r1,1440
80012384:	cd fb       	rjmp	80012342 <flashc_memcpy+0x246>
80012386:	d7 03       	nop

80012388 <flashc_memset64>:
80012388:	d4 31       	pushm	r0-r7,lr
8001238a:	21 9d       	sub	sp,100
8001238c:	50 7c       	stdsp	sp[0x1c],r12
8001238e:	fe fe 03 26 	ld.w	lr,pc[806]
		256,
		384,
		512,
		768,
		1024,
	};
80012392:	fa cc ff d4 	sub	r12,sp,-44
80012396:	fc e6 00 08 	ld.d	r6,lr[8]
8001239a:	f8 e7 00 08 	st.d	r12[8],r6
volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
8001239e:	30 06       	mov	r6,0
800123a0:	30 07       	mov	r7,0
800123a2:	fa e7 00 44 	st.d	sp[68],r6
		256,
		384,
		512,
		768,
		1024,
	};
800123a6:	fc e6 00 00 	ld.d	r6,lr[0]
800123aa:	f8 e7 00 00 	st.d	r12[0],r6
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
800123ae:	40 7e       	lddsp	lr,sp[0x1c]
		384,
		512,
		768,
		1024,
	};
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
800123b0:	fe 6c 14 00 	mov	r12,-125952
800123b4:	78 2c       	ld.w	r12,r12[0x8]
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
800123b6:	51 8e       	stdsp	sp[0x60],lr
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800123b8:	f9 dc c1 a3 	bfextu	r12,r12,0xd,0x3
800123bc:	fa ce ff 9c 	sub	lr,sp,-100
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800123c0:	50 58       	stdsp	sp[0x14],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800123c2:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
800123c6:	fc 18 80 00 	movh	r8,0x8000
800123ca:	f9 1c ff c8 	ld.uh	r12,r12[-56]
800123ce:	ab 6c       	lsl	r12,0xa
800123d0:	f8 08 00 08 	add	r8,r12,r8
800123d4:	50 88       	stdsp	sp[0x20],r8
	dest.u8ptr = dst;
800123d6:	40 74       	lddsp	r4,sp[0x1c]
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800123d8:	58 0a       	cp.w	r10,0
800123da:	5c 2b       	cpc	r11
800123dc:	c1 80       	breq	8001240c <flashc_memset64+0x84>
800123de:	08 98       	mov	r8,r4
800123e0:	2f 98       	sub	r8,-7
800123e2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800123e6:	fa cc ff 9c 	sub	r12,sp,-100
800123ea:	10 0c       	add	r12,r8
800123ec:	f9 6a ff e0 	st.b	r12[-32],r10

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800123f0:	20 18       	sub	r8,1
		source.u8[i] = src;
		src >>= 8;
800123f2:	f4 0c 16 08 	lsr	r12,r10,0x8
800123f6:	f6 0e 16 08 	lsr	lr,r11,0x8
800123fa:	f9 eb 11 8c 	or	r12,r12,r11<<0x18

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800123fe:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
		source.u8[i] = src;
		src >>= 8;
80012402:	1c 9b       	mov	r11,lr
80012404:	18 9a       	mov	r10,r12
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
80012406:	58 0a       	cp.w	r10,0
80012408:	5c 2b       	cpc	r11
8001240a:	ce e1       	brne	800123e6 <flashc_memset64+0x5e>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
8001240c:	40 7b       	lddsp	r11,sp[0x1c]
8001240e:	12 0b       	add	r11,r9
80012410:	50 1b       	stdsp	sp[0x4],r11

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80012412:	40 7a       	lddsp	r10,sp[0x1c]
80012414:	e0 69 ff ff 	mov	r9,65535
80012418:	ea 19 7f ff 	orh	r9,0x7fff
8001241c:	12 3a       	cp.w	r10,r9
8001241e:	e0 8b 01 33 	brhi	80012684 <flashc_memset64+0x2fc>
		dest.u8ptr = AVR32_FLASH;
80012422:	fc 14 80 00 	movh	r4,0x8000
80012426:	51 84       	stdsp	sp[0x60],r4
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
80012428:	40 1a       	lddsp	r10,sp[0x4]
8001242a:	e0 69 02 00 	mov	r9,512
8001242e:	ea 19 80 80 	orh	r9,0x8080
80012432:	12 3a       	cp.w	r10,r9
80012434:	e0 88 01 16 	brls	80012660 <flashc_memset64+0x2d8>
80012438:	50 39       	stdsp	sp[0xc],r9
8001243a:	50 49       	stdsp	sp[0x10],r9
8001243c:	50 19       	stdsp	sp[0x4],r9
8001243e:	12 9e       	mov	lr,r9
80012440:	12 98       	mov	r8,r9
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80012442:	fd de c0 03 	bfextu	lr,lr,0x0,0x3
80012446:	fa cb ff c4 	sub	r11,sp,-60
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8001244a:	1c 18       	sub	r8,lr
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8001244c:	1c 0b       	add	r11,lr
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8001244e:	2f 88       	sub	r8,-8
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80012450:	50 6e       	stdsp	sp[0x18],lr
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80012452:	50 a8       	stdsp	sp[0x28],r8
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80012454:	50 9b       	stdsp	sp[0x24],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80012456:	fa e6 00 44 	ld.d	r6,sp[68]
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8001245a:	30 01       	mov	r1,0
8001245c:	e0 63 05 a0 	mov	r3,1440

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80012460:	30 82       	mov	r2,8
80012462:	fe 65 14 00 	mov	r5,-125952
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80012466:	3a 50       	mov	r0,-91
	u_avr32_flashc_fcmd.FCMD.cmd = command;
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80012468:	40 19       	lddsp	r9,sp[0x4]
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
8001246a:	08 39       	cp.w	r9,r4
8001246c:	e0 88 00 b5 	brls	800125d6 <flashc_memset64+0x24e>
80012470:	64 08       	ld.w	r8,r2[0x0]

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80012472:	5d 18       	icall	r8
80012474:	6a 18       	ld.w	r8,r5[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80012476:	30 3a       	mov	r10,3
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80012478:	f1 da d0 06 	bfins	r8,r10,0x0,0x6
8001247c:	51 68       	stdsp	sp[0x58],r8
8001247e:	fb 60 00 58 	st.b	sp[88],r0
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80012482:	41 68       	lddsp	r8,sp[0x58]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80012484:	8b 18       	st.w	r5[0x4],r8
80012486:	6a 28       	ld.w	r8,r5[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80012488:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8001248c:	87 08       	st.w	r3[0x0],r8
8001248e:	64 08       	ld.w	r8,r2[0x0]
	flashc_wait_until_ready();
80012490:	5d 18       	icall	r8
80012492:	66 08       	ld.w	r8,r3[0x0]

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
80012494:	08 9b       	mov	r11,r4

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
80012496:	40 3e       	lddsp	lr,sp[0xc]
80012498:	e0 1b fe 00 	andl	r11,0xfe00
8001249c:	fa e7 00 3c 	st.d	sp[60],r6
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800124a0:	f6 c9 fe 00 	sub	r9,r11,-512
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800124a4:	fc 09 0d 4e 	min	lr,lr,r9
800124a8:	50 2e       	stdsp	sp[0x8],lr
800124aa:	10 41       	or	r1,r8

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
800124ac:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800124b0:	e0 80 00 97 	breq	800125de <flashc_memset64+0x256>
800124b4:	51 7b       	stdsp	sp[0x5c],r11
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800124b6:	08 99       	mov	r9,r4
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800124b8:	e0 19 ff f8 	andl	r9,0xfff8
800124bc:	12 9a       	mov	r10,r9
800124be:	12 3b       	cp.w	r11,r9
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800124c0:	c1 52       	brcc	800124ea <flashc_memset64+0x162>
800124c2:	16 98       	mov	r8,r11
800124c4:	12 9c       	mov	r12,r9
800124c6:	16 9e       	mov	lr,r11
800124c8:	f0 ea 00 00 	ld.d	r10,r8[0]
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800124cc:	b1 2a       	st.d	r8++,r10
800124ce:	10 39       	cp.w	r9,r8
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800124d0:	fe 9b ff fc 	brhi	800124c8 <flashc_memset64+0x140>
800124d4:	fc 08 11 ff 	rsub	r8,lr,-1
800124d8:	18 9a       	mov	r10,r12
800124da:	12 08       	add	r8,r9
800124dc:	1c 9b       	mov	r11,lr
800124de:	e0 18 ff f8 	andl	r8,0xfff8
800124e2:	2f 88       	sub	r8,-8
800124e4:	fc 08 00 08 	add	r8,lr,r8
800124e8:	51 78       	stdsp	sp[0x5c],r8
800124ea:	e9 d4 c0 03 	bfextu	r4,r4,0x0,0x3
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800124ee:	c7 80       	breq	800125de <flashc_memset64+0x256>
800124f0:	41 7e       	lddsp	lr,sp[0x5c]
800124f2:	30 08       	mov	r8,0
800124f4:	50 09       	stdsp	sp[0x0],r9
800124f6:	fc 08 00 0c 	add	r12,lr,r8
800124fa:	fa c9 ff c4 	sub	r9,sp,-60
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
800124fe:	19 8c       	ld.ub	r12,r12[0x0]
80012500:	f2 08 0b 0c 	st.b	r9[r8],r12
80012504:	2f f8       	sub	r8,-1
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80012506:	08 38       	cp.w	r8,r4
80012508:	cf 71       	brne	800124f6 <flashc_memset64+0x16e>
8001250a:	fc 08 00 08 	add	r8,lr,r8
8001250e:	40 09       	lddsp	r9,sp[0x0]
80012510:	51 78       	stdsp	sp[0x5c],r8
80012512:	51 89       	stdsp	sp[0x60],r9
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80012514:	40 38       	lddsp	r8,sp[0xc]

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
80012516:	10 39       	cp.w	r9,r8
80012518:	c0 82       	brcc	80012528 <flashc_memset64+0x1a0>
8001251a:	12 9a       	mov	r10,r9
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
8001251c:	fa e8 00 3c 	ld.d	r8,sp[60]
80012520:	b5 28       	st.d	r10++,r8
80012522:	fa e7 00 3c 	st.d	sp[60],r6
					flash_dword.u64 = source.u64;
80012526:	51 8a       	stdsp	sp[0x60],r10
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
80012528:	40 2c       	lddsp	r12,sp[0x8]
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
8001252a:	14 1c       	sub	r12,r10
8001252c:	a3 5c       	asr	r12,0x3
8001252e:	c0 90       	breq	80012540 <flashc_memset64+0x1b8>
80012530:	14 99       	mov	r9,r10
80012532:	18 98       	mov	r8,r12
80012534:	b3 26       	st.d	r9++,r6
			*dest.u64ptr++ = source.u64;
80012536:	20 18       	sub	r8,1
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80012538:	cf e1       	brne	80012534 <flashc_memset64+0x1ac>
8001253a:	f4 0c 00 3a 	add	r10,r10,r12<<0x3
8001253e:	51 8a       	stdsp	sp[0x60],r10
80012540:	40 48       	lddsp	r8,sp[0x10]
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80012542:	e0 18 fe 00 	andl	r8,0xfe00
80012546:	10 3b       	cp.w	r11,r8
80012548:	c1 f3       	brcs	80012586 <flashc_memset64+0x1fe>
8001254a:	40 1e       	lddsp	lr,sp[0x4]
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
8001254c:	51 7e       	stdsp	sp[0x5c],lr
8001254e:	40 6b       	lddsp	r11,sp[0x18]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80012550:	58 0b       	cp.w	r11,0
80012552:	c0 f0       	breq	80012570 <flashc_memset64+0x1e8>
80012554:	1c 99       	mov	r9,lr
80012556:	40 98       	lddsp	r8,sp[0x24]
80012558:	fa cc ff bc 	sub	r12,sp,-68
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
8001255c:	13 3b       	ld.ub	r11,r9++

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
8001255e:	10 cb       	st.b	r8++,r11
80012560:	18 38       	cp.w	r8,r12
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80012562:	cf d1       	brne	8001255c <flashc_memset64+0x1d4>
80012564:	40 a9       	lddsp	r9,sp[0x28]
80012566:	51 79       	stdsp	sp[0x5c],r9
80012568:	fa e8 00 3c 	ld.d	r8,sp[60]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
8001256c:	b5 28       	st.d	r10++,r8
8001256e:	51 8a       	stdsp	sp[0x60],r10
80012570:	41 78       	lddsp	r8,sp[0x5c]
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80012572:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80012576:	c0 80       	breq	80012586 <flashc_memset64+0x1fe>
80012578:	f0 ea 00 00 	ld.d	r10,r8[0]
					*tmp.u64ptr = *tmp.u64ptr;
8001257c:	b1 2a       	st.d	r8++,r10
8001257e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80012582:	cf b1       	brne	80012578 <flashc_memset64+0x1f0>
80012584:	51 78       	stdsp	sp[0x5c],r8
80012586:	41 84       	lddsp	r4,sp[0x60]
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
80012588:	fc 18 80 80 	movh	r8,0x8080
8001258c:	10 34       	cp.w	r4,r8
8001258e:	e0 8b 00 2a 	brhi	800125e2 <flashc_memset64+0x25a>
80012592:	40 5e       	lddsp	lr,sp[0x14]
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80012594:	58 0e       	cp.w	lr,0
80012596:	c3 d1       	brne	80012610 <flashc_memset64+0x288>
80012598:	64 08       	ld.w	r8,r2[0x0]

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
8001259a:	5d 18       	icall	r8
8001259c:	6a 18       	ld.w	r8,r5[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8001259e:	30 19       	mov	r9,1
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800125a0:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
800125a4:	51 48       	stdsp	sp[0x50],r8
800125a6:	fb 60 00 50 	st.b	sp[80],r0
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800125aa:	41 48       	lddsp	r8,sp[0x50]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800125ac:	8b 18       	st.w	r5[0x4],r8
800125ae:	6a 28       	ld.w	r8,r5[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800125b0:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800125b4:	87 08       	st.w	r3[0x0],r8
800125b6:	64 08       	ld.w	r8,r2[0x0]
	flashc_wait_until_ready();
800125b8:	5d 18       	icall	r8
800125ba:	66 08       	ld.w	r8,r3[0x0]
			if (erase) {
				flashc_erase_page(-1, false);
				error_status |= flashc_error_status;
			}
			flashc_write_page(-1);
			error_status |= flashc_error_status;
800125bc:	40 8b       	lddsp	r11,sp[0x20]

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
800125be:	10 41       	or	r1,r8
			if (erase) {
				flashc_erase_page(-1, false);
				error_status |= flashc_error_status;
			}
			flashc_write_page(-1);
			error_status |= flashc_error_status;
800125c0:	08 3b       	cp.w	r11,r4

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
800125c2:	e0 8b 00 05 	brhi	800125cc <flashc_memset64+0x244>
800125c6:	fc 18 80 80 	movh	r8,0x8080
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800125ca:	51 88       	stdsp	sp[0x60],r8
800125cc:	41 84       	lddsp	r4,sp[0x60]
			if (erase) {
				flashc_erase_user_page(false);
				error_status |= flashc_error_status;
			}
			flashc_write_user_page();
			error_status |= flashc_error_status;
800125ce:	40 19       	lddsp	r9,sp[0x4]
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800125d0:	08 39       	cp.w	r9,r4
800125d2:	fe 9b ff 4f 	brhi	80012470 <flashc_memset64+0xe8>
800125d6:	87 01       	st.w	r3[0x0],r1
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800125d8:	40 7c       	lddsp	r12,sp[0x1c]

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800125da:	2e 7d       	sub	sp,-100
800125dc:	d8 32       	popm	r0-r7,pc
800125de:	41 8a       	lddsp	r10,sp[0x60]
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800125e0:	ca 4b       	rjmp	80012528 <flashc_memset64+0x1a0>
800125e2:	40 5a       	lddsp	r10,sp[0x14]
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
800125e4:	58 0a       	cp.w	r10,0
800125e6:	c2 91       	brne	80012638 <flashc_memset64+0x2b0>
800125e8:	64 08       	ld.w	r8,r2[0x0]

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
800125ea:	5d 18       	icall	r8
800125ec:	6a 18       	ld.w	r8,r5[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
800125ee:	30 d9       	mov	r9,13
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800125f0:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
800125f4:	50 b8       	stdsp	sp[0x2c],r8
800125f6:	fb 60 00 2c 	st.b	sp[44],r0
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800125fa:	40 b8       	lddsp	r8,sp[0x2c]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800125fc:	8b 18       	st.w	r5[0x4],r8
800125fe:	6a 28       	ld.w	r8,r5[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80012600:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
80012604:	87 08       	st.w	r3[0x0],r8
80012606:	64 08       	ld.w	r8,r2[0x0]
	flashc_wait_until_ready();
80012608:	5d 18       	icall	r8
8001260a:	66 08       	ld.w	r8,r3[0x0]
			if (erase) {
				flashc_erase_user_page(false);
				error_status |= flashc_error_status;
			}
			flashc_write_user_page();
			error_status |= flashc_error_status;
8001260c:	10 41       	or	r1,r8
8001260e:	cd fb       	rjmp	800125cc <flashc_memset64+0x244>
80012610:	64 08       	ld.w	r8,r2[0x0]

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80012612:	5d 18       	icall	r8
80012614:	6a 18       	ld.w	r8,r5[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80012616:	30 29       	mov	r9,2
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80012618:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
8001261c:	51 58       	stdsp	sp[0x54],r8
8001261e:	fb 60 00 54 	st.b	sp[84],r0
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80012622:	41 58       	lddsp	r8,sp[0x54]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80012624:	8b 18       	st.w	r5[0x4],r8
80012626:	6a 28       	ld.w	r8,r5[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80012628:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8001262c:	87 08       	st.w	r3[0x0],r8
8001262e:	64 08       	ld.w	r8,r2[0x0]
	flashc_wait_until_ready();
80012630:	5d 18       	icall	r8
80012632:	66 08       	ld.w	r8,r3[0x0]
		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
				flashc_erase_page(-1, false);
				error_status |= flashc_error_status;
80012634:	10 41       	or	r1,r8
80012636:	cb 1b       	rjmp	80012598 <flashc_memset64+0x210>
80012638:	64 08       	ld.w	r8,r2[0x0]

void flashc_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
8001263a:	5d 18       	icall	r8
8001263c:	6a 18       	ld.w	r8,r5[0x4]
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8001263e:	30 e9       	mov	r9,14
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80012640:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
80012644:	51 38       	stdsp	sp[0x4c],r8
80012646:	fb 60 00 4c 	st.b	sp[76],r0
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
8001264a:	41 38       	lddsp	r8,sp[0x4c]
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
8001264c:	8b 18       	st.w	r5[0x4],r8
8001264e:	6a 28       	ld.w	r8,r5[0x8]
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80012650:	e2 18 00 0c 	andl	r8,0xc,COH
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
80012654:	87 08       	st.w	r3[0x0],r8
80012656:	64 08       	ld.w	r8,r2[0x0]
	flashc_wait_until_ready();
80012658:	5d 18       	icall	r8
8001265a:	66 08       	ld.w	r8,r3[0x0]
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
				flashc_erase_user_page(false);
				error_status |= flashc_error_status;
8001265c:	10 41       	or	r1,r8
8001265e:	cc 5b       	rjmp	800125e8 <flashc_memset64+0x260>
80012660:	fc 1e 80 80 	movh	lr,0x8080
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80012664:	1c 3a       	cp.w	r10,lr
80012666:	e0 8b 00 1e 	brhi	800126a2 <flashc_memset64+0x31a>
8001266a:	40 89       	lddsp	r9,sp[0x20]
8001266c:	12 3a       	cp.w	r10,r9
8001266e:	f2 0a 17 b0 	movhi	r10,r9
80012672:	14 98       	mov	r8,r10
80012674:	e0 18 ff f8 	andl	r8,0xfff8
80012678:	50 1a       	stdsp	sp[0x4],r10
8001267a:	50 38       	stdsp	sp[0xc],r8
8001267c:	50 4a       	stdsp	sp[0x10],r10
8001267e:	14 9e       	mov	lr,r10
80012680:	14 98       	mov	r8,r10
80012682:	ce 0a       	rjmp	80012442 <flashc_memset64+0xba>
80012684:	40 88       	lddsp	r8,sp[0x20]
	dest_end.u8ptr = dest.u8ptr + nbytes;

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
		dest.u8ptr = AVR32_FLASH;
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80012686:	14 38       	cp.w	r8,r10
80012688:	fe 9b fe d0 	brhi	80012428 <flashc_memset64+0xa0>
8001268c:	e0 6b ff ff 	mov	r11,65535
80012690:	ea 1b 80 7f 	orh	r11,0x807f
80012694:	16 3a       	cp.w	r10,r11
80012696:	fe 9b fe c9 	brhi	80012428 <flashc_memset64+0xa0>
8001269a:	fc 14 80 80 	movh	r4,0x8080
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
8001269e:	51 84       	stdsp	sp[0x60],r4
800126a0:	cc 4a       	rjmp	80012428 <flashc_memset64+0xa0>
800126a2:	14 9b       	mov	r11,r10
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
800126a4:	50 4a       	stdsp	sp[0x10],r10
800126a6:	e0 1b ff f8 	andl	r11,0xfff8
800126aa:	14 9e       	mov	lr,r10
800126ac:	50 3b       	stdsp	sp[0xc],r11
800126ae:	40 18       	lddsp	r8,sp[0x4]
800126b0:	cc 9a       	rjmp	80012442 <flashc_memset64+0xba>
800126b2:	d7 03       	nop
800126b4:	80 02       	ld.sh	r2,r0[0x0]
800126b6:	3f 48       	mov	r8,-12

800126b8 <flashc_memset32>:
800126b8:	eb cd 40 c0 	pushm	r6-r7,lr
800126bc:	30 0e       	mov	lr,0
800126be:	16 96       	mov	r6,r11
}


volatile void *flashc_memset32(volatile void *dst, uint32_t src, size_t nbytes, bool erase)
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
800126c0:	1c 97       	mov	r7,lr
800126c2:	12 98       	mov	r8,r9
800126c4:	0c 9b       	mov	r11,r6
800126c6:	14 99       	mov	r9,r10
800126c8:	0e 4b       	or	r11,r7
800126ca:	0e 9a       	mov	r10,r7
800126cc:	0c 4a       	or	r10,r6
800126ce:	c5 de       	rcall	80012388 <flashc_memset64>
800126d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800126d4 <gpio_enable_pin_pull_up>:
 */
void gpio_enable_pin_pull_up(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->puers = 1 << (pin & 0x1F);
800126d4:	30 18       	mov	r8,1
800126d6:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_pull_up(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800126da:	a5 9c       	lsr	r12,0x5
800126dc:	a9 6c       	lsl	r12,0x8
800126de:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->puers = 1 << (pin & 0x1F);
800126e2:	f9 48 00 74 	st.w	r12[116],r8
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	gpio_port->pderc = 1 << (pin & 0x1F);
#endif
}
800126e6:	5e fc       	retal	r12

800126e8 <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800126e8:	f8 08 16 05 	lsr	r8,r12,0x5
800126ec:	a9 68       	lsl	r8,0x8
800126ee:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800126f2:	71 88       	ld.w	r8,r8[0x60]
800126f4:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800126f8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800126fc:	5e fc       	retal	r12

800126fe <gpio_set_gpio_pin>:
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800126fe:	30 18       	mov	r8,1
80012700:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80012704:	a5 9c       	lsr	r12,0x5
80012706:	a9 6c       	lsl	r12,0x8
80012708:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8001270c:	f9 48 00 54 	st.w	r12[84],r8
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80012710:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80012714:	99 18       	st.w	r12[0x4],r8
}
80012716:	5e fc       	retal	r12

80012718 <gpio_clr_gpio_pin>:
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80012718:	30 18       	mov	r8,1
8001271a:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8001271e:	a5 9c       	lsr	r12,0x5
80012720:	a9 6c       	lsl	r12,0x8
80012722:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80012726:	f9 48 00 58 	st.w	r12[88],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8001272a:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8001272e:	99 18       	st.w	r12[0x4],r8
}
80012730:	5e fc       	retal	r12

80012732 <gpio_enable_pin_glitch_filter>:
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->gfers = 1 << (pin & 0x1F);
80012732:	30 18       	mov	r8,1
80012734:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80012738:	a5 9c       	lsr	r12,0x5
8001273a:	a9 6c       	lsl	r12,0x8
8001273c:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->gfers = 1 << (pin & 0x1F);
80012740:	f9 48 00 c4 	st.w	r12[196],r8
}
80012744:	5e fc       	retal	r12

80012746 <gpio_enable_pin_interrupt>:
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80012746:	30 1a       	mov	r10,1
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80012748:	f8 08 16 05 	lsr	r8,r12,0x5

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8001274c:	f4 0c 09 49 	lsl	r9,r10,r12
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80012750:	a9 68       	lsl	r8,0x8
80012752:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80012756:	f1 49 00 c4 	st.w	r8[196],r9
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8001275a:	14 3b       	cp.w	r11,r10
8001275c:	c0 c0       	breq	80012774 <gpio_enable_pin_interrupt+0x2e>
8001275e:	c0 82       	brcc	8001276e <gpio_enable_pin_interrupt+0x28>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80012760:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80012764:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80012768:	f1 49 00 94 	st.w	r8[148],r9
8001276c:	5e fd       	retal	0
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8001276e:	58 2b       	cp.w	r11,2
80012770:	c0 90       	breq	80012782 <gpio_enable_pin_interrupt+0x3c>
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1s = 1 << (pin & 0x1F);
80012772:	5e fa       	retal	r10
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80012774:	f1 49 00 a4 	st.w	r8[164],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80012778:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
8001277c:	f1 49 00 94 	st.w	r8[148],r9
80012780:	5e fd       	retal	0
		gpio_port->imr0s = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80012782:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1s = 1 << (pin & 0x1F);
80012786:	f1 49 00 b4 	st.w	r8[180],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
8001278a:	f1 49 00 94 	st.w	r8[148],r9
8001278e:	5e fd       	retal	0

80012790 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80012790:	f8 08 16 05 	lsr	r8,r12,0x5
80012794:	a9 68       	lsl	r8,0x8
80012796:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
8001279a:	f0 f8 00 d0 	ld.w	r8,r8[208]
8001279e:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800127a2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800127a6:	5e fc       	retal	r12

800127a8 <gpio_clear_pin_interrupt_flag>:
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800127a8:	30 18       	mov	r8,1
800127aa:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800127ae:	a5 9c       	lsr	r12,0x5
800127b0:	a9 6c       	lsl	r12,0x8
800127b2:	e0 2c f0 00 	sub	r12,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800127b6:	f9 48 00 d8 	st.w	r12[216],r8
#endif
}
800127ba:	5e fc       	retal	r12

800127bc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800127bc:	eb cd 40 c0 	pushm	r6-r7,lr
800127c0:	18 98       	mov	r8,r12
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800127c2:	58 0b       	cp.w	r11,0
800127c4:	c3 60       	breq	80012830 <gpio_enable_module+0x74>
800127c6:	30 0e       	mov	lr,0
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800127c8:	30 16       	mov	r6,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800127ca:	1c 9c       	mov	r12,lr
800127cc:	c0 d8       	rjmp	800127e6 <gpio_enable_module+0x2a>
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800127ce:	ec 07 09 4a 	lsl	r10,r6,r7
800127d2:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800127d4:	93 aa       	st.w	r9[0x28],r10
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800127d6:	93 2a       	st.w	r9[0x8],r10
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800127d8:	2f fe       	sub	lr,-1
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800127da:	30 09       	mov	r9,0
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800127dc:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800127de:	1c 3b       	cp.w	r11,lr
800127e0:	e0 88 00 17 	brls	8001280e <gpio_enable_module+0x52>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
800127e4:	2f 88       	sub	r8,-8
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800127e6:	70 07       	ld.w	r7,r8[0x0]
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
800127e8:	70 1a       	ld.w	r10,r8[0x4]
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800127ea:	ee 09 16 05 	lsr	r9,r7,0x5
800127ee:	a9 69       	lsl	r9,0x8
800127f0:	e0 29 f0 00 	sub	r9,61440

	/* Enable the correct function. */
	switch (function) {
800127f4:	58 1a       	cp.w	r10,1
800127f6:	c0 e0       	breq	80012812 <gpio_enable_module+0x56>
800127f8:	ce b3       	brcs	800127ce <gpio_enable_module+0x12>
800127fa:	58 2a       	cp.w	r10,2
800127fc:	c1 50       	breq	80012826 <gpio_enable_module+0x6a>
800127fe:	58 3a       	cp.w	r10,3
80012800:	c0 e0       	breq	8001281c <gpio_enable_module+0x60>
80012802:	30 19       	mov	r9,1
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80012804:	2f fe       	sub	lr,-1
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80012806:	12 4c       	or	r12,r9
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80012808:	1c 3b       	cp.w	r11,lr
8001280a:	fe 9b ff ed 	brhi	800127e4 <gpio_enable_module+0x28>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8001280e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80012812:	f4 07 09 4a 	lsl	r10,r10,r7
80012816:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80012818:	93 aa       	st.w	r9[0x28],r10
8001281a:	cd eb       	rjmp	800127d6 <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8001281c:	ec 07 09 4a 	lsl	r10,r6,r7
80012820:	93 5a       	st.w	r9[0x14],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80012822:	93 9a       	st.w	r9[0x24],r10
80012824:	cd 9b       	rjmp	800127d6 <gpio_enable_module+0x1a>
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80012826:	ec 07 09 4a 	lsl	r10,r6,r7
8001282a:	93 6a       	st.w	r9[0x18],r10
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8001282c:	93 9a       	st.w	r9[0x24],r10
8001282e:	cd 4b       	rjmp	800127d6 <gpio_enable_module+0x1a>
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
80012830:	16 9c       	mov	r12,r11
80012832:	ce eb       	rjmp	8001280e <gpio_enable_module+0x52>

80012834 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80012834:	c0 08       	rjmp	80012834 <_unhandled_interrupt>
80012836:	d7 03       	nop

80012838 <INTC_register_interrupt>:

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80012838:	f3 db c0 05 	bfextu	r9,r11,0x0,0x5
8001283c:	49 b8       	lddpc	r8,800128a8 <INTC_register_interrupt+0x70>
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8001283e:	a5 9b       	lsr	r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80012840:	f0 0b 00 38 	add	r8,r8,r11<<0x3
80012844:	70 18       	ld.w	r8,r8[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80012846:	f0 09 09 2c 	st.w	r8[r9<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8001284a:	58 0a       	cp.w	r10,0
8001284c:	c1 00       	breq	8001286c <INTC_register_interrupt+0x34>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	} else if (int_level == AVR32_INTC_INT1) {
8001284e:	58 1a       	cp.w	r10,1
80012850:	c1 70       	breq	8001287e <INTC_register_interrupt+0x46>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
	} else if (int_level == AVR32_INTC_INT2) {
80012852:	58 2a       	cp.w	r10,2
80012854:	c1 f0       	breq	80012892 <INTC_register_interrupt+0x5a>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80012856:	49 69       	lddpc	r9,800128ac <INTC_register_interrupt+0x74>
80012858:	49 68       	lddpc	r8,800128b0 <INTC_register_interrupt+0x78>
8001285a:	f2 08 01 08 	sub	r8,r9,r8
8001285e:	fe 79 08 00 	mov	r9,-63488
80012862:	ea 18 c0 00 	orh	r8,0xc000
80012866:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
8001286a:	5e fc       	retal	r12
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8001286c:	fe 78 08 00 	mov	r8,-63488
80012870:	49 09       	lddpc	r9,800128b0 <INTC_register_interrupt+0x78>
80012872:	49 1a       	lddpc	r10,800128b4 <INTC_register_interrupt+0x7c>
80012874:	f4 09 01 09 	sub	r9,r10,r9
80012878:	f0 0b 09 29 	st.w	r8[r11<<0x2],r9
8001287c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8001287e:	48 f9       	lddpc	r9,800128b8 <INTC_register_interrupt+0x80>
80012880:	48 c8       	lddpc	r8,800128b0 <INTC_register_interrupt+0x78>
80012882:	f2 08 01 08 	sub	r8,r9,r8
80012886:	fe 79 08 00 	mov	r9,-63488
8001288a:	bf a8       	sbr	r8,0x1e
8001288c:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
80012890:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80012892:	48 b9       	lddpc	r9,800128bc <INTC_register_interrupt+0x84>
80012894:	48 78       	lddpc	r8,800128b0 <INTC_register_interrupt+0x78>
80012896:	f2 08 01 08 	sub	r8,r9,r8
8001289a:	fe 79 08 00 	mov	r9,-63488
8001289e:	bf b8       	sbr	r8,0x1f
800128a0:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800128a4:	5e fc       	retal	r12
800128a6:	d7 03       	nop
800128a8:	80 02       	ld.sh	r2,r0[0x0]
800128aa:	3f 58       	mov	r8,-11
800128ac:	80 02       	ld.sh	r2,r0[0x0]
800128ae:	3d 2e       	mov	lr,-46
800128b0:	80 02       	ld.sh	r2,r0[0x0]
800128b2:	3c 00       	mov	r0,-64
800128b4:	80 02       	ld.sh	r2,r0[0x0]
800128b6:	3d 04       	mov	r4,-48
800128b8:	80 02       	ld.sh	r2,r0[0x0]
800128ba:	3d 12       	mov	r2,-47
800128bc:	80 02       	ld.sh	r2,r0[0x0]
800128be:	3d 20       	mov	r0,-46

800128c0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800128c0:	eb cd 40 e0 	pushm	r5-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800128c4:	48 f8       	lddpc	r8,80012900 <INTC_init_interrupts+0x40>
800128c6:	e3 b8 00 01 	mtsr	0x4,r8
800128ca:	48 f5       	lddpc	r5,80012904 <INTC_init_interrupts+0x44>
800128cc:	48 f7       	lddpc	r7,80012908 <INTC_init_interrupts+0x48>
800128ce:	10 15       	sub	r5,r8
800128d0:	30 0e       	mov	lr,0
800128d2:	fe cc 00 9e 	sub	r12,pc,158

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800128d6:	fe 76 08 00 	mov	r6,-63488

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800128da:	6e 0a       	ld.w	r10,r7[0x0]
800128dc:	58 0a       	cp.w	r10,0
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800128de:	c0 90       	breq	800128f0 <INTC_init_interrupts+0x30>
800128e0:	30 08       	mov	r8,0
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800128e2:	6e 1b       	ld.w	r11,r7[0x4]
800128e4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800128e8:	2f f8       	sub	r8,-1
800128ea:	10 3a       	cp.w	r10,r8
800128ec:	fe 9b ff fc 	brhi	800128e4 <INTC_init_interrupts+0x24>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800128f0:	ec 0e 09 25 	st.w	r6[lr<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800128f4:	2f 87       	sub	r7,-8
800128f6:	2f fe       	sub	lr,-1
800128f8:	59 4e       	cp.w	lr,20
800128fa:	cf 01       	brne	800128da <INTC_init_interrupts+0x1a>
800128fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80012900:	80 02       	ld.sh	r2,r0[0x0]
80012902:	3c 00       	mov	r0,-64
80012904:	80 02       	ld.sh	r2,r0[0x0]
80012906:	3d 04       	mov	r4,-48
80012908:	80 02       	ld.sh	r2,r0[0x0]
8001290a:	3f 58       	mov	r8,-11

8001290c <_get_interrupt_handler>:
8001290c:	e0 68 00 83 	mov	r8,131
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80012910:	f0 0c 01 0c 	sub	r12,r8,r12
80012914:	fe 78 08 00 	mov	r8,-63488
80012918:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8001291c:	f2 ca ff c0 	sub	r10,r9,-64
80012920:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80012924:	58 0c       	cp.w	r12,0
80012926:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
80012928:	48 68       	lddpc	r8,80012940 <_get_interrupt_handler+0x34>
8001292a:	f8 0c 12 00 	clz	r12,r12
8001292e:	f0 09 00 39 	add	r9,r8,r9<<0x3
80012932:	f8 0c 11 1f 	rsub	r12,r12,31
80012936:	72 18       	ld.w	r8,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80012938:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8001293c:	5e fc       	retal	r12
8001293e:	d7 03       	nop
80012940:	80 02       	ld.sh	r2,r0[0x0]
80012942:	3f 58       	mov	r8,-11

80012944 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80012944:	30 e8       	mov	r8,14
80012946:	f0 0c 18 00 	cp.b	r12,r8
8001294a:	e0 8b 00 06 	brhi	80012956 <pdca_get_handler+0x12>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8001294e:	a7 6c       	lsl	r12,0x6
80012950:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80012954:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80012956:	5e fe       	retal	-1

80012958 <pdca_disable>:
80012958:	30 e8       	mov	r8,14
8001295a:	f0 0c 18 00 	cp.b	r12,r8
8001295e:	e0 8b 00 08 	brhi	8001296e <pdca_disable+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80012962:	a7 6c       	lsl	r12,0x6
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80012964:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80012966:	e0 3c 00 00 	sub	r12,65536
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8001296a:	99 58       	st.w	r12[0x14],r8
}
8001296c:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8001296e:	3f fc       	mov	r12,-1
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80012970:	30 28       	mov	r8,2
80012972:	99 58       	st.w	r12[0x14],r8
}
80012974:	5e fc       	retal	r12

80012976 <pdca_enable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80012976:	30 e8       	mov	r8,14
80012978:	f0 0c 18 00 	cp.b	r12,r8
8001297c:	e0 8b 00 08 	brhi	8001298c <pdca_enable_interrupt_transfer_complete+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80012980:	a7 6c       	lsl	r12,0x6
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80012982:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80012984:	e0 3c 00 00 	sub	r12,65536
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80012988:	99 88       	st.w	r12[0x20],r8
}
8001298a:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8001298c:	3f fc       	mov	r12,-1
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
8001298e:	30 28       	mov	r8,2
80012990:	99 88       	st.w	r12[0x20],r8
}
80012992:	5e fc       	retal	r12

80012994 <pdca_disable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80012994:	30 e8       	mov	r8,14
80012996:	f0 0c 18 00 	cp.b	r12,r8
8001299a:	e0 88 00 0e 	brls	800129b6 <pdca_disable_interrupt_transfer_complete+0x22>
8001299e:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800129a0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800129a4:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800129a6:	30 29       	mov	r9,2
800129a8:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800129aa:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800129ac:	ed b8 00 10 	bld	r8,0x10
800129b0:	c0 20       	breq	800129b4 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800129b2:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800129b4:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800129b6:	a7 6c       	lsl	r12,0x6
800129b8:	e0 3c 00 00 	sub	r12,65536
800129bc:	cf 2b       	rjmp	800129a0 <pdca_disable_interrupt_transfer_complete+0xc>

800129be <pdca_load_channel>:

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800129be:	30 e8       	mov	r8,14
800129c0:	f0 0c 18 00 	cp.b	r12,r8
800129c4:	e0 88 00 11 	brls	800129e6 <pdca_load_channel+0x28>
800129c8:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800129ca:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800129ce:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)addr;
800129d0:	99 0b       	st.w	r12[0x0],r11
	pdca_channel->tcr = size;
800129d2:	99 2a       	st.w	r12[0x8],r10
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800129d4:	e0 69 01 00 	mov	r9,256
800129d8:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
800129da:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800129dc:	ed b8 00 10 	bld	r8,0x10
800129e0:	c0 20       	breq	800129e4 <pdca_load_channel+0x26>
      cpu_irq_enable();
800129e2:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800129e4:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800129e6:	a7 6c       	lsl	r12,0x6
800129e8:	e0 3c 00 00 	sub	r12,65536
800129ec:	ce fb       	rjmp	800129ca <pdca_load_channel+0xc>

800129ee <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
800129ee:	eb cd 40 80 	pushm	r7,lr
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800129f2:	30 e8       	mov	r8,14

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800129f4:	f8 09 15 06 	lsl	r9,r12,0x6
800129f8:	e0 39 00 00 	sub	r9,65536

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800129fc:	f0 0c 18 00 	cp.b	r12,r8
80012a00:	f9 b8 0b ff 	movhi	r8,-1
80012a04:	f0 0e 17 b0 	movhi	lr,r8
80012a08:	f2 08 17 80 	movls	r8,r9
80012a0c:	f2 0e 17 80 	movls	lr,r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80012a10:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80012a14:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
80012a16:	30 27       	mov	r7,2
80012a18:	9d 97       	st.w	lr[0x24],r7
	pdca_channel->isr;
80012a1a:	7c be       	ld.w	lr,lr[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80012a1c:	ed ba 00 10 	bld	r10,0x10
80012a20:	c0 20       	breq	80012a24 <pdca_init_channel+0x36>
      cpu_irq_enable();
80012a22:	d5 03       	csrf	0x10
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80012a24:	30 ea       	mov	r10,14
80012a26:	f8 0a 18 00 	cp.b	r10,r12
80012a2a:	f9 b9 03 ff 	movlo	r9,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80012a2e:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80012a32:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
80012a34:	30 1c       	mov	r12,1
80012a36:	93 9c       	st.w	r9[0x24],r12
	pdca_channel->isr;
80012a38:	72 b9       	ld.w	r9,r9[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80012a3a:	ed ba 00 10 	bld	r10,0x10
80012a3e:	c0 20       	breq	80012a42 <pdca_init_channel+0x54>
      cpu_irq_enable();
80012a40:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80012a42:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80012a46:	d3 03       	ssrf	0x10
	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80012a48:	76 0a       	ld.w	r10,r11[0x0]
80012a4a:	91 0a       	st.w	r8[0x0],r10
	pdca_channel->tcr = opt->size;
80012a4c:	76 1a       	ld.w	r10,r11[0x4]
80012a4e:	91 2a       	st.w	r8[0x8],r10
	pdca_channel->psr = opt->pid;
80012a50:	76 4a       	ld.w	r10,r11[0x10]
80012a52:	91 1a       	st.w	r8[0x4],r10
	pdca_channel->marr = (uint32_t)opt->r_addr;
80012a54:	76 2a       	ld.w	r10,r11[0x8]
80012a56:	91 3a       	st.w	r8[0xc],r10
	pdca_channel->tcrr = opt->r_size;
80012a58:	76 3a       	ld.w	r10,r11[0xc]
80012a5a:	91 4a       	st.w	r8[0x10],r10
	pdca_channel->mr =
80012a5c:	76 5a       	ld.w	r10,r11[0x14]
80012a5e:	91 6a       	st.w	r8[0x18],r10
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80012a60:	e0 6a 01 00 	mov	r10,256
80012a64:	91 5a       	st.w	r8[0x14],r10
	pdca_channel->isr;
80012a66:	70 b8       	ld.w	r8,r8[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80012a68:	ed b9 00 10 	bld	r9,0x10
80012a6c:	c0 20       	breq	80012a70 <pdca_init_channel+0x82>
      cpu_irq_enable();
80012a6e:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
80012a70:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80012a74 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80012a74:	f8 c8 00 01 	sub	r8,r12,1
80012a78:	f0 0b 00 0b 	add	r11,r8,r11
80012a7c:	f6 0c 0d 0a 	divu	r10,r11,r12
80012a80:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80012a82:	f4 c8 00 01 	sub	r8,r10,1
80012a86:	e0 48 00 fe 	cp.w	r8,254
80012a8a:	e0 8b 00 04 	brhi	80012a92 <getBaudDiv+0x1e>
		return -1;
	}

	return baudDiv;
80012a8e:	5c 8c       	casts.h	r12
}
80012a90:	5e fc       	retal	r12

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);

	if (baudDiv <= 0 || baudDiv > 255) {
80012a92:	5e fe       	retal	-1

80012a94 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80012a94:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80012a96:	30 18       	mov	r8,1
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80012a98:	18 99       	mov	r9,r12
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80012a9a:	f7 3a 00 0d 	ld.ub	r10,r11[13]
80012a9e:	f0 0a 18 00 	cp.b	r10,r8
80012aa2:	e0 88 00 04 	brls	80012aaa <spi_initMaster+0x16>
80012aa6:	30 2c       	mov	r12,2
80012aa8:	d8 02       	popm	pc

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
	u_avr32_spi_mr.MR.llb = 0;
80012aaa:	30 0a       	mov	r10,0
	if (options->modfdis > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80012aac:	e0 68 00 80 	mov	r8,128
80012ab0:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
80012ab2:	30 1e       	mov	lr,1

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80012ab4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80012ab6:	f7 3b 00 0d 	ld.ub	r11,r11[13]
	u_avr32_spi_mr.MR.llb = 0;
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
	spi->mr = u_avr32_spi_mr.mr;
80012aba:	14 9c       	mov	r12,r10
	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
80012abc:	f1 de d0 01 	bfins	r8,lr,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80012ac0:	f1 db d0 81 	bfins	r8,r11,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80012ac4:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80012ac8:	30 fa       	mov	r10,15
80012aca:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80012ace:	93 18       	st.w	r9[0x4],r8

	return SPI_OK;
}
80012ad0:	d8 02       	popm	pc

80012ad2 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80012ad2:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80012ad4:	30 18       	mov	r8,1
80012ad6:	f0 0b 18 00 	cp.b	r11,r8
80012ada:	5f be       	srhi	lr
80012adc:	f0 0a 18 00 	cp.b	r10,r8
80012ae0:	5f b8       	srhi	r8
80012ae2:	1c 48       	or	r8,lr
80012ae4:	c0 a1       	brne	80012af8 <spi_selectionMode+0x26>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80012ae6:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80012ae8:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80012aec:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80012af0:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80012af4:	99 18       	st.w	r12[0x4],r8
80012af6:	d8 0a       	popm	pc,r12=0
		uint8_t pcs_decode,
		uint8_t delay)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80012af8:	30 2c       	mov	r12,2
80012afa:	d8 02       	popm	pc

80012afc <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80012afc:	78 19       	ld.w	r9,r12[0x4]

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80012afe:	18 98       	mov	r8,r12
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80012b00:	ea 19 00 0f 	orh	r9,0xf
80012b04:	99 19       	st.w	r12[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80012b06:	78 1c       	ld.w	r12,r12[0x4]
80012b08:	e2 1c 00 04 	andl	r12,0x4,COH
80012b0c:	c0 80       	breq	80012b1c <spi_selectChip+0x20>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80012b0e:	30 e9       	mov	r9,14
80012b10:	f2 0b 18 00 	cp.b	r11,r9
80012b14:	e0 88 00 12 	brls	80012b38 <spi_selectChip+0x3c>
	} else {
		if (chip > 3) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80012b18:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80012b1a:	5e fc       	retal	r12
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80012b1c:	30 39       	mov	r9,3
80012b1e:	f2 0b 18 00 	cp.b	r11,r9
80012b22:	fe 9b ff fb 	brhi	80012b18 <spi_selectChip+0x1c>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80012b26:	70 19       	ld.w	r9,r8[0x4]
80012b28:	2f 0b       	sub	r11,-16
80012b2a:	30 1a       	mov	r10,1
80012b2c:	f4 0b 09 4b 	lsl	r11,r10,r11
80012b30:	5c db       	com	r11
80012b32:	12 6b       	and	r11,r9
80012b34:	91 1b       	st.w	r8[0x4],r11
80012b36:	5e fc       	retal	r12
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80012b38:	70 19       	ld.w	r9,r8[0x4]
80012b3a:	b1 6b       	lsl	r11,0x10
80012b3c:	30 0c       	mov	r12,0
80012b3e:	ea 1b ff f0 	orh	r11,0xfff0
80012b42:	e8 1b ff ff 	orl	r11,0xffff
80012b46:	12 6b       	and	r11,r9
80012b48:	91 1b       	st.w	r8[0x4],r11
80012b4a:	5e fc       	retal	r12

80012b4c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80012b4c:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80012b4e:	c0 58       	rjmp	80012b58 <spi_unselectChip+0xc>
80012b50:	2f f9       	sub	r9,-1
		if (!timeout--) {
80012b52:	e0 49 3a 99 	cp.w	r9,15001
80012b56:	c0 d0       	breq	80012b70 <spi_unselectChip+0x24>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80012b58:	78 48       	ld.w	r8,r12[0x10]
80012b5a:	ed b8 00 09 	bld	r8,0x9
80012b5e:	cf 91       	brne	80012b50 <spi_unselectChip+0x4>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80012b60:	78 18       	ld.w	r8,r12[0x4]
80012b62:	ea 18 00 0f 	orh	r8,0xf
80012b66:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80012b68:	fc 18 01 00 	movh	r8,0x100
80012b6c:	99 08       	st.w	r12[0x0],r8
80012b6e:	5e fd       	retal	0
spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80012b70:	5e ff       	retal	1
80012b72:	d7 03       	nop

80012b74 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80012b74:	eb cd 40 fe 	pushm	r1-r7,lr
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80012b78:	30 34       	mov	r4,3
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80012b7a:	16 97       	mov	r7,r11
80012b7c:	18 96       	mov	r6,r12
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80012b7e:	f7 35 00 0c 	ld.ub	r5,r11[12]
80012b82:	e8 05 18 00 	cp.b	r5,r4
80012b86:	e0 8b 00 09 	brhi	80012b98 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
80012b8a:	f7 32 00 0b 	ld.ub	r2,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80012b8e:	30 13       	mov	r3,1
80012b90:	e6 02 18 00 	cp.b	r2,r3
80012b94:	e0 88 00 05 	brls	80012b9e <spi_setupChipReg+0x2a>
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
		break;
80012b98:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80012b9a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80012b9e:	f7 31 00 08 	ld.ub	r1,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80012ba2:	30 78       	mov	r8,7
80012ba4:	f0 01 18 00 	cp.b	r1,r8
80012ba8:	fe 98 ff f8 	brls	80012b98 <spi_setupChipReg+0x24>
80012bac:	31 08       	mov	r8,16
80012bae:	f0 01 18 00 	cp.b	r1,r8
80012bb2:	fe 9b ff f3 	brhi	80012b98 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80012bb6:	14 9b       	mov	r11,r10
80012bb8:	6e 1c       	ld.w	r12,r7[0x4]
80012bba:	c5 df       	rcall	80012a74 <getBaudDiv>
80012bbc:	ce e5       	brlt	80012b98 <spi_setupChipReg+0x24>

	if (baudDiv < 0) {
80012bbe:	0a 9a       	mov	r10,r5
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80012bc0:	ec 1a 00 01 	eorl	r10,0x1
80012bc4:	30 08       	mov	r8,0
	if (baudDiv < 0) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80012bc6:	a1 95       	lsr	r5,0x1
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80012bc8:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
80012bcc:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80012bd0:	ef 3a 00 09 	ld.ub	r10,r7[9]
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80012bd4:	20 81       	sub	r1,8
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80012bd6:	f1 d2 d0 61 	bfins	r8,r2,0x3,0x1

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80012bda:	0f 89       	ld.ub	r9,r7[0x0]
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
80012bdc:	f1 d1 d0 84 	bfins	r8,r1,0x4,0x4
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80012be0:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80012be4:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80012be8:	ef 3a 00 0a 	ld.ub	r10,r7[10]
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80012bec:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
80012bf0:	e6 09 18 00 	cp.b	r9,r3

	switch (options->reg) {
80012bf4:	c0 f0       	breq	80012c12 <spi_setupChipReg+0x9e>
80012bf6:	c0 b3       	brcs	80012c0c <spi_setupChipReg+0x98>
80012bf8:	30 2a       	mov	r10,2
80012bfa:	f4 09 18 00 	cp.b	r9,r10
80012bfe:	c0 d0       	breq	80012c18 <spi_setupChipReg+0xa4>
80012c00:	e8 09 18 00 	cp.b	r9,r4
80012c04:	cc a1       	brne	80012b98 <spi_setupChipReg+0x24>
80012c06:	8d f8       	st.w	r6[0x3c],r8
	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80012c08:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80012c0c:	8d c8       	st.w	r6[0x30],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80012c0e:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80012c12:	8d d8       	st.w	r6[0x34],r8
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80012c14:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80012c18:	8d e8       	st.w	r6[0x38],r8
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80012c1a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80012c1e:	d7 03       	nop

80012c20 <spi_enable>:
80012c20:	30 18       	mov	r8,1
80012c22:	99 08       	st.w	r12[0x0],r8
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
}
80012c24:	5e fc       	retal	r12

80012c26 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80012c26:	30 09       	mov	r9,0
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80012c28:	c0 58       	rjmp	80012c32 <spi_write+0xc>
80012c2a:	2f f9       	sub	r9,-1
		if (!timeout--) {
80012c2c:	e0 49 3a 99 	cp.w	r9,15001
80012c30:	c0 80       	breq	80012c40 <spi_write+0x1a>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80012c32:	78 48       	ld.w	r8,r12[0x10]
80012c34:	ed b8 00 01 	bld	r8,0x1
80012c38:	cf 91       	brne	80012c2a <spi_write+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80012c3a:	5c 7b       	castu.h	r11
80012c3c:	99 3b       	st.w	r12[0xc],r11
80012c3e:	5e fd       	retal	0
spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
		if (!timeout--) {
80012c40:	5e ff       	retal	1

80012c42 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80012c42:	30 09       	mov	r9,0
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80012c44:	c0 58       	rjmp	80012c4e <spi_read+0xc>
80012c46:	2f f9       	sub	r9,-1
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80012c48:	e0 49 3a 99 	cp.w	r9,15001
80012c4c:	c0 b0       	breq	80012c62 <spi_read+0x20>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80012c4e:	78 48       	ld.w	r8,r12[0x10]
80012c50:	e2 18 02 01 	andl	r8,0x201,COH
80012c54:	e0 48 02 01 	cp.w	r8,513
80012c58:	cf 71       	brne	80012c46 <spi_read+0x4>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80012c5a:	78 28       	ld.w	r8,r12[0x8]
80012c5c:	30 0c       	mov	r12,0
80012c5e:	b6 08       	st.h	r11[0x0],r8

	return SPI_OK;
}
80012c60:	5e fc       	retal	r12
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80012c62:	5e ff       	retal	1

80012c64 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80012c64:	d4 01       	pushm	lr
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80012c66:	76 09       	ld.w	r9,r11[0x0]
80012c68:	58 29       	cp.w	r9,2
80012c6a:	e0 8b 00 4b 	brhi	80012d00 <tc_init_waveform+0x9c>
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80012c6e:	76 18       	ld.w	r8,r11[0x4]
80012c70:	10 9e       	mov	lr,r8
80012c72:	e6 1e c0 00 	andh	lr,0xc000,COH
80012c76:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80012c7a:	af ba       	sbr	r10,0xf
80012c7c:	1c 4a       	or	r10,lr
80012c7e:	10 9e       	mov	lr,r8
80012c80:	e6 1e 30 00 	andh	lr,0x3000,COH
80012c84:	1c 4a       	or	r10,lr
80012c86:	10 9e       	mov	lr,r8
80012c88:	e6 1e 0c 00 	andh	lr,0xc00,COH
80012c8c:	1c 4a       	or	r10,lr
80012c8e:	10 9e       	mov	lr,r8
80012c90:	e6 1e 03 00 	andh	lr,0x300,COH
80012c94:	1c 4a       	or	r10,lr
80012c96:	10 9e       	mov	lr,r8
80012c98:	e6 1e 00 c0 	andh	lr,0xc0,COH
80012c9c:	1c 4a       	or	r10,lr
80012c9e:	10 9e       	mov	lr,r8
80012ca0:	e6 1e 00 30 	andh	lr,0x30,COH
80012ca4:	1c 4a       	or	r10,lr
80012ca6:	10 9e       	mov	lr,r8
80012ca8:	e6 1e 00 0c 	andh	lr,0xc,COH
80012cac:	1c 4a       	or	r10,lr
80012cae:	10 9e       	mov	lr,r8
80012cb0:	e6 1e 00 03 	andh	lr,0x3,COH
80012cb4:	1c 4a       	or	r10,lr
80012cb6:	10 9e       	mov	lr,r8
80012cb8:	e2 1e 60 00 	andl	lr,0x6000,COH
80012cbc:	1c 4a       	or	r10,lr
80012cbe:	10 9e       	mov	lr,r8
80012cc0:	e2 1e 10 00 	andl	lr,0x1000,COH
80012cc4:	1c 4a       	or	r10,lr
80012cc6:	10 9e       	mov	lr,r8
80012cc8:	e2 1e 0c 00 	andl	lr,0xc00,COH
80012ccc:	1c 4a       	or	r10,lr
80012cce:	10 9e       	mov	lr,r8
80012cd0:	e2 1e 03 00 	andl	lr,0x300,COH
80012cd4:	1c 4a       	or	r10,lr
80012cd6:	10 9e       	mov	lr,r8
80012cd8:	e2 1e 00 80 	andl	lr,0x80,COH
80012cdc:	10 9b       	mov	r11,r8
80012cde:	1c 4a       	or	r10,lr
80012ce0:	e2 1b 00 08 	andl	r11,0x8,COH
80012ce4:	10 9e       	mov	lr,r8
80012ce6:	a5 69       	lsl	r9,0x4
80012ce8:	e2 1e 00 40 	andl	lr,0x40,COH
80012cec:	2f f9       	sub	r9,-1
80012cee:	1c 4a       	or	r10,lr
80012cf0:	e2 18 00 30 	andl	r8,0x30,COH
80012cf4:	f5 e8 10 08 	or	r8,r10,r8
80012cf8:	16 48       	or	r8,r11
80012cfa:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80012cfe:	d8 0a       	popm	pc,r12=0


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80012d00:	dc 0a       	popm	pc,r12=-1

80012d02 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d02:	58 2b       	cp.w	r11,2
80012d04:	e0 8b 00 07 	brhi	80012d12 <tc_start+0x10>
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80012d08:	a7 6b       	lsl	r11,0x6
80012d0a:	16 0c       	add	r12,r11
80012d0c:	30 58       	mov	r8,5
80012d0e:	99 08       	st.w	r12[0x0],r8
80012d10:	5e fd       	retal	0


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d12:	5e fe       	retal	-1

80012d14 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d14:	58 2b       	cp.w	r11,2
80012d16:	e0 8b 00 07 	brhi	80012d24 <tc_read_sr+0x10>
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80012d1a:	a7 6b       	lsl	r11,0x6
80012d1c:	2e 0b       	sub	r11,-32
80012d1e:	16 0c       	add	r12,r11
80012d20:	78 0c       	ld.w	r12,r12[0x0]
}
80012d22:	5e fc       	retal	r12


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d24:	5e fe       	retal	-1

80012d26 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d26:	58 2b       	cp.w	r11,2
80012d28:	e0 8b 00 1a 	brhi	80012d5c <tc_write_rc+0x36>
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80012d2c:	f6 08 15 04 	lsl	r8,r11,0x4
80012d30:	2f f8       	sub	r8,-1
80012d32:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80012d36:	ed b8 00 0f 	bld	r8,0xf
80012d3a:	c0 e1       	brne	80012d56 <tc_write_rc+0x30>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80012d3c:	a7 6b       	lsl	r11,0x6
80012d3e:	f8 0b 00 0b 	add	r11,r12,r11
80012d42:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80012d46:	2e 4b       	sub	r11,-28
80012d48:	76 08       	ld.w	r8,r11[0x0]
80012d4a:	e0 18 00 00 	andl	r8,0x0
80012d4e:	f9 e8 10 08 	or	r8,r12,r8
80012d52:	97 08       	st.w	r11[0x0],r8

  return value;
}
80012d54:	5e fc       	retal	r12
80012d56:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80012d5a:	5e fc       	retal	r12


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d5c:	5e fe       	retal	-1

80012d5e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80012d5e:	eb cd 40 80 	pushm	r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80012d62:	e1 be 00 00 	mfsr	lr,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012d66:	58 2b       	cp.w	r11,2
80012d68:	e0 8b 00 5f 	brhi	80012e26 <tc_configure_interrupts+0xc8>
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80012d6c:	74 08       	ld.w	r8,r10[0x0]
80012d6e:	10 99       	mov	r9,r8
80012d70:	e2 19 00 02 	andl	r9,0x2,COH
80012d74:	e2 18 00 fd 	andl	r8,0xfd,COH
80012d78:	12 48       	or	r8,r9
80012d7a:	f6 09 15 06 	lsl	r9,r11,0x6
80012d7e:	f8 09 00 07 	add	r7,r12,r9
80012d82:	2d c7       	sub	r7,-36
80012d84:	8f 08       	st.w	r7[0x0],r8
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80012d86:	ee 1e 00 01 	eorh	lr,0x1
80012d8a:	fd de c2 01 	bfextu	lr,lr,0x10,0x1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80012d8e:	c4 e1       	brne	80012e2a <tc_configure_interrupts+0xcc>
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80012d90:	a7 6b       	lsl	r11,0x6
80012d92:	2e 0b       	sub	r11,-32
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012d94:	74 08       	ld.w	r8,r10[0x0]
80012d96:	f8 09 00 0a 	add	r10,r12,r9
80012d9a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80012d9e:	16 0c       	add	r12,r11
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012da0:	e0 6b 00 80 	mov	r11,128
80012da4:	58 07       	cp.w	r7,0
80012da6:	f9 bb 01 00 	movne	r11,0
80012daa:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80012dae:	ec 19 00 01 	eorl	r9,0x1
80012db2:	f7 e9 10 09 	or	r9,r11,r9
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80012db6:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80012dba:	f9 bb 00 40 	moveq	r11,64
80012dbe:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012dc2:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80012dc4:	f7 d8 c0 a1 	bfextu	r11,r8,0x5,0x1
80012dc8:	f9 bb 00 20 	moveq	r11,32
80012dcc:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012dd0:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80012dd2:	f7 d8 c0 81 	bfextu	r11,r8,0x4,0x1
80012dd6:	f9 bb 00 10 	moveq	r11,16
80012dda:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012dde:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80012de0:	f7 d8 c0 61 	bfextu	r11,r8,0x3,0x1
80012de4:	f9 bb 00 08 	moveq	r11,8
80012de8:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012dec:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80012dee:	f7 d8 c0 41 	bfextu	r11,r8,0x2,0x1
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80012df2:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80012df6:	58 0b       	cp.w	r11,0
80012df8:	f9 bb 00 04 	moveq	r11,4
80012dfc:	f9 bb 01 00 	movne	r11,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80012e00:	58 08       	cp.w	r8,0
80012e02:	f9 b8 00 02 	moveq	r8,2
80012e06:	f9 b8 01 00 	movne	r8,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80012e0a:	16 49       	or	r9,r11
80012e0c:	f3 e8 10 08 	or	r8,r9,r8
80012e10:	2d 8a       	sub	r10,-40
80012e12:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80012e14:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80012e16:	58 0e       	cp.w	lr,0
80012e18:	c0 41       	brne	80012e20 <tc_configure_interrupts+0xc2>
80012e1a:	1c 9c       	mov	r12,lr
80012e1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80012e20:	d5 03       	csrf	0x10
80012e22:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
  bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80012e26:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80012e2a:	d3 03       	ssrf	0x10
80012e2c:	cb 2b       	rjmp	80012d90 <tc_configure_interrupts+0x32>

80012e2e <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80012e2e:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80012e30:	f6 08 15 04 	lsl	r8,r11,0x4
80012e34:	14 38       	cp.w	r8,r10
80012e36:	e0 8b 00 26 	brhi	80012e82 <usart_set_async_baudrate+0x54>
80012e3a:	31 0e       	mov	lr,16
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80012e3c:	f0 09 16 01 	lsr	r9,r8,0x1
80012e40:	f2 0a 00 39 	add	r9,r9,r10<<0x3
80012e44:	f2 08 0d 08 	divu	r8,r9,r8
80012e48:	10 99       	mov	r9,r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80012e4a:	a3 98       	lsr	r8,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80012e4c:	f0 cb 00 01 	sub	r11,r8,1
80012e50:	e0 4b ff fe 	cp.w	r11,65534
80012e54:	e0 8b 00 1b 	brhi	80012e8a <usart_set_async_baudrate+0x5c>
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80012e58:	78 1a       	ld.w	r10,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80012e5a:	e8 6b 00 00 	mov	r11,524288
80012e5e:	e4 1a ff f7 	andh	r10,0xfff7
80012e62:	e0 1a fe cf 	andl	r10,0xfecf
80012e66:	59 0e       	cp.w	lr,16
80012e68:	f6 0e 17 10 	movne	lr,r11
80012e6c:	f9 be 00 00 	moveq	lr,0
80012e70:	fd ea 10 0a 	or	r10,lr,r10
80012e74:	99 1a       	st.w	r12[0x4],r10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80012e76:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80012e7a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80012e7e:	99 88       	st.w	r12[0x20],r8
80012e80:	d8 0a       	popm	pc,r12=0
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80012e82:	f6 08 15 03 	lsl	r8,r11,0x3
80012e86:	30 8e       	mov	lr,8
80012e88:	cd ab       	rjmp	80012e3c <usart_set_async_baudrate+0xe>
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80012e8a:	da 0a       	popm	pc,r12=1

80012e8c <usart_write_line>:
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80012e8c:	17 8a       	ld.ub	r10,r11[0x0]
80012e8e:	58 0a       	cp.w	r10,0
80012e90:	5e 0c       	reteq	r12
80012e92:	30 09       	mov	r9,0
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80012e94:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80012e96:	ed b8 00 01 	bld	r8,0x1
80012e9a:	c0 91       	brne	80012eac <usart_write_line+0x20>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80012e9c:	f1 da c0 09 	bfextu	r8,r10,0x0,0x9


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
80012ea0:	2f fb       	sub	r11,-1

int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80012ea2:	99 78       	st.w	r12[0x1c],r8
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80012ea4:	17 8a       	ld.ub	r10,r11[0x0]
80012ea6:	58 0a       	cp.w	r10,0
80012ea8:	cf 51       	brne	80012e92 <usart_write_line+0x6>
80012eaa:	5e fc       	retal	r12
80012eac:	2f f9       	sub	r9,-1
{
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80012eae:	e0 49 27 10 	cp.w	r9,10000
80012eb2:	cf 11       	brne	80012e94 <usart_write_line+0x8>


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
80012eb4:	2f fb       	sub	r11,-1
80012eb6:	cf 7b       	rjmp	80012ea4 <usart_write_line+0x18>

80012eb8 <usart_init_rs232>:
              AVR32_USART_CR_RTSDIS_MASK;
}


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80012eb8:	eb cd 40 e0 	pushm	r5-r7,lr
80012ebc:	18 97       	mov	r7,r12
80012ebe:	16 96       	mov	r6,r11
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80012ec0:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80012ec4:	ed b8 00 10 	bld	r8,0x10
80012ec8:	c2 e1       	brne	80012f24 <usart_init_rs232+0x6c>
  usart->idr = 0xFFFFFFFF;
80012eca:	3f f8       	mov	r8,-1
80012ecc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80012ece:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80012ed0:	30 08       	mov	r8,0
80012ed2:	8f 18       	st.w	r7[0x4],r8
  usart->rtor = 0;
80012ed4:	8f 98       	st.w	r7[0x24],r8
  usart->ttgr = 0;
80012ed6:	8f a8       	st.w	r7[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80012ed8:	ea 68 61 0c 	mov	r8,680204
80012edc:	8f 08       	st.w	r7[0x0],r8
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80012ede:	58 06       	cp.w	r6,0
80012ee0:	c2 00       	breq	80012f20 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
80012ee2:	0d c8       	ld.ub	r8,r6[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80012ee4:	30 49       	mov	r9,4
80012ee6:	f2 08 18 00 	cp.b	r8,r9
80012eea:	e0 88 00 1b 	brls	80012f20 <usart_init_rs232+0x68>
80012eee:	30 95       	mov	r5,9
80012ef0:	ea 08 18 00 	cp.b	r8,r5
80012ef4:	e0 8b 00 16 	brhi	80012f20 <usart_init_rs232+0x68>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80012ef8:	0d d9       	ld.ub	r9,r6[0x5]
80012efa:	30 78       	mov	r8,7
80012efc:	f0 09 18 00 	cp.b	r9,r8
80012f00:	e0 8b 00 10 	brhi	80012f20 <usart_init_rs232+0x68>
      opt->stopbits > 2 + 255 ||
80012f04:	8c 39       	ld.sh	r9,r6[0x6]
80012f06:	e0 68 01 01 	mov	r8,257
80012f0a:	f0 09 19 00 	cp.h	r9,r8
80012f0e:	e0 8b 00 09 	brhi	80012f20 <usart_init_rs232+0x68>
      opt->channelmode > 3 ||
80012f12:	ed 39 00 08 	ld.ub	r9,r6[8]
80012f16:	30 38       	mov	r8,3
80012f18:	f0 09 18 00 	cp.b	r9,r8
80012f1c:	e0 88 00 0a 	brls	80012f30 <usart_init_rs232+0x78>
  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80012f20:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80012f24:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80012f26:	3f f8       	mov	r8,-1
80012f28:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80012f2a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80012f2c:	d5 03       	csrf	0x10
80012f2e:	cd 1b       	rjmp	80012ed0 <usart_init_rs232+0x18>
  if (!opt || // Null pointer.
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80012f30:	6c 0b       	ld.w	r11,r6[0x0]
80012f32:	0e 9c       	mov	r12,r7
80012f34:	c7 df       	rcall	80012e2e <usart_set_async_baudrate>
80012f36:	58 1c       	cp.w	r12,1
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80012f38:	cf 40       	breq	80012f20 <usart_init_rs232+0x68>
80012f3a:	0d c8       	ld.ub	r8,r6[0x4]
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80012f3c:	ea 08 18 00 	cp.b	r8,r5
80012f40:	c2 a0       	breq	80012f94 <usart_init_rs232+0xdc>
80012f42:	6e 19       	ld.w	r9,r7[0x4]
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80012f44:	20 58       	sub	r8,5
80012f46:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80012f4a:	8f 18       	st.w	r7[0x4],r8
80012f4c:	6e 19       	ld.w	r9,r7[0x4]
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80012f4e:	ed 3a 00 08 	ld.ub	r10,r6[8]
80012f52:	0d d8       	ld.ub	r8,r6[0x5]
80012f54:	a9 78       	lsl	r8,0x9
80012f56:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80012f5a:	12 48       	or	r8,r9
80012f5c:	8f 18       	st.w	r7[0x4],r8
80012f5e:	30 29       	mov	r9,2
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80012f60:	8c 38       	ld.sh	r8,r6[0x6]
80012f62:	f2 08 19 00 	cp.h	r8,r9
80012f66:	e0 88 00 11 	brls	80012f88 <usart_init_rs232+0xd0>
80012f6a:	6e 18       	ld.w	r8,r7[0x4]
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80012f6c:	ad b8       	sbr	r8,0xd
80012f6e:	8f 18       	st.w	r7[0x4],r8
80012f70:	8c b8       	ld.uh	r8,r6[0x6]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80012f72:	20 28       	sub	r8,2
80012f74:	8f a8       	st.w	r7[0x28],r8
80012f76:	6e 18       	ld.w	r8,r7[0x4]
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80012f78:	e0 18 ff f0 	andl	r8,0xfff0
80012f7c:	8f 18       	st.w	r7[0x4],r8
80012f7e:	30 0c       	mov	r12,0
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80012f80:	35 08       	mov	r8,80
80012f82:	8f 08       	st.w	r7[0x0],r8
80012f84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80012f88:	6e 19       	ld.w	r9,r7[0x4]
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80012f8a:	5c 78       	castu.h	r8
80012f8c:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80012f90:	8f 18       	st.w	r7[0x4],r8
80012f92:	cf 2b       	rjmp	80012f76 <usart_init_rs232+0xbe>
80012f94:	6e 18       	ld.w	r8,r7[0x4]
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80012f96:	b1 b8       	sbr	r8,0x11
80012f98:	8f 18       	st.w	r7[0x4],r8
80012f9a:	cd 9b       	rjmp	80012f4c <usart_init_rs232+0x94>

80012f9c <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
80012f9c:	d4 01       	pushm	lr


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80012f9e:	18 9b       	mov	r11,r12
80012fa0:	fe 7c 14 00 	mov	r12,-60416
80012fa4:	c7 4f       	rcall	80012e8c <usart_write_line>
80012fa6:	d8 02       	popm	pc

80012fa8 <print_dbg_ulong>:

void print_dbg(const char *str)
{
  // Redirection to the debug USART.
  print(DBG_USART, str);
}
80012fa8:	eb cd 40 c0 	pushm	r6-r7,lr
80012fac:	20 3d       	sub	sp,12
80012fae:	30 08       	mov	r8,0
{
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80012fb0:	30 a9       	mov	r9,10
80012fb2:	fb 68 00 0a 	st.b	sp[10],r8
80012fb6:	1a 9b       	mov	r11,sp
  do
  {
    tmp[--i] = '0' + n % 10;
80012fb8:	e0 6e cc cd 	mov	lr,52429
80012fbc:	ea 1e cc cc 	orh	lr,0xcccc
80012fc0:	f8 0e 06 46 	mulu.d	r6,r12,lr
80012fc4:	20 19       	sub	r9,1
80012fc6:	0e 98       	mov	r8,r7
80012fc8:	a3 98       	lsr	r8,0x3
80012fca:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80012fce:	f8 0a 01 1c 	sub	r12,r12,r10<<0x1
80012fd2:	2d 0c       	sub	r12,-48
80012fd4:	f6 09 0b 0c 	st.b	r11[r9],r12
    n /= 10;
80012fd8:	10 9c       	mov	r12,r8
  } while (n);
80012fda:	58 08       	cp.w	r8,0
80012fdc:	cf 21       	brne	80012fc0 <print_dbg_ulong+0x18>


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80012fde:	12 0b       	add	r11,r9
80012fe0:	fe 7c 14 00 	mov	r12,-60416
80012fe4:	c5 4f       	rcall	80012e8c <usart_write_line>
80012fe6:	2f dd       	sub	sp,-12

void print_dbg_ulong(unsigned long n)
{
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
}
80012fe8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80012fec <print_dbg_hex>:
80012fec:	d4 01       	pushm	lr
80012fee:	20 3d       	sub	sp,12
80012ff0:	49 98       	lddpc	r8,80013054 <print_dbg_hex+0x68>
80012ff2:	f8 09 16 1c 	lsr	r9,r12,0x1c

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
  for (i = 7; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
80012ff6:	f0 09 07 09 	ld.ub	r9,r8[r9]
80012ffa:	ba 89       	st.b	sp[0x0],r9
{
  char tmp[9];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
80012ffc:	30 09       	mov	r9,0
80012ffe:	fb 69 00 08 	st.b	sp[8],r9
  for (i = 7; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
80013002:	f3 dc c0 04 	bfextu	r9,r12,0x0,0x4
80013006:	f0 09 07 09 	ld.ub	r9,r8[r9]
8001300a:	ba f9       	st.b	sp[0x7],r9
8001300c:	f3 dc c0 84 	bfextu	r9,r12,0x4,0x4
80013010:	f0 09 07 09 	ld.ub	r9,r8[r9]
80013014:	ba e9       	st.b	sp[0x6],r9
80013016:	f3 dc c1 04 	bfextu	r9,r12,0x8,0x4
8001301a:	f0 09 07 09 	ld.ub	r9,r8[r9]
8001301e:	ba d9       	st.b	sp[0x5],r9
80013020:	f3 dc c1 84 	bfextu	r9,r12,0xc,0x4
80013024:	f0 09 07 09 	ld.ub	r9,r8[r9]
80013028:	ba c9       	st.b	sp[0x4],r9
8001302a:	f3 dc c2 04 	bfextu	r9,r12,0x10,0x4
8001302e:	f0 09 07 09 	ld.ub	r9,r8[r9]
80013032:	ba b9       	st.b	sp[0x3],r9
80013034:	f3 dc c2 84 	bfextu	r9,r12,0x14,0x4
80013038:	f9 dc c3 04 	bfextu	r12,r12,0x18,0x4
8001303c:	f0 09 07 09 	ld.ub	r9,r8[r9]
80013040:	f0 0c 07 08 	ld.ub	r8,r8[r12]
80013044:	ba a9       	st.b	sp[0x2],r9
80013046:	ba 98       	st.b	sp[0x1],r8


void print(volatile avr32_usart_t *usart, const char *str)
{
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80013048:	1a 9b       	mov	r11,sp
8001304a:	fe 7c 14 00 	mov	r12,-60416
8001304e:	c1 ff       	rcall	80012e8c <usart_write_line>
80013050:	2f dd       	sub	sp,-12

void print_dbg_hex(unsigned long n)
{
  // Redirection to the debug USART.
  print_hex(DBG_USART, n);
}
80013052:	d8 02       	popm	pc
80013054:	80 02       	ld.sh	r2,r0[0x0]
80013056:	3f f8       	mov	r8,-1

80013058 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80013058:	eb cd 40 c0 	pushm	r6-r7,lr
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
8001305c:	e0 69 2c ee 	mov	r9,11502
80013060:	e0 68 2c f0 	mov	r8,11504
80013064:	13 8b       	ld.ub	r11,r9[0x0]
80013066:	11 dc       	ld.ub	r12,r8[0x5]
80013068:	30 39       	mov	r9,3
8001306a:	f2 0b 18 00 	cp.b	r11,r9
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
8001306e:	c4 60       	breq	800130fa <sd_mmc_spi_get_capacity+0xa2>
80013070:	11 fe       	ld.ub	lr,r8[0x7]
80013072:	f1 37 00 08 	ld.ub	r7,r8[8]
80013076:	a7 87       	lsr	r7,0x6
80013078:	ee 0e 00 27 	add	r7,r7,lr<<0x2
8001307c:	11 ee       	ld.ub	lr,r8[0x6]
8001307e:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
    capacity = (uint64_t)c_size << 19;
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80013082:	ab 6e       	lsl	lr,0xa
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80013084:	f1 39 00 0a 	ld.ub	r9,r8[10]
80013088:	1c 07       	add	r7,lr
8001308a:	f2 06 16 07 	lsr	r6,r9,0x7
8001308e:	2f f7       	sub	r7,-1
80013090:	f1 3e 00 09 	ld.ub	lr,r8[9]
80013094:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80013098:	ec 0e 00 1e 	add	lr,r6,lr<<0x1
8001309c:	2f ee       	sub	lr,-2
8001309e:	ee 0e 09 4e 	lsl	lr,r7,lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
800130a2:	20 1e       	sub	lr,1
800130a4:	e0 6a 2c e8 	mov	r10,11496
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
800130a8:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
800130ac:	95 0e       	st.w	r10[0x0],lr
800130ae:	74 0e       	ld.w	lr,r10[0x0]
800130b0:	2f fe       	sub	lr,-1
800130b2:	fc 0c 09 4e 	lsl	lr,lr,r12
800130b6:	1c 96       	mov	r6,lr
800130b8:	30 0e       	mov	lr,0
800130ba:	1c 97       	mov	r7,lr
    capacity_mult = 0;
800130bc:	e0 6e 2c dc 	mov	lr,11484
800130c0:	fc e7 00 00 	st.d	lr[0],r6
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
800130c4:	e0 67 2c e4 	mov	r7,11492
800130c8:	30 0e       	mov	lr,0
800130ca:	ae 0e       	st.h	r7[0x0],lr
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
800130cc:	30 97       	mov	r7,9
800130ce:	ee 0c 18 00 	cp.b	r12,r7
800130d2:	e0 88 00 07 	brls	800130e0 <sd_mmc_spi_get_capacity+0x88>
    }
  }
  if (card_type == MMC_CARD)
800130d6:	74 0e       	ld.w	lr,r10[0x0]
800130d8:	20 9c       	sub	r12,9
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
800130da:	fc 0c 09 4c 	lsl	r12,lr,r12
800130de:	95 0c       	st.w	r10[0x0],r12
800130e0:	58 0b       	cp.w	r11,0
800130e2:	c3 51       	brne	8001314c <sd_mmc_spi_get_capacity+0xf4>
800130e4:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
800130e8:	f1 38 00 0b 	ld.ub	r8,r8[11]
800130ec:	f3 d9 c0 45 	bfextu	r9,r9,0x2,0x5
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
800130f0:	a5 98       	lsr	r8,0x5
800130f2:	f1 ea 10 38 	or	r8,r8,r10<<0x3
800130f6:	2f f8       	sub	r8,-1
800130f8:	c3 28       	rjmp	8001315c <sd_mmc_spi_get_capacity+0x104>
800130fa:	f1 3e 00 08 	ld.ub	lr,r8[8]
800130fe:	f1 39 00 09 	ld.ub	r9,r8[9]
80013102:	f3 ee 10 89 	or	r9,r9,lr<<0x8
    ++c_size;
80013106:	11 fe       	ld.ub	lr,r8[0x7]
    capacity = (uint64_t)c_size << 19;
80013108:	fd de c0 06 	bfextu	lr,lr,0x0,0x6
8001310c:	f3 ee 11 0e 	or	lr,r9,lr<<0x10
80013110:	2f fe       	sub	lr,-1
80013112:	fc 09 16 0d 	lsr	r9,lr,0xd
80013116:	fc 0a 15 13 	lsl	r10,lr,0x13
    capacity_mult = (c_size >> 13) & 0x01FF;
8001311a:	e0 6c 2c dc 	mov	r12,11484
8001311e:	12 9b       	mov	r11,r9
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80013120:	f8 eb 00 00 	st.d	r12[0],r10
80013124:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
80013128:	e0 69 2c e4 	mov	r9,11492
8001312c:	b2 0a       	st.h	r9[0x0],r10
8001312e:	f8 ea 00 00 	ld.d	r10,r12[0]
80013132:	92 0c       	ld.sh	r12,r9[0x0]
80013134:	f4 09 16 09 	lsr	r9,r10,0x9
80013138:	b7 7c       	lsl	r12,0x17
8001313a:	f3 eb 11 79 	or	r9,r9,r11<<0x17
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
8001313e:	20 19       	sub	r9,1
80013140:	18 09       	add	r9,r12
80013142:	e0 6a 2c e8 	mov	r10,11496
80013146:	95 09       	st.w	r10[0x0],r9
80013148:	f1 39 00 0a 	ld.ub	r9,r8[10]
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
8001314c:	f1 38 00 0b 	ld.ub	r8,r8[11]
80013150:	a7 98       	lsr	r8,0x7
80013152:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
}
80013156:	f0 09 00 19 	add	r9,r8,r9<<0x1
8001315a:	30 18       	mov	r8,1
8001315c:	2f f9       	sub	r9,-1
8001315e:	b1 39       	mul	r9,r8
80013160:	e0 68 2c e6 	mov	r8,11494
80013164:	b0 09       	st.h	r8[0x0],r9
80013166:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001316a:	d7 03       	nop

8001316c <sd_mmc_spi_write_close>:
8001316c:	5e fc       	retal	r12
8001316e:	d7 03       	nop

80013170 <sd_mmc_spi_read_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA read transfer
//! page programming.
//!
void sd_mmc_spi_read_close_PDCA (void)
{
80013170:	d4 01       	pushm	lr

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80013172:	e0 6b 00 ff 	mov	r11,255
80013176:	fe 7c 28 00 	mov	r12,-55296
8001317a:	fe b0 fd 56 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
8001317e:	e0 6b 00 ff 	mov	r11,255
80013182:	fe 7c 28 00 	mov	r12,-55296
80013186:	fe b0 fd 50 	rcall	80012c26 <spi_write>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
8001318a:	e0 6b 00 ff 	mov	r11,255
8001318e:	fe 7c 28 00 	mov	r12,-55296
80013192:	fe b0 fd 4a 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80013196:	e0 6b 00 ff 	mov	r11,255
8001319a:	fe 7c 28 00 	mov	r12,-55296
8001319e:	fe b0 fd 44 	rcall	80012c26 <spi_write>

  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800131a2:	30 2b       	mov	r11,2
800131a4:	fe 7c 28 00 	mov	r12,-55296
800131a8:	fe b0 fc d2 	rcall	80012b4c <spi_unselectChip>

}
800131ac:	d8 02       	popm	pc
800131ae:	d7 03       	nop

800131b0 <sd_mmc_spi_wait_not_busy>:
800131b0:	d4 21       	pushm	r4-r7,lr
800131b2:	20 1d       	sub	sp,4
800131b4:	30 2b       	mov	r11,2
800131b6:	fe 7c 28 00 	mov	r12,-55296
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800131ba:	fa c6 ff fe 	sub	r6,sp,-2
800131be:	fe b0 fc 9f 	rcall	80012afc <spi_selectChip>
800131c2:	e0 65 2d 00 	mov	r5,11520
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800131c6:	30 07       	mov	r7,0
800131c8:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
800131ca:	c0 98       	rjmp	800131dc <sd_mmc_spi_wait_not_busy+0x2c>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800131cc:	1b b8       	ld.ub	r8,sp[0x3]
800131ce:	aa 88       	st.b	r5[0x0],r8
800131d0:	e8 08 18 00 	cp.b	r8,r4
  {
    retry++;
    if (retry == 200000)
800131d4:	c1 40       	breq	800131fc <sd_mmc_spi_wait_not_busy+0x4c>
800131d6:	e2 57 0d 40 	cp.w	r7,200000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800131da:	c1 80       	breq	8001320a <sd_mmc_spi_wait_not_busy+0x5a>
800131dc:	e0 6b 00 ff 	mov	r11,255
800131e0:	fe 7c 28 00 	mov	r12,-55296
800131e4:	fe b0 fd 21 	rcall	80012c26 <spi_write>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800131e8:	0c 9b       	mov	r11,r6
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800131ea:	2f f7       	sub	r7,-1
800131ec:	fe 7c 28 00 	mov	r12,-55296
800131f0:	fe b0 fd 29 	rcall	80012c42 <spi_read>
800131f4:	58 1c       	cp.w	r12,1
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800131f6:	ce b1       	brne	800131cc <sd_mmc_spi_wait_not_busy+0x1c>
800131f8:	3f f8       	mov	r8,-1
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800131fa:	aa 88       	st.b	r5[0x0],r8
800131fc:	30 2b       	mov	r11,2
800131fe:	fe 7c 28 00 	mov	r12,-55296
80013202:	fe b0 fc a5 	rcall	80012b4c <spi_unselectChip>
80013206:	2f fd       	sub	sp,-4
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80013208:	da 2a       	popm	r4-r7,pc,r12=1
8001320a:	30 2b       	mov	r11,2
8001320c:	fe 7c 28 00 	mov	r12,-55296
80013210:	fe b0 fc 9e 	rcall	80012b4c <spi_unselectChip>
80013214:	2f fd       	sub	sp,-4
80013216:	d8 2a       	popm	r4-r7,pc,r12=0

80013218 <sd_mmc_spi_write_open>:
80013218:	d4 01       	pushm	lr
8001321a:	e0 68 06 90 	mov	r8,1680
8001321e:	a9 7c       	lsl	r12,0x9
80013220:	91 0c       	st.w	r8[0x0],r12
80013222:	cc 7f       	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013224:	d8 02       	popm	pc
80013226:	d7 03       	nop

80013228 <sd_mmc_spi_command>:
80013228:	eb cd 40 e0 	pushm	r5-r7,lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9; // gl_ptr_mem = pos * 512

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
}
8001322c:	20 1d       	sub	sp,4
8001322e:	16 97       	mov	r7,r11
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
80013230:	18 96       	mov	r6,r12
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80013232:	e0 6b 00 ff 	mov	r11,255
80013236:	fe 7c 28 00 	mov	r12,-55296
8001323a:	fe b0 fc f6 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
8001323e:	fe 7c 28 00 	mov	r12,-55296
80013242:	0c 9b       	mov	r11,r6
80013244:	a7 ab       	sbr	r11,0x6
80013246:	5c 5b       	castu.b	r11
80013248:	fe b0 fc ef 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
8001324c:	ee 0b 16 18 	lsr	r11,r7,0x18
80013250:	fe 7c 28 00 	mov	r12,-55296
80013254:	fe b0 fc e9 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI, arg>>16);
80013258:	ee 0b 16 10 	lsr	r11,r7,0x10
8001325c:	fe 7c 28 00 	mov	r12,-55296
80013260:	fe b0 fc e3 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI, arg>>8 );
80013264:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80013268:	fe 7c 28 00 	mov	r12,-55296
8001326c:	fe b0 fc dd 	rcall	80012c26 <spi_write>
  spi_write(SD_MMC_SPI, arg    );
80013270:	0e 9b       	mov	r11,r7
80013272:	fe 7c 28 00 	mov	r12,-55296
80013276:	5c 7b       	castu.h	r11
80013278:	fe b0 fc d7 	rcall	80012c26 <spi_write>
  switch(command)
8001327c:	30 08       	mov	r8,0
8001327e:	f0 06 18 00 	cp.b	r6,r8
80013282:	e0 80 00 ec 	breq	8001345a <sd_mmc_spi_command+0x232>
80013286:	30 88       	mov	r8,8
80013288:	f0 06 18 00 	cp.b	r6,r8
8001328c:	e0 80 00 ee 	breq	80013468 <sd_mmc_spi_command+0x240>
         break;
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
         break;
      default:
         spi_write(SD_MMC_SPI, 0xff);
80013290:	e0 6b 00 ff 	mov	r11,255
80013294:	fe 7c 28 00 	mov	r12,-55296
80013298:	fe b0 fc c7 	rcall	80012c26 <spi_write>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8001329c:	e0 6b 00 ff 	mov	r11,255

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
800132a0:	e0 67 2d 00 	mov	r7,11520
800132a4:	3f f5       	mov	r5,-1
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800132a6:	fe 7c 28 00 	mov	r12,-55296

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
800132aa:	ae 85       	st.b	r7[0x0],r5
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800132ac:	fe b0 fc bd 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800132b0:	fa c6 ff fe 	sub	r6,sp,-2
800132b4:	fe 7c 28 00 	mov	r12,-55296
800132b8:	0c 9b       	mov	r11,r6
800132ba:	fe b0 fc c4 	rcall	80012c42 <spi_read>
800132be:	58 1c       	cp.w	r12,1
800132c0:	e0 80 00 db 	breq	80013476 <sd_mmc_spi_command+0x24e>
     return 0xFF;
   return data_read;
800132c4:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800132c6:	ae 8c       	st.b	r7[0x0],r12
800132c8:	ea 0c 18 00 	cp.b	r12,r5
800132cc:	e0 81 00 c4 	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800132d0:	e0 6b 00 ff 	mov	r11,255
800132d4:	fe 7c 28 00 	mov	r12,-55296
800132d8:	fe b0 fc a7 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800132dc:	0c 9b       	mov	r11,r6
800132de:	fe 7c 28 00 	mov	r12,-55296
800132e2:	fe b0 fc b0 	rcall	80012c42 <spi_read>
800132e6:	58 1c       	cp.w	r12,1
800132e8:	e0 80 00 c9 	breq	8001347a <sd_mmc_spi_command+0x252>
     return 0xFF;
   return data_read;
800132ec:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800132ee:	ae 8c       	st.b	r7[0x0],r12
800132f0:	3f f8       	mov	r8,-1
800132f2:	f0 0c 18 00 	cp.b	r12,r8
800132f6:	e0 81 00 af 	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800132fa:	e0 6b 00 ff 	mov	r11,255
800132fe:	fe 7c 28 00 	mov	r12,-55296
80013302:	fe b0 fc 92 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013306:	0c 9b       	mov	r11,r6
80013308:	fe 7c 28 00 	mov	r12,-55296
8001330c:	fe b0 fc 9b 	rcall	80012c42 <spi_read>
80013310:	58 1c       	cp.w	r12,1
80013312:	e0 80 00 b7 	breq	80013480 <sd_mmc_spi_command+0x258>
     return 0xFF;
   return data_read;
80013316:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013318:	ae 8c       	st.b	r7[0x0],r12
8001331a:	3f f8       	mov	r8,-1
8001331c:	f0 0c 18 00 	cp.b	r12,r8
80013320:	e0 81 00 9a 	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013324:	e0 6b 00 ff 	mov	r11,255
80013328:	fe 7c 28 00 	mov	r12,-55296
8001332c:	fe b0 fc 7d 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013330:	0c 9b       	mov	r11,r6
80013332:	fe 7c 28 00 	mov	r12,-55296
80013336:	fe b0 fc 86 	rcall	80012c42 <spi_read>
8001333a:	58 1c       	cp.w	r12,1
8001333c:	e0 80 00 a5 	breq	80013486 <sd_mmc_spi_command+0x25e>
     return 0xFF;
   return data_read;
80013340:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013342:	ae 8c       	st.b	r7[0x0],r12
80013344:	3f f8       	mov	r8,-1
80013346:	f0 0c 18 00 	cp.b	r12,r8
8001334a:	e0 81 00 85 	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8001334e:	e0 6b 00 ff 	mov	r11,255
80013352:	fe 7c 28 00 	mov	r12,-55296
80013356:	fe b0 fc 68 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8001335a:	0c 9b       	mov	r11,r6
8001335c:	fe 7c 28 00 	mov	r12,-55296
80013360:	fe b0 fc 71 	rcall	80012c42 <spi_read>
80013364:	58 1c       	cp.w	r12,1
80013366:	e0 80 00 93 	breq	8001348c <sd_mmc_spi_command+0x264>
     return 0xFF;
   return data_read;
8001336a:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8001336c:	ae 8c       	st.b	r7[0x0],r12
8001336e:	3f f8       	mov	r8,-1
80013370:	f0 0c 18 00 	cp.b	r12,r8
80013374:	c7 01       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013376:	e0 6b 00 ff 	mov	r11,255
8001337a:	fe 7c 28 00 	mov	r12,-55296
8001337e:	fe b0 fc 54 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013382:	0c 9b       	mov	r11,r6
80013384:	fe 7c 28 00 	mov	r12,-55296
80013388:	fe b0 fc 5d 	rcall	80012c42 <spi_read>
8001338c:	58 1c       	cp.w	r12,1
8001338e:	e0 80 00 82 	breq	80013492 <sd_mmc_spi_command+0x26a>
     return 0xFF;
   return data_read;
80013392:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013394:	ae 8c       	st.b	r7[0x0],r12
80013396:	3f f8       	mov	r8,-1
80013398:	f0 0c 18 00 	cp.b	r12,r8
8001339c:	c5 c1       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8001339e:	e0 6b 00 ff 	mov	r11,255
800133a2:	fe 7c 28 00 	mov	r12,-55296
800133a6:	fe b0 fc 40 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800133aa:	0c 9b       	mov	r11,r6
800133ac:	fe 7c 28 00 	mov	r12,-55296
800133b0:	fe b0 fc 49 	rcall	80012c42 <spi_read>
800133b4:	58 1c       	cp.w	r12,1
800133b6:	c7 10       	breq	80013498 <sd_mmc_spi_command+0x270>
     return 0xFF;
   return data_read;
800133b8:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800133ba:	ae 8c       	st.b	r7[0x0],r12
800133bc:	3f f8       	mov	r8,-1
800133be:	f0 0c 18 00 	cp.b	r12,r8
800133c2:	c4 91       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800133c4:	e0 6b 00 ff 	mov	r11,255
800133c8:	fe 7c 28 00 	mov	r12,-55296
800133cc:	fe b0 fc 2d 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800133d0:	0c 9b       	mov	r11,r6
800133d2:	fe 7c 28 00 	mov	r12,-55296
800133d6:	fe b0 fc 36 	rcall	80012c42 <spi_read>
800133da:	58 1c       	cp.w	r12,1
800133dc:	c6 10       	breq	8001349e <sd_mmc_spi_command+0x276>
     return 0xFF;
   return data_read;
800133de:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800133e0:	ae 8c       	st.b	r7[0x0],r12
800133e2:	3f f8       	mov	r8,-1
800133e4:	f0 0c 18 00 	cp.b	r12,r8
800133e8:	c3 61       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800133ea:	e0 6b 00 ff 	mov	r11,255
800133ee:	fe 7c 28 00 	mov	r12,-55296
800133f2:	fe b0 fc 1a 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800133f6:	0c 9b       	mov	r11,r6
800133f8:	fe 7c 28 00 	mov	r12,-55296
800133fc:	fe b0 fc 23 	rcall	80012c42 <spi_read>
80013400:	58 1c       	cp.w	r12,1
80013402:	c5 10       	breq	800134a4 <sd_mmc_spi_command+0x27c>
     return 0xFF;
   return data_read;
80013404:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013406:	ae 8c       	st.b	r7[0x0],r12
80013408:	3f f8       	mov	r8,-1
8001340a:	f0 0c 18 00 	cp.b	r12,r8
8001340e:	c2 31       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013410:	e0 6b 00 ff 	mov	r11,255
80013414:	fe 7c 28 00 	mov	r12,-55296
80013418:	fe b0 fc 07 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8001341c:	0c 9b       	mov	r11,r6
8001341e:	fe 7c 28 00 	mov	r12,-55296
80013422:	fe b0 fc 10 	rcall	80012c42 <spi_read>
80013426:	58 1c       	cp.w	r12,1
80013428:	c4 10       	breq	800134aa <sd_mmc_spi_command+0x282>
     return 0xFF;
   return data_read;
8001342a:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8001342c:	ae 8c       	st.b	r7[0x0],r12
8001342e:	3f f8       	mov	r8,-1
80013430:	f0 0c 18 00 	cp.b	r12,r8
80013434:	c1 01       	brne	80013454 <sd_mmc_spi_command+0x22c>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013436:	e0 6b 00 ff 	mov	r11,255
8001343a:	fe 7c 28 00 	mov	r12,-55296
8001343e:	fe b0 fb f4 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013442:	0c 9b       	mov	r11,r6
80013444:	fe 7c 28 00 	mov	r12,-55296
80013448:	fe b0 fb fd 	rcall	80012c42 <spi_read>
8001344c:	58 1c       	cp.w	r12,1
8001344e:	c3 10       	breq	800134b0 <sd_mmc_spi_command+0x288>
     return 0xFF;
   return data_read;
80013450:	1b bc       	ld.ub	r12,sp[0x3]
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013452:	ae 8c       	st.b	r7[0x0],r12
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
80013454:	2f fd       	sub	sp,-4
80013456:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  spi_write(SD_MMC_SPI, arg>>8 );
  spi_write(SD_MMC_SPI, arg    );
  switch(command)
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
8001345a:	e0 6b 00 95 	mov	r11,149
8001345e:	fe 7c 28 00 	mov	r12,-55296
80013462:	fe b0 fb e2 	rcall	80012c26 <spi_write>
         break;
80013466:	c1 bb       	rjmp	8001329c <sd_mmc_spi_command+0x74>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80013468:	e0 6b 00 87 	mov	r11,135
8001346c:	fe 7c 28 00 	mov	r12,-55296
80013470:	fe b0 fb db 	rcall	80012c26 <spi_write>
         break;
80013474:	c1 4b       	rjmp	8001329c <sd_mmc_spi_command+0x74>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013476:	ae 85       	st.b	r7[0x0],r5
80013478:	c2 cb       	rjmp	800132d0 <sd_mmc_spi_command+0xa8>
8001347a:	3f f8       	mov	r8,-1
8001347c:	ae 88       	st.b	r7[0x0],r8
8001347e:	c3 eb       	rjmp	800132fa <sd_mmc_spi_command+0xd2>
80013480:	3f f8       	mov	r8,-1
80013482:	ae 88       	st.b	r7[0x0],r8
80013484:	c5 0b       	rjmp	80013324 <sd_mmc_spi_command+0xfc>
80013486:	3f f8       	mov	r8,-1
80013488:	ae 88       	st.b	r7[0x0],r8
8001348a:	c6 2b       	rjmp	8001334e <sd_mmc_spi_command+0x126>
8001348c:	3f f8       	mov	r8,-1
8001348e:	ae 88       	st.b	r7[0x0],r8
80013490:	c7 3b       	rjmp	80013376 <sd_mmc_spi_command+0x14e>
80013492:	3f f8       	mov	r8,-1
80013494:	ae 88       	st.b	r7[0x0],r8
80013496:	c8 4b       	rjmp	8001339e <sd_mmc_spi_command+0x176>
80013498:	3f f8       	mov	r8,-1
8001349a:	ae 88       	st.b	r7[0x0],r8
8001349c:	c9 4b       	rjmp	800133c4 <sd_mmc_spi_command+0x19c>
8001349e:	3f f8       	mov	r8,-1
800134a0:	ae 88       	st.b	r7[0x0],r8
800134a2:	ca 4b       	rjmp	800133ea <sd_mmc_spi_command+0x1c2>
800134a4:	3f f8       	mov	r8,-1
800134a6:	ae 88       	st.b	r7[0x0],r8
800134a8:	cb 4b       	rjmp	80013410 <sd_mmc_spi_command+0x1e8>
800134aa:	3f f8       	mov	r8,-1
800134ac:	ae 88       	st.b	r7[0x0],r8
800134ae:	cc 4b       	rjmp	80013436 <sd_mmc_spi_command+0x20e>
800134b0:	3f f8       	mov	r8,-1
800134b2:	e0 6c 00 ff 	mov	r12,255
800134b6:	ae 88       	st.b	r7[0x0],r8
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
800134b8:	2f fd       	sub	sp,-4
800134ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800134be:	d7 03       	nop

800134c0 <sd_mmc_spi_read_open_PDCA>:
800134c0:	d4 21       	pushm	r4-r7,lr
800134c2:	20 1d       	sub	sp,4
800134c4:	a9 7c       	lsl	r12,0x9
800134c6:	e0 67 06 90 	mov	r7,1680
800134ca:	8f 0c       	st.w	r7[0x0],r12

  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9;                    // gl_ptr_mem = pos * 512

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800134cc:	c7 2e       	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
800134ce:	c0 31       	brne	800134d4 <sd_mmc_spi_read_open_PDCA+0x14>
    spi_write(SD_MMC_SPI,0xFF);
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }
  return true;   // Read done.
}
800134d0:	2f fd       	sub	sp,-4
800134d2:	d8 22       	popm	r4-r7,pc
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;


  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI
800134d4:	30 2b       	mov	r11,2
800134d6:	fe 7c 28 00 	mov	r12,-55296
800134da:	fe b0 fb 11 	rcall	80012afc <spi_selectChip>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
800134de:	e0 68 2c ee 	mov	r8,11502
800134e2:	11 89       	ld.ub	r9,r8[0x0]
800134e4:	30 38       	mov	r8,3
800134e6:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
800134ea:	c3 90       	breq	8001355c <sd_mmc_spi_read_open_PDCA+0x9c>
800134ec:	6e 0b       	ld.w	r11,r7[0x0]
800134ee:	31 1c       	mov	r12,17
800134f0:	e0 66 2d 00 	mov	r6,11520
800134f4:	c9 ae       	rcall	80013228 <sd_mmc_spi_command>
  }

  // check for valid response
  if (r1 != 0x00)
800134f6:	ac 8c       	st.b	r6[0x0],r12
800134f8:	58 0c       	cp.w	r12,0
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
       return false;
800134fa:	c2 81       	brne	8001354a <sd_mmc_spi_read_open_PDCA+0x8a>
800134fc:	18 97       	mov	r7,r12
800134fe:	fa c5 ff fe 	sub	r5,sp,-2
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013502:	3f f4       	mov	r4,-1
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
     return 0xFF;
   return data_read;
80013504:	c0 a8       	rjmp	80013518 <sd_mmc_spi_read_open_PDCA+0x58>
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013506:	1b b8       	ld.ub	r8,sp[0x3]
80013508:	ac 88       	st.b	r6[0x0],r8
8001350a:	e8 08 18 00 	cp.b	r8,r4

  // check for valid response
  if (r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
8001350e:	c1 41       	brne	80013536 <sd_mmc_spi_read_open_PDCA+0x76>
  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
80013510:	2f f7       	sub	r7,-1
80013512:	e0 47 75 30 	cp.w	r7,30000
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013516:	c1 a0       	breq	8001354a <sd_mmc_spi_read_open_PDCA+0x8a>
80013518:	e0 6b 00 ff 	mov	r11,255
8001351c:	fe 7c 28 00 	mov	r12,-55296
80013520:	fe b0 fb 83 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013524:	0a 9b       	mov	r11,r5
80013526:	fe 7c 28 00 	mov	r12,-55296
8001352a:	fe b0 fb 8c 	rcall	80012c42 <spi_read>
8001352e:	58 1c       	cp.w	r12,1
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80013530:	ce b1       	brne	80013506 <sd_mmc_spi_read_open_PDCA+0x46>
80013532:	ac 84       	st.b	r6[0x0],r4
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80013534:	ce eb       	rjmp	80013510 <sd_mmc_spi_read_open_PDCA+0x50>
80013536:	3f e9       	mov	r9,-2
80013538:	f2 08 18 00 	cp.b	r8,r9
  {
    spi_write(SD_MMC_SPI,0xFF);
8001353c:	c0 e0       	breq	80013558 <sd_mmc_spi_read_open_PDCA+0x98>
8001353e:	e0 6b 00 ff 	mov	r11,255
80013542:	fe 7c 28 00 	mov	r12,-55296
80013546:	fe b0 fb 70 	rcall	80012c26 <spi_write>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001354a:	30 2b       	mov	r11,2
8001354c:	fe 7c 28 00 	mov	r12,-55296
80013550:	fe b0 fa fe 	rcall	80012b4c <spi_unselectChip>
80013554:	2f fd       	sub	sp,-4
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80013556:	d8 2a       	popm	r4-r7,pc,r12=0
80013558:	30 1c       	mov	r12,1

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
8001355a:	cb bb       	rjmp	800134d0 <sd_mmc_spi_read_open_PDCA+0x10>
8001355c:	6e 0b       	ld.w	r11,r7[0x0]
8001355e:	31 1c       	mov	r12,17
80013560:	a9 9b       	lsr	r11,0x9
80013562:	e0 66 2d 00 	mov	r6,11520
80013566:	c6 1e       	rcall	80013228 <sd_mmc_spi_command>
80013568:	ac 8c       	st.b	r6[0x0],r12
8001356a:	cc 7b       	rjmp	800134f8 <sd_mmc_spi_read_open_PDCA+0x38>

8001356c <sd_mmc_spi_check_hc>:
8001356c:	eb cd 40 e0 	pushm	r5-r7,lr
80013570:	20 1d       	sub	sp,4
80013572:	c1 fe       	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013574:	c0 61       	brne	80013580 <sd_mmc_spi_check_hc+0x14>
80013576:	3f f7       	mov	r7,-1
80013578:	0e 9c       	mov	r12,r7
8001357a:	2f fd       	sub	sp,-4
8001357c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80013580:	30 2b       	mov	r11,2
80013582:	fe 7c 28 00 	mov	r12,-55296
80013586:	fe b0 fa bb 	rcall	80012afc <spi_selectChip>
8001358a:	30 0b       	mov	r11,0
8001358c:	33 ac       	mov	r12,58
8001358e:	e0 66 2d 00 	mov	r6,11520
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
80013592:	c4 be       	rcall	80013228 <sd_mmc_spi_command>
80013594:	ac 8c       	st.b	r6[0x0],r12
80013596:	c5 41       	brne	8001363e <sd_mmc_spi_check_hc+0xd2>
  // check for valid response
  if(r1 != 0) {
80013598:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8001359c:	fe 7c 28 00 	mov	r12,-55296
800135a0:	fe b0 fb 43 	rcall	80012c26 <spi_write>
800135a4:	fa c5 ff fe 	sub	r5,sp,-2
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800135a8:	fe 7c 28 00 	mov	r12,-55296
800135ac:	0a 9b       	mov	r11,r5
800135ae:	fe b0 fb 4a 	rcall	80012c42 <spi_read>
800135b2:	58 1c       	cp.w	r12,1
800135b4:	c3 a0       	breq	80013628 <sd_mmc_spi_check_hc+0xbc>
800135b6:	1b b7       	ld.ub	r7,sp[0x3]
800135b8:	ef d7 c0 c1 	bfextu	r7,r7,0x6,0x1
800135bc:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800135c0:	fe 7c 28 00 	mov	r12,-55296
800135c4:	fe b0 fb 31 	rcall	80012c26 <spi_write>
800135c8:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800135ca:	fe 7c 28 00 	mov	r12,-55296
800135ce:	fe b0 fb 3a 	rcall	80012c42 <spi_read>
800135d2:	58 1c       	cp.w	r12,1
800135d4:	c3 20       	breq	80013638 <sd_mmc_spi_check_hc+0xcc>
800135d6:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
800135d8:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800135dc:	ac 88       	st.b	r6[0x0],r8
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
800135de:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800135e2:	fe b0 fb 22 	rcall	80012c26 <spi_write>
800135e6:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800135e8:	fe 7c 28 00 	mov	r12,-55296
800135ec:	fe b0 fb 2b 	rcall	80012c42 <spi_read>
800135f0:	58 1c       	cp.w	r12,1
800135f2:	c2 00       	breq	80013632 <sd_mmc_spi_check_hc+0xc6>
800135f4:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
800135f6:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800135fa:	ac 88       	st.b	r6[0x0],r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
800135fc:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013600:	fe b0 fb 13 	rcall	80012c26 <spi_write>
80013604:	0a 9b       	mov	r11,r5
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013606:	fe 7c 28 00 	mov	r12,-55296
8001360a:	fe b0 fb 1c 	rcall	80012c42 <spi_read>
8001360e:	58 1c       	cp.w	r12,1
80013610:	c0 e0       	breq	8001362c <sd_mmc_spi_check_hc+0xc0>
80013612:	1b b8       	ld.ub	r8,sp[0x3]
     return 0xFF;
   return data_read;
80013614:	ac 88       	st.b	r6[0x0],r8
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80013616:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013618:	fe 7c 28 00 	mov	r12,-55296
8001361c:	fe b0 fa 98 	rcall	80012b4c <spi_unselectChip>
80013620:	0e 9c       	mov	r12,r7
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
80013622:	2f fd       	sub	sp,-4
80013624:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80013628:	18 97       	mov	r7,r12
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8001362a:	cc 9b       	rjmp	800135bc <sd_mmc_spi_check_hc+0x50>
8001362c:	e0 68 00 ff 	mov	r8,255
80013630:	cf 2b       	rjmp	80013614 <sd_mmc_spi_check_hc+0xa8>
80013632:	e0 68 00 ff 	mov	r8,255
80013636:	ce 0b       	rjmp	800135f6 <sd_mmc_spi_check_hc+0x8a>
80013638:	e0 68 00 ff 	mov	r8,255
8001363c:	cc eb       	rjmp	800135d8 <sd_mmc_spi_check_hc+0x6c>
8001363e:	30 2b       	mov	r11,2

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
  // check for valid response
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013640:	fe 7c 28 00 	mov	r12,-55296
80013644:	fe b0 fa 84 	rcall	80012b4c <spi_unselectChip>
80013648:	c9 7b       	rjmp	80013576 <sd_mmc_spi_check_hc+0xa>
8001364a:	d7 03       	nop

8001364c <sd_mmc_spi_write_sector_from_ram>:
8001364c:	d4 21       	pushm	r4-r7,lr
8001364e:	20 1d       	sub	sp,4
80013650:	18 97       	mov	r7,r12
80013652:	fe b0 fd af 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013656:	c0 31       	brne	8001365c <sd_mmc_spi_write_sector_from_ram+0x10>
80013658:	2f fd       	sub	sp,-4
8001365a:	d8 22       	popm	r4-r7,pc
8001365c:	30 2b       	mov	r11,2
8001365e:	fe 7c 28 00 	mov	r12,-55296
80013662:	fe b0 fa 4d 	rcall	80012afc <spi_selectChip>
80013666:	e0 68 2c ee 	mov	r8,11502
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8001366a:	11 89       	ld.ub	r9,r8[0x0]
8001366c:	30 38       	mov	r8,3
8001366e:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80013672:	c5 40       	breq	8001371a <sd_mmc_spi_write_sector_from_ram+0xce>
80013674:	e0 64 06 90 	mov	r4,1680
80013678:	31 8c       	mov	r12,24
8001367a:	68 0b       	ld.w	r11,r4[0x0]
8001367c:	e0 65 2d 00 	mov	r5,11520
  }

  // check for valid response
  if(r1 != 0x00)
80013680:	fe b0 fd d4 	rcall	80013228 <sd_mmc_spi_command>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80013684:	aa 8c       	st.b	r5[0x0],r12
80013686:	58 0c       	cp.w	r12,0
80013688:	c4 21       	brne	8001370c <sd_mmc_spi_write_sector_from_ram+0xc0>
8001368a:	e0 6b 00 ff 	mov	r11,255
8001368e:	fe 7c 28 00 	mov	r12,-55296

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80013692:	fe b0 fa ca 	rcall	80012c26 <spi_write>
80013696:	e0 6b 00 fe 	mov	r11,254
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
8001369a:	fe 7c 28 00 	mov	r12,-55296
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
8001369e:	ee c6 fe 00 	sub	r6,r7,-512
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800136a2:	fe b0 fa c2 	rcall	80012c26 <spi_write>
800136a6:	0f 3b       	ld.ub	r11,r7++
800136a8:	fe 7c 28 00 	mov	r12,-55296
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800136ac:	fe b0 fa bd 	rcall	80012c26 <spi_write>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
800136b0:	0c 37       	cp.w	r7,r6
800136b2:	cf a1       	brne	800136a6 <sd_mmc_spi_write_sector_from_ram+0x5a>
800136b4:	e0 6b 00 ff 	mov	r11,255
800136b8:	fe 7c 28 00 	mov	r12,-55296
  spi_write(SD_MMC_SPI,0xFF);
800136bc:	fe b0 fa b5 	rcall	80012c26 <spi_write>
800136c0:	e0 6b 00 ff 	mov	r11,255
800136c4:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800136c8:	fe b0 fa af 	rcall	80012c26 <spi_write>
800136cc:	e0 6b 00 ff 	mov	r11,255
800136d0:	fe 7c 28 00 	mov	r12,-55296
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800136d4:	fe b0 fa a9 	rcall	80012c26 <spi_write>
800136d8:	fa cb ff fe 	sub	r11,sp,-2
800136dc:	fe 7c 28 00 	mov	r12,-55296
800136e0:	fe b0 fa b1 	rcall	80012c42 <spi_read>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
800136e4:	58 1c       	cp.w	r12,1
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
800136e6:	c5 80       	breq	80013796 <sd_mmc_spi_write_sector_from_ram+0x14a>
800136e8:	1b b8       	ld.ub	r8,sp[0x3]
800136ea:	aa 88       	st.b	r5[0x0],r8
800136ec:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
800136f0:	58 58       	cp.w	r8,5
800136f2:	c1 f0       	breq	80013730 <sd_mmc_spi_write_sector_from_ram+0xe4>
800136f4:	e0 6b 00 ff 	mov	r11,255
800136f8:	fe 7c 28 00 	mov	r12,-55296
    spi_write(SD_MMC_SPI,0xFF);
800136fc:	fe b0 fa 95 	rcall	80012c26 <spi_write>
80013700:	e0 6b 00 ff 	mov	r11,255
80013704:	fe 7c 28 00 	mov	r12,-55296
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80013708:	fe b0 fa 8f 	rcall	80012c26 <spi_write>
8001370c:	30 2b       	mov	r11,2
8001370e:	fe 7c 28 00 	mov	r12,-55296
80013712:	fe b0 fa 1d 	rcall	80012b4c <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80013716:	2f fd       	sub	sp,-4
80013718:	d8 2a       	popm	r4-r7,pc,r12=0
8001371a:	e0 64 06 90 	mov	r4,1680
8001371e:	31 8c       	mov	r12,24
80013720:	68 0b       	ld.w	r11,r4[0x0]
80013722:	e0 65 2d 00 	mov	r5,11520
    spi_write(SD_MMC_SPI,0xFF);
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80013726:	a9 9b       	lsr	r11,0x9
80013728:	fe b0 fd 80 	rcall	80013228 <sd_mmc_spi_command>
8001372c:	aa 8c       	st.b	r5[0x0],r12
8001372e:	ca cb       	rjmp	80013686 <sd_mmc_spi_write_sector_from_ram+0x3a>
80013730:	e0 6b 00 ff 	mov	r11,255
  spi_write(SD_MMC_SPI,0xFF);
80013734:	fe 7c 28 00 	mov	r12,-55296
80013738:	fe b0 fa 77 	rcall	80012c26 <spi_write>
8001373c:	e0 6b 00 ff 	mov	r11,255

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013740:	fe 7c 28 00 	mov	r12,-55296
80013744:	fe b0 fa 71 	rcall	80012c26 <spi_write>
  gl_ptr_mem += 512;        // Update the memory pointer.
80013748:	30 2b       	mov	r11,2
8001374a:	fe 7c 28 00 	mov	r12,-55296
8001374e:	fe b0 f9 ff 	rcall	80012b4c <spi_unselectChip>

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80013752:	68 08       	ld.w	r8,r4[0x0]
80013754:	f0 c8 fe 00 	sub	r8,r8,-512
80013758:	89 08       	st.w	r4[0x0],r8
8001375a:	fe b0 fd 2b 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
8001375e:	c1 f1       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013760:	fe b0 fd 28 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013764:	c1 c1       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013766:	fe b0 fd 25 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
8001376a:	c1 91       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
8001376c:	fe b0 fd 22 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013770:	c1 61       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013772:	fe b0 fd 1f 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013776:	c1 31       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013778:	fe b0 fd 1c 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
8001377c:	c1 01       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
8001377e:	fe b0 fd 19 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013782:	c0 d1       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013784:	fe b0 fd 16 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
80013788:	c0 a1       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
8001378a:	fe b0 fd 13 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
  spi_write(SD_MMC_SPI,0xFF);

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
8001378e:	c0 71       	brne	8001379c <sd_mmc_spi_write_sector_from_ram+0x150>
80013790:	fe b0 fd 10 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80013794:	c6 2b       	rjmp	80013658 <sd_mmc_spi_write_sector_from_ram+0xc>
80013796:	3f f8       	mov	r8,-1
80013798:	aa 88       	st.b	r5[0x0],r8
8001379a:	ca db       	rjmp	800136f4 <sd_mmc_spi_write_sector_from_ram+0xa8>
8001379c:	30 1c       	mov	r12,1
8001379e:	c5 db       	rjmp	80013658 <sd_mmc_spi_write_sector_from_ram+0xc>

800137a0 <sd_mmc_spi_get_if>:
800137a0:	eb cd 40 e0 	pushm	r5-r7,lr
800137a4:	20 1d       	sub	sp,4
800137a6:	fe b0 fd 05 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
800137aa:	c0 51       	brne	800137b4 <sd_mmc_spi_get_if+0x14>
800137ac:	3f fc       	mov	r12,-1
800137ae:	2f fd       	sub	sp,-4
800137b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800137b4:	30 2b       	mov	r11,2
800137b6:	fe 7c 28 00 	mov	r12,-55296
800137ba:	fe b0 f9 a1 	rcall	80012afc <spi_selectChip>
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
800137be:	e0 6b 01 aa 	mov	r11,426
800137c2:	e0 67 2d 00 	mov	r7,11520
800137c6:	30 8c       	mov	r12,8
800137c8:	fe b0 fd 30 	rcall	80013228 <sd_mmc_spi_command>
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
800137cc:	ae 8c       	st.b	r7[0x0],r12
800137ce:	ed bc 00 02 	bld	r12,0x2
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800137d2:	c5 00       	breq	80013872 <sd_mmc_spi_get_if+0xd2>
800137d4:	e0 6b 00 ff 	mov	r11,255
800137d8:	fe 7c 28 00 	mov	r12,-55296
800137dc:	fe b0 fa 25 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800137e0:	fa c6 ff fe 	sub	r6,sp,-2
800137e4:	fe 7c 28 00 	mov	r12,-55296
800137e8:	0c 9b       	mov	r11,r6
800137ea:	fe b0 fa 2c 	rcall	80012c42 <spi_read>
800137ee:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
800137f0:	c4 90       	breq	80013882 <sd_mmc_spi_get_if+0xe2>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800137f2:	1b b8       	ld.ub	r8,sp[0x3]
800137f4:	e0 6b 00 ff 	mov	r11,255
800137f8:	ae 88       	st.b	r7[0x0],r8
800137fa:	fe 7c 28 00 	mov	r12,-55296
800137fe:	fe b0 fa 14 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013802:	0c 9b       	mov	r11,r6
80013804:	fe 7c 28 00 	mov	r12,-55296
80013808:	fe b0 fa 1d 	rcall	80012c42 <spi_read>
8001380c:	58 1c       	cp.w	r12,1
     return 0xFF;
   return data_read;
8001380e:	c4 00       	breq	8001388e <sd_mmc_spi_get_if+0xee>
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013810:	1b b8       	ld.ub	r8,sp[0x3]
80013812:	e0 6b 00 ff 	mov	r11,255
80013816:	ae 88       	st.b	r7[0x0],r8
80013818:	fe 7c 28 00 	mov	r12,-55296
8001381c:	fe b0 fa 05 	rcall	80012c26 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013820:	0c 9b       	mov	r11,r6
80013822:	fe 7c 28 00 	mov	r12,-55296
80013826:	e0 65 2d 00 	mov	r5,11520
8001382a:	fe b0 fa 0c 	rcall	80012c42 <spi_read>
     return 0xFF;
   return data_read;
8001382e:	58 1c       	cp.w	r12,1
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80013830:	c2 c0       	breq	80013888 <sd_mmc_spi_get_if+0xe8>
  if((r1 & 0x01) == 0) {
80013832:	1b b8       	ld.ub	r8,sp[0x3]
80013834:	aa 88       	st.b	r5[0x0],r8
80013836:	ed b8 00 00 	bld	r8,0x0
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8001383a:	c3 61       	brne	800138a6 <sd_mmc_spi_get_if+0x106>
8001383c:	e0 6b 00 ff 	mov	r11,255
80013840:	fe 7c 28 00 	mov	r12,-55296
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013844:	fe b0 f9 f1 	rcall	80012c26 <spi_write>
80013848:	0c 9b       	mov	r11,r6
8001384a:	fe 7c 28 00 	mov	r12,-55296
8001384e:	fe b0 f9 fa 	rcall	80012c42 <spi_read>
     return 0xFF;
   return data_read;
80013852:	58 1c       	cp.w	r12,1
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80013854:	c2 00       	breq	80013894 <sd_mmc_spi_get_if+0xf4>
  if(r1 != 0xaa) {
80013856:	1b b8       	ld.ub	r8,sp[0x3]
80013858:	ae 88       	st.b	r7[0x0],r8
8001385a:	3a a9       	mov	r9,-86
8001385c:	f2 08 18 00 	cp.b	r8,r9
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013860:	c1 c1       	brne	80013898 <sd_mmc_spi_get_if+0xf8>
80013862:	30 2b       	mov	r11,2
80013864:	fe 7c 28 00 	mov	r12,-55296
80013868:	fe b0 f9 72 	rcall	80012b4c <spi_unselectChip>
8001386c:	2f fd       	sub	sp,-4

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001386e:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80013872:	30 2b       	mov	r11,2
80013874:	fe 7c 28 00 	mov	r12,-55296
80013878:	fe b0 f9 6a 	rcall	80012b4c <spi_unselectChip>
8001387c:	2f fd       	sub	sp,-4
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8001387e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80013882:	e0 68 00 ff 	mov	r8,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
80013886:	cb 7b       	rjmp	800137f4 <sd_mmc_spi_get_if+0x54>
80013888:	3f f8       	mov	r8,-1
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
8001388a:	aa 88       	st.b	r5[0x0],r8
8001388c:	cd 8b       	rjmp	8001383c <sd_mmc_spi_get_if+0x9c>
8001388e:	e0 68 00 ff 	mov	r8,255
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80013892:	cc 0b       	rjmp	80013812 <sd_mmc_spi_get_if+0x72>
  if(r1 != 0xaa) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013894:	3f f8       	mov	r8,-1
80013896:	ae 88       	st.b	r7[0x0],r8
80013898:	30 2b       	mov	r11,2
8001389a:	fe 7c 28 00 	mov	r12,-55296
8001389e:	fe b0 f9 57 	rcall	80012b4c <spi_unselectChip>
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800138a2:	3f fc       	mov	r12,-1
800138a4:	c8 5b       	rjmp	800137ae <sd_mmc_spi_get_if+0xe>
800138a6:	30 2b       	mov	r11,2
800138a8:	fe 7c 28 00 	mov	r12,-55296
800138ac:	fe b0 f9 50 	rcall	80012b4c <spi_unselectChip>
800138b0:	c7 eb       	rjmp	800137ac <sd_mmc_spi_get_if+0xc>
800138b2:	d7 03       	nop

800138b4 <sd_mmc_spi_internal_init>:
800138b4:	d4 31       	pushm	r0-r7,lr
800138b6:	20 1d       	sub	sp,4
800138b8:	e6 68 1a 80 	mov	r8,400000
800138bc:	e0 69 06 a4 	mov	r9,1700
800138c0:	e0 67 06 94 	mov	r7,1684
800138c4:	72 0a       	ld.w	r10,r9[0x0]
800138c6:	8f 18       	st.w	r7[0x4],r8
800138c8:	0e 9b       	mov	r11,r7
800138ca:	fe 7c 28 00 	mov	r12,-55296
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800138ce:	fe b0 f9 53 	rcall	80012b74 <spi_setupChipReg>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800138d2:	30 2b       	mov	r11,2
800138d4:	fe 7c 28 00 	mov	r12,-55296
800138d8:	fe b0 f9 12 	rcall	80012afc <spi_selectChip>
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
800138dc:	e0 6b 00 ff 	mov	r11,255
800138e0:	fe 7c 28 00 	mov	r12,-55296
800138e4:	fe b0 f9 a1 	rcall	80012c26 <spi_write>
800138e8:	e0 6b 00 ff 	mov	r11,255
800138ec:	fe 7c 28 00 	mov	r12,-55296
800138f0:	fe b0 f9 9b 	rcall	80012c26 <spi_write>
800138f4:	e0 6b 00 ff 	mov	r11,255
800138f8:	fe 7c 28 00 	mov	r12,-55296
800138fc:	fe b0 f9 95 	rcall	80012c26 <spi_write>
80013900:	e0 6b 00 ff 	mov	r11,255
80013904:	fe 7c 28 00 	mov	r12,-55296
80013908:	fe b0 f9 8f 	rcall	80012c26 <spi_write>
8001390c:	e0 6b 00 ff 	mov	r11,255
80013910:	fe 7c 28 00 	mov	r12,-55296
80013914:	fe b0 f9 89 	rcall	80012c26 <spi_write>
80013918:	e0 6b 00 ff 	mov	r11,255
8001391c:	fe 7c 28 00 	mov	r12,-55296
80013920:	fe b0 f9 83 	rcall	80012c26 <spi_write>
80013924:	e0 6b 00 ff 	mov	r11,255
80013928:	fe 7c 28 00 	mov	r12,-55296
8001392c:	fe b0 f9 7d 	rcall	80012c26 <spi_write>
80013930:	e0 6b 00 ff 	mov	r11,255
80013934:	fe 7c 28 00 	mov	r12,-55296
80013938:	fe b0 f9 77 	rcall	80012c26 <spi_write>
8001393c:	e0 6b 00 ff 	mov	r11,255
80013940:	fe 7c 28 00 	mov	r12,-55296
80013944:	fe b0 f9 71 	rcall	80012c26 <spi_write>
80013948:	e0 6b 00 ff 	mov	r11,255
8001394c:	fe 7c 28 00 	mov	r12,-55296
80013950:	fe b0 f9 6b 	rcall	80012c26 <spi_write>
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013954:	30 2b       	mov	r11,2
80013956:	fe 7c 28 00 	mov	r12,-55296
8001395a:	fe b0 f8 f9 	rcall	80012b4c <spi_unselectChip>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8001395e:	30 08       	mov	r8,0
80013960:	e0 69 06 a8 	mov	r9,1704
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013964:	30 2b       	mov	r11,2
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80013966:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
80013968:	e0 61 2c ee 	mov	r1,11502
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8001396c:	fe 7c 28 00 	mov	r12,-55296
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
  card_type = MMC_CARD;
80013970:	a2 88       	st.b	r1[0x0],r8
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013972:	fe b0 f8 c5 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80013976:	30 0b       	mov	r11,0
80013978:	16 9c       	mov	r12,r11
8001397a:	fe b0 fc 57 	rcall	80013228 <sd_mmc_spi_command>
8001397e:	e0 66 2d 00 	mov	r6,11520
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013982:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013984:	ac 8c       	st.b	r6[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013986:	fe 7c 28 00 	mov	r12,-55296
8001398a:	fe b0 f8 e1 	rcall	80012b4c <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8001398e:	e0 6b 00 ff 	mov	r11,255
80013992:	fe 7c 28 00 	mov	r12,-55296
80013996:	30 05       	mov	r5,0
80013998:	fe b0 f9 47 	rcall	80012c26 <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8001399c:	0c 90       	mov	r0,r6
8001399e:	30 12       	mov	r2,1
800139a0:	c1 78       	rjmp	800139ce <sd_mmc_spi_internal_init+0x11a>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800139a2:	fe b0 f8 ad 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800139a6:	30 0b       	mov	r11,0
800139a8:	16 9c       	mov	r12,r11
800139aa:	fe b0 fc 3f 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800139ae:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800139b0:	a0 8c       	st.b	r0[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800139b2:	fe 7c 28 00 	mov	r12,-55296
800139b6:	fe b0 f8 cb 	rcall	80012b4c <spi_unselectChip>
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800139ba:	e0 6b 00 ff 	mov	r11,255
800139be:	fe 7c 28 00 	mov	r12,-55296
800139c2:	fe b0 f9 32 	rcall	80012c26 <spi_write>
    // do retry counter
    retry++;
    if(retry > 100)
800139c6:	e0 45 00 64 	cp.w	r5,100
800139ca:	e0 80 00 b4 	breq	80013b32 <sd_mmc_spi_internal_init+0x27e>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800139ce:	30 2b       	mov	r11,2
800139d0:	fe 7c 28 00 	mov	r12,-55296
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800139d4:	2f f5       	sub	r5,-1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800139d6:	0d 84       	ld.ub	r4,r6[0x0]
800139d8:	e0 63 2d 00 	mov	r3,11520
800139dc:	e4 04 18 00 	cp.b	r4,r2
800139e0:	ce 11       	brne	800139a2 <sd_mmc_spi_internal_init+0xee>

  if_cond = sd_mmc_spi_get_if();
800139e2:	cd fe       	rcall	800137a0 <sd_mmc_spi_get_if>
800139e4:	5b fc       	cp.w	r12,-1
  if(if_cond == -1) {
800139e6:	e0 80 00 a6 	breq	80013b32 <sd_mmc_spi_internal_init+0x27e>
800139ea:	58 1c       	cp.w	r12,1
      return false; // card is bad
  } else if (if_cond == 1) {
800139ec:	e0 80 00 a6 	breq	80013b38 <sd_mmc_spi_internal_init+0x284>
800139f0:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800139f2:	fe 7c 28 00 	mov	r12,-55296
800139f6:	fe b0 f8 83 	rcall	80012afc <spi_selectChip>
800139fa:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
800139fc:	33 7c       	mov	r12,55
800139fe:	fe b0 fc 15 	rcall	80013228 <sd_mmc_spi_command>
80013a02:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a04:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013a06:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a0a:	fe b0 f8 a1 	rcall	80012b4c <spi_unselectChip>
80013a0e:	e0 6b 00 ff 	mov	r11,255
      card_type = SD_CARD_2;
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80013a12:	fe 7c 28 00 	mov	r12,-55296
80013a16:	fe b0 f9 08 	rcall	80012c26 <spi_write>
80013a1a:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013a1c:	fe 7c 28 00 	mov	r12,-55296
80013a20:	fe b0 f8 6e 	rcall	80012afc <spi_selectChip>
80013a24:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013a26:	32 9c       	mov	r12,41
80013a28:	fe b0 fc 00 	rcall	80013228 <sd_mmc_spi_command>
80013a2c:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a2e:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013a30:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a34:	fe b0 f8 8c 	rcall	80012b4c <spi_unselectChip>
80013a38:	e0 6b 00 ff 	mov	r11,255
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80013a3c:	fe 7c 28 00 	mov	r12,-55296
80013a40:	fe b0 f8 f3 	rcall	80012c26 <spi_write>
80013a44:	07 88       	ld.ub	r8,r3[0x0]

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80013a46:	e2 18 00 fe 	andl	r8,0xfe,COH
80013a4a:	e0 80 00 d3 	breq	80013bf0 <sd_mmc_spi_internal_init+0x33c>
80013a4e:	30 08       	mov	r8,0
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80013a50:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013a52:	a2 88       	st.b	r1[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80013a54:	fe 7c 28 00 	mov	r12,-55296
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013a58:	fe b0 f8 52 	rcall	80012afc <spi_selectChip>
80013a5c:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013a5e:	16 9c       	mov	r12,r11
80013a60:	fe b0 fb e4 	rcall	80013228 <sd_mmc_spi_command>
80013a64:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a66:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013a68:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a6c:	fe b0 f8 70 	rcall	80012b4c <spi_unselectChip>
80013a70:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013a74:	fe 7c 28 00 	mov	r12,-55296
80013a78:	30 05       	mov	r5,0
80013a7a:	fe b0 f8 d6 	rcall	80012c26 <spi_write>
80013a7e:	30 14       	mov	r4,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80013a80:	c1 68       	rjmp	80013aac <sd_mmc_spi_internal_init+0x1f8>
80013a82:	fe b0 f8 3d 	rcall	80012afc <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013a86:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013a88:	16 9c       	mov	r12,r11
80013a8a:	fe b0 fb cf 	rcall	80013228 <sd_mmc_spi_command>
80013a8e:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a90:	a6 8c       	st.b	r3[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013a92:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013a96:	fe b0 f8 5b 	rcall	80012b4c <spi_unselectChip>
80013a9a:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013a9e:	fe 7c 28 00 	mov	r12,-55296
80013aa2:	fe b0 f8 c2 	rcall	80012c26 <spi_write>
80013aa6:	e0 45 00 64 	cp.w	r5,100
        // do retry counter
        retry++;
        if(retry > 100)
80013aaa:	c4 40       	breq	80013b32 <sd_mmc_spi_internal_init+0x27e>
80013aac:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013aae:	fe 7c 28 00 	mov	r12,-55296
80013ab2:	2f f5       	sub	r5,-1
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013ab4:	0d 88       	ld.ub	r8,r6[0x0]
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80013ab6:	e8 08 18 00 	cp.b	r8,r4
80013aba:	ce 41       	brne	80013a82 <sd_mmc_spi_internal_init+0x1ce>
80013abc:	03 88       	ld.ub	r8,r1[0x0]
80013abe:	c4 08       	rjmp	80013b3e <sd_mmc_spi_internal_init+0x28a>
80013ac0:	03 89       	ld.ub	r9,r1[0x0]
     if(retry == 50000)    // measured approx. 500 on several cards
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80013ac2:	30 28       	mov	r8,2
80013ac4:	f0 09 18 00 	cp.b	r9,r8
80013ac8:	e0 80 01 77 	breq	80013db6 <sd_mmc_spi_internal_init+0x502>
80013acc:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013ace:	fe 7c 28 00 	mov	r12,-55296
80013ad2:	fe b0 f8 15 	rcall	80012afc <spi_selectChip>
80013ad6:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013ad8:	33 bc       	mov	r12,59
80013ada:	fe b0 fb a7 	rcall	80013228 <sd_mmc_spi_command>
80013ade:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013ae0:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013ae2:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013ae6:	fe b0 f8 33 	rcall	80012b4c <spi_unselectChip>
80013aea:	e0 6b 00 ff 	mov	r11,255
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013aee:	fe 7c 28 00 	mov	r12,-55296
80013af2:	fe b0 f8 9a 	rcall	80012c26 <spi_write>
80013af6:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013af8:	fe 7c 28 00 	mov	r12,-55296
80013afc:	fe b0 f8 00 	rcall	80012afc <spi_selectChip>
80013b00:	e0 6b 02 00 	mov	r11,512
  r1 = sd_mmc_spi_command(command, arg);
80013b04:	31 0c       	mov	r12,16
80013b06:	fe b0 fb 91 	rcall	80013228 <sd_mmc_spi_command>
80013b0a:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013b0c:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013b0e:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013b12:	fe b0 f8 1d 	rcall	80012b4c <spi_unselectChip>
80013b16:	e0 6b 00 ff 	mov	r11,255
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013b1a:	fe 7c 28 00 	mov	r12,-55296
80013b1e:	e0 64 2d 00 	mov	r4,11520
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013b22:	fe b0 f8 82 	rcall	80012c26 <spi_write>
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013b26:	0d 85       	ld.ub	r5,r6[0x0]
  if (r1 != 0x00)
80013b28:	58 05       	cp.w	r5,0
80013b2a:	c0 41       	brne	80013b32 <sd_mmc_spi_internal_init+0x27e>
80013b2c:	fe b0 fb 42 	rcall	800131b0 <sd_mmc_spi_wait_not_busy>
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80013b30:	c6 31       	brne	80013bf6 <sd_mmc_spi_internal_init+0x342>
80013b32:	30 0c       	mov	r12,0
  sd_mmc_spi_init_done = true;

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
  return true;
80013b34:	2f fd       	sub	sp,-4
}
80013b36:	d8 32       	popm	r0-r7,pc
80013b38:	30 28       	mov	r8,2

  if_cond = sd_mmc_spi_get_if();
  if(if_cond == -1) {
      return false; // card is bad
  } else if (if_cond == 1) {
      card_type = SD_CARD_2;
80013b3a:	a2 88       	st.b	r1[0x0],r8
80013b3c:	30 28       	mov	r8,2
80013b3e:	30 05       	mov	r5,0
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80013b40:	30 14       	mov	r4,1

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80013b42:	30 23       	mov	r3,2
80013b44:	c1 d8       	rjmp	80013b7e <sd_mmc_spi_internal_init+0x2ca>
80013b46:	fe b0 f7 db 	rcall	80012afc <spi_selectChip>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013b4a:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013b4c:	30 1c       	mov	r12,1
80013b4e:	fe b0 fb 6d 	rcall	80013228 <sd_mmc_spi_command>
80013b52:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013b54:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013b56:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013b5a:	fe b0 f7 f9 	rcall	80012b4c <spi_unselectChip>
80013b5e:	e0 6b 00 ff 	mov	r11,255
      break;
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80013b62:	fe 7c 28 00 	mov	r12,-55296
80013b66:	fe b0 f8 60 	rcall	80012c26 <spi_write>
80013b6a:	e0 45 c3 4f 	cp.w	r5,49999
      break;
    }
     // do retry counter
     retry++;
     if(retry == 50000)    // measured approx. 500 on several cards
80013b6e:	ce 20       	breq	80013b32 <sd_mmc_spi_internal_init+0x27e>
80013b70:	2f f5       	sub	r5,-1
80013b72:	0d 89       	ld.ub	r9,r6[0x0]
        return false;
  } while (r1);
80013b74:	30 08       	mov	r8,0
80013b76:	f0 09 18 00 	cp.b	r9,r8
80013b7a:	ca 30       	breq	80013ac0 <sd_mmc_spi_internal_init+0x20c>
80013b7c:	03 88       	ld.ub	r8,r1[0x0]
80013b7e:	e8 08 18 00 	cp.b	r8,r4

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80013b82:	c2 00       	breq	80013bc2 <sd_mmc_spi_internal_init+0x30e>
80013b84:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013b86:	fe 7c 28 00 	mov	r12,-55296
80013b8a:	cd e3       	brcs	80013b46 <sd_mmc_spi_internal_init+0x292>

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
80013b8c:	e6 08 18 00 	cp.b	r8,r3
80013b90:	ce d1       	brne	80013b6a <sd_mmc_spi_internal_init+0x2b6>
80013b92:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013b94:	fe 7c 28 00 	mov	r12,-55296
80013b98:	fe b0 f7 b2 	rcall	80012afc <spi_selectChip>
80013b9c:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013b9e:	33 7c       	mov	r12,55
80013ba0:	fe b0 fb 44 	rcall	80013228 <sd_mmc_spi_command>
80013ba4:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013ba6:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013ba8:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013bac:	fe b0 f7 d0 	rcall	80012b4c <spi_unselectChip>
80013bb0:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013bb2:	fe 7c 28 00 	mov	r12,-55296
80013bb6:	fe b0 f7 a3 	rcall	80012afc <spi_selectChip>
80013bba:	fc 1b 40 00 	movh	r11,0x4000
  r1 = sd_mmc_spi_command(command, arg);
80013bbe:	32 9c       	mov	r12,41
80013bc0:	cc 7b       	rjmp	80013b4e <sd_mmc_spi_internal_init+0x29a>
80013bc2:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013bc4:	fe 7c 28 00 	mov	r12,-55296
80013bc8:	fe b0 f7 9a 	rcall	80012afc <spi_selectChip>
80013bcc:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013bce:	33 7c       	mov	r12,55
80013bd0:	fe b0 fb 2c 	rcall	80013228 <sd_mmc_spi_command>
80013bd4:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013bd6:	ac 8c       	st.b	r6[0x0],r12
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80013bd8:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013bdc:	fe b0 f7 b8 	rcall	80012b4c <spi_unselectChip>
80013be0:	30 2b       	mov	r11,2
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013be2:	fe 7c 28 00 	mov	r12,-55296
80013be6:	fe b0 f7 8b 	rcall	80012afc <spi_selectChip>
80013bea:	30 0b       	mov	r11,0
  r1 = sd_mmc_spi_command(command, arg);
80013bec:	32 9c       	mov	r12,41
80013bee:	cb 0b       	rjmp	80013b4e <sd_mmc_spi_internal_init+0x29a>
80013bf0:	a2 84       	st.b	r1[0x0],r4

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
80013bf2:	30 18       	mov	r8,1
80013bf4:	ca 5b       	rjmp	80013b3e <sd_mmc_spi_internal_init+0x28a>
80013bf6:	30 2b       	mov	r11,2
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80013bf8:	fe 7c 28 00 	mov	r12,-55296
80013bfc:	fe b0 f7 80 	rcall	80012afc <spi_selectChip>
80013c00:	30 0b       	mov	r11,0
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80013c02:	30 9c       	mov	r12,9
80013c04:	fe b0 fb 12 	rcall	80013228 <sd_mmc_spi_command>
80013c08:	a8 8c       	st.b	r4[0x0],r12
80013c0a:	e0 81 01 f1 	brne	80013fec <sd_mmc_spi_internal_init+0x738>
  // check for valid response
  if(r1 != 0x00)
80013c0e:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013c12:	fe 7c 28 00 	mov	r12,-55296
80013c16:	fe b0 f8 08 	rcall	80012c26 <spi_write>
80013c1a:	1a 95       	mov	r5,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013c1c:	fe 7c 28 00 	mov	r12,-55296
80013c20:	1a 9b       	mov	r11,sp
80013c22:	fe b0 f8 10 	rcall	80012c42 <spi_read>
80013c26:	58 1c       	cp.w	r12,1
80013c28:	e0 80 01 ed 	breq	80014002 <sd_mmc_spi_internal_init+0x74e>
80013c2c:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013c2e:	a8 88       	st.b	r4[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013c30:	3f e9       	mov	r9,-2
80013c32:	f2 08 18 00 	cp.b	r8,r9
80013c36:	e0 80 00 d1 	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013c3a:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013c3e:	fe 7c 28 00 	mov	r12,-55296
80013c42:	fe b0 f7 f2 	rcall	80012c26 <spi_write>
80013c46:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013c48:	fe 7c 28 00 	mov	r12,-55296
80013c4c:	fe b0 f7 fb 	rcall	80012c42 <spi_read>
80013c50:	58 1c       	cp.w	r12,1
80013c52:	e0 80 00 c0 	breq	80013dd2 <sd_mmc_spi_internal_init+0x51e>
80013c56:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013c58:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013c5a:	3f e9       	mov	r9,-2
80013c5c:	f2 08 18 00 	cp.b	r8,r9
80013c60:	e0 80 00 bc 	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013c64:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013c68:	fe 7c 28 00 	mov	r12,-55296
80013c6c:	fe b0 f7 dd 	rcall	80012c26 <spi_write>
80013c70:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013c72:	fe 7c 28 00 	mov	r12,-55296
80013c76:	fe b0 f7 e6 	rcall	80012c42 <spi_read>
80013c7a:	58 1c       	cp.w	r12,1
80013c7c:	e0 80 01 cb 	breq	80014012 <sd_mmc_spi_internal_init+0x75e>
80013c80:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013c82:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013c84:	3f e9       	mov	r9,-2
80013c86:	f2 08 18 00 	cp.b	r8,r9
80013c8a:	e0 80 00 a7 	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013c8e:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013c92:	fe 7c 28 00 	mov	r12,-55296
80013c96:	fe b0 f7 c8 	rcall	80012c26 <spi_write>
80013c9a:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013c9c:	fe 7c 28 00 	mov	r12,-55296
80013ca0:	fe b0 f7 d1 	rcall	80012c42 <spi_read>
80013ca4:	58 1c       	cp.w	r12,1
80013ca6:	e0 80 01 b2 	breq	8001400a <sd_mmc_spi_internal_init+0x756>
80013caa:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013cac:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013cae:	3f e9       	mov	r9,-2
80013cb0:	f2 08 18 00 	cp.b	r8,r9
80013cb4:	e0 80 00 92 	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013cb8:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013cbc:	fe 7c 28 00 	mov	r12,-55296
80013cc0:	fe b0 f7 b3 	rcall	80012c26 <spi_write>
80013cc4:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013cc6:	fe 7c 28 00 	mov	r12,-55296
80013cca:	fe b0 f7 bc 	rcall	80012c42 <spi_read>
80013cce:	58 1c       	cp.w	r12,1
80013cd0:	e0 80 01 a9 	breq	80014022 <sd_mmc_spi_internal_init+0x76e>
80013cd4:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013cd6:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013cd8:	3f e9       	mov	r9,-2
80013cda:	f2 08 18 00 	cp.b	r8,r9
80013cde:	c7 d0       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013ce0:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013ce4:	fe 7c 28 00 	mov	r12,-55296
80013ce8:	fe b0 f7 9f 	rcall	80012c26 <spi_write>
80013cec:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013cee:	fe 7c 28 00 	mov	r12,-55296
80013cf2:	fe b0 f7 a8 	rcall	80012c42 <spi_read>
80013cf6:	58 1c       	cp.w	r12,1
80013cf8:	e0 80 01 91 	breq	8001401a <sd_mmc_spi_internal_init+0x766>
80013cfc:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013cfe:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013d00:	3f e9       	mov	r9,-2
80013d02:	f2 08 18 00 	cp.b	r8,r9
80013d06:	c6 90       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013d08:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013d0c:	fe 7c 28 00 	mov	r12,-55296
80013d10:	fe b0 f7 8b 	rcall	80012c26 <spi_write>
80013d14:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013d16:	fe 7c 28 00 	mov	r12,-55296
80013d1a:	fe b0 f7 94 	rcall	80012c42 <spi_read>
80013d1e:	58 1c       	cp.w	r12,1
80013d20:	e0 80 01 85 	breq	8001402a <sd_mmc_spi_internal_init+0x776>
80013d24:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013d26:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013d28:	3f e9       	mov	r9,-2
80013d2a:	f2 08 18 00 	cp.b	r8,r9
80013d2e:	c5 50       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013d30:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013d34:	fe 7c 28 00 	mov	r12,-55296
80013d38:	fe b0 f7 77 	rcall	80012c26 <spi_write>
80013d3c:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013d3e:	fe 7c 28 00 	mov	r12,-55296
80013d42:	fe b0 f7 80 	rcall	80012c42 <spi_read>
80013d46:	58 1c       	cp.w	r12,1
80013d48:	e0 80 01 75 	breq	80014032 <sd_mmc_spi_internal_init+0x77e>
80013d4c:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013d4e:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013d50:	3f e9       	mov	r9,-2
80013d52:	f2 08 18 00 	cp.b	r8,r9
80013d56:	c4 10       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013d58:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013d5c:	fe 7c 28 00 	mov	r12,-55296
80013d60:	fe b0 f7 63 	rcall	80012c26 <spi_write>
80013d64:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013d66:	fe 7c 28 00 	mov	r12,-55296
80013d6a:	fe b0 f7 6c 	rcall	80012c42 <spi_read>
80013d6e:	58 1c       	cp.w	r12,1
80013d70:	e0 80 01 68 	breq	80014040 <sd_mmc_spi_internal_init+0x78c>
80013d74:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013d76:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013d78:	3f e9       	mov	r9,-2
80013d7a:	f2 08 18 00 	cp.b	r8,r9
80013d7e:	c2 d0       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013d80:	e0 6b 00 ff 	mov	r11,255
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80013d84:	fe 7c 28 00 	mov	r12,-55296
80013d88:	fe b0 f7 4f 	rcall	80012c26 <spi_write>
80013d8c:	1a 9b       	mov	r11,sp
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80013d8e:	fe 7c 28 00 	mov	r12,-55296
80013d92:	fe b0 f7 58 	rcall	80012c42 <spi_read>
80013d96:	58 1c       	cp.w	r12,1
80013d98:	e0 80 01 51 	breq	8001403a <sd_mmc_spi_internal_init+0x786>
80013d9c:	1b 98       	ld.ub	r8,sp[0x1]
     return 0xFF;
   return data_read;
80013d9e:	ac 88       	st.b	r6[0x0],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013da0:	3f e9       	mov	r9,-2
80013da2:	f2 08 18 00 	cp.b	r8,r9
80013da6:	c1 90       	breq	80013dd8 <sd_mmc_spi_internal_init+0x524>
80013da8:	30 2b       	mov	r11,2
  {
    if (retry > 8)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013daa:	fe 7c 28 00 	mov	r12,-55296
80013dae:	fe b0 f6 cf 	rcall	80012b4c <spi_unselectChip>
80013db2:	30 0c       	mov	r12,0
80013db4:	cc 0a       	rjmp	80013b34 <sd_mmc_spi_internal_init+0x280>
80013db6:	fe b0 fb db 	rcall	8001356c <sd_mmc_spi_check_hc>
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
    if_cond = sd_mmc_spi_check_hc();
80013dba:	5b fc       	cp.w	r12,-1
    if (if_cond == -1) {
80013dbc:	fe 90 fe bb 	breq	80013b32 <sd_mmc_spi_internal_init+0x27e>
80013dc0:	58 1c       	cp.w	r12,1
      return false;
    } else if (if_cond == 1){
80013dc2:	fe 91 fe 85 	brne	80013acc <sd_mmc_spi_internal_init+0x218>
80013dc6:	30 39       	mov	r9,3
          card_type = SD_CARD_2_SDHC;
80013dc8:	e0 68 2c ee 	mov	r8,11502
80013dcc:	b0 89       	st.b	r8[0x0],r9
80013dce:	fe 9f fe 7f 	bral	80013acc <sd_mmc_spi_internal_init+0x218>
80013dd2:	3f f8       	mov	r8,-1
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013dd4:	ac 88       	st.b	r6[0x0],r8
80013dd6:	c4 7b       	rjmp	80013c64 <sd_mmc_spi_internal_init+0x3b0>
80013dd8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013ddc:	fe 7c 28 00 	mov	r12,-55296
80013de0:	fe b0 f7 23 	rcall	80012c26 <spi_write>
80013de4:	fa c5 ff fe 	sub	r5,sp,-2
   spi_read(SD_MMC_SPI,&data_read);
80013de8:	fe 7c 28 00 	mov	r12,-55296
80013dec:	0a 9b       	mov	r11,r5
80013dee:	fe b0 f7 2a 	rcall	80012c42 <spi_read>
80013df2:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013df4:	e0 66 2c f0 	mov	r6,11504
80013df8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013dfc:	ac 88       	st.b	r6[0x0],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013dfe:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e02:	fe b0 f7 12 	rcall	80012c26 <spi_write>
80013e06:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e08:	fe 7c 28 00 	mov	r12,-55296
80013e0c:	fe b0 f7 1b 	rcall	80012c42 <spi_read>
80013e10:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e12:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e16:	ac 98       	st.b	r6[0x1],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e18:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e1c:	fe b0 f7 05 	rcall	80012c26 <spi_write>
80013e20:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e22:	fe 7c 28 00 	mov	r12,-55296
80013e26:	fe b0 f7 0e 	rcall	80012c42 <spi_read>
80013e2a:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e2c:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e30:	ac a8       	st.b	r6[0x2],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e32:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e36:	fe b0 f6 f8 	rcall	80012c26 <spi_write>
80013e3a:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e3c:	fe 7c 28 00 	mov	r12,-55296
80013e40:	fe b0 f7 01 	rcall	80012c42 <spi_read>
80013e44:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e46:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e4a:	ac b8       	st.b	r6[0x3],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e4c:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e50:	fe b0 f6 eb 	rcall	80012c26 <spi_write>
80013e54:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e56:	fe 7c 28 00 	mov	r12,-55296
80013e5a:	fe b0 f6 f4 	rcall	80012c42 <spi_read>
80013e5e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e60:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e64:	ac c8       	st.b	r6[0x4],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e66:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e6a:	fe b0 f6 de 	rcall	80012c26 <spi_write>
80013e6e:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e70:	fe 7c 28 00 	mov	r12,-55296
80013e74:	fe b0 f6 e7 	rcall	80012c42 <spi_read>
80013e78:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e7a:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e7e:	ac d8       	st.b	r6[0x5],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e80:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e84:	fe b0 f6 d1 	rcall	80012c26 <spi_write>
80013e88:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013e8a:	fe 7c 28 00 	mov	r12,-55296
80013e8e:	fe b0 f6 da 	rcall	80012c42 <spi_read>
80013e92:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013e94:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e98:	ac e8       	st.b	r6[0x6],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013e9a:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013e9e:	fe b0 f6 c4 	rcall	80012c26 <spi_write>
80013ea2:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013ea4:	fe 7c 28 00 	mov	r12,-55296
80013ea8:	fe b0 f6 cd 	rcall	80012c42 <spi_read>
80013eac:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013eae:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013eb2:	ac f8       	st.b	r6[0x7],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013eb4:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013eb8:	fe b0 f6 b7 	rcall	80012c26 <spi_write>
80013ebc:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013ebe:	fe 7c 28 00 	mov	r12,-55296
80013ec2:	fe b0 f6 c0 	rcall	80012c42 <spi_read>
80013ec6:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013ec8:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013ecc:	ed 68 00 08 	st.b	r6[8],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013ed0:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013ed4:	fe b0 f6 a9 	rcall	80012c26 <spi_write>
80013ed8:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013eda:	fe 7c 28 00 	mov	r12,-55296
80013ede:	fe b0 f6 b2 	rcall	80012c42 <spi_read>
80013ee2:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013ee4:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013ee8:	ed 68 00 09 	st.b	r6[9],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013eec:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013ef0:	fe b0 f6 9b 	rcall	80012c26 <spi_write>
80013ef4:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013ef6:	fe 7c 28 00 	mov	r12,-55296
80013efa:	fe b0 f6 a4 	rcall	80012c42 <spi_read>
80013efe:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f00:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f04:	ed 68 00 0a 	st.b	r6[10],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f08:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f0c:	fe b0 f6 8d 	rcall	80012c26 <spi_write>
80013f10:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013f12:	fe 7c 28 00 	mov	r12,-55296
80013f16:	fe b0 f6 96 	rcall	80012c42 <spi_read>
80013f1a:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f1c:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f20:	ed 68 00 0b 	st.b	r6[11],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f24:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f28:	fe b0 f6 7f 	rcall	80012c26 <spi_write>
80013f2c:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013f2e:	fe 7c 28 00 	mov	r12,-55296
80013f32:	fe b0 f6 88 	rcall	80012c42 <spi_read>
80013f36:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f38:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f3c:	ed 68 00 0c 	st.b	r6[12],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f40:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f44:	fe b0 f6 71 	rcall	80012c26 <spi_write>
80013f48:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013f4a:	fe 7c 28 00 	mov	r12,-55296
80013f4e:	fe b0 f6 7a 	rcall	80012c42 <spi_read>
80013f52:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f54:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f58:	ed 68 00 0d 	st.b	r6[13],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f5c:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f60:	fe b0 f6 63 	rcall	80012c26 <spi_write>
80013f64:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013f66:	fe 7c 28 00 	mov	r12,-55296
80013f6a:	fe b0 f6 6c 	rcall	80012c42 <spi_read>
80013f6e:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f70:	e0 6b 00 ff 	mov	r11,255
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f74:	ed 68 00 0e 	st.b	r6[14],r8
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f78:	fe 7c 28 00 	mov	r12,-55296
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80013f7c:	fe b0 f6 55 	rcall	80012c26 <spi_write>
80013f80:	0a 9b       	mov	r11,r5
   spi_read(SD_MMC_SPI,&data_read);
80013f82:	fe 7c 28 00 	mov	r12,-55296
80013f86:	fe b0 f6 5e 	rcall	80012c42 <spi_read>
80013f8a:	9a 18       	ld.sh	r8,sp[0x2]
    buffer[retry] = data_read;
80013f8c:	e0 6b 00 ff 	mov	r11,255
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80013f90:	ed 68 00 0f 	st.b	r6[15],r8
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
80013f94:	fe 7c 28 00 	mov	r12,-55296
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80013f98:	fe b0 f6 47 	rcall	80012c26 <spi_write>
80013f9c:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);
80013fa0:	fe 7c 28 00 	mov	r12,-55296
80013fa4:	fe b0 f6 41 	rcall	80012c26 <spi_write>
80013fa8:	e0 6b 00 ff 	mov	r11,255
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80013fac:	fe 7c 28 00 	mov	r12,-55296
80013fb0:	fe b0 f6 3b 	rcall	80012c26 <spi_write>
80013fb4:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013fb6:	fe 7c 28 00 	mov	r12,-55296
80013fba:	fe b0 f5 c9 	rcall	80012b4c <spi_unselectChip>
80013fbe:	fe b0 f8 4d 	rcall	80013058 <sd_mmc_spi_get_capacity>
  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80013fc2:	e0 69 06 a4 	mov	r9,1700
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80013fc6:	30 18       	mov	r8,1

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80013fc8:	72 0a       	ld.w	r10,r9[0x0]
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80013fca:	e0 69 06 a8 	mov	r9,1704

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80013fce:	b2 88       	st.b	r9[0x0],r8
80013fd0:	e0 68 1b 00 	mov	r8,6912
80013fd4:	ea 18 00 b7 	orh	r8,0xb7
80013fd8:	e0 6b 06 94 	mov	r11,1684
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80013fdc:	8f 18       	st.w	r7[0x4],r8
80013fde:	fe 7c 28 00 	mov	r12,-55296
80013fe2:	fe b0 f5 c9 	rcall	80012b74 <spi_setupChipReg>
  return true;
80013fe6:	30 1c       	mov	r12,1
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80013fe8:	fe 9f fd a6 	bral	80013b34 <sd_mmc_spi_internal_init+0x280>
80013fec:	30 2b       	mov	r11,2
80013fee:	fe 7c 28 00 	mov	r12,-55296
    sd_mmc_spi_init_done = false;
80013ff2:	fe b0 f5 ad 	rcall	80012b4c <spi_unselectChip>
80013ff6:	e0 68 06 a8 	mov	r8,1704
80013ffa:	30 0c       	mov	r12,0
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80013ffc:	b0 85       	st.b	r8[0x0],r5
80013ffe:	fe 9f fd 9b 	bral	80013b34 <sd_mmc_spi_internal_init+0x280>
80014002:	3f f8       	mov	r8,-1
80014004:	a8 88       	st.b	r4[0x0],r8
80014006:	fe 9f fe 1a 	bral	80013c3a <sd_mmc_spi_internal_init+0x386>
8001400a:	3f f8       	mov	r8,-1
8001400c:	ac 88       	st.b	r6[0x0],r8
8001400e:	fe 9f fe 55 	bral	80013cb8 <sd_mmc_spi_internal_init+0x404>
80014012:	3f f8       	mov	r8,-1
80014014:	ac 88       	st.b	r6[0x0],r8
80014016:	fe 9f fe 3c 	bral	80013c8e <sd_mmc_spi_internal_init+0x3da>
8001401a:	3f f8       	mov	r8,-1
8001401c:	ac 88       	st.b	r6[0x0],r8
8001401e:	fe 9f fe 75 	bral	80013d08 <sd_mmc_spi_internal_init+0x454>
80014022:	3f f8       	mov	r8,-1
80014024:	ac 88       	st.b	r6[0x0],r8
80014026:	fe 9f fe 5d 	bral	80013ce0 <sd_mmc_spi_internal_init+0x42c>
8001402a:	3f f8       	mov	r8,-1
8001402c:	ac 88       	st.b	r6[0x0],r8
8001402e:	fe 9f fe 81 	bral	80013d30 <sd_mmc_spi_internal_init+0x47c>
80014032:	3f f8       	mov	r8,-1
80014034:	ac 88       	st.b	r6[0x0],r8
80014036:	fe 9f fe 91 	bral	80013d58 <sd_mmc_spi_internal_init+0x4a4>
8001403a:	3f f8       	mov	r8,-1
8001403c:	ac 88       	st.b	r6[0x0],r8
8001403e:	cb 5a       	rjmp	80013da8 <sd_mmc_spi_internal_init+0x4f4>
80014040:	3f f8       	mov	r8,-1
80014042:	ac 88       	st.b	r6[0x0],r8
80014044:	fe 9f fe 9e 	bral	80013d80 <sd_mmc_spi_internal_init+0x4cc>

80014048 <sd_mmc_spi_init>:
80014048:	eb cd 40 10 	pushm	r4,lr
8001404c:	e0 68 06 94 	mov	r8,1684
80014050:	fa c4 ff f8 	sub	r4,sp,-8
80014054:	e8 ea 00 08 	ld.d	r10,r4[8]
80014058:	f0 eb 00 08 	st.d	r8[8],r10
8001405c:	e0 69 06 a4 	mov	r9,1700
80014060:	93 0c       	st.w	r9[0x0],r12
80014062:	e8 ea 00 00 	ld.d	r10,r4[0]
80014066:	f0 eb 00 00 	st.d	r8[0],r10
8001406a:	fe b0 fc 25 	rcall	800138b4 <sd_mmc_spi_internal_init>
8001406e:	e3 cd 80 10 	ldm	sp++,r4,pc
80014072:	d7 03       	nop

80014074 <sd_mmc_spi_mem_check>:
80014074:	eb cd 40 e0 	pushm	r5-r7,lr
80014078:	e0 65 06 a8 	mov	r5,1704
8001407c:	30 07       	mov	r7,0
8001407e:	0b 88       	ld.ub	r8,r5[0x0]
80014080:	ee 08 18 00 	cp.b	r8,r7
bool sd_mmc_spi_check_presence(void)
{
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80014084:	e0 81 01 2c 	brne	800142dc <sd_mmc_spi_mem_check+0x268>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80014088:	30 2b       	mov	r11,2
8001408a:	fe 7c 28 00 	mov	r12,-55296
8001408e:	fe b0 f5 37 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80014092:	30 0b       	mov	r11,0
80014094:	16 9c       	mov	r12,r11
80014096:	fe b0 f8 c9 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001409a:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8001409c:	e0 67 2d 00 	mov	r7,11520
800140a0:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800140a2:	fe 7c 28 00 	mov	r12,-55296
800140a6:	fe b0 f5 53 	rcall	80012b4c <spi_unselectChip>
  return r1;
800140aa:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
800140ac:	ae 88       	st.b	r7[0x0],r8
800140ae:	30 16       	mov	r6,1
800140b0:	ec 08 18 00 	cp.b	r8,r6
800140b4:	e0 80 01 29 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800140b8:	e0 6b 00 ff 	mov	r11,255
800140bc:	fe 7c 28 00 	mov	r12,-55296
800140c0:	fe b0 f5 b3 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800140c4:	30 2b       	mov	r11,2
800140c6:	fe 7c 28 00 	mov	r12,-55296
800140ca:	fe b0 f5 19 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800140ce:	30 0b       	mov	r11,0
800140d0:	16 9c       	mov	r12,r11
800140d2:	fe b0 f8 ab 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800140d6:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800140d8:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800140da:	fe 7c 28 00 	mov	r12,-55296
800140de:	fe b0 f5 37 	rcall	80012b4c <spi_unselectChip>
  return r1;
800140e2:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
800140e4:	ae 88       	st.b	r7[0x0],r8
800140e6:	ec 08 18 00 	cp.b	r8,r6
800140ea:	e0 80 01 0e 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800140ee:	e0 6b 00 ff 	mov	r11,255
800140f2:	fe 7c 28 00 	mov	r12,-55296
800140f6:	fe b0 f5 98 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800140fa:	30 2b       	mov	r11,2
800140fc:	fe 7c 28 00 	mov	r12,-55296
80014100:	fe b0 f4 fe 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80014104:	30 0b       	mov	r11,0
80014106:	16 9c       	mov	r12,r11
80014108:	fe b0 f8 90 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001410c:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8001410e:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014110:	fe 7c 28 00 	mov	r12,-55296
80014114:	fe b0 f5 1c 	rcall	80012b4c <spi_unselectChip>
  return r1;
80014118:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8001411a:	ae 88       	st.b	r7[0x0],r8
8001411c:	ec 08 18 00 	cp.b	r8,r6
80014120:	e0 80 00 f3 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80014124:	e0 6b 00 ff 	mov	r11,255
80014128:	fe 7c 28 00 	mov	r12,-55296
8001412c:	fe b0 f5 7d 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80014130:	30 2b       	mov	r11,2
80014132:	fe 7c 28 00 	mov	r12,-55296
80014136:	fe b0 f4 e3 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8001413a:	30 0b       	mov	r11,0
8001413c:	16 9c       	mov	r12,r11
8001413e:	fe b0 f8 75 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014142:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80014144:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014146:	fe 7c 28 00 	mov	r12,-55296
8001414a:	fe b0 f5 01 	rcall	80012b4c <spi_unselectChip>
  return r1;
8001414e:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80014150:	ae 88       	st.b	r7[0x0],r8
80014152:	ec 08 18 00 	cp.b	r8,r6
80014156:	e0 80 00 d8 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8001415a:	e0 6b 00 ff 	mov	r11,255
8001415e:	fe 7c 28 00 	mov	r12,-55296
80014162:	fe b0 f5 62 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80014166:	30 2b       	mov	r11,2
80014168:	fe 7c 28 00 	mov	r12,-55296
8001416c:	fe b0 f4 c8 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80014170:	30 0b       	mov	r11,0
80014172:	16 9c       	mov	r12,r11
80014174:	fe b0 f8 5a 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014178:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8001417a:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001417c:	fe 7c 28 00 	mov	r12,-55296
80014180:	fe b0 f4 e6 	rcall	80012b4c <spi_unselectChip>
  return r1;
80014184:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80014186:	ae 88       	st.b	r7[0x0],r8
80014188:	ec 08 18 00 	cp.b	r8,r6
8001418c:	e0 80 00 bd 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80014190:	e0 6b 00 ff 	mov	r11,255
80014194:	fe 7c 28 00 	mov	r12,-55296
80014198:	fe b0 f5 47 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8001419c:	30 2b       	mov	r11,2
8001419e:	fe 7c 28 00 	mov	r12,-55296
800141a2:	fe b0 f4 ad 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800141a6:	30 0b       	mov	r11,0
800141a8:	16 9c       	mov	r12,r11
800141aa:	fe b0 f8 3f 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800141ae:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800141b0:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800141b2:	fe 7c 28 00 	mov	r12,-55296
800141b6:	fe b0 f4 cb 	rcall	80012b4c <spi_unselectChip>
  return r1;
800141ba:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
800141bc:	ae 88       	st.b	r7[0x0],r8
800141be:	ec 08 18 00 	cp.b	r8,r6
800141c2:	e0 80 00 a2 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800141c6:	e0 6b 00 ff 	mov	r11,255
800141ca:	fe 7c 28 00 	mov	r12,-55296
800141ce:	fe b0 f5 2c 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800141d2:	30 2b       	mov	r11,2
800141d4:	fe 7c 28 00 	mov	r12,-55296
800141d8:	fe b0 f4 92 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800141dc:	30 0b       	mov	r11,0
800141de:	16 9c       	mov	r12,r11
800141e0:	fe b0 f8 24 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800141e4:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800141e6:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800141e8:	fe 7c 28 00 	mov	r12,-55296
800141ec:	fe b0 f4 b0 	rcall	80012b4c <spi_unselectChip>
  return r1;
800141f0:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
800141f2:	ae 88       	st.b	r7[0x0],r8
800141f4:	ec 08 18 00 	cp.b	r8,r6
800141f8:	e0 80 00 87 	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800141fc:	e0 6b 00 ff 	mov	r11,255
80014200:	fe 7c 28 00 	mov	r12,-55296
80014204:	fe b0 f5 11 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80014208:	30 2b       	mov	r11,2
8001420a:	fe 7c 28 00 	mov	r12,-55296
8001420e:	fe b0 f4 77 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80014212:	30 0b       	mov	r11,0
80014214:	16 9c       	mov	r12,r11
80014216:	fe b0 f8 09 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001421a:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
8001421c:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001421e:	fe 7c 28 00 	mov	r12,-55296
80014222:	fe b0 f4 95 	rcall	80012b4c <spi_unselectChip>
  return r1;
80014226:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80014228:	ae 88       	st.b	r7[0x0],r8
8001422a:	ec 08 18 00 	cp.b	r8,r6
8001422e:	c6 c0       	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80014230:	e0 6b 00 ff 	mov	r11,255
80014234:	fe 7c 28 00 	mov	r12,-55296
80014238:	fe b0 f4 f7 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8001423c:	30 2b       	mov	r11,2
8001423e:	fe 7c 28 00 	mov	r12,-55296
80014242:	fe b0 f4 5d 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80014246:	30 0b       	mov	r11,0
80014248:	16 9c       	mov	r12,r11
8001424a:	fe b0 f7 ef 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8001424e:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80014250:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014252:	fe 7c 28 00 	mov	r12,-55296
80014256:	fe b0 f4 7b 	rcall	80012b4c <spi_unselectChip>
  return r1;
8001425a:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8001425c:	ae 88       	st.b	r7[0x0],r8
8001425e:	ec 08 18 00 	cp.b	r8,r6
80014262:	c5 20       	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80014264:	e0 6b 00 ff 	mov	r11,255
80014268:	fe 7c 28 00 	mov	r12,-55296
8001426c:	fe b0 f4 dd 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80014270:	30 2b       	mov	r11,2
80014272:	fe 7c 28 00 	mov	r12,-55296
80014276:	fe b0 f4 43 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
8001427a:	30 0b       	mov	r11,0
8001427c:	16 9c       	mov	r12,r11
8001427e:	fe b0 f7 d5 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014282:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80014284:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80014286:	fe 7c 28 00 	mov	r12,-55296
8001428a:	fe b0 f4 61 	rcall	80012b4c <spi_unselectChip>
  return r1;
8001428e:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80014290:	ae 88       	st.b	r7[0x0],r8
80014292:	ec 08 18 00 	cp.b	r8,r6
80014296:	c3 80       	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80014298:	e0 6b 00 ff 	mov	r11,255
8001429c:	fe 7c 28 00 	mov	r12,-55296
800142a0:	fe b0 f4 c3 	rcall	80012c26 <spi_write>
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800142a4:	30 2b       	mov	r11,2
800142a6:	fe 7c 28 00 	mov	r12,-55296
800142aa:	fe b0 f4 29 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800142ae:	30 0b       	mov	r11,0
800142b0:	16 9c       	mov	r12,r11
800142b2:	fe b0 f7 bb 	rcall	80013228 <sd_mmc_spi_command>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800142b6:	30 2b       	mov	r11,2
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
800142b8:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800142ba:	fe 7c 28 00 	mov	r12,-55296
800142be:	fe b0 f4 47 	rcall	80012b4c <spi_unselectChip>
  return r1;
800142c2:	0f 88       	ld.ub	r8,r7[0x0]
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
800142c4:	ae 88       	st.b	r7[0x0],r8
800142c6:	ec 08 18 00 	cp.b	r8,r6
800142ca:	c1 e0       	breq	80014306 <sd_mmc_spi_mem_check+0x292>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800142cc:	e0 6b 00 ff 	mov	r11,255
800142d0:	fe 7c 28 00 	mov	r12,-55296
800142d4:	fe b0 f4 a9 	rcall	80012c26 <spi_write>
800142d8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800142dc:	30 2b       	mov	r11,2
800142de:	fe 7c 28 00 	mov	r12,-55296
800142e2:	fe b0 f4 0d 	rcall	80012afc <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
800142e6:	30 0b       	mov	r11,0
800142e8:	33 bc       	mov	r12,59
800142ea:	fe b0 f7 9f 	rcall	80013228 <sd_mmc_spi_command>
800142ee:	e0 66 2d 00 	mov	r6,11520
800142f2:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800142f4:	ac 8c       	st.b	r6[0x0],r12
800142f6:	fe 7c 28 00 	mov	r12,-55296
800142fa:	fe b0 f4 29 	rcall	80012b4c <spi_unselectChip>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
800142fe:	0d 88       	ld.ub	r8,r6[0x0]
80014300:	ac 88       	st.b	r6[0x0],r8
80014302:	58 08       	cp.w	r8,0
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
  if (sd_mmc_spi_check_presence())
  {
    if (sd_mmc_spi_init_done == false)
80014304:	c0 c1       	brne	8001431c <sd_mmc_spi_mem_check+0x2a8>
80014306:	0b 89       	ld.ub	r9,r5[0x0]
80014308:	30 08       	mov	r8,0
8001430a:	f0 09 18 00 	cp.b	r9,r8
8001430e:	c0 30       	breq	80014314 <sd_mmc_spi_mem_check+0x2a0>
80014310:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80014314:	fe b0 fa d0 	rcall	800138b4 <sd_mmc_spi_internal_init>
    }
    else
      return true;
  }
  return false;
}
80014318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
8001431c:	aa 87       	st.b	r5[0x0],r7
8001431e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80014322:	d7 03       	nop

80014324 <uhd_get_speed>:
	cpu_irq_restore(flags);
}

uhd_speed_t uhd_get_speed(void)
{
	switch (uhd_get_speed_mode()) {
80014324:	fe 68 08 04 	mov	r8,-129020
80014328:	70 08       	ld.w	r8,r8[0x0]
8001432a:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
8001432e:	58 38       	cp.w	r8,3
80014330:	c0 50       	breq	8001433a <uhd_get_speed+0x16>
80014332:	48 39       	lddpc	r9,8001433c <uhd_get_speed+0x18>
80014334:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]

	default:
		Assert(false);
		return UHD_SPEED_LOW;
	}
}
80014338:	5e fc       	retal	r12
	cpu_irq_restore(flags);
}

uhd_speed_t uhd_get_speed(void)
{
	switch (uhd_get_speed_mode()) {
8001433a:	5e fd       	retal	0
8001433c:	80 02       	ld.sh	r2,r0[0x0]
8001433e:	40 08       	lddsp	r8,sp[0x0]

80014340 <uhd_send_reset>:
	return uhd_get_microsof_number();
}

void uhd_send_reset(uhd_callback_reset_t callback)
{
	uhd_reset_callback = callback;
80014340:	e0 69 06 ac 	mov	r9,1708
	uhd_start_reset();
80014344:	93 0c       	st.w	r9[0x0],r12
80014346:	fe 68 04 00 	mov	r8,-130048
8001434a:	70 09       	ld.w	r9,r8[0x0]
8001434c:	a9 b9       	sbr	r9,0x9
}
8001434e:	91 09       	st.w	r8[0x0],r9
80014350:	5e fc       	retal	r12
80014352:	d7 03       	nop

80014354 <uhd_suspend>:

void uhd_suspend(void)
{
80014354:	eb cd 40 80 	pushm	r7,lr
	if (uhd_ctrl_request_timeout) {
80014358:	e0 68 2d 14 	mov	r8,11540
8001435c:	90 08       	ld.sh	r8,r8[0x0]
8001435e:	58 08       	cp.w	r8,0
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014360:	c4 d1       	brne	800143fa <uhd_suspend+0xa6>
80014362:	fe 69 05 c4 	mov	r9,-129596
		uhd_freeze_pipe(pipe);
80014366:	72 0e       	ld.w	lr,r9[0x0]
80014368:	fe 69 05 f4 	mov	r9,-129548
8001436c:	e2 68 00 00 	mov	r8,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014370:	93 08       	st.w	r9[0x0],r8
80014372:	fe 69 05 c8 	mov	r9,-129592
		uhd_freeze_pipe(pipe);
80014376:	72 0c       	ld.w	r12,r9[0x0]
80014378:	fe 69 05 f8 	mov	r9,-129544
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8001437c:	93 08       	st.w	r9[0x0],r8
8001437e:	fe 69 05 cc 	mov	r9,-129588
		uhd_freeze_pipe(pipe);
80014382:	72 0b       	ld.w	r11,r9[0x0]
80014384:	fe 69 05 fc 	mov	r9,-129540
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014388:	93 08       	st.w	r9[0x0],r8
8001438a:	fe 69 05 d0 	mov	r9,-129584
		uhd_freeze_pipe(pipe);
8001438e:	72 0a       	ld.w	r10,r9[0x0]
80014390:	fe 69 06 00 	mov	r9,-129536
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014394:	93 08       	st.w	r9[0x0],r8
80014396:	10 5e       	eor	lr,r8
80014398:	10 5c       	eor	r12,r8
8001439a:	10 5b       	eor	r11,r8
8001439c:	10 5a       	eor	r10,r8
8001439e:	fe 69 05 d4 	mov	r9,-129580
		uhd_freeze_pipe(pipe);
800143a2:	fe 67 06 04 	mov	r7,-129532
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
800143a6:	72 09       	ld.w	r9,r9[0x0]
800143a8:	fd de c2 21 	bfextu	lr,lr,0x11,0x1
800143ac:	8f 08       	st.w	r7[0x0],r8
800143ae:	10 59       	eor	r9,r8
800143b0:	f9 dc c2 21 	bfextu	r12,r12,0x11,0x1
800143b4:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
800143b8:	a3 6c       	lsl	r12,0x2
800143ba:	f7 db c2 21 	bfextu	r11,r11,0x11,0x1
800143be:	f9 ee 10 1e 	or	lr,r12,lr<<0x1
800143c2:	f5 da c2 21 	bfextu	r10,r10,0x11,0x1
800143c6:	fd eb 10 3b 	or	r11,lr,r11<<0x3
800143ca:	f7 ea 10 4a 	or	r10,r11,r10<<0x4
800143ce:	f5 e9 10 5a 	or	r10,r10,r9<<0x5
800143d2:	fe 69 05 d8 	mov	r9,-129576
800143d6:	72 09       	ld.w	r9,r9[0x0]
800143d8:	10 59       	eor	r9,r8
800143da:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
800143de:	f5 e9 10 69 	or	r9,r10,r9<<0x6
		uhd_freeze_pipe(pipe);
800143e2:	fe 6a 06 08 	mov	r10,-129528
800143e6:	95 08       	st.w	r10[0x0],r8
800143e8:	e0 68 07 29 	mov	r8,1833
	}
	// Wait three SOFs before entering in suspend state
	uhd_suspend_start = 3;
800143ec:	b0 89       	st.b	r8[0x0],r9
800143ee:	30 39       	mov	r9,3
800143f0:	e0 68 07 28 	mov	r8,1832

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
800143f4:	b0 89       	st.b	r8[0x0],r9
800143f6:	e3 cd 80 80 	ldm	sp++,r7,pc
		return;
800143fa:	30 19       	mov	r9,1
800143fc:	e0 68 07 2b 	mov	r8,1835
80014400:	b0 89       	st.b	r8[0x0],r9
80014402:	e3 cd 80 80 	ldm	sp++,r7,pc
80014406:	d7 03       	nop

80014408 <uhd_ep_alloc>:
80014408:	d4 21       	pushm	r4-r7,lr
8001440a:	fe 69 00 00 	mov	r9,-131072
8001440e:	f2 f8 04 1c 	ld.w	r8,r9[1052]
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80014412:	ed b8 00 01 	bld	r8,0x1
80014416:	c2 90       	breq	80014468 <uhd_ep_alloc+0x60>
80014418:	30 2a       	mov	r10,2
8001441a:	30 19       	mov	r9,1
			continue;
		}
		uhd_enable_pipe(pipe);
8001441c:	fe 68 00 00 	mov	r8,-131072
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80014420:	e0 67 02 00 	mov	r7,512

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
80014424:	f0 fe 04 1c 	ld.w	lr,r8[1052]
80014428:	f5 ee 10 0e 	or	lr,r10,lr
8001442c:	f1 4e 04 1c 	st.w	r8[1052],lr
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80014430:	e0 68 01 00 	mov	r8,256
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
80014434:	17 ae       	ld.ub	lr,r11[0x2]
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80014436:	30 06       	mov	r6,0
80014438:	fc 06 18 00 	cp.b	r6,lr
8001443c:	f0 06 17 90 	movgt	r6,r8
80014440:	ee 06 17 a0 	movle	r6,r7
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80014444:	17 b8       	ld.ub	r8,r11[0x3]
		// Bank choice
		switch(ep_type) {
80014446:	30 27       	mov	r7,2
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80014448:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
		// Bank choice
		switch(ep_type) {
8001444c:	ee 08 18 00 	cp.b	r8,r7
80014450:	e0 80 00 9b 	breq	80014586 <uhd_ep_alloc+0x17e>
80014454:	30 37       	mov	r7,3
80014456:	ee 08 18 00 	cp.b	r8,r7
8001445a:	c1 d0       	breq	80014494 <uhd_ep_alloc+0x8c>
8001445c:	30 17       	mov	r7,1
8001445e:	ee 08 18 00 	cp.b	r8,r7
80014462:	e0 80 00 8e 	breq	8001457e <uhd_ep_alloc+0x176>
		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
		uhd_enable_stall_interrupt(pipe);
		uhd_enable_pipe_error_interrupt(pipe);
		uhd_enable_pipe_interrupt(pipe);
		return true;
80014466:	d8 2a       	popm	r4-r7,pc,r12=0
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80014468:	f2 f8 04 1c 	ld.w	r8,r9[1052]
8001446c:	ed b8 00 02 	bld	r8,0x2
80014470:	c0 f1       	brne	8001448e <uhd_ep_alloc+0x86>
80014472:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80014476:	ed b8 00 03 	bld	r8,0x3
8001447a:	c4 c1       	brne	80014512 <uhd_ep_alloc+0x10a>
8001447c:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80014480:	ed b8 00 04 	bld	r8,0x4
80014484:	e0 80 00 84 	breq	8001458c <uhd_ep_alloc+0x184>
80014488:	31 0a       	mov	r10,16
8001448a:	30 49       	mov	r9,4
8001448c:	cc 8b       	rjmp	8001441c <uhd_ep_alloc+0x14>
8001448e:	30 4a       	mov	r10,4
80014490:	30 29       	mov	r9,2
80014492:	cc 5b       	rjmp	8001441c <uhd_ep_alloc+0x14>
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80014494:	17 e5       	ld.ub	r5,r11[0x6]
80014496:	30 07       	mov	r7,0
80014498:	b9 65       	lsl	r5,0x18
		default:
			Assert(false);
			return false;
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
8001449a:	fd de c0 04 	bfextu	lr,lr,0x0,0x4
8001449e:	ad 68       	lsl	r8,0xc
800144a0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800144a4:	ab a8       	sbr	r8,0xa
800144a6:	0c 48       	or	r8,r6
800144a8:	f1 e5 10 05 	or	r5,r8,r5
800144ac:	eb e7 10 06 	or	r6,r5,r7
800144b0:	fe 65 05 00 	mov	r5,-129792
800144b4:	17 d4       	ld.ub	r4,r11[0x5]
800144b6:	f2 0e 15 02 	lsl	lr,r9,0x2
800144ba:	17 cb       	ld.ub	r11,r11[0x4]
800144bc:	fc 05 00 08 	add	r8,lr,r5
800144c0:	e9 eb 10 8b 	or	r11,r4,r11<<0x8
800144c4:	30 87       	mov	r7,8
800144c6:	e0 65 04 00 	mov	r5,1024
800144ca:	5c cb       	swap.bh	r11
800144cc:	5c 7b       	castu.h	r11
800144ce:	f6 07 0c 4b 	max	r11,r11,r7
800144d2:	f6 05 0d 45 	min	r5,r11,r5
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
800144d6:	fe 6b 05 30 	mov	r11,-129744
		default:
			Assert(false);
			return false;
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
800144da:	a1 75       	lsl	r5,0x1
800144dc:	20 15       	sub	r5,1
800144de:	ea 05 12 00 	clz	r5,r5
800144e2:	ea 05 11 1c 	rsub	r5,r5,28
800144e6:	ed e5 10 45 	or	r5,r6,r5<<0x4
800144ea:	91 05       	st.w	r8[0x0],r5
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
800144ec:	fc 0b 00 06 	add	r6,lr,r11
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
800144f0:	70 0b       	ld.w	r11,r8[0x0]
800144f2:	a1 bb       	sbr	r11,0x1
800144f4:	91 0b       	st.w	r8[0x0],r11
		if (!Is_uhd_pipe_configured(pipe)) {
800144f6:	6c 08       	ld.w	r8,r6[0x0]
800144f8:	e6 18 00 04 	andh	r8,0x4,COH
800144fc:	c0 e1       	brne	80014518 <uhd_ep_alloc+0x110>
			uhd_disable_pipe(pipe);
800144fe:	5c da       	com	r10
80014500:	10 9c       	mov	r12,r8
80014502:	fe 68 00 00 	mov	r8,-131072
80014506:	f0 f9 04 1c 	ld.w	r9,r8[1052]
8001450a:	12 6a       	and	r10,r9
8001450c:	f1 4a 04 1c 	st.w	r8[1052],r10
			return false;
80014510:	d8 22       	popm	r4-r7,pc
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80014512:	30 8a       	mov	r10,8
80014514:	30 39       	mov	r9,3
80014516:	c8 3b       	rjmp	8001441c <uhd_ep_alloc+0x14>
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
			uhd_disable_pipe(pipe);
			return false;
		}
		uhd_configure_address(pipe, add);
80014518:	37 f5       	mov	r5,127
8001451a:	12 98       	mov	r8,r9
8001451c:	f7 d9 c0 02 	bfextu	r11,r9,0x0,0x2
80014520:	e2 18 00 04 	andl	r8,0x4,COH
80014524:	a3 7b       	lsl	r11,0x3
80014526:	e0 38 fb dc 	sub	r8,130012
8001452a:	ea 0b 09 4b 	lsl	r11,r5,r11
8001452e:	70 06       	ld.w	r6,r8[0x0]
80014530:	16 95       	mov	r5,r11
80014532:	5c 95       	brev	r5
80014534:	ea 05 12 00 	clz	r5,r5
80014538:	16 86       	andn	r6,r11
8001453a:	f8 05 09 4c 	lsl	r12,r12,r5
8001453e:	f9 eb 00 0b 	and	r11,r12,r11
80014542:	0c 4b       	or	r11,r6
80014544:	91 0b       	st.w	r8[0x0],r11
		uhd_enable_pipe(pipe);
80014546:	fe 68 00 00 	mov	r8,-131072
8001454a:	f0 fb 04 1c 	ld.w	r11,r8[1052]
8001454e:	16 4a       	or	r10,r11
80014550:	f1 4a 04 1c 	st.w	r8[1052],r10

		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
80014554:	fc 1b 02 00 	movh	r11,0x200
80014558:	f2 ca 00 01 	sub	r10,r9,1
8001455c:	f6 0a 09 4a 	lsl	r10,r11,r10
80014560:	f1 4a 04 18 	st.w	r8[1048],r10
		uhd_enable_stall_interrupt(pipe);
80014564:	e0 3e fa 10 	sub	lr,129552
80014568:	34 0a       	mov	r10,64
8001456a:	9d 0a       	st.w	lr[0x0],r10
		uhd_enable_pipe_error_interrupt(pipe);
8001456c:	9d 07       	st.w	lr[0x0],r7
		uhd_enable_pipe_interrupt(pipe);
8001456e:	e0 6a 01 00 	mov	r10,256
80014572:	30 1c       	mov	r12,1
80014574:	f4 09 09 49 	lsl	r9,r10,r9
80014578:	f1 49 04 18 	st.w	r8[1048],r9
		return true;
8001457c:	d8 22       	popm	r4-r7,pc
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
8001457e:	17 e5       	ld.ub	r5,r11[0x6]
80014580:	30 47       	mov	r7,4
80014582:	b9 65       	lsl	r5,0x18
		case 1:
			bank = AVR32_USBB_UECFG0_EPBK_SINGLE;
			break;
		case 2:
			bank = AVR32_USBB_UECFG0_EPBK_DOUBLE;
			break;
80014584:	c8 bb       	rjmp	8001449a <uhd_ep_alloc+0x92>
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80014586:	30 05       	mov	r5,0
80014588:	30 47       	mov	r7,4
8001458a:	c8 8b       	rjmp	8001449a <uhd_ep_alloc+0x92>
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
8001458c:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80014590:	ed b8 00 05 	bld	r8,0x5
80014594:	c0 a1       	brne	800145a8 <uhd_ep_alloc+0x1a0>
80014596:	f2 f8 04 1c 	ld.w	r8,r9[1052]
8001459a:	ed b8 00 06 	bld	r8,0x6
8001459e:	fe 90 ff 64 	breq	80014466 <uhd_ep_alloc+0x5e>
800145a2:	34 0a       	mov	r10,64
800145a4:	30 69       	mov	r9,6
800145a6:	c3 bb       	rjmp	8001441c <uhd_ep_alloc+0x14>
800145a8:	32 0a       	mov	r10,32
800145aa:	30 59       	mov	r9,5
800145ac:	c3 8b       	rjmp	8001441c <uhd_ep_alloc+0x14>

800145ae <uhd_ep0_alloc>:
	uhd_send_resume();
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
800145ae:	d4 01       	pushm	lr
	if (ep_size < 8) {
800145b0:	30 78       	mov	r8,7
800145b2:	f0 0b 18 00 	cp.b	r11,r8
800145b6:	e0 88 00 3f 	brls	80014634 <uhd_ep0_alloc+0x86>
#error TODO Add USB address in a list
		return true;
	}
#endif

	uhd_enable_pipe(0);
800145ba:	fe 69 00 00 	mov	r9,-131072
800145be:	f2 f8 04 1c 	ld.w	r8,r9[1052]
800145c2:	a1 a8       	sbr	r8,0x0
800145c4:	f3 48 04 1c 	st.w	r9[1052],r8
	uhd_configure_pipe(0, // Pipe 0
800145c8:	30 8e       	mov	lr,8
800145ca:	fe 68 05 00 	mov	r8,-129792
800145ce:	f6 0e 0c 4b 	max	r11,r11,lr
800145d2:	e0 6a 04 00 	mov	r10,1024
800145d6:	f6 0a 0d 4a 	min	r10,r11,r10
800145da:	a1 7a       	lsl	r10,0x1
800145dc:	20 1a       	sub	r10,1
800145de:	f4 0a 12 00 	clz	r10,r10
800145e2:	f4 0a 11 1c 	rsub	r10,r10,28
800145e6:	a5 6a       	lsl	r10,0x4
800145e8:	91 0a       	st.w	r8[0x0],r10
#else
			ep_size,
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
800145ea:	70 0a       	ld.w	r10,r8[0x0]
800145ec:	a1 ba       	sbr	r10,0x1
800145ee:	91 0a       	st.w	r8[0x0],r10
	if (!Is_uhd_pipe_configured(0)) {
800145f0:	fe 68 05 30 	mov	r8,-129744
800145f4:	70 08       	ld.w	r8,r8[0x0]
800145f6:	e6 18 00 04 	andh	r8,0x4,COH
800145fa:	c1 60       	breq	80014626 <uhd_ep0_alloc+0x78>
		uhd_disable_pipe(0);
		return false;
	}
	uhd_configure_address(0, add);
800145fc:	fe 6a 04 24 	mov	r10,-130012
80014600:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80014604:	74 08       	ld.w	r8,r10[0x0]
80014606:	e0 18 ff 80 	andl	r8,0xff80
8001460a:	f9 e8 10 08 	or	r8,r12,r8
8001460e:	95 08       	st.w	r10[0x0],r8

	// Always enable stall and error interrupts of control endpoint
	uhd_enable_stall_interrupt(0);
80014610:	fe 68 05 f0 	mov	r8,-129552
80014614:	34 0a       	mov	r10,64
80014616:	91 0a       	st.w	r8[0x0],r10
	uhd_enable_pipe_error_interrupt(0);
80014618:	91 0e       	st.w	r8[0x0],lr
	uhd_enable_pipe_interrupt(0);
8001461a:	30 1c       	mov	r12,1
8001461c:	e0 68 01 00 	mov	r8,256
80014620:	f3 48 04 18 	st.w	r9[1048],r8
	return true;
}
80014624:	d8 02       	popm	pc
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
	if (!Is_uhd_pipe_configured(0)) {
		uhd_disable_pipe(0);
80014626:	10 9c       	mov	r12,r8
80014628:	f2 f8 04 1c 	ld.w	r8,r9[1052]
8001462c:	a1 c8       	cbr	r8,0x0
8001462e:	f3 48 04 1c 	st.w	r9[1052],r8
		return false;
80014632:	d8 02       	popm	pc
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
	if (ep_size < 8) {
80014634:	d8 0a       	popm	pc,r12=0
80014636:	d7 03       	nop

80014638 <otg_dual_enable>:
	}
	otg_data_memory_barrier();
}

bool otg_dual_enable(void)
{
80014638:	eb cd 40 80 	pushm	r7,lr
	if (otg_initialized) {
8001463c:	e0 68 06 a9 	mov	r8,1705
80014640:	30 09       	mov	r9,0
80014642:	11 8a       	ld.ub	r10,r8[0x0]
80014644:	f2 0a 18 00 	cp.b	r10,r9
80014648:	c0 30       	breq	8001464e <otg_dual_enable+0x16>
8001464a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false; // Dual role already initialized
	}
	otg_initialized = true;
8001464e:	30 19       	mov	r9,1

	//* Enable USB hardware clock
	sysclk_enable_usb();
80014650:	b0 89       	st.b	r8[0x0],r9
80014652:	e0 a0 0b af 	rcall	80015db0 <sysclk_enable_usb>

	//* Link USB interrupt on OTG interrupt in dual role
	irq_register_handler(otg_interrupt, AVR32_USBB_IRQ, UHD_USB_INT_LEVEL);
80014656:	30 0a       	mov	r10,0
80014658:	e0 6b 02 20 	mov	r11,544
8001465c:	fe cc f5 34 	sub	r12,pc,-2764
	//pm_asyn_wake_up_enable(AVR32_PM_AWEN_USB_WAKEN_MASK);

# ifdef USB_ID
	// By default USBB is already configured with ID pin enable
	// The USBB must be enabled to provide interrupt
	otg_input_id_pin();
80014660:	fe b0 f0 ec 	rcall	80012838 <INTC_register_interrupt>
80014664:	fe 78 10 00 	mov	r8,-61440
80014668:	fc 19 00 20 	movh	r9,0x20
8001466c:	91 69       	st.w	r8[0x18],r9
8001466e:	91 99       	st.w	r8[0x24],r9
80014670:	91 29       	st.w	r8[0x8],r9
	otg_unfreeze_clock();
80014672:	f1 49 00 74 	st.w	r8[116],r9
80014676:	fe 68 08 00 	mov	r8,-129024
8001467a:	70 09       	ld.w	r9,r8[0x0]
	otg_enable();
8001467c:	af c9       	cbr	r9,0xe
8001467e:	91 09       	st.w	r8[0x0],r9
80014680:	70 09       	ld.w	r9,r8[0x0]
	otg_enable_id_interrupt();
80014682:	af b9       	sbr	r9,0xf
80014684:	91 09       	st.w	r8[0x0],r9
80014686:	70 09       	ld.w	r9,r8[0x0]
	otg_ack_id_transition();
80014688:	a1 a9       	sbr	r9,0x0
8001468a:	91 09       	st.w	r8[0x0],r9
8001468c:	30 17       	mov	r7,1
8001468e:	fe 69 08 08 	mov	r9,-129016
	otg_freeze_clock();
80014692:	93 07       	st.w	r9[0x0],r7
80014694:	70 09       	ld.w	r9,r8[0x0]
	if (Is_otg_id_device()) {
80014696:	af a9       	sbr	r9,0xe
80014698:	91 09       	st.w	r8[0x0],r9
8001469a:	fe 68 08 04 	mov	r8,-129020
8001469e:	70 08       	ld.w	r8,r8[0x0]
800146a0:	ed b8 00 0a 	bld	r8,0xa
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
		udc_start();
	} else {
		UHC_MODE_CHANGE(true);
800146a4:	c0 90       	breq	800146b6 <otg_dual_enable+0x7e>
800146a6:	0e 9c       	mov	r12,r7
		uhc_start();
800146a8:	e0 a0 2f 16 	rcall	8001a4d4 <usb_mode_change>
800146ac:	e0 a0 0c 60 	rcall	80015f6c <uhc_start>
	return true;  // ID pin management has been enabled
# else
	uhd_sleep_mode(UHD_STATE_OFF);
	return false; // ID pin management has not been enabled
# endif
}
800146b0:	0e 9c       	mov	r12,r7
	otg_enable_id_interrupt();
	otg_ack_id_transition();
	otg_freeze_clock();
	if (Is_otg_id_device()) {
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
800146b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800146b6:	30 0c       	mov	r12,0
800146b8:	e0 a0 2f 0e 	rcall	8001a4d4 <usb_mode_change>
800146bc:	0e 9c       	mov	r12,r7
800146be:	e3 cd 80 80 	ldm	sp++,r7,pc
800146c2:	d7 03       	nop

800146c4 <uhd_enable>:
800146c4:	eb cd 40 80 	pushm	r7,lr
800146c8:	e1 b7 00 00 	mfsr	r7,0x0
800146cc:	d3 03       	ssrf	0x10
800146ce:	cb 5f       	rcall	80014638 <otg_dual_enable>
800146d0:	c0 71       	brne	800146de <uhd_enable+0x1a>
800146d2:	fe 6b 08 04 	mov	r11,-129020
800146d6:	76 08       	ld.w	r8,r11[0x0]
		return;
	}

#ifdef USB_ID
	// Check that the host mode is selected by ID pin
	if (!Is_otg_id_host()) {
800146d8:	e2 18 04 00 	andl	r8,0x400,COH
800146dc:	c0 70       	breq	800146ea <uhd_enable+0x26>
800146de:	e6 17 00 01 	andh	r7,0x1,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800146e2:	c0 21       	brne	800146e6 <uhd_enable+0x22>
800146e4:	d5 03       	csrf	0x10
      cpu_irq_enable();
800146e6:	e3 cd 80 80 	ldm	sp++,r7,pc
   }

	barrier();
800146ea:	fe 79 10 00 	mov	r9,-61440
	otg_force_host_mode();
#endif

	// Enable USB hardware
#ifdef USB_VBOF
	uhd_output_vbof_pin();
800146ee:	fc 1a 00 40 	movh	r10,0x40
800146f2:	93 6a       	st.w	r9[0x18],r10
800146f4:	93 9a       	st.w	r9[0x24],r10
800146f6:	93 2a       	st.w	r9[0x8],r10
800146f8:	f3 4a 00 88 	st.w	r9[136],r10
800146fc:	f3 4a 00 78 	st.w	r9[120],r10
80014700:	fe 69 08 00 	mov	r9,-129024
# if USB_VBOF_ACTIVE_LEVEL == HIGH
	uhd_set_vbof_active_high();
# else // USB_VBOF_ACTIVE_LEVEL == LOW
	uhd_set_vbof_active_low();
80014704:	72 0a       	ld.w	r10,r9[0x0]
80014706:	ad ba       	sbr	r10,0xd
80014708:	93 0a       	st.w	r9[0x0],r10
8001470a:	72 0a       	ld.w	r10,r9[0x0]
# endif
#endif
	otg_enable_pad();
8001470c:	ad aa       	sbr	r10,0xc
8001470e:	93 0a       	st.w	r9[0x0],r10
80014710:	72 0a       	ld.w	r10,r9[0x0]
	otg_enable();
80014712:	af ba       	sbr	r10,0xf
80014714:	93 0a       	st.w	r9[0x0],r10
80014716:	e0 6a 2d 14 	mov	r10,11540

	uhd_ctrl_request_first = NULL;
	uhd_ctrl_request_last = NULL;
	uhd_ctrl_request_timeout = 0;
8001471a:	b4 08       	st.h	r10[0x0],r8
	uhd_suspend_start = 0;
	uhd_resume_start = 0;
	uhd_b_suspend_requested = false;

	otg_unfreeze_clock();
8001471c:	72 0a       	ld.w	r10,r9[0x0]
8001471e:	af ca       	cbr	r10,0xe
80014720:	93 0a       	st.w	r9[0x0],r10
	uhd_disable_high_speed_mode();
#  endif
#endif

	// Clear all interrupts that may have been set by a previous host mode
	AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_DCONNIC_MASK
80014722:	37 fa       	mov	r10,127
80014724:	fe 69 00 00 	mov	r9,-131072
80014728:	f3 4a 04 08 	st.w	r9[1032],r10
			| AVR32_USBB_UHINTCLR_DDISCIC_MASK | AVR32_USBB_UHINTCLR_HSOFIC_MASK
			| AVR32_USBB_UHINTCLR_HWUPIC_MASK | AVR32_USBB_UHINTCLR_RSMEDIC_MASK
			| AVR32_USBB_UHINTCLR_RSTIC_MASK | AVR32_USBB_UHINTCLR_RXRSMIC_MASK;
	otg_ack_vbus_transition();
8001472c:	fe 6a 08 08 	mov	r10,-129016
80014730:	30 2c       	mov	r12,2
80014732:	95 0c       	st.w	r10[0x0],r12

	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
80014734:	f2 fa 08 00 	ld.w	r10,r9[2048]
80014738:	e8 1a 01 0a 	orl	r10,0x10a
8001473c:	f3 4a 08 00 	st.w	r9[2048],r10
# endif
#endif
	otg_enable_pad();
	otg_enable();

	uhd_ctrl_request_first = NULL;
80014740:	e0 6a 2d 08 	mov	r10,11528
80014744:	10 99       	mov	r9,r8
	uhd_ctrl_request_last = NULL;
80014746:	95 08       	st.w	r10[0x0],r8
80014748:	e0 6a 2d 10 	mov	r10,11536
	uhd_ctrl_request_timeout = 0;
	uhd_suspend_start = 0;
8001474c:	95 08       	st.w	r10[0x0],r8
	uhd_resume_start = 0;
8001474e:	e0 68 07 28 	mov	r8,1832
	uhd_b_suspend_requested = false;
80014752:	b0 89       	st.b	r8[0x0],r9
80014754:	e0 68 07 2a 	mov	r8,1834
	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
			|AVR32_USBB_USBCON_VBUSTE_MASK
			|AVR32_USBB_USBCON_VBERRE_MASK);
	uhd_enable_vbus();
80014758:	b0 89       	st.b	r8[0x0],r9
8001475a:	e0 68 07 2b 	mov	r8,1835
8001475e:	b0 89       	st.b	r8[0x0],r9

	// Force Vbus interrupt when Vbus is always high
	// This is possible due to a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
80014760:	fe 69 08 0c 	mov	r9,-129012
		otg_raise_vbus_transition();
80014764:	e0 68 02 00 	mov	r8,512
80014768:	93 08       	st.w	r9[0x0],r8
	}

	// Enable main control interrupt
	// Connection, SOF and reset
	AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_DCONNIES_MASK
8001476a:	76 08       	ld.w	r8,r11[0x0]
8001476c:	ed b8 00 0b 	bld	r8,0xb
80014770:	f3 fc 0a 00 	st.weq	r9[0x0],r12
			| AVR32_USBB_UHINTESET_HSOFIES_MASK
			| AVR32_USBB_UHINTESET_RSTIES_MASK;

	otg_freeze_clock();
80014774:	32 59       	mov	r9,37
80014776:	fe 68 00 00 	mov	r8,-131072
8001477a:	f1 49 04 18 	st.w	r8[1048],r9
8001477e:	fe 69 08 00 	mov	r9,-129024
80014782:	72 08       	ld.w	r8,r9[0x0]
80014784:	af a8       	sbr	r8,0xe
80014786:	93 08       	st.w	r9[0x0],r8
80014788:	ca bb       	rjmp	800146de <uhd_enable+0x1a>
8001478a:	d7 03       	nop

8001478c <uhd_disable>:
8001478c:	eb cd 40 c0 	pushm	r6-r7,lr
80014790:	fe 69 08 04 	mov	r9,-129020
80014794:	18 96       	mov	r6,r12
80014796:	72 08       	ld.w	r8,r9[0x0]
80014798:	ed b8 00 0e 	bld	r8,0xe
void uhd_disable(bool b_id_stop)
{
	irqflags_t flags;

	// Check USB clock ready after a potential sleep mode < IDLE
	while (!Is_otg_clock_usable());
8001479c:	cf d1       	brne	80014796 <uhd_disable+0xa>
	otg_unfreeze_clock();
8001479e:	fe 67 08 00 	mov	r7,-129024
800147a2:	6e 08       	ld.w	r8,r7[0x0]
800147a4:	af c8       	cbr	r8,0xe
800147a6:	8f 08       	st.w	r7[0x0],r8

	// Disable Vbus change and error interrupts
	Clr_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSTE_MASK
800147a8:	fe 68 00 00 	mov	r8,-131072
800147ac:	f0 f9 08 00 	ld.w	r9,r8[2048]
800147b0:	e0 19 ff f5 	andl	r9,0xfff5
800147b4:	f1 49 08 00 	st.w	r8[2048],r9
			| AVR32_USBB_USBCON_VBERRE_MASK);

	// Disable main control interrupt
	// (Connection, disconnection, SOF and reset)
	AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_DCONNIEC_MASK
800147b8:	37 f9       	mov	r9,127
800147ba:	f1 49 04 14 	st.w	r8[1044],r9
			| AVR32_USBB_UHINTECLR_HSOFIEC_MASK
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
800147be:	fe 69 04 00 	mov	r9,-130048
800147c2:	72 08       	ld.w	r8,r9[0x0]
800147c4:	a9 c8       	cbr	r8,0x8
800147c6:	93 08       	st.w	r9[0x0],r8
	uhd_disable_vbus();
800147c8:	fe 68 08 08 	mov	r8,-129016
800147cc:	e0 69 02 00 	mov	r9,512
	uhc_notify_connection(false);
800147d0:	30 0c       	mov	r12,0
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
	uhd_disable_vbus();
800147d2:	91 09       	st.w	r8[0x0],r9
	uhc_notify_connection(false);
800147d4:	e0 a0 0f 58 	rcall	80016684 <uhc_notify_connection>
	otg_freeze_clock();
800147d8:	6e 08       	ld.w	r8,r7[0x0]
800147da:	af a8       	sbr	r8,0xe
800147dc:	8f 08       	st.w	r7[0x0],r8

#ifdef USB_ID
	uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
	if (!b_id_stop) {
800147de:	58 06       	cp.w	r6,0
800147e0:	c0 31       	brne	800147e6 <uhd_disable+0x5a>
800147e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800147e6:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
800147ea:	d3 03       	ssrf	0x10
}


void otg_dual_disable(void)
{
	if (!otg_initialized) {
800147ec:	e0 68 06 a9 	mov	r8,1705
800147f0:	30 09       	mov	r9,0
800147f2:	11 8a       	ld.ub	r10,r8[0x0]
800147f4:	f2 0a 18 00 	cp.b	r10,r9
		return; // Dual role not initialized
	}
	otg_initialized = false;

	// Do not authorize asynchronous USB interrupts
	AVR32_PM.AWEN.usb_waken = 0;
800147f8:	c1 90       	breq	8001482a <uhd_disable+0x9e>
800147fa:	fe 7a 0c 00 	mov	r10,-62464
800147fe:	30 0c       	mov	r12,0
80014800:	f4 fb 01 44 	ld.w	r11,r10[324]
80014804:	f7 dc d0 01 	bfins	r11,r12,0x0,0x1
80014808:	f5 4b 01 44 	st.w	r10[324],r11
	otg_unfreeze_clock();
8001480c:	6e 0a       	ld.w	r10,r7[0x0]
8001480e:	af ca       	cbr	r10,0xe
# ifdef USB_ID
	otg_disable_id_interrupt();
80014810:	8f 0a       	st.w	r7[0x0],r10
80014812:	6e 0a       	ld.w	r10,r7[0x0]
80014814:	a1 ca       	cbr	r10,0x0
# endif
	otg_disable();
80014816:	8f 0a       	st.w	r7[0x0],r10
80014818:	6e 0a       	ld.w	r10,r7[0x0]
8001481a:	af da       	cbr	r10,0xf
void otg_dual_disable(void)
{
	if (!otg_initialized) {
		return; // Dual role not initialized
	}
	otg_initialized = false;
8001481c:	8f 0a       	st.w	r7[0x0],r10
	otg_unfreeze_clock();
# ifdef USB_ID
	otg_disable_id_interrupt();
# endif
	otg_disable();
	otg_disable_pad();
8001481e:	b0 89       	st.b	r8[0x0],r9
80014820:	6e 08       	ld.w	r8,r7[0x0]
80014822:	ad c8       	cbr	r8,0xc
	sysclk_disable_usb();
80014824:	8f 08       	st.w	r7[0x0],r8
80014826:	e0 a0 0a 4b 	rcall	80015cbc <sysclk_disable_usb>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8001482a:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
   }

	barrier();
8001482e:	c0 30       	breq	80014834 <uhd_disable+0xa8>
80014830:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80014834:	d5 03       	csrf	0x10
80014836:	cf db       	rjmp	80014830 <uhd_disable+0xa4>

80014838 <uhd_ctrl_request_end>:
80014838:	eb cd 40 f8 	pushm	r3-r7,lr
8001483c:	20 2d       	sub	sp,8
8001483e:	30 08       	mov	r8,0
80014840:	18 93       	mov	r3,r12
80014842:	e0 64 2d 14 	mov	r4,11540
	irqflags_t flags;
	uhd_callback_setup_end_t callback_end;
	struct uhd_ctrl_request_t *request_to_free;
	bool b_new_request;

	uhd_ctrl_request_timeout = 0;
80014846:	e0 67 2d 08 	mov	r7,11528

	//	print_dbg("\r\n ctrl request end.");

	// Remove request from the control request list
	callback_end = uhd_ctrl_request_first->callback_end;
8001484a:	a8 08       	st.h	r4[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8001484c:	6e 0c       	ld.w	r12,r7[0x0]
8001484e:	78 65       	ld.w	r5,r12[0x18]
	cpu_irq_disable();
80014850:	e1 b8 00 00 	mfsr	r8,0x0
	request_to_free = uhd_ctrl_request_first;
	flags = cpu_irq_save();
	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;
80014854:	d3 03       	ssrf	0x10
80014856:	6e 09       	ld.w	r9,r7[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80014858:	72 76       	ld.w	r6,r9[0x1c]
8001485a:	8f 06       	st.w	r7[0x0],r6
8001485c:	ed b8 00 10 	bld	r8,0x10
	b_new_request = (uhd_ctrl_request_first != NULL);
	cpu_irq_restore(flags);
	free(request_to_free);
80014860:	e0 81 00 c2 	brne	800149e4 <uhd_ctrl_request_end+0x1ac>

	// Call callback
	if (callback_end != NULL) {
80014864:	e0 a0 75 06 	rcall	80023270 <free>
		callback_end(uhd_get_configured_address(0), status, uhd_ctrl_nb_trans);
80014868:	58 05       	cp.w	r5,0
8001486a:	c0 b0       	breq	80014880 <uhd_ctrl_request_end+0x48>
8001486c:	fe 68 04 24 	mov	r8,-130012
80014870:	70 0c       	ld.w	r12,r8[0x0]
80014872:	e0 68 2d 0c 	mov	r8,11532
80014876:	06 9b       	mov	r11,r3
80014878:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
	}

	// If a setup request is pending and no started by previous callback
	if (b_new_request) {
8001487c:	90 8a       	ld.uh	r10,r8[0x0]
	} setup;
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
8001487e:	5d 15       	icall	r5
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80014880:	58 06       	cp.w	r6,0
80014882:	c3 50       	breq	800148ec <uhd_ctrl_request_end+0xb4>
	} setup;
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
80014884:	e0 68 2d 04 	mov	r8,11524
80014888:	6e 0b       	ld.w	r11,r7[0x0]
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
8001488a:	30 8a       	mov	r10,8
8001488c:	30 07       	mov	r7,0
8001488e:	2f fb       	sub	r11,-1

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
	uhd_ctrl_nb_trans = 0;
80014890:	91 07       	st.w	r8[0x0],r7
80014892:	1a 9c       	mov	r12,sp
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014894:	e0 a0 77 16 	rcall	800236c0 <memcpy>
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80014898:	e0 68 2d 0c 	mov	r8,11532

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
8001489c:	b0 07       	st.h	r8[0x0],r7
8001489e:	fe 68 00 00 	mov	r8,-131072
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800148a2:	40 09       	lddsp	r9,sp[0x0]
800148a4:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
800148a8:	5c ca       	swap.bh	r10
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
800148aa:	5c 8a       	casts.h	r10

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
800148ac:	f0 fb 04 1c 	ld.w	r11,r8[1052]
800148b0:	f3 da d0 10 	bfins	r9,r10,0x0,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800148b4:	40 18       	lddsp	r8,sp[0x4]
800148b6:	f0 0a 14 10 	asr	r10,r8,0x10
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
800148ba:	5c ca       	swap.bh	r10
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
800148bc:	5c 8a       	casts.h	r10
800148be:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
800148c2:	f1 da d2 10 	bfins	r8,r10,0x10,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800148c6:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
800148ca:	5c ca       	swap.bh	r10
800148cc:	5c 8a       	casts.h	r10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
800148ce:	58 0b       	cp.w	r11,0
800148d0:	c0 c0       	breq	800148e8 <uhd_ctrl_request_end+0xb0>
800148d2:	fe 6b 04 24 	mov	r11,-130012
800148d6:	76 0b       	ld.w	r11,r11[0x0]
800148d8:	e0 6c 2d 08 	mov	r12,11528
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
		uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
800148dc:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7

	// If a setup request is pending and no started by previous callback
	if (b_new_request) {
		uhd_ctrl_phase_setup();
	}
	if (uhd_b_suspend_requested) {
800148e0:	78 0c       	ld.w	r12,r12[0x0]
800148e2:	19 8c       	ld.ub	r12,r12[0x0]
800148e4:	16 3c       	cp.w	r12,r11
800148e6:	c0 d0       	breq	80014900 <uhd_ctrl_request_end+0xc8>
800148e8:	30 1c       	mov	r12,1
800148ea:	ca 7f       	rcall	80014838 <uhd_ctrl_request_end>
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
800148ec:	e0 68 07 2b 	mov	r8,1835
800148f0:	30 09       	mov	r9,0
		return; // Endpoint not valid
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
800148f2:	11 8a       	ld.ub	r10,r8[0x0]
800148f4:	f2 0a 18 00 	cp.b	r10,r9
800148f8:	c2 51       	brne	80014942 <uhd_ctrl_request_end+0x10a>
800148fa:	2f ed       	sub	sp,-8
800148fc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80014900:	fe 6c 05 00 	mov	r12,-129792
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
	uhd_ack_setup_ready(0);
80014904:	78 0b       	ld.w	r11,r12[0x0]
80014906:	e0 1b fc ff 	andl	r11,0xfcff
	Assert(sizeof(setup) == sizeof(uint64_t));
	ptr_ep_data = (volatile uint64_t *)&uhd_get_pipe_fifo_access(0, 64);
	*ptr_ep_data = setup.value64;
8001490a:	99 0b       	st.w	r12[0x0],r11
8001490c:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
80014910:	30 4c       	mov	r12,4
80014912:	fe 6b 05 60 	mov	r11,-129696

	uhd_ctrl_request_timeout = 5000;
80014916:	97 0c       	st.w	r11[0x0],r12
80014918:	10 9a       	mov	r10,r8
8001491a:	12 9b       	mov	r11,r9
	uhd_enable_setup_ready_interrupt(0);
8001491c:	fc 18 e0 00 	movh	r8,0xe000
80014920:	f0 eb 00 00 	st.d	r8[0],r10
	uhd_ack_fifocon(0);
80014924:	e0 68 13 88 	mov	r8,5000
80014928:	a8 08       	st.h	r4[0x0],r8
8001492a:	fe 68 05 f0 	mov	r8,-129552
	uhd_unfreeze_pipe(0);
8001492e:	91 0c       	st.w	r8[0x0],r12
80014930:	e0 69 40 00 	mov	r9,16384
	if (b_new_request) {
		uhd_ctrl_phase_setup();
	}
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
80014934:	fe 68 06 20 	mov	r8,-129504
	uhd_start_reset();
}

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
80014938:	91 09       	st.w	r8[0x0],r9
8001493a:	e2 69 00 00 	mov	r9,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8001493e:	91 09       	st.w	r8[0x0],r9
80014940:	cd 6b       	rjmp	800148ec <uhd_ctrl_request_end+0xb4>
		uhd_freeze_pipe(pipe);
80014942:	b0 89       	st.b	r8[0x0],r9
80014944:	88 09       	ld.sh	r9,r4[0x0]
80014946:	58 09       	cp.w	r9,0
80014948:	c5 01       	brne	800149e8 <uhd_ctrl_request_end+0x1b0>
8001494a:	fe 69 05 c4 	mov	r9,-129596
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8001494e:	72 07       	ld.w	r7,r9[0x0]
80014950:	fe 69 05 f4 	mov	r9,-129548
		uhd_freeze_pipe(pipe);
80014954:	e2 68 00 00 	mov	r8,131072
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014958:	93 08       	st.w	r9[0x0],r8
8001495a:	fe 69 05 c8 	mov	r9,-129592
		uhd_freeze_pipe(pipe);
8001495e:	72 0c       	ld.w	r12,r9[0x0]
80014960:	fe 69 05 f8 	mov	r9,-129544
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014964:	93 08       	st.w	r9[0x0],r8
80014966:	fe 69 05 cc 	mov	r9,-129588
		uhd_freeze_pipe(pipe);
8001496a:	72 0b       	ld.w	r11,r9[0x0]
8001496c:	fe 69 05 fc 	mov	r9,-129540
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014970:	93 08       	st.w	r9[0x0],r8
80014972:	fe 69 05 d0 	mov	r9,-129584
80014976:	72 0a       	ld.w	r10,r9[0x0]
80014978:	fe 69 06 00 	mov	r9,-129536
		uhd_freeze_pipe(pipe);
8001497c:	93 08       	st.w	r9[0x0],r8
8001497e:	10 57       	eor	r7,r8
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
80014980:	10 5c       	eor	r12,r8
80014982:	10 5b       	eor	r11,r8
80014984:	10 5a       	eor	r10,r8
		uhd_freeze_pipe(pipe);
80014986:	fe 69 05 d4 	mov	r9,-129580
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8001498a:	fe 66 06 04 	mov	r6,-129532
8001498e:	72 09       	ld.w	r9,r9[0x0]
80014990:	ef d7 c2 21 	bfextu	r7,r7,0x11,0x1
80014994:	8d 08       	st.w	r6[0x0],r8
80014996:	10 59       	eor	r9,r8
80014998:	f9 dc c2 21 	bfextu	r12,r12,0x11,0x1
8001499c:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
800149a0:	a3 6c       	lsl	r12,0x2
800149a2:	f7 db c2 21 	bfextu	r11,r11,0x11,0x1
800149a6:	f9 e7 10 17 	or	r7,r12,r7<<0x1
800149aa:	f5 da c2 21 	bfextu	r10,r10,0x11,0x1
800149ae:	ef eb 10 3b 	or	r11,r7,r11<<0x3
800149b2:	f7 ea 10 4a 	or	r10,r11,r10<<0x4
800149b6:	f5 e9 10 5a 	or	r10,r10,r9<<0x5
800149ba:	fe 69 05 d8 	mov	r9,-129576
		uhd_freeze_pipe(pipe);
800149be:	72 09       	ld.w	r9,r9[0x0]
800149c0:	10 59       	eor	r9,r8
800149c2:	f3 d9 c2 21 	bfextu	r9,r9,0x11,0x1
	}
	// Wait three SOFs before entering in suspend state
	uhd_suspend_start = 3;
800149c6:	f5 e9 10 69 	or	r9,r10,r9<<0x6
800149ca:	fe 6a 06 08 	mov	r10,-129528
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
800149ce:	95 08       	st.w	r10[0x0],r8
800149d0:	e0 68 07 29 	mov	r8,1833
      cpu_irq_enable();
800149d4:	b0 89       	st.b	r8[0x0],r9

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
800149d6:	30 39       	mov	r9,3
800149d8:	e0 68 07 28 	mov	r8,1832
	if (uhd_b_suspend_requested) {
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
		uhd_suspend();
	}
}
800149dc:	b0 89       	st.b	r8[0x0],r9
800149de:	2f ed       	sub	sp,-8
800149e0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800149e4:	d5 03       	csrf	0x10
800149e6:	c3 fb       	rjmp	80014864 <uhd_ctrl_request_end+0x2c>
800149e8:	30 19       	mov	r9,1
800149ea:	b0 89       	st.b	r8[0x0],r9
800149ec:	2f ed       	sub	sp,-8
800149ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800149f2:	d7 03       	nop

800149f4 <uhd_setup_request>:
800149f4:	eb cd 40 fc 	pushm	r2-r7,lr
800149f8:	20 3d       	sub	sp,12
800149fa:	18 97       	mov	r7,r12
800149fc:	50 0b       	stdsp	sp[0x0],r11
800149fe:	14 92       	mov	r2,r10
80014a00:	12 96       	mov	r6,r9
80014a02:	10 93       	mov	r3,r8
		usb_setup_req_t *req,
		uint8_t *payload,
		uint16_t payload_size,
		uhd_callback_setup_run_t callback_run,
		uhd_callback_setup_end_t callback_end)
{
80014a04:	40 a4       	lddsp	r4,sp[0x28]
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
80014a06:	32 0c       	mov	r12,32
80014a08:	e0 a0 74 3c 	rcall	80023280 <malloc>
	if (request == NULL) {
80014a0c:	40 0b       	lddsp	r11,sp[0x0]
{
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
80014a0e:	18 95       	mov	r5,r12
	if (request == NULL) {
80014a10:	c5 c0       	breq	80014ac8 <uhd_setup_request+0xd4>
		Assert(false);
		return false;
	}

	// Fill structure
	request->add = (uint8_t) add;
80014a12:	18 c7       	st.b	r12++,r7
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
80014a14:	30 8a       	mov	r10,8
80014a16:	e0 a0 76 55 	rcall	800236c0 <memcpy>
	request->payload = payload;
	request->payload_size = payload_size;
	request->callback_run = callback_run;
	request->callback_end = callback_end;
	request->next_request = NULL;
80014a1a:	30 08       	mov	r8,0
	}

	// Fill structure
	request->add = (uint8_t) add;
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
	request->payload = payload;
80014a1c:	8b 32       	st.w	r5[0xc],r2
	request->payload_size = payload_size;
80014a1e:	eb 56 00 10 	st.h	r5[16],r6
	request->callback_run = callback_run;
80014a22:	8b 53       	st.w	r5[0x14],r3
	request->callback_end = callback_end;
80014a24:	8b 64       	st.w	r5[0x18],r4
	request->next_request = NULL;
80014a26:	8b 78       	st.w	r5[0x1c],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80014a28:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
80014a2c:	d3 03       	ssrf	0x10

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
80014a2e:	e0 69 2d 08 	mov	r9,11528
80014a32:	72 0a       	ld.w	r10,r9[0x0]
80014a34:	58 0a       	cp.w	r10,0
		uhd_ctrl_request_first = request;
		b_start_request = true;
	} else {
		uhd_ctrl_request_last->next_request = request;
80014a36:	c6 f0       	breq	80014b14 <uhd_setup_request+0x120>
80014a38:	10 9a       	mov	r10,r8
80014a3a:	e0 68 2d 10 	mov	r8,11536
	}
	uhd_ctrl_request_last = request;
80014a3e:	70 0c       	ld.w	r12,r8[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80014a40:	99 75       	st.w	r12[0x1c],r5
80014a42:	91 05       	st.w	r8[0x0],r5
80014a44:	ed bb 00 10 	bld	r11,0x10
	cpu_irq_restore(flags);

	if (b_start_request) {
80014a48:	c3 e1       	brne	80014ac4 <uhd_setup_request+0xd0>
	*ptr_ep_data = setup.value64;

	uhd_ctrl_request_timeout = 5000;
	uhd_enable_setup_ready_interrupt(0);
	uhd_ack_fifocon(0);
	uhd_unfreeze_pipe(0);
80014a4a:	58 0a       	cp.w	r10,0
80014a4c:	c0 41       	brne	80014a54 <uhd_setup_request+0x60>
80014a4e:	2f dd       	sub	sp,-12
	} setup;
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
80014a50:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80014a54:	e0 68 2d 04 	mov	r8,11524
80014a58:	72 0b       	ld.w	r11,r9[0x0]
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80014a5a:	30 07       	mov	r7,0
80014a5c:	2f fb       	sub	r11,-1
80014a5e:	91 07       	st.w	r8[0x0],r7
80014a60:	30 8a       	mov	r10,8
80014a62:	fa cc ff fc 	sub	r12,sp,-4

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
	uhd_ctrl_nb_trans = 0;
80014a66:	e0 a0 76 2d 	rcall	800236c0 <memcpy>
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014a6a:	e0 68 2d 0c 	mov	r8,11532

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
80014a6e:	b0 07       	st.h	r8[0x0],r7
80014a70:	fe 68 00 00 	mov	r8,-131072
80014a74:	40 19       	lddsp	r9,sp[0x4]
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014a76:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
80014a7a:	5c ca       	swap.bh	r10
80014a7c:	5c 8a       	casts.h	r10
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80014a7e:	f0 fb 04 1c 	ld.w	r11,r8[1052]

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
80014a82:	f3 da d0 10 	bfins	r9,r10,0x0,0x10
80014a86:	40 28       	lddsp	r8,sp[0x8]
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014a88:	f0 0a 14 10 	asr	r10,r8,0x10
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
80014a8c:	5c ca       	swap.bh	r10
80014a8e:	5c 8a       	casts.h	r10
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80014a90:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
80014a94:	f1 da d2 10 	bfins	r8,r10,0x10,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014a98:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
80014a9c:	5c ca       	swap.bh	r10
80014a9e:	5c 8a       	casts.h	r10
80014aa0:	58 0b       	cp.w	r11,0
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80014aa2:	c0 c0       	breq	80014aba <uhd_setup_request+0xc6>
80014aa4:	fe 6b 04 24 	mov	r11,-130012
80014aa8:	76 0b       	ld.w	r11,r11[0x0]
80014aaa:	e0 6c 2d 08 	mov	r12,11528
80014aae:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
		uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
80014ab2:	78 0c       	ld.w	r12,r12[0x0]
80014ab4:	19 8c       	ld.ub	r12,r12[0x0]
80014ab6:	16 3c       	cp.w	r12,r11
80014ab8:	c0 b0       	breq	80014ace <uhd_setup_request+0xda>
80014aba:	30 1c       	mov	r12,1
      cpu_irq_enable();
80014abc:	cb ee       	rcall	80014838 <uhd_ctrl_request_end>
80014abe:	2f dd       	sub	sp,-12
	if (b_start_request) {
		// Start immediately request
		uhd_ctrl_phase_setup();
	}
	return true;
}
80014ac0:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80014ac4:	d5 03       	csrf	0x10
		return; // Endpoint not valid
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
80014ac6:	cc 2b       	rjmp	80014a4a <uhd_setup_request+0x56>
80014ac8:	2f dd       	sub	sp,-12
80014aca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80014ace:	fe 6c 05 00 	mov	r12,-129792
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80014ad2:	78 0b       	ld.w	r11,r12[0x0]
80014ad4:	e0 1b fc ff 	andl	r11,0xfcff
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
	uhd_ack_setup_ready(0);
80014ad8:	99 0b       	st.w	r12[0x0],r11
80014ada:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
	Assert(sizeof(setup) == sizeof(uint64_t));
	ptr_ep_data = (volatile uint64_t *)&uhd_get_pipe_fifo_access(0, 64);
	*ptr_ep_data = setup.value64;
80014ade:	30 4c       	mov	r12,4
80014ae0:	fe 6b 05 60 	mov	r11,-129696
80014ae4:	97 0c       	st.w	r11[0x0],r12
80014ae6:	10 9a       	mov	r10,r8
80014ae8:	12 9b       	mov	r11,r9

	uhd_ctrl_request_timeout = 5000;
80014aea:	fc 18 e0 00 	movh	r8,0xe000
80014aee:	f0 eb 00 00 	st.d	r8[0],r10
	uhd_enable_setup_ready_interrupt(0);
80014af2:	e0 69 13 88 	mov	r9,5000
80014af6:	e0 68 2d 14 	mov	r8,11540
	uhd_ack_fifocon(0);
80014afa:	b0 09       	st.h	r8[0x0],r9
80014afc:	fe 68 05 f0 	mov	r8,-129552
80014b00:	91 0c       	st.w	r8[0x0],r12
	uhd_unfreeze_pipe(0);
80014b02:	e0 69 40 00 	mov	r9,16384
80014b06:	fe 68 06 20 	mov	r8,-129504
	request->next_request = NULL;

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
		uhd_ctrl_request_first = request;
80014b0a:	91 09       	st.w	r8[0x0],r9
80014b0c:	e2 69 00 00 	mov	r9,131072
80014b10:	91 09       	st.w	r8[0x0],r9
80014b12:	c9 eb       	rjmp	80014a4e <uhd_setup_request+0x5a>
80014b14:	93 05       	st.w	r9[0x0],r5
80014b16:	30 1a       	mov	r10,1
80014b18:	e0 68 2d 10 	mov	r8,11536
80014b1c:	c9 3b       	rjmp	80014a42 <uhd_setup_request+0x4e>
80014b1e:	d7 03       	nop

80014b20 <uhd_ep_abort_pipe>:
80014b20:	eb cd 40 c0 	pushm	r6-r7,lr
80014b24:	fe 68 00 00 	mov	r8,-131072
80014b28:	e0 79 00 00 	mov	r9,65536
80014b2c:	f0 fa 04 1c 	ld.w	r10,r8[1052]
80014b30:	f2 0c 09 49 	lsl	r9,r9,r12
 * \param status Reason of abort
 */
static void uhd_ep_abort_pipe(uint8_t pipe, uhd_trans_status_t status)
{
	// Stop transfer
	uhd_reset_pipe(pipe);
80014b34:	f3 ea 10 0a 	or	r10,r9,r10
80014b38:	f1 4a 04 1c 	st.w	r8[1052],r10
80014b3c:	f0 fa 04 1c 	ld.w	r10,r8[1052]
80014b40:	5c d9       	com	r9
80014b42:	14 69       	and	r9,r10

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
80014b44:	fe 6a 05 00 	mov	r10,-129792
 * \param status Reason of abort
 */
static void uhd_ep_abort_pipe(uint8_t pipe, uhd_trans_status_t status)
{
	// Stop transfer
	uhd_reset_pipe(pipe);
80014b48:	f1 49 04 1c 	st.w	r8[1052],r9

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
80014b4c:	f8 08 15 02 	lsl	r8,r12,0x2
80014b50:	f0 0a 00 0e 	add	lr,r8,r10
	uhd_enable_stall_interrupt(pipe);
80014b54:	fe 6a 05 f0 	mov	r10,-129552
{
	// Stop transfer
	uhd_reset_pipe(pipe);

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
80014b58:	7c 09       	ld.w	r9,lr[0x0]
80014b5a:	ab a9       	sbr	r9,0xa
80014b5c:	9d 09       	st.w	lr[0x0],r9
	uhd_enable_stall_interrupt(pipe);
80014b5e:	f0 0a 00 09 	add	r9,r8,r10
80014b62:	34 0a       	mov	r10,64
80014b64:	93 0a       	st.w	r9[0x0],r10
	uhd_enable_pipe_error_interrupt(pipe);

	uhd_disable_out_ready_interrupt(pipe);
80014b66:	e0 38 f9 e0 	sub	r8,129504
	uhd_reset_pipe(pipe);

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
	uhd_enable_stall_interrupt(pipe);
	uhd_enable_pipe_error_interrupt(pipe);
80014b6a:	30 8a       	mov	r10,8
80014b6c:	93 0a       	st.w	r9[0x0],r10

	uhd_disable_out_ready_interrupt(pipe);
80014b6e:	30 29       	mov	r9,2
80014b70:	91 09       	st.w	r8[0x0],r9
	uhd_pipe_dma_set_control(pipe, 0);
80014b72:	f8 08 15 04 	lsl	r8,r12,0x4
80014b76:	e0 38 f9 00 	sub	r8,129280
80014b7a:	30 09       	mov	r9,0
80014b7c:	91 29       	st.w	r8[0x8],r9
static void uhd_pipe_finish_job(uint8_t pipe, uhd_trans_status_t status)
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
80014b7e:	e0 68 06 b0 	mov	r8,1712
80014b82:	f8 ca 00 01 	sub	r10,r12,1
80014b86:	f4 0a 00 2a 	add	r10,r10,r10<<0x2
80014b8a:	f0 0a 00 2a 	add	r10,r8,r10<<0x2
	if (ptr_job->busy == false) {
80014b8e:	74 08       	ld.w	r8,r10[0x0]
80014b90:	58 08       	cp.w	r8,0
		return; // No job running
	}
	ptr_job->busy = false;
80014b92:	c2 b4       	brge	80014be8 <uhd_ep_abort_pipe+0xc8>
80014b94:	f1 d9 d3 e1 	bfins	r8,r9,0x1f,0x1
	if (NULL == ptr_job->call_end) {
80014b98:	95 08       	st.w	r10[0x0],r8
80014b9a:	74 48       	ld.w	r8,r10[0x10]
80014b9c:	58 08       	cp.w	r8,0
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
80014b9e:	c2 50       	breq	80014be8 <uhd_ep_abort_pipe+0xc8>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80014ba0:	7c 06       	ld.w	r6,lr[0x0]
80014ba2:	74 39       	ld.w	r9,r10[0xc]
			uhd_get_pipe_endpoint_address(pipe),
80014ba4:	16 9a       	mov	r10,r11
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80014ba6:	7c 0b       	ld.w	r11,lr[0x0]
80014ba8:	fd d6 c2 04 	bfextu	lr,r6,0x10,0x4
80014bac:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
80014bb0:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80014bb4:	a3 77       	lsl	r7,0x3
80014bb6:	e0 66 00 80 	mov	r6,128
80014bba:	e2 1c 03 fc 	andl	r12,0x3fc,COH
80014bbe:	58 1b       	cp.w	r11,1
80014bc0:	ec 0b 17 00 	moveq	r11,r6
80014bc4:	f9 bb 01 00 	movne	r11,0
80014bc8:	e0 3c fb dc 	sub	r12,130012
80014bcc:	1c 4b       	or	r11,lr
80014bce:	78 0c       	ld.w	r12,r12[0x0]
80014bd0:	37 fe       	mov	lr,127
80014bd2:	fc 07 09 4e 	lsl	lr,lr,r7
80014bd6:	fd ec 00 0c 	and	r12,lr,r12
80014bda:	5c 9e       	brev	lr
80014bdc:	fc 0e 12 00 	clz	lr,lr
80014be0:	f8 0e 0a 4c 	lsr	r12,r12,lr
80014be4:	5c 5c       	castu.b	r12
80014be6:	5d 18       	icall	r8
80014be8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80014bec <uhd_ep_free>:
80014bec:	d4 31       	pushm	r0-r7,lr
80014bee:	20 2d       	sub	sp,8
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80014bf0:	30 17       	mov	r7,1
80014bf2:	18 91       	mov	r1,r12
80014bf4:	16 90       	mov	r0,r11
80014bf6:	30 06       	mov	r6,0
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014bf8:	fe 65 00 00 	mov	r5,-131072
80014bfc:	0e 94       	mov	r4,r7
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80014bfe:	30 63       	mov	r3,6
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014c00:	37 f2       	mov	r2,127
			continue;
		}
		if (endp != 0xFF) {
80014c02:	3f f8       	mov	r8,-1
80014c04:	c0 48       	rjmp	80014c0c <uhd_ep_free+0x20>
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80014c06:	2f f7       	sub	r7,-1
80014c08:	2f f6       	sub	r6,-1
80014c0a:	5c 57       	castu.b	r7
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014c0c:	ea fa 04 1c 	ld.w	r10,r5[1052]
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80014c10:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014c14:	e8 0c 09 49 	lsl	r9,r4,r12
80014c18:	f3 ea 00 0a 	and	r10,r9,r10
80014c1c:	c1 50       	breq	80014c46 <uhd_ep_free+0x5a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014c1e:	18 9a       	mov	r10,r12
80014c20:	e2 1a 00 fc 	andl	r10,0xfc,COH
80014c24:	e0 3a fb dc 	sub	r10,130012
80014c28:	74 0b       	ld.w	r11,r10[0x0]
80014c2a:	f5 dc c0 02 	bfextu	r10,r12,0x0,0x2
80014c2e:	a3 7a       	lsl	r10,0x3
80014c30:	e4 0a 09 4a 	lsl	r10,r2,r10
80014c34:	f5 eb 00 0b 	and	r11,r10,r11
80014c38:	5c 9a       	brev	r10
80014c3a:	f4 0a 12 00 	clz	r10,r10
80014c3e:	f6 0a 0a 4a 	lsr	r10,r11,r10
80014c42:	14 31       	cp.w	r1,r10
80014c44:	c0 70       	breq	80014c52 <uhd_ep_free+0x66>
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80014c46:	e6 07 18 00 	cp.b	r7,r3
80014c4a:	fe 98 ff de 	brls	80014c06 <uhd_ep_free+0x1a>
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
	}
}
80014c4e:	2f ed       	sub	sp,-8
80014c50:	d8 32       	popm	r0-r7,pc
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
80014c52:	f0 00 18 00 	cp.b	r0,r8
80014c56:	c2 d0       	breq	80014cb0 <uhd_ep_free+0xc4>
			// Disable specific endpoint number
			if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80014c58:	f8 0a 15 02 	lsl	r10,r12,0x2
80014c5c:	e0 3a fb 00 	sub	r10,129792
80014c60:	74 0e       	ld.w	lr,r10[0x0]
80014c62:	fd de c2 04 	bfextu	lr,lr,0x10,0x4
80014c66:	74 0b       	ld.w	r11,r10[0x0]
80014c68:	50 0e       	stdsp	sp[0x0],lr
80014c6a:	e0 6e 00 80 	mov	lr,128
80014c6e:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80014c72:	58 1b       	cp.w	r11,1
80014c74:	fc 0b 17 00 	moveq	r11,lr
80014c78:	f9 bb 01 00 	movne	r11,0
80014c7c:	40 0e       	lddsp	lr,sp[0x0]
80014c7e:	1c 4b       	or	r11,lr
80014c80:	16 30       	cp.w	r0,r11
80014c82:	ce 21       	brne	80014c46 <uhd_ep_free+0x5a>
				continue; // Mismatch
			}
		}
		// Unalloc pipe
		uhd_disable_pipe(pipe);
80014c84:	ea fb 04 1c 	ld.w	r11,r5[1052]
80014c88:	5c d9       	com	r9
80014c8a:	16 69       	and	r9,r11
80014c8c:	eb 49 04 1c 	st.w	r5[1052],r9
		uhd_unallocate_memory(pipe);
80014c90:	74 09       	ld.w	r9,r10[0x0]
80014c92:	a1 d9       	cbr	r9,0x1
80014c94:	95 09       	st.w	r10[0x0],r9

		// Stop transfer on this pipe
#ifndef USB_HOST_HUB_SUPPORT
		if (pipe == 0) {
80014c96:	58 0c       	cp.w	r12,0
80014c98:	c1 11       	brne	80014cba <uhd_ep_free+0xce>
			// Endpoint control
			if (uhd_ctrl_request_timeout) {
80014c9a:	e0 6a 2d 14 	mov	r10,11540
80014c9e:	94 09       	ld.sh	r9,r10[0x0]
80014ca0:	58 09       	cp.w	r9,0
				uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
80014ca2:	cd 20       	breq	80014c46 <uhd_ep_free+0x5a>
80014ca4:	50 18       	stdsp	sp[0x4],r8
80014ca6:	30 1c       	mov	r12,1
80014ca8:	fe b0 fd c8 	rcall	80014838 <uhd_ctrl_request_end>
80014cac:	40 18       	lddsp	r8,sp[0x4]
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
80014cae:	ca cb       	rjmp	80014c06 <uhd_ep_free+0x1a>
80014cb0:	f8 0a 15 02 	lsl	r10,r12,0x2
80014cb4:	e0 3a fb 00 	sub	r10,129792
			}
			continue;
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
80014cb8:	ce 6b       	rjmp	80014c84 <uhd_ep_free+0x98>
80014cba:	50 18       	stdsp	sp[0x4],r8
80014cbc:	30 1b       	mov	r11,1
80014cbe:	c3 1f       	rcall	80014b20 <uhd_ep_abort_pipe>
80014cc0:	40 18       	lddsp	r8,sp[0x4]
80014cc2:	cc 2b       	rjmp	80014c46 <uhd_ep_free+0x5a>

80014cc4 <uhd_pipe_trans_complet>:
80014cc4:	eb cd 40 f8 	pushm	r3-r7,lr
80014cc8:	e0 69 06 b0 	mov	r9,1712
80014ccc:	f8 c8 00 01 	sub	r8,r12,1
	iram_size_t max_trans;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
80014cd0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80014cd4:	f2 08 00 28 	add	r8,r9,r8<<0x2

	if (!ptr_job->busy) {
80014cd8:	70 0a       	ld.w	r10,r8[0x0]
80014cda:	58 0a       	cp.w	r10,0
80014cdc:	e0 84 00 8c 	brge	80014df4 <uhd_pipe_trans_complet+0x130>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
80014ce0:	70 39       	ld.w	r9,r8[0xc]
80014ce2:	70 26       	ld.w	r6,r8[0x8]
80014ce4:	0c 39       	cp.w	r9,r6
80014ce6:	e0 80 00 89 	breq	80014df8 <uhd_pipe_trans_complet+0x134>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
80014cea:	fe 67 05 00 	mov	r7,-129792
80014cee:	f8 0e 15 02 	lsl	lr,r12,0x2
80014cf2:	fc 07 00 0b 	add	r11,lr,r7
80014cf6:	76 07       	ld.w	r7,r11[0x0]
80014cf8:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
80014cfc:	58 17       	cp.w	r7,1
80014cfe:	e0 80 00 d5 	breq	80014ea8 <uhd_pipe_trans_complet+0x1e4>
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
				 max_trans = 256L * uhd_get_pipe_size(pipe);
80014d02:	e0 77 00 00 	mov	r7,65536
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
80014d06:	12 16       	sub	r6,r9
80014d08:	0c 37       	cp.w	r7,r6
80014d0a:	ec 07 17 b0 	movhi	r7,r6
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
80014d0e:	e0 57 00 00 	cp.w	r7,65536
80014d12:	e0 80 00 c9 	breq	80014ea4 <uhd_pipe_trans_complet+0x1e0>
			// Set 0 to transfer the maximum
			uhd_dma_ctrl = (0 <<
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		} else {
			uhd_dma_ctrl = (next_trans <<
80014d16:	ee 06 15 10 	lsl	r6,r7,0x10
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
80014d1a:	76 05       	ld.w	r5,r11[0x0]
80014d1c:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80014d20:	58 25       	cp.w	r5,2
80014d22:	e0 80 00 b0 	breq	80014e82 <uhd_pipe_trans_complet+0x1be>
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
80014d26:	76 0a       	ld.w	r10,r11[0x0]
80014d28:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
80014d2c:	58 1a       	cp.w	r10,1
80014d2e:	e0 80 00 d0 	breq	80014ece <uhd_pipe_trans_complet+0x20a>
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
				// Enable short packet reception
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOT_IRQ_EN_MASK
80014d32:	e8 16 00 14 	orl	r6,0x14
						| AVR32_USBB_UHDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
80014d36:	70 1a       	ld.w	r10,r8[0x4]
80014d38:	f4 09 00 09 	add	r9,r10,r9
80014d3c:	f8 0a 15 04 	lsl	r10,r12,0x4
80014d40:	e0 3a f9 00 	sub	r10,129280
80014d44:	95 19       	st.w	r10[0x4],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80014d46:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
80014d4a:	d3 03       	ssrf	0x10
				AVR32_USBB_UHDMA1_CONTROL_CH_EN_MASK;

		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
80014d4c:	74 39       	ld.w	r9,r10[0xc]
80014d4e:	ed b9 00 04 	bld	r9,0x4
80014d52:	c1 a0       	breq	80014d86 <uhd_pipe_trans_complet+0xc2>
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
80014d54:	76 09       	ld.w	r9,r11[0x0]
80014d56:	f3 d9 c1 02 	bfextu	r9,r9,0x8,0x2
80014d5a:	58 19       	cp.w	r9,1
80014d5c:	c7 70       	breq	80014e4a <uhd_pipe_trans_complet+0x186>
				uhd_in_request_number(pipe,
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
80014d5e:	e0 3e f9 e0 	sub	lr,129504
80014d62:	e0 69 10 00 	mov	r9,4096
80014d66:	9d 09       	st.w	lr[0x0],r9
			uhd_unfreeze_pipe(pipe);
80014d68:	e2 69 00 00 	mov	r9,131072
80014d6c:	9d 09       	st.w	lr[0x0],r9
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
		uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80014d6e:	e8 16 00 21 	orl	r6,0x21
				uhd_in_request_number(pipe,
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
			uhd_unfreeze_pipe(pipe);
			uhd_pipe_dma_set_control(pipe, uhd_dma_ctrl);
80014d72:	95 26       	st.w	r10[0x8],r6
			ptr_job->nb_trans += next_trans;
80014d74:	70 39       	ld.w	r9,r8[0xc]
80014d76:	f2 07 00 07 	add	r7,r9,r7
80014d7a:	91 37       	st.w	r8[0xc],r7
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80014d7c:	e6 15 00 01 	andh	r5,0x1,COH
80014d80:	c6 30       	breq	80014e46 <uhd_pipe_trans_complet+0x182>
			cpu_irq_restore(flags);
			return;
80014d82:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80014d86:	e6 15 00 01 	andh	r5,0x1,COH
80014d8a:	c0 21       	brne	80014d8e <uhd_pipe_trans_complet+0xca>
      cpu_irq_enable();
80014d8c:	d5 03       	csrf	0x10
		}
		cpu_irq_restore(flags);
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
80014d8e:	70 39       	ld.w	r9,r8[0xc]
80014d90:	91 29       	st.w	r8[0x8],r9
	}
	if (uhd_is_pipe_out(pipe)) {
80014d92:	76 07       	ld.w	r7,r11[0x0]
		}
		cpu_irq_restore(flags);
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
80014d94:	70 0a       	ld.w	r10,r8[0x0]
	}
	if (uhd_is_pipe_out(pipe)) {
80014d96:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
80014d9a:	58 27       	cp.w	r7,2
80014d9c:	c3 90       	breq	80014e0e <uhd_pipe_trans_complet+0x14a>
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
	if (ptr_job->busy == false) {
80014d9e:	58 0a       	cp.w	r10,0
80014da0:	c2 a4       	brge	80014df4 <uhd_pipe_trans_complet+0x130>
		return; // No job running
	}
	ptr_job->busy = false;
80014da2:	14 9e       	mov	lr,r10
80014da4:	30 0a       	mov	r10,0
80014da6:	fd da d3 e1 	bfins	lr,r10,0x1f,0x1
80014daa:	91 0e       	st.w	r8[0x0],lr
	if (NULL == ptr_job->call_end) {
80014dac:	70 48       	ld.w	r8,r8[0x10]
80014dae:	58 08       	cp.w	r8,0
80014db0:	c2 20       	breq	80014df4 <uhd_pipe_trans_complet+0x130>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
80014db2:	76 0e       	ld.w	lr,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80014db4:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
			uhd_get_pipe_endpoint_address(pipe),
80014db8:	76 06       	ld.w	r6,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80014dba:	e2 1c 03 fc 	andl	r12,0x3fc,COH
80014dbe:	f7 de c2 04 	bfextu	r11,lr,0x10,0x4
80014dc2:	e0 3c fb dc 	sub	r12,130012
80014dc6:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
80014dca:	e0 6e 00 80 	mov	lr,128
80014dce:	58 16       	cp.w	r6,1
80014dd0:	f4 0e 17 10 	movne	lr,r10
80014dd4:	a3 77       	lsl	r7,0x3
80014dd6:	fd eb 10 0b 	or	r11,lr,r11
80014dda:	78 0e       	ld.w	lr,r12[0x0]
80014ddc:	37 fc       	mov	r12,127
80014dde:	f8 07 09 4c 	lsl	r12,r12,r7
80014de2:	f9 ee 00 0e 	and	lr,r12,lr
80014de6:	5c 9c       	brev	r12
80014de8:	f8 0c 12 00 	clz	r12,r12
80014dec:	fc 0c 0a 4c 	lsr	r12,lr,r12
80014df0:	5c 5c       	castu.b	r12
80014df2:	5d 18       	icall	r8
80014df4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
80014df8:	fe 67 05 00 	mov	r7,-129792
80014dfc:	f8 0e 15 02 	lsl	lr,r12,0x2
80014e00:	fc 07 00 0b 	add	r11,lr,r7
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}
	if (uhd_is_pipe_out(pipe)) {
80014e04:	76 07       	ld.w	r7,r11[0x0]
80014e06:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
80014e0a:	58 27       	cp.w	r7,2
80014e0c:	cc 91       	brne	80014d9e <uhd_pipe_trans_complet+0xda>
		if (ptr_job->b_shortpacket) {
80014e0e:	14 96       	mov	r6,r10
80014e10:	e6 16 40 00 	andh	r6,0x4000,COH
80014e14:	cc 50       	breq	80014d9e <uhd_pipe_trans_complet+0xda>
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			uhd_ack_out_ready(pipe);
80014e16:	fe 69 05 60 	mov	r9,-129696
80014e1a:	fc 09 00 08 	add	r8,lr,r9
80014e1e:	91 07       	st.w	r8[0x0],r7
			if (Is_uhd_write_enabled(pipe)) {
80014e20:	fe 69 05 30 	mov	r9,-129744
80014e24:	fc 09 00 08 	add	r8,lr,r9
80014e28:	70 08       	ld.w	r8,r8[0x0]
80014e2a:	ed b8 00 10 	bld	r8,0x10
80014e2e:	c0 61       	brne	80014e3a <uhd_pipe_trans_complet+0x176>
				// Force interrupt in case of pipe already free
				uhd_raise_out_ready(pipe);
80014e30:	fe 69 05 90 	mov	r9,-129648
80014e34:	fc 09 00 08 	add	r8,lr,r9
80014e38:	91 07       	st.w	r8[0x0],r7
			}
			uhd_enable_out_ready_interrupt(pipe);
80014e3a:	e0 3e fa 10 	sub	lr,129552
80014e3e:	30 28       	mov	r8,2
80014e40:	9d 08       	st.w	lr[0x0],r8
			return;
80014e42:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80014e46:	d5 03       	csrf	0x10
80014e48:	c9 db       	rjmp	80014d82 <uhd_pipe_trans_complet+0xbe>
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
				uhd_in_request_number(pipe,
80014e4a:	fe 69 06 50 	mov	r9,-129456
80014e4e:	fc 09 00 0c 	add	r12,lr,r9
80014e52:	78 09       	ld.w	r9,r12[0x0]
80014e54:	76 03       	ld.w	r3,r11[0x0]
80014e56:	e0 19 ff 00 	andl	r9,0xff00
80014e5a:	76 04       	ld.w	r4,r11[0x0]
80014e5c:	f7 d3 c0 83 	bfextu	r11,r3,0x4,0x3
80014e60:	e9 d4 c0 83 	bfextu	r4,r4,0x4,0x3
80014e64:	30 83       	mov	r3,8
80014e66:	2f d4       	sub	r4,-3
80014e68:	e6 0b 09 4b 	lsl	r11,r3,r11
80014e6c:	20 1b       	sub	r11,1
80014e6e:	0e 0b       	add	r11,r7
80014e70:	f6 04 0a 4b 	lsr	r11,r11,r4
80014e74:	20 1b       	sub	r11,1
80014e76:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80014e7a:	f7 e9 10 09 	or	r9,r11,r9
80014e7e:	99 09       	st.w	r12[0x0],r9
80014e80:	c6 fb       	rjmp	80014d5e <uhd_pipe_trans_complet+0x9a>
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
80014e82:	76 05       	ld.w	r5,r11[0x0]
80014e84:	30 84       	mov	r4,8
80014e86:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80014e8a:	e8 05 09 45 	lsl	r5,r4,r5
80014e8e:	20 15       	sub	r5,1
80014e90:	ef e5 00 05 	and	r5,r7,r5
80014e94:	fe 90 ff 51 	breq	80014d36 <uhd_pipe_trans_complet+0x72>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
80014e98:	30 05       	mov	r5,0
		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
80014e9a:	08 46       	or	r6,r4
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
80014e9c:	f5 d5 d3 c1 	bfins	r10,r5,0x1e,0x1
80014ea0:	91 0a       	st.w	r8[0x0],r10
80014ea2:	c4 ab       	rjmp	80014d36 <uhd_pipe_trans_complet+0x72>
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
80014ea4:	30 06       	mov	r6,0
80014ea6:	c3 ab       	rjmp	80014d1a <uhd_pipe_trans_complet+0x56>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
80014ea8:	76 05       	ld.w	r5,r11[0x0]
80014eaa:	30 87       	mov	r7,8
80014eac:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80014eb0:	ee 05 09 45 	lsl	r5,r7,r5
80014eb4:	ea 07 09 45 	lsl	r5,r5,r7
80014eb8:	e0 45 ff ff 	cp.w	r5,65535
80014ebc:	fe 99 ff 23 	brgt	80014d02 <uhd_pipe_trans_complet+0x3e>
				 max_trans = 256L * uhd_get_pipe_size(pipe);
80014ec0:	76 05       	ld.w	r5,r11[0x0]
80014ec2:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80014ec6:	ee 05 09 47 	lsl	r7,r7,r5
80014eca:	a9 67       	lsl	r7,0x8
80014ecc:	c1 db       	rjmp	80014d06 <uhd_pipe_trans_complet+0x42>
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
80014ece:	76 0a       	ld.w	r10,r11[0x0]
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
80014ed0:	30 85       	mov	r5,8
80014ed2:	f5 da c0 83 	bfextu	r10,r10,0x4,0x3
80014ed6:	ea 0a 09 4a 	lsl	r10,r5,r10
80014eda:	0e 3a       	cp.w	r10,r7
80014edc:	fe 93 ff 2d 	brlo	80014d36 <uhd_pipe_trans_complet+0x72>
80014ee0:	c2 9b       	rjmp	80014d32 <uhd_pipe_trans_complet+0x6e>
80014ee2:	d7 03       	nop

80014ee4 <uhd_ep_run>:
80014ee4:	eb cd 40 f8 	pushm	r3-r7,lr
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014ee8:	fe 6e 00 00 	mov	lr,-131072
80014eec:	fc fe 04 1c 	ld.w	lr,lr[1052]
		bool b_shortpacket,
		uint8_t *buf,
		iram_size_t buf_size,
		uint16_t timeout,
		uhd_callback_trans_t callback)
{
80014ef0:	fa c4 ff e8 	sub	r4,sp,-24
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014ef4:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
		bool b_shortpacket,
		uint8_t *buf,
		iram_size_t buf_size,
		uint16_t timeout,
		uhd_callback_trans_t callback)
{
80014ef8:	68 17       	ld.w	r7,r4[0x4]
80014efa:	68 04       	ld.w	r4,r4[0x0]
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014efc:	c0 90       	breq	80014f0e <uhd_ep_run+0x2a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014efe:	fe 6e 04 24 	mov	lr,-130012
80014f02:	7c 0e       	ld.w	lr,lr[0x0]
80014f04:	fd de c0 07 	bfextu	lr,lr,0x0,0x7
80014f08:	1c 3c       	cp.w	r12,lr
80014f0a:	e0 80 00 cb 	breq	800150a0 <uhd_ep_run+0x1bc>
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80014f0e:	fe 6e 00 00 	mov	lr,-131072
80014f12:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f16:	ed be 00 01 	bld	lr,0x1
80014f1a:	c2 a0       	breq	80014f6e <uhd_ep_run+0x8a>
80014f1c:	fe 6e 00 00 	mov	lr,-131072
80014f20:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f24:	ed be 00 02 	bld	lr,0x2
80014f28:	c3 c0       	breq	80014fa0 <uhd_ep_run+0xbc>
80014f2a:	fe 6e 00 00 	mov	lr,-131072
80014f2e:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f32:	ed be 00 03 	bld	lr,0x3
80014f36:	c4 e0       	breq	80014fd2 <uhd_ep_run+0xee>
80014f38:	fe 6e 00 00 	mov	lr,-131072
80014f3c:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f40:	ed be 00 04 	bld	lr,0x4
80014f44:	c6 00       	breq	80015004 <uhd_ep_run+0x120>
80014f46:	fe 6e 00 00 	mov	lr,-131072
80014f4a:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f4e:	ed be 00 05 	bld	lr,0x5
80014f52:	c7 20       	breq	80015036 <uhd_ep_run+0x152>
80014f54:	fe 6e 00 00 	mov	lr,-131072
80014f58:	fc fe 04 1c 	ld.w	lr,lr[1052]
80014f5c:	ed be 00 06 	bld	lr,0x6
80014f60:	e0 80 00 85 	breq	8001506a <uhd_ep_run+0x186>
	uint8_t pipe;
	uhd_pipe_job_t *ptr_job;

	pipe = uhd_get_pipe(add,endp);
	if (pipe == AVR32_USBB_EPT_NUM) {
	  print_dbg("\r\n uhd error: pipe not found");
80014f64:	4f 0c       	lddpc	r12,80015124 <uhd_ep_run+0x240>
80014f66:	fe b0 f0 1b 	rcall	80012f9c <print_dbg>
80014f6a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014f6e:	fe 6e 04 24 	mov	lr,-130012
80014f72:	7c 0e       	ld.w	lr,lr[0x0]
80014f74:	fd de c1 07 	bfextu	lr,lr,0x8,0x7
80014f78:	1c 3c       	cp.w	r12,lr
80014f7a:	cd 11       	brne	80014f1c <uhd_ep_run+0x38>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80014f7c:	fe 6e 05 04 	mov	lr,-129788
80014f80:	7c 06       	ld.w	r6,lr[0x0]
80014f82:	7c 05       	ld.w	r5,lr[0x0]
80014f84:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80014f88:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80014f8c:	e0 6e 00 80 	mov	lr,128
80014f90:	58 15       	cp.w	r5,1
80014f92:	f9 be 01 00 	movne	lr,0
80014f96:	0c 4e       	or	lr,r6
80014f98:	1c 3b       	cp.w	r11,lr
80014f9a:	cc 11       	brne	80014f1c <uhd_ep_run+0x38>
80014f9c:	30 1c       	mov	r12,1
80014f9e:	c9 38       	rjmp	800150c4 <uhd_ep_run+0x1e0>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014fa0:	fe 6e 04 24 	mov	lr,-130012
80014fa4:	7c 0e       	ld.w	lr,lr[0x0]
80014fa6:	fd de c2 07 	bfextu	lr,lr,0x10,0x7
80014faa:	1c 3c       	cp.w	r12,lr
80014fac:	cb f1       	brne	80014f2a <uhd_ep_run+0x46>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80014fae:	fe 6e 05 08 	mov	lr,-129784
80014fb2:	7c 06       	ld.w	r6,lr[0x0]
80014fb4:	7c 05       	ld.w	r5,lr[0x0]
80014fb6:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80014fba:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80014fbe:	e0 6e 00 80 	mov	lr,128
80014fc2:	58 15       	cp.w	r5,1
80014fc4:	f9 be 01 00 	movne	lr,0
80014fc8:	0c 4e       	or	lr,r6
80014fca:	1c 3b       	cp.w	r11,lr
80014fcc:	ca f1       	brne	80014f2a <uhd_ep_run+0x46>
80014fce:	30 2c       	mov	r12,2
80014fd0:	c7 a8       	rjmp	800150c4 <uhd_ep_run+0x1e0>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80014fd2:	fe 6e 04 24 	mov	lr,-130012
80014fd6:	7c 0e       	ld.w	lr,lr[0x0]
80014fd8:	fd de c3 07 	bfextu	lr,lr,0x18,0x7
80014fdc:	1c 3c       	cp.w	r12,lr
80014fde:	ca d1       	brne	80014f38 <uhd_ep_run+0x54>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80014fe0:	fe 6e 05 0c 	mov	lr,-129780
80014fe4:	7c 06       	ld.w	r6,lr[0x0]
80014fe6:	7c 05       	ld.w	r5,lr[0x0]
80014fe8:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80014fec:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80014ff0:	e0 6e 00 80 	mov	lr,128
80014ff4:	58 15       	cp.w	r5,1
80014ff6:	f9 be 01 00 	movne	lr,0
80014ffa:	0c 4e       	or	lr,r6
80014ffc:	1c 3b       	cp.w	r11,lr
80014ffe:	c9 d1       	brne	80014f38 <uhd_ep_run+0x54>
80015000:	30 3c       	mov	r12,3
80015002:	c6 18       	rjmp	800150c4 <uhd_ep_run+0x1e0>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80015004:	fe 6e 04 28 	mov	lr,-130008
80015008:	7c 0e       	ld.w	lr,lr[0x0]
8001500a:	fd de c0 07 	bfextu	lr,lr,0x0,0x7
8001500e:	1c 3c       	cp.w	r12,lr
80015010:	c9 b1       	brne	80014f46 <uhd_ep_run+0x62>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80015012:	fe 6e 05 10 	mov	lr,-129776
80015016:	7c 06       	ld.w	r6,lr[0x0]
80015018:	7c 05       	ld.w	r5,lr[0x0]
8001501a:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
8001501e:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80015022:	e0 6e 00 80 	mov	lr,128
80015026:	58 15       	cp.w	r5,1
80015028:	f9 be 01 00 	movne	lr,0
8001502c:	0c 4e       	or	lr,r6
8001502e:	1c 3b       	cp.w	r11,lr
80015030:	c8 b1       	brne	80014f46 <uhd_ep_run+0x62>
80015032:	30 4c       	mov	r12,4
80015034:	c4 88       	rjmp	800150c4 <uhd_ep_run+0x1e0>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80015036:	fe 6e 04 28 	mov	lr,-130008
8001503a:	7c 0e       	ld.w	lr,lr[0x0]
8001503c:	fd de c1 07 	bfextu	lr,lr,0x8,0x7
80015040:	1c 3c       	cp.w	r12,lr
80015042:	c8 91       	brne	80014f54 <uhd_ep_run+0x70>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80015044:	fe 6e 05 14 	mov	lr,-129772
80015048:	7c 06       	ld.w	r6,lr[0x0]
8001504a:	7c 05       	ld.w	r5,lr[0x0]
8001504c:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
80015050:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80015054:	e0 6e 00 80 	mov	lr,128
80015058:	58 15       	cp.w	r5,1
8001505a:	f9 be 01 00 	movne	lr,0
8001505e:	0c 4e       	or	lr,r6
80015060:	1c 3b       	cp.w	r11,lr
80015062:	fe 91 ff 79 	brne	80014f54 <uhd_ep_run+0x70>
80015066:	30 5c       	mov	r12,5
80015068:	c2 e8       	rjmp	800150c4 <uhd_ep_run+0x1e0>
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
8001506a:	fe 6e 04 28 	mov	lr,-130008
8001506e:	7c 0e       	ld.w	lr,lr[0x0]
80015070:	fd de c2 07 	bfextu	lr,lr,0x10,0x7
80015074:	1c 3c       	cp.w	r12,lr
80015076:	fe 91 ff 77 	brne	80014f64 <uhd_ep_run+0x80>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
8001507a:	fe 6c 05 18 	mov	r12,-129768
8001507e:	78 0e       	ld.w	lr,r12[0x0]
80015080:	78 06       	ld.w	r6,r12[0x0]
80015082:	fd de c2 04 	bfextu	lr,lr,0x10,0x4
80015086:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
8001508a:	e0 6c 00 80 	mov	r12,128
8001508e:	58 16       	cp.w	r6,1
80015090:	f9 bc 01 00 	movne	r12,0
80015094:	1c 4c       	or	r12,lr
80015096:	18 3b       	cp.w	r11,r12
80015098:	fe 91 ff 66 	brne	80014f64 <uhd_ep_run+0x80>
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
	return true;
8001509c:	30 6c       	mov	r12,6
8001509e:	c1 38       	rjmp	800150c4 <uhd_ep_run+0x1e0>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
800150a0:	fe 6e 05 00 	mov	lr,-129792
800150a4:	7c 06       	ld.w	r6,lr[0x0]
800150a6:	7c 05       	ld.w	r5,lr[0x0]
800150a8:	ed d6 c2 04 	bfextu	r6,r6,0x10,0x4
800150ac:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
800150b0:	e0 6e 00 80 	mov	lr,128
800150b4:	58 15       	cp.w	r5,1
800150b6:	f9 be 01 00 	movne	lr,0
800150ba:	0c 4e       	or	lr,r6
800150bc:	1c 3b       	cp.w	r11,lr
800150be:	fe 91 ff 28 	brne	80014f0e <uhd_ep_run+0x2a>
800150c2:	30 0c       	mov	r12,0
	  print_dbg("\r\n uhd error: pipe not found");
		return false; // pipe not found
	}

	// Get job about pipe
	ptr_job = &uhd_pipe_job[pipe-1];
800150c4:	f8 cb 00 01 	sub	r11,r12,1
800150c8:	e0 6e 06 b0 	mov	lr,1712
800150cc:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800150d0:	fc 0b 00 2b 	add	r11,lr,r11<<0x2

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800150d4:	e1 b6 00 00 	mfsr	r6,0x0
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
800150d8:	d3 03       	ssrf	0x10
800150da:	76 0e       	ld.w	lr,r11[0x0]
800150dc:	1c 93       	mov	r3,lr
800150de:	e6 13 80 00 	andh	r3,0x8000,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800150e2:	c0 70       	breq	800150f0 <uhd_ep_run+0x20c>
800150e4:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
800150e8:	c0 21       	brne	800150ec <uhd_ep_run+0x208>
   }

	barrier();
800150ea:	d5 03       	csrf	0x10
800150ec:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		cpu_irq_restore(flags);
		//		print_dbg("\r\n uhd error: job is already underway");
		return false; // Job already on going
	}
	ptr_job->busy = true;
800150f0:	30 15       	mov	r5,1
800150f2:	fd d5 d3 e1 	bfins	lr,r5,0x1f,0x1

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
800150f6:	97 0e       	st.w	r11[0x0],lr
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
800150f8:	b6 14       	st.h	r11[0x2],r4
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->call_end = callback;
800150fa:	97 28       	st.w	r11[0x8],r8
	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
800150fc:	97 47       	st.w	r11[0x10],r7
		return false; // Job already on going
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
800150fe:	76 08       	ld.w	r8,r11[0x0]
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80015100:	97 19       	st.w	r11[0x4],r9
80015102:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
80015106:	97 33       	st.w	r11[0xc],r3
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015108:	97 08       	st.w	r11[0x0],r8
8001510a:	e6 16 00 01 	andh	r6,0x1,COH
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
8001510e:	c0 50       	breq	80015118 <uhd_ep_run+0x234>
80015110:	fe b0 fd da 	rcall	80014cc4 <uhd_pipe_trans_complet>
80015114:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
80015118:	d5 03       	csrf	0x10
8001511a:	fe b0 fd d5 	rcall	80014cc4 <uhd_pipe_trans_complet>
8001511e:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
80015122:	d7 03       	nop
80015124:	80 02       	ld.sh	r2,r0[0x0]
80015126:	40 20       	lddsp	r0,sp[0x8]

80015128 <otg_interrupt>:
80015128:	d4 31       	pushm	r0-r7,lr
8001512a:	20 1d       	sub	sp,4
8001512c:	fe 69 08 04 	mov	r9,-129020
ISR(otg_interrupt, AVR32_USBB_IRQ_GROUP, UHD_USB_INT_LEVEL)
{
	bool b_mode_device;

#ifdef USB_ID
	if (Is_otg_id_transition()) {
80015130:	72 08       	ld.w	r8,r9[0x0]
80015132:	ed b8 00 00 	bld	r8,0x0
80015136:	c0 c0       	breq	8001514e <otg_interrupt+0x26>
			UHC_MODE_CHANGE(true);
			uhc_start();
		}
		return;
	}
	b_mode_device = Is_otg_id_device();
80015138:	72 08       	ld.w	r8,r9[0x0]
#else
	b_mode_device = Is_otg_device_mode_forced();
#endif

	// Redirection to host or device interrupt
	if (b_mode_device) {
8001513a:	ed b8 00 0a 	bld	r8,0xa
8001513e:	c2 e1       	brne	8001519a <otg_interrupt+0x72>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
80015140:	fe 68 00 00 	mov	r8,-131072
80015144:	f0 f8 08 18 	ld.w	r8,r8[2072]
}
80015148:	2f fd       	sub	sp,-4
8001514a:	d4 32       	popm	r0-r7,lr
8001514c:	d6 03       	rete
{
	bool b_mode_device;

#ifdef USB_ID
	if (Is_otg_id_transition()) {
		while (!Is_otg_clock_usable());
8001514e:	72 08       	ld.w	r8,r9[0x0]
80015150:	ed b8 00 0e 	bld	r8,0xe
80015154:	cf d1       	brne	8001514e <otg_interrupt+0x26>
		otg_unfreeze_clock();
80015156:	fe 68 08 00 	mov	r8,-129024
8001515a:	70 09       	ld.w	r9,r8[0x0]
8001515c:	af c9       	cbr	r9,0xe
8001515e:	91 09       	st.w	r8[0x0],r9
		otg_ack_id_transition();
80015160:	30 1c       	mov	r12,1
80015162:	fe 69 08 08 	mov	r9,-129016
80015166:	93 0c       	st.w	r9[0x0],r12
		otg_freeze_clock();
80015168:	70 09       	ld.w	r9,r8[0x0]
8001516a:	af a9       	sbr	r9,0xe
8001516c:	91 09       	st.w	r8[0x0],r9
		if (Is_otg_id_device()) {
8001516e:	fe 68 08 04 	mov	r8,-129020
80015172:	70 08       	ld.w	r8,r8[0x0]
80015174:	ed b8 00 0a 	bld	r8,0xa
80015178:	c0 a1       	brne	8001518c <otg_interrupt+0x64>
			uhc_stop(false);
8001517a:	30 0c       	mov	r12,0
8001517c:	e0 a0 06 f4 	rcall	80015f64 <uhc_stop>
			UHC_MODE_CHANGE(false);
80015180:	30 0c       	mov	r12,0
80015182:	e0 a0 29 a9 	rcall	8001a4d4 <usb_mode_change>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80015186:	2f fd       	sub	sp,-4
80015188:	d4 32       	popm	r0-r7,lr
8001518a:	d6 03       	rete
			uhc_stop(false);
			UHC_MODE_CHANGE(false);
			udc_start();
		} else {
			udc_stop();
			UHC_MODE_CHANGE(true);
8001518c:	e0 a0 29 a4 	rcall	8001a4d4 <usb_mode_change>
			uhc_start();
80015190:	e0 a0 06 ee 	rcall	80015f6c <uhc_start>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80015194:	2f fd       	sub	sp,-4
80015196:	d4 32       	popm	r0-r7,lr
80015198:	d6 03       	rete
static void uhd_interrupt(void)
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
8001519a:	fe 6a 04 04 	mov	r10,-130044
8001519e:	74 08       	ld.w	r8,r10[0x0]
800151a0:	ed b8 00 05 	bld	r8,0x5
800151a4:	e0 80 00 a5 	breq	800152ee <otg_interrupt+0x1c6>
		uhd_sof_interrupt();
		return;
	}

	// Manage pipe interrupts
	pipe_int = uhd_get_interrupt_pipe_number();
800151a8:	fe 69 00 00 	mov	r9,-131072
800151ac:	f2 f8 04 04 	ld.w	r8,r9[1028]
800151b0:	f2 fc 04 10 	ld.w	r12,r9[1040]
800151b4:	a9 88       	lsr	r8,0x8
800151b6:	f1 ec 02 8c 	and	r12,r8,r12>>0x8
800151ba:	a7 bc       	sbr	r12,0x7
800151bc:	5c 9c       	brev	r12
800151be:	f8 0c 12 00 	clz	r12,r12
	if (pipe_int == 0) {
800151c2:	e0 80 00 c3 	breq	80015348 <otg_interrupt+0x220>
		// Interrupt acked by control endpoint managed
		uhd_ctrl_interrupt();
		return;
	}
	if (pipe_int != AVR32_USBB_EPT_NUM) {
800151c6:	30 78       	mov	r8,7
800151c8:	f0 0c 18 00 	cp.b	r12,r8
800151cc:	c5 c1       	brne	80015284 <otg_interrupt+0x15c>
		// Interrupt acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt(pipe_int);
		return;
	}
	pipe_int = uhd_get_pipe_dma_interrupt_number();
800151ce:	f2 fb 04 04 	ld.w	r11,r9[1028]
800151d2:	f2 fc 04 10 	ld.w	r12,r9[1040]
800151d6:	b9 9b       	lsr	r11,0x19
800151d8:	f7 ec 03 9b 	and	r11,r11,r12>>0x19
800151dc:	a7 ab       	sbr	r11,0x6
800151de:	5c 9b       	brev	r11
800151e0:	f6 0b 12 00 	clz	r11,r11
800151e4:	f6 cc ff ff 	sub	r12,r11,-1
	if (pipe_int != AVR32_USBB_EPT_NUM) {
800151e8:	f0 0c 18 00 	cp.b	r12,r8
800151ec:	c3 b0       	breq	80015262 <otg_interrupt+0x13a>
static void uhd_pipe_interrupt_dma(uint8_t pipe)
{
	uhd_pipe_job_t *ptr_job;
	uint32_t nb_remaining;

	if (uhd_pipe_dma_get_status(pipe)
800151ee:	f8 08 15 04 	lsl	r8,r12,0x4
800151f2:	e0 38 f9 00 	sub	r8,129280
800151f6:	70 39       	ld.w	r9,r8[0xc]
800151f8:	ed b9 00 00 	bld	r9,0x0
800151fc:	ca 20       	breq	80015140 <otg_interrupt+0x18>
			& AVR32_USBB_UHDMA1_STATUS_CH_EN_MASK) {
		return; // Ignore EOT_STA interrupt
	}
	// Save number of data no transfered
	nb_remaining = (uhd_pipe_dma_get_status(pipe) &
800151fe:	70 3b       	ld.w	r11,r8[0xc]
80015200:	b1 8b       	lsr	r11,0x10
			AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_MASK)
			>> AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_OFFSET;
	if (nb_remaining) {
80015202:	c0 d0       	breq	8001521c <otg_interrupt+0xf4>
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];
80015204:	e0 69 06 b0 	mov	r9,1712
80015208:	f8 c8 00 01 	sub	r8,r12,1
8001520c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80015210:	f2 08 00 28 	add	r8,r9,r8<<0x2

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
80015214:	70 39       	ld.w	r9,r8[0xc]
80015216:	16 19       	sub	r9,r11

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
80015218:	91 29       	st.w	r8[0x8],r9
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
8001521a:	91 39       	st.w	r8[0xc],r9

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}

	if (uhd_is_pipe_out(pipe)) {
8001521c:	f8 0a 15 02 	lsl	r10,r12,0x2
80015220:	fe 69 05 00 	mov	r9,-129792
80015224:	f4 09 00 08 	add	r8,r10,r9
80015228:	70 08       	ld.w	r8,r8[0x0]
8001522a:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
8001522e:	58 28       	cp.w	r8,2
80015230:	e0 80 02 35 	breq	8001569a <otg_interrupt+0x572>
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
	} else {
		if (!Is_uhd_pipe_frozen(pipe)) {
80015234:	fe 68 05 c0 	mov	r8,-129600
80015238:	f4 08 00 09 	add	r9,r10,r8
8001523c:	72 08       	ld.w	r8,r9[0x0]
8001523e:	ed b8 00 11 	bld	r8,0x11
80015242:	c0 80       	breq	80015252 <otg_interrupt+0x12a>
			// Pipe is not freeze in case of :
			// - incomplete transfer when the request number INRQ is not complete.
			// - low USB speed and with a high CPU frequency,
			// a ACK from host can be always running on USB line.

			if (nb_remaining) {
80015244:	58 0b       	cp.w	r11,0
80015246:	c0 90       	breq	80015258 <otg_interrupt+0x130>
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
80015248:	e0 3a fa 10 	sub	r10,129552
8001524c:	e2 68 00 00 	mov	r8,131072
80015250:	95 08       	st.w	r10[0x0],r8
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
				}
			}
		}
		uhd_pipe_trans_complet(pipe);
80015252:	fe b0 fd 39 	rcall	80014cc4 <uhd_pipe_trans_complet>
80015256:	c7 5b       	rjmp	80015140 <otg_interrupt+0x18>
			if (nb_remaining) {
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
			} else {
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
80015258:	72 08       	ld.w	r8,r9[0x0]
8001525a:	ed b8 00 11 	bld	r8,0x11
8001525e:	cf d1       	brne	80015258 <otg_interrupt+0x130>
80015260:	cf 9b       	rjmp	80015252 <otg_interrupt+0x12a>
		// Interrupt DMA acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt_dma(pipe_int);
		return;
	}
	// USB bus reset detection
	if (Is_uhd_reset_sent()) {
80015262:	74 08       	ld.w	r8,r10[0x0]
80015264:	e2 18 00 04 	andl	r8,0x4,COH
80015268:	e0 80 01 79 	breq	8001555a <otg_interrupt+0x432>
		uhd_ack_reset_sent();
8001526c:	fe 68 04 08 	mov	r8,-130040
80015270:	30 49       	mov	r9,4
80015272:	91 09       	st.w	r8[0x0],r9
		if (uhd_reset_callback != NULL) {
80015274:	e0 68 06 ac 	mov	r8,1708
80015278:	70 08       	ld.w	r8,r8[0x0]
8001527a:	58 08       	cp.w	r8,0
8001527c:	fe 90 ff 62 	breq	80015140 <otg_interrupt+0x18>
			uhd_reset_callback();
80015280:	5d 18       	icall	r8
80015282:	c5 fb       	rjmp	80015140 <otg_interrupt+0x18>
 *
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
80015284:	fe 68 05 c0 	mov	r8,-129600
80015288:	f8 0b 15 02 	lsl	r11,r12,0x2
8001528c:	f6 08 00 0e 	add	lr,r11,r8
80015290:	7c 08       	ld.w	r8,lr[0x0]
80015292:	ed b8 00 0c 	bld	r8,0xc
80015296:	e0 81 00 95 	brne	800153c0 <otg_interrupt+0x298>
8001529a:	fe 68 05 30 	mov	r8,-129744
8001529e:	f6 08 00 09 	add	r9,r11,r8
800152a2:	72 0a       	ld.w	r10,r9[0x0]
800152a4:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
800152a8:	e0 80 02 00 	breq	800156a8 <otg_interrupt+0x580>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
800152ac:	7c 08       	ld.w	r8,lr[0x0]
800152ae:	ed b8 00 01 	bld	r8,0x1
800152b2:	c0 61       	brne	800152be <otg_interrupt+0x196>
800152b4:	72 08       	ld.w	r8,r9[0x0]
800152b6:	ed b8 00 01 	bld	r8,0x1
800152ba:	e0 80 01 a5 	breq	80015604 <otg_interrupt+0x4dc>
		uhd_ack_fifocon(pipe);
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
800152be:	72 08       	ld.w	r8,r9[0x0]
800152c0:	e2 18 00 40 	andl	r8,0x40,COH
800152c4:	e0 81 01 d9 	brne	80015676 <otg_interrupt+0x54e>
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
800152c8:	72 09       	ld.w	r9,r9[0x0]
800152ca:	ed b9 00 03 	bld	r9,0x3
800152ce:	fe 91 ff 39 	brne	80015140 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
800152d2:	e0 3b f9 80 	sub	r11,129408
800152d6:	76 09       	ld.w	r9,r11[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
800152d8:	97 08       	st.w	r11[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
800152da:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
800152de:	20 18       	sub	r8,1
800152e0:	58 28       	cp.w	r8,2
800152e2:	e0 88 01 a9 	brls	80015634 <otg_interrupt+0x50c>
800152e6:	30 6b       	mov	r11,6
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
		// Get and ack error
		uhd_ep_abort_pipe(pipe, uhd_pipe_get_error(pipe));
800152e8:	fe b0 fc 1c 	rcall	80014b20 <uhd_ep_abort_pipe>
800152ec:	c2 ab       	rjmp	80015140 <otg_interrupt+0x18>
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
		uhd_ack_sof();
800152ee:	32 09       	mov	r9,32
800152f0:	fe 68 04 08 	mov	r8,-130040
800152f4:	91 09       	st.w	r8[0x0],r9
			return;
		}
	}

	// Manage a delay to enter in suspend
	if (uhd_suspend_start) {
800152f6:	e0 68 07 28 	mov	r8,1832
800152fa:	11 89       	ld.ub	r9,r8[0x0]
800152fc:	58 09       	cp.w	r9,0
800152fe:	c6 60       	breq	800153ca <otg_interrupt+0x2a2>
		if (--uhd_suspend_start == 0) {
80015300:	20 19       	sub	r9,1
80015302:	5c 59       	castu.b	r9
80015304:	b0 89       	st.b	r8[0x0],r9
80015306:	fe 91 ff 1d 	brne	80015140 <otg_interrupt+0x18>
			// then wait end of SOF generation
			// to be sure that disable SOF has been accepted
#ifdef AVR32_USBB_USBSTA_SPEED_HIGH // If UTMI
			while (115<uhd_get_frame_position()) {
#else
			while (185<uhd_get_frame_position()) {
8001530a:	fe 69 04 20 	mov	r9,-130016
8001530e:	72 08       	ld.w	r8,r9[0x0]
80015310:	f1 d8 c2 08 	bfextu	r8,r8,0x10,0x8
80015314:	e0 48 00 b9 	cp.w	r8,185
80015318:	e0 88 00 06 	brls	80015324 <otg_interrupt+0x1fc>
#endif
				if (Is_uhd_disconnection()) {
8001531c:	74 08       	ld.w	r8,r10[0x0]
8001531e:	ed b8 00 01 	bld	r8,0x1
80015322:	cf 61       	brne	8001530e <otg_interrupt+0x1e6>
					break;
				}
			}
			uhd_disable_sof();
80015324:	fe 69 04 00 	mov	r9,-130048
80015328:	72 08       	ld.w	r8,r9[0x0]
8001532a:	a9 c8       	cbr	r8,0x8
8001532c:	93 08       	st.w	r9[0x0],r8

			// Ack previous wakeup and resumes interrupts
			AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_HWUPIC_MASK
8001532e:	fe 68 00 00 	mov	r8,-131072
80015332:	35 89       	mov	r9,88
80015334:	f1 49 04 08 	st.w	r8[1032],r9
					|AVR32_USBB_UHINTCLR_RSMEDIC_MASK
					|AVR32_USBB_UHINTCLR_RXRSMIC_MASK;

			// Enable wakeup/resumes interrupts
			AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_HWUPIES_MASK
80015338:	f1 49 04 18 	st.w	r8[1048],r9
					|AVR32_USBB_UHINTESET_RSMEDIES_MASK
					|AVR32_USBB_UHINTESET_RXRSMIES_MASK;

			otg_freeze_clock();
8001533c:	fe 69 08 00 	mov	r9,-129024
80015340:	72 08       	ld.w	r8,r9[0x0]
80015342:	af a8       	sbr	r8,0xe
80015344:	93 08       	st.w	r9[0x0],r8
80015346:	cf da       	rjmp	80015140 <otg_interrupt+0x18>
{
	// A setup request is on-going
	Assert(uhd_ctrl_request_timeout!=0);

	// Disable setup, IN and OUT interrupts of control endpoint
	AVR32_USBB.upcon0clr = AVR32_USBB_UPCON0CLR_TXSTPEC_MASK
80015348:	30 78       	mov	r8,7
8001534a:	f3 48 06 20 	st.w	r9[1568],r8
			| AVR32_USBB_UPCON0CLR_RXINEC_MASK
			| AVR32_USBB_UPCON0CLR_TXOUTEC_MASK;

	// Search event on control endpoint
	if (Is_uhd_setup_ready(0)) {
8001534e:	fe 69 05 30 	mov	r9,-129744
80015352:	72 08       	ld.w	r8,r9[0x0]
80015354:	ed b8 00 02 	bld	r8,0x2
80015358:	c7 91       	brne	8001544a <otg_interrupt+0x322>
		// SETUP packet sent
		uhd_freeze_pipe(0);
8001535a:	fe 6b 05 f0 	mov	r11,-129552
8001535e:	e2 69 00 00 	mov	r9,131072
80015362:	97 09       	st.w	r11[0x0],r9
		uhd_ack_setup_ready(0);
80015364:	30 4a       	mov	r10,4
80015366:	fe 68 05 60 	mov	r8,-129696
8001536a:	91 0a       	st.w	r8[0x0],r10
		Assert(uhd_ctrl_request_phase == UHD_CTRL_REQ_PHASE_SETUP);

		// Start DATA phase
		if ((uhd_ctrl_request_first->req.bmRequestType & USB_REQ_DIR_MASK)
8001536c:	e0 67 2d 08 	mov	r7,11528
80015370:	18 9e       	mov	lr,r12
80015372:	6e 0a       	ld.w	r10,r7[0x0]
80015374:	15 96       	ld.ub	r6,r10[0x1]
80015376:	f8 06 18 00 	cp.b	r6,r12
8001537a:	e0 85 02 e5 	brlt	80015944 <otg_interrupt+0x81c>
				== USB_REQ_DIR_IN ) {
			uhd_ctrl_phase_data_in_start();
		} else {
			if (uhd_ctrl_request_first->req.wLength) {
8001537e:	15 f6       	ld.ub	r6,r10[0x7]
80015380:	f5 3e 00 08 	ld.ub	lr,r10[8]
80015384:	fd e6 10 8e 	or	lr,lr,r6<<0x8
80015388:	f8 0e 19 00 	cp.h	lr,r12
8001538c:	e0 81 01 ce 	brne	80015728 <otg_interrupt+0x600>
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80015390:	fe 6c 05 00 	mov	r12,-129792
80015394:	78 0a       	ld.w	r10,r12[0x0]
80015396:	e0 1a fc ff 	andl	r10,0xfcff
8001539a:	a9 aa       	sbr	r10,0x8
8001539c:	99 0a       	st.w	r12[0x0],r10
	uhd_ack_in_received(0);
8001539e:	30 1a       	mov	r10,1
800153a0:	91 0a       	st.w	r8[0x0],r10
	uhd_ack_short_packet(0);
800153a2:	e0 6c 00 80 	mov	r12,128
800153a6:	91 0c       	st.w	r8[0x0],r12
	uhd_enable_in_received_interrupt(0);
800153a8:	97 0a       	st.w	r11[0x0],r10
	uhd_ack_fifocon(0);
800153aa:	fe 68 06 20 	mov	r8,-129504
800153ae:	e0 6a 40 00 	mov	r10,16384
800153b2:	91 0a       	st.w	r8[0x0],r10
	uhd_unfreeze_pipe(0);
800153b4:	91 09       	st.w	r8[0x0],r9
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
800153b6:	30 39       	mov	r9,3
800153b8:	e0 68 2d 04 	mov	r8,11524
800153bc:	91 09       	st.w	r8[0x0],r9
800153be:	cc 1a       	rjmp	80015140 <otg_interrupt+0x18>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800153c0:	fe 68 05 30 	mov	r8,-129744
800153c4:	f6 08 00 09 	add	r9,r11,r8
800153c8:	c7 2b       	rjmp	800152ac <otg_interrupt+0x184>
			uhd_sleep_mode(UHD_STATE_SUSPEND);
		}
		return; // Abort SOF events
	}
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
800153ca:	e0 68 07 2a 	mov	r8,1834
800153ce:	11 89       	ld.ub	r9,r8[0x0]
800153d0:	58 09       	cp.w	r9,0
800153d2:	c5 90       	breq	80015484 <otg_interrupt+0x35c>
		if (--uhd_resume_start == 0) {
800153d4:	20 19       	sub	r9,1
800153d6:	5c 59       	castu.b	r9
800153d8:	b0 89       	st.b	r8[0x0],r9
800153da:	fe 91 fe b3 	brne	80015140 <otg_interrupt+0x18>
800153de:	e0 68 07 29 	mov	r8,1833
800153e2:	11 88       	ld.ub	r8,r8[0x0]
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
800153e4:	ed b8 00 01 	bld	r8,0x1
800153e8:	c0 61       	brne	800153f4 <otg_interrupt+0x2cc>
					uhd_unfreeze_pipe(pipe);
800153ea:	e2 6a 00 00 	mov	r10,131072
800153ee:	fe 69 06 24 	mov	r9,-129500
800153f2:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
800153f4:	ed b8 00 02 	bld	r8,0x2
800153f8:	c0 61       	brne	80015404 <otg_interrupt+0x2dc>
					uhd_unfreeze_pipe(pipe);
800153fa:	e2 6a 00 00 	mov	r10,131072
800153fe:	fe 69 06 28 	mov	r9,-129496
80015402:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80015404:	ed b8 00 03 	bld	r8,0x3
80015408:	c0 61       	brne	80015414 <otg_interrupt+0x2ec>
					uhd_unfreeze_pipe(pipe);
8001540a:	e2 6a 00 00 	mov	r10,131072
8001540e:	fe 69 06 2c 	mov	r9,-129492
80015412:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80015414:	ed b8 00 04 	bld	r8,0x4
80015418:	c0 61       	brne	80015424 <otg_interrupt+0x2fc>
					uhd_unfreeze_pipe(pipe);
8001541a:	e2 6a 00 00 	mov	r10,131072
8001541e:	fe 69 06 30 	mov	r9,-129488
80015422:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80015424:	ed b8 00 05 	bld	r8,0x5
80015428:	c0 61       	brne	80015434 <otg_interrupt+0x30c>
					uhd_unfreeze_pipe(pipe);
8001542a:	e2 6a 00 00 	mov	r10,131072
8001542e:	fe 69 06 34 	mov	r9,-129484
80015432:	93 0a       	st.w	r9[0x0],r10
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80015434:	ed b8 00 06 	bld	r8,0x6
80015438:	c0 61       	brne	80015444 <otg_interrupt+0x31c>
					uhd_unfreeze_pipe(pipe);
8001543a:	e2 69 00 00 	mov	r9,131072
8001543e:	fe 68 06 38 	mov	r8,-129480
80015442:	91 09       	st.w	r8[0x0],r9
				}
			}
			uhc_notify_resume();
80015444:	e0 a0 09 62 	rcall	80016708 <uhc_notify_resume>
80015448:	c7 ca       	rjmp	80015140 <otg_interrupt+0x18>
				uhd_ctrl_phase_zlp_in();
			}
		}
		return;
	}
	if (Is_uhd_in_received(0)) {
8001544a:	72 0c       	ld.w	r12,r9[0x0]
8001544c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80015450:	e0 80 00 f8 	breq	80015640 <otg_interrupt+0x518>
		// In case of low USB speed and with a high CPU frequency,
		// a ACK from host can be always running on USB line
		// then wait end of ACK on IN pipe.
		while(!Is_uhd_pipe_frozen(0));
80015454:	fe 69 05 c0 	mov	r9,-129600
80015458:	72 08       	ld.w	r8,r9[0x0]
8001545a:	ed b8 00 11 	bld	r8,0x11
8001545e:	cf d1       	brne	80015458 <otg_interrupt+0x330>

		// IN packet received
		uhd_ack_in_received(0);
80015460:	fe 68 05 60 	mov	r8,-129696
80015464:	30 19       	mov	r9,1
80015466:	91 09       	st.w	r8[0x0],r9
		switch(uhd_ctrl_request_phase) {
80015468:	e0 60 2d 04 	mov	r0,11524
8001546c:	60 08       	ld.w	r8,r0[0x0]
8001546e:	58 28       	cp.w	r8,2
80015470:	e0 80 02 14 	breq	80015898 <otg_interrupt+0x770>
80015474:	58 38       	cp.w	r8,3
80015476:	fe 91 fe 65 	brne	80015140 <otg_interrupt+0x18>
		case UHD_CTRL_REQ_PHASE_DATA_IN:
			uhd_ctrl_phase_data_in();
			break;
		case UHD_CTRL_REQ_PHASE_ZLP_IN:
			uhd_ctrl_request_end(UHD_TRANS_NOERROR);
8001547a:	30 0c       	mov	r12,0
8001547c:	fe b0 f9 de 	rcall	80014838 <uhd_ctrl_request_end>
80015480:	fe 9f fe 60 	bral	80015140 <otg_interrupt+0x18>
			uhc_notify_resume();
		}
		return; // Abort SOF events
	}
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
80015484:	e0 68 2d 14 	mov	r8,11540
80015488:	90 09       	ld.sh	r9,r8[0x0]
8001548a:	58 09       	cp.w	r9,0
8001548c:	c0 80       	breq	8001549c <otg_interrupt+0x374>
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
8001548e:	90 09       	ld.sh	r9,r8[0x0]
80015490:	20 19       	sub	r9,1
80015492:	b0 09       	st.h	r8[0x0],r9
80015494:	90 08       	ld.sh	r8,r8[0x0]
80015496:	58 08       	cp.w	r8,0
80015498:	e0 80 03 07 	breq	80015aa6 <otg_interrupt+0x97e>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
8001549c:	e0 67 06 b0 	mov	r7,1712
800154a0:	6e 08       	ld.w	r8,r7[0x0]
800154a2:	58 08       	cp.w	r8,0
800154a4:	c0 94       	brge	800154b6 <otg_interrupt+0x38e>
			if (ptr_job->timeout) {
800154a6:	8e 18       	ld.sh	r8,r7[0x2]
800154a8:	58 08       	cp.w	r8,0
800154aa:	c0 60       	breq	800154b6 <otg_interrupt+0x38e>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
800154ac:	20 18       	sub	r8,1
800154ae:	5c 88       	casts.h	r8
800154b0:	ae 18       	st.h	r7[0x2],r8
800154b2:	e0 80 03 99 	breq	80015be4 <otg_interrupt+0xabc>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
800154b6:	e0 68 06 b0 	mov	r8,1712
800154ba:	6e 59       	ld.w	r9,r7[0x14]
800154bc:	58 09       	cp.w	r9,0
800154be:	c0 b4       	brge	800154d4 <otg_interrupt+0x3ac>
			if (ptr_job->timeout) {
800154c0:	f1 09 00 16 	ld.sh	r9,r8[22]
800154c4:	58 09       	cp.w	r9,0
800154c6:	c0 70       	breq	800154d4 <otg_interrupt+0x3ac>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
800154c8:	20 19       	sub	r9,1
800154ca:	5c 89       	casts.h	r9
800154cc:	f1 59 00 16 	st.h	r8[22],r9
800154d0:	e0 80 03 90 	breq	80015bf0 <otg_interrupt+0xac8>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
800154d4:	e0 68 06 b0 	mov	r8,1712
800154d8:	6e a9       	ld.w	r9,r7[0x28]
800154da:	58 09       	cp.w	r9,0
800154dc:	c0 b4       	brge	800154f2 <otg_interrupt+0x3ca>
			if (ptr_job->timeout) {
800154de:	f1 09 00 2a 	ld.sh	r9,r8[42]
800154e2:	58 09       	cp.w	r9,0
800154e4:	c0 70       	breq	800154f2 <otg_interrupt+0x3ca>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
800154e6:	20 19       	sub	r9,1
800154e8:	5c 89       	casts.h	r9
800154ea:	f1 59 00 2a 	st.h	r8[42],r9
800154ee:	e0 80 03 87 	breq	80015bfc <otg_interrupt+0xad4>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
800154f2:	e0 68 06 b0 	mov	r8,1712
800154f6:	6e f9       	ld.w	r9,r7[0x3c]
800154f8:	58 09       	cp.w	r9,0
800154fa:	c0 b4       	brge	80015510 <otg_interrupt+0x3e8>
			if (ptr_job->timeout) {
800154fc:	f1 09 00 3e 	ld.sh	r9,r8[62]
80015500:	58 09       	cp.w	r9,0
80015502:	c0 70       	breq	80015510 <otg_interrupt+0x3e8>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80015504:	20 19       	sub	r9,1
80015506:	5c 89       	casts.h	r9
80015508:	f1 59 00 3e 	st.h	r8[62],r9
8001550c:	e0 80 03 7e 	breq	80015c08 <otg_interrupt+0xae0>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80015510:	e0 68 06 b0 	mov	r8,1712
80015514:	6f 49       	ld.w	r9,r7[0x50]
80015516:	58 09       	cp.w	r9,0
80015518:	c0 b4       	brge	8001552e <otg_interrupt+0x406>
			if (ptr_job->timeout) {
8001551a:	f1 09 00 52 	ld.sh	r9,r8[82]
8001551e:	58 09       	cp.w	r9,0
80015520:	c0 70       	breq	8001552e <otg_interrupt+0x406>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80015522:	20 19       	sub	r9,1
80015524:	5c 89       	casts.h	r9
80015526:	f1 59 00 52 	st.h	r8[82],r9
8001552a:	e0 80 03 75 	breq	80015c14 <otg_interrupt+0xaec>
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
8001552e:	6f 99       	ld.w	r9,r7[0x64]
80015530:	e0 68 06 b0 	mov	r8,1712
80015534:	58 09       	cp.w	r9,0
80015536:	c0 b4       	brge	8001554c <otg_interrupt+0x424>
			if (ptr_job->timeout) {
80015538:	f1 09 00 66 	ld.sh	r9,r8[102]
8001553c:	58 09       	cp.w	r9,0
8001553e:	c0 70       	breq	8001554c <otg_interrupt+0x424>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80015540:	20 19       	sub	r9,1
80015542:	5c 89       	casts.h	r9
80015544:	f1 59 00 66 	st.h	r8[102],r9
80015548:	e0 80 03 32 	breq	80015bac <otg_interrupt+0xa84>
				}
			}
		}
	}
	// Notify the UHC
	uhc_notify_sof(false);
8001554c:	30 0c       	mov	r12,0
8001554e:	e0 a0 04 df 	rcall	80015f0c <uhc_notify_sof>

	// Notify the user application
	UHC_SOF_EVENT();
80015552:	e0 a0 27 c6 	rcall	8001a4de <usb_sof>
80015556:	fe 9f fd f5 	bral	80015140 <otg_interrupt+0x18>
		}
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
8001555a:	74 0a       	ld.w	r10,r10[0x0]
8001555c:	ed ba 00 01 	bld	r10,0x1
80015560:	c0 81       	brne	80015570 <otg_interrupt+0x448>
80015562:	fe 6a 04 10 	mov	r10,-130032
80015566:	74 0a       	ld.w	r10,r10[0x0]
80015568:	ed ba 00 01 	bld	r10,0x1
8001556c:	e0 80 02 a7 	breq	80015aba <otg_interrupt+0x992>
		uhd_suspend_start = 0;
		uhd_resume_start = 0;
		uhc_notify_connection(false);
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
80015570:	fe 68 04 04 	mov	r8,-130044
80015574:	70 08       	ld.w	r8,r8[0x0]
80015576:	ed b8 00 00 	bld	r8,0x0
8001557a:	c0 81       	brne	8001558a <otg_interrupt+0x462>
8001557c:	fe 68 04 10 	mov	r8,-130032
80015580:	70 08       	ld.w	r8,r8[0x0]
80015582:	ed b8 00 00 	bld	r8,0x0
80015586:	e0 80 02 b8 	breq	80015af6 <otg_interrupt+0x9ce>
		uhc_notify_connection(true);
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
8001558a:	fe 69 08 04 	mov	r9,-129020
8001558e:	72 08       	ld.w	r8,r9[0x0]
80015590:	ed b8 00 03 	bld	r8,0x3
80015594:	e0 80 01 f1 	breq	80015976 <otg_interrupt+0x84e>
		UHC_VBUS_ERROR();
		return;
	}

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
80015598:	72 08       	ld.w	r8,r9[0x0]
8001559a:	ed b8 00 0e 	bld	r8,0xe
8001559e:	cf d1       	brne	80015598 <otg_interrupt+0x470>
	otg_unfreeze_clock();
800155a0:	fe 69 08 00 	mov	r9,-129024
800155a4:	72 08       	ld.w	r8,r9[0x0]
800155a6:	af c8       	cbr	r8,0xe
800155a8:	93 08       	st.w	r9[0x0],r8

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
800155aa:	fe 68 04 10 	mov	r8,-130032
800155ae:	70 08       	ld.w	r8,r8[0x0]
800155b0:	ed b8 00 06 	bld	r8,0x6
800155b4:	e0 81 01 43 	brne	8001583a <otg_interrupt+0x712>
800155b8:	fe 68 04 04 	mov	r8,-130044
800155bc:	70 09       	ld.w	r9,r8[0x0]
800155be:	ed b9 00 06 	bld	r9,0x6
800155c2:	c0 a0       	breq	800155d6 <otg_interrupt+0x4ae>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
800155c4:	70 09       	ld.w	r9,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
800155c6:	ed b9 00 03 	bld	r9,0x3
800155ca:	c0 60       	breq	800155d6 <otg_interrupt+0x4ae>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
800155cc:	70 08       	ld.w	r8,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
800155ce:	ed b8 00 04 	bld	r8,0x4
800155d2:	e0 81 01 34 	brne	8001583a <otg_interrupt+0x712>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
800155d6:	fe 68 00 00 	mov	r8,-131072
800155da:	35 89       	mov	r9,88
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800155dc:	fe 6a 04 00 	mov	r10,-130048
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
800155e0:	f1 49 04 14 	st.w	r8[1044],r9
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800155e4:	74 08       	ld.w	r8,r10[0x0]
800155e6:	a9 a8       	sbr	r8,0x8
		if ((!Is_uhd_downstream_resume())
800155e8:	fe 69 04 04 	mov	r9,-130044
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800155ec:	95 08       	st.w	r10[0x0],r8
		if ((!Is_uhd_downstream_resume())
800155ee:	72 08       	ld.w	r8,r9[0x0]
				&&(!Is_uhd_disconnection())) {
800155f0:	ed b8 00 03 	bld	r8,0x3
800155f4:	f3 f8 10 00 	ld.wne	r8,r9[0x0]
			if (Is_uhd_high_speed_mode()) {
				uhd_send_resume();
			}
		}
		// Wait 50ms before restarting transfer
		uhd_resume_start = 50;
800155f8:	e0 68 07 2a 	mov	r8,1834
800155fc:	33 29       	mov	r9,50
800155fe:	b0 89       	st.b	r8[0x0],r9
80015600:	fe 9f fd a0 	bral	80015140 <otg_interrupt+0x18>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
		uhd_disable_out_ready_interrupt(pipe);
80015604:	30 29       	mov	r9,2
80015606:	fe 6c 06 20 	mov	r12,-129504
8001560a:	f6 0c 00 08 	add	r8,r11,r12
8001560e:	91 09       	st.w	r8[0x0],r9
		// One bank is free then send a ZLP
		uhd_ack_out_ready(pipe);
80015610:	fe 6c 05 60 	mov	r12,-129696
80015614:	f6 0c 00 0a 	add	r10,r11,r12
80015618:	95 09       	st.w	r10[0x0],r9
		uhd_ack_fifocon(pipe);
8001561a:	e0 69 40 00 	mov	r9,16384
8001561e:	91 09       	st.w	r8[0x0],r9
		uhd_unfreeze_pipe(pipe);
80015620:	e2 69 00 00 	mov	r9,131072
80015624:	91 09       	st.w	r8[0x0],r9
		uhd_enable_bank_interrupt(pipe);
80015626:	e0 3b fa 10 	sub	r11,129552
8001562a:	e0 68 10 00 	mov	r8,4096
8001562e:	97 08       	st.w	r11[0x0],r8
80015630:	fe 9f fd 88 	bral	80015140 <otg_interrupt+0x18>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80015634:	fe f9 05 ec 	ld.w	r9,pc[1516]
80015638:	f2 08 03 2b 	ld.w	r11,r9[r8<<0x2]
8001563c:	fe 9f fe 56 	bral	800152e8 <otg_interrupt+0x1c0>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_out_ready(0)) {
80015640:	72 08       	ld.w	r8,r9[0x0]
80015642:	ed b8 00 01 	bld	r8,0x1
80015646:	e0 81 01 13 	brne	8001586c <otg_interrupt+0x744>
		// OUT packet sent
		uhd_freeze_pipe(0);
8001564a:	fe 64 05 f0 	mov	r4,-129552
8001564e:	e2 65 00 00 	mov	r5,131072
80015652:	89 05       	st.w	r4[0x0],r5
		uhd_ack_out_ready(0);
80015654:	30 28       	mov	r8,2
80015656:	fe 6e 05 60 	mov	lr,-129696
8001565a:	9d 08       	st.w	lr[0x0],r8
		switch(uhd_ctrl_request_phase) {
8001565c:	e0 60 2d 04 	mov	r0,11524
80015660:	60 08       	ld.w	r8,r0[0x0]
80015662:	58 18       	cp.w	r8,1
80015664:	e0 80 01 a5 	breq	800159ae <otg_interrupt+0x886>
80015668:	58 48       	cp.w	r8,4
8001566a:	fe 91 fd 6b 	brne	80015140 <otg_interrupt+0x18>
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
		// Get and ack error
		uhd_ctrl_request_end(uhd_pipe_get_error(0));
8001566e:	fe b0 f8 e5 	rcall	80014838 <uhd_ctrl_request_end>
80015672:	fe 9f fd 67 	bral	80015140 <otg_interrupt+0x18>
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
80015676:	fe 69 05 60 	mov	r9,-129696
8001567a:	f6 09 00 08 	add	r8,r11,r9
8001567e:	34 09       	mov	r9,64
80015680:	91 09       	st.w	r8[0x0],r9
		uhd_reset_data_toggle(pipe);
80015682:	fe 69 05 f0 	mov	r9,-129552
80015686:	f6 09 00 08 	add	r8,r11,r9
8001568a:	e4 69 00 00 	mov	r9,262144
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
8001568e:	30 4b       	mov	r11,4
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
80015690:	91 09       	st.w	r8[0x0],r9
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
80015692:	fe b0 fa 47 	rcall	80014b20 <uhd_ep_abort_pipe>
80015696:	fe 9f fd 55 	bral	80015140 <otg_interrupt+0x18>
	}

	if (uhd_is_pipe_out(pipe)) {
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
8001569a:	e0 3a fa 10 	sub	r10,129552
8001569e:	e0 68 10 00 	mov	r8,4096
800156a2:	95 08       	st.w	r10[0x0],r8
800156a4:	fe 9f fd 4e 	bral	80015140 <otg_interrupt+0x18>
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
		uhd_disable_bank_interrupt(pipe);
800156a8:	fe 69 06 20 	mov	r9,-129504
800156ac:	f6 09 00 08 	add	r8,r11,r9
800156b0:	e0 69 10 00 	mov	r9,4096
800156b4:	91 09       	st.w	r8[0x0],r9
static void uhd_pipe_finish_job(uint8_t pipe, uhd_trans_status_t status)
{
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
800156b6:	e0 68 06 b0 	mov	r8,1712
800156ba:	f8 c9 00 01 	sub	r9,r12,1
800156be:	f2 09 00 29 	add	r9,r9,r9<<0x2
800156c2:	f0 09 00 29 	add	r9,r8,r9<<0x2
	if (ptr_job->busy == false) {
800156c6:	72 08       	ld.w	r8,r9[0x0]
800156c8:	58 08       	cp.w	r8,0
800156ca:	fe 94 fd 3b 	brge	80015140 <otg_interrupt+0x18>
		return; // No job running
	}
	ptr_job->busy = false;
800156ce:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
800156d2:	93 08       	st.w	r9[0x0],r8
	if (NULL == ptr_job->call_end) {
800156d4:	72 48       	ld.w	r8,r9[0x10]
800156d6:	58 08       	cp.w	r8,0
800156d8:	fe 90 fd 34 	breq	80015140 <otg_interrupt+0x18>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
800156dc:	e0 3b fb 00 	sub	r11,129792
800156e0:	76 0e       	ld.w	lr,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800156e2:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
			uhd_get_pipe_endpoint_address(pipe),
800156e6:	76 06       	ld.w	r6,r11[0x0]
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
800156e8:	e2 1c 00 3c 	andl	r12,0x3c,COH
800156ec:	f7 de c2 04 	bfextu	r11,lr,0x10,0x4
800156f0:	ed d6 c1 02 	bfextu	r6,r6,0x8,0x2
800156f4:	e0 3c fb dc 	sub	r12,130012
800156f8:	e0 6e 00 80 	mov	lr,128
800156fc:	58 16       	cp.w	r6,1
800156fe:	f9 be 01 00 	movne	lr,0
80015702:	a3 77       	lsl	r7,0x3
80015704:	fd eb 10 0b 	or	r11,lr,r11
80015708:	78 0e       	ld.w	lr,r12[0x0]
8001570a:	37 fc       	mov	r12,127
8001570c:	f8 07 09 4c 	lsl	r12,r12,r7
80015710:	f9 ee 00 0e 	and	lr,r12,lr
80015714:	72 39       	ld.w	r9,r9[0xc]
80015716:	5c 9c       	brev	r12
80015718:	f8 0c 12 00 	clz	r12,r12
8001571c:	fc 0c 0a 4c 	lsr	r12,lr,r12
80015720:	5c 5c       	castu.b	r12
80015722:	5d 18       	icall	r8
80015724:	fe 9f fd 0e 	bral	80015140 <otg_interrupt+0x18>
static void uhd_ctrl_phase_data_out(void)
{
	uint8_t *ptr_ep_data;
	uint8_t ep_ctrl_size;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
80015728:	e0 60 2d 04 	mov	r0,11524
8001572c:	30 14       	mov	r4,1
8001572e:	81 04       	st.w	r0[0x0],r4

	if (uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength) {
80015730:	f5 3e 00 08 	ld.ub	lr,r10[8]
80015734:	e0 66 2d 0c 	mov	r6,11532
80015738:	15 f5       	ld.ub	r5,r10[0x7]
8001573a:	fd e5 10 85 	or	r5,lr,r5<<0x8
8001573e:	8c 0e       	ld.sh	lr,r6[0x0]
80015740:	5c 85       	casts.h	r5
80015742:	fc 05 19 00 	cp.h	r5,lr
80015746:	e0 80 01 f3 	breq	80015b2c <otg_interrupt+0xa04>
		// End of DATA phase
		uhd_ctrl_phase_zlp_in();
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
8001574a:	f5 08 00 10 	ld.sh	r8,r10[16]
8001574e:	f8 08 19 00 	cp.h	r8,r12
80015752:	c1 81       	brne	80015782 <otg_interrupt+0x65a>
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
				|| !uhd_ctrl_request_first->callback_run(
80015754:	74 58       	ld.w	r8,r10[0x14]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80015756:	58 08       	cp.w	r8,0
80015758:	e0 80 01 17 	breq	80015986 <otg_interrupt+0x85e>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
8001575c:	fe 69 04 24 	mov	r9,-130012
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80015760:	f4 cb ff f4 	sub	r11,r10,-12
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
80015764:	72 0c       	ld.w	r12,r9[0x0]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80015766:	2f 0a       	sub	r10,-16
80015768:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8001576c:	5d 18       	icall	r8
8001576e:	e0 80 01 0c 	breq	80015986 <otg_interrupt+0x85e>
80015772:	6e 0a       	ld.w	r10,r7[0x0]
80015774:	8c 0e       	ld.sh	lr,r6[0x0]
80015776:	15 f5       	ld.ub	r5,r10[0x7]
80015778:	f5 38 00 08 	ld.ub	r8,r10[8]
8001577c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80015780:	5c 85       	casts.h	r5
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80015782:	fe 69 05 00 	mov	r9,-129792
80015786:	72 0c       	ld.w	r12,r9[0x0]
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80015788:	72 08       	ld.w	r8,r9[0x0]
8001578a:	e0 18 fc ff 	andl	r8,0xfcff
8001578e:	a9 b8       	sbr	r8,0x9
80015790:	93 08       	st.w	r9[0x0],r8
	uhd_ack_out_ready(0);
80015792:	fe 68 05 60 	mov	r8,-129696
80015796:	30 29       	mov	r9,2
80015798:	91 09       	st.w	r8[0x0],r9
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
8001579a:	f1 dc c0 83 	bfextu	r8,r12,0x4,0x3

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
8001579e:	fc 05 19 00 	cp.h	r5,lr
800157a2:	5f bb       	srhi	r11
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
800157a4:	30 8e       	mov	lr,8
800157a6:	fc 08 09 4e 	lsl	lr,lr,r8

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800157aa:	30 08       	mov	r8,0
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
800157ac:	5c 5e       	castu.b	lr

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800157ae:	f0 0e 18 00 	cp.b	lr,r8
800157b2:	5f 19       	srne	r9
800157b4:	f7 e9 00 09 	and	r9,r11,r9
800157b8:	f0 09 18 00 	cp.b	r9,r8
800157bc:	c3 10       	breq	8001581e <otg_interrupt+0x6f6>
800157be:	f5 08 00 10 	ld.sh	r8,r10[16]
800157c2:	30 0b       	mov	r11,0
800157c4:	f6 08 19 00 	cp.h	r8,r11
800157c8:	c2 b0       	breq	8001581e <otg_interrupt+0x6f6>
800157ca:	16 95       	mov	r5,r11
800157cc:	fc 19 e0 00 	movh	r9,0xe000
800157d0:	c0 68       	rjmp	800157dc <otg_interrupt+0x6b4>
800157d2:	f5 08 00 10 	ld.sh	r8,r10[16]
800157d6:	ea 08 19 00 	cp.h	r8,r5
800157da:	c2 20       	breq	8001581e <otg_interrupt+0x6f6>
			&& ep_ctrl_size && uhd_ctrl_request_first->payload_size) {
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
800157dc:	74 38       	ld.w	r8,r10[0xc]
800157de:	11 3c       	ld.ub	r12,r8++
800157e0:	12 cc       	st.b	r9++,r12
800157e2:	95 38       	st.w	r10[0xc],r8
		uhd_ctrl_nb_trans++;
800157e4:	8c 08       	ld.sh	r8,r6[0x0]
800157e6:	2f f8       	sub	r8,-1
800157e8:	ac 08       	st.h	r6[0x0],r8
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
800157ea:	6e 08       	ld.w	r8,r7[0x0]
800157ec:	f1 0a 00 10 	ld.sh	r10,r8[16]
800157f0:	20 1a       	sub	r10,1
800157f2:	f1 5a 00 10 	st.h	r8[16],r10

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800157f6:	fc 09 01 08 	sub	r8,lr,r9
800157fa:	6e 0a       	ld.w	r10,r7[0x0]
800157fc:	f6 08 18 00 	cp.b	r8,r11
80015800:	5f 1c       	srne	r12
80015802:	8c 04       	ld.sh	r4,r6[0x0]
80015804:	15 f3       	ld.ub	r3,r10[0x7]
80015806:	f5 38 00 08 	ld.ub	r8,r10[8]
8001580a:	f1 e3 10 88 	or	r8,r8,r3<<0x8
8001580e:	f0 04 19 00 	cp.h	r4,r8
80015812:	5f 38       	srlo	r8
80015814:	f9 e8 00 08 	and	r8,r12,r8
80015818:	f6 08 18 00 	cp.b	r8,r11
8001581c:	cd b1       	brne	800157d2 <otg_interrupt+0x6aa>
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
		uhd_ctrl_nb_trans++;
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
	}
	uhd_enable_out_ready_interrupt(0);
8001581e:	30 29       	mov	r9,2
80015820:	fe 68 05 f0 	mov	r8,-129552
80015824:	91 09       	st.w	r8[0x0],r9
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	uhd_enable_out_ready_interrupt(0);
	uhd_ack_fifocon(0);
80015826:	fe 68 06 20 	mov	r8,-129504
8001582a:	e0 69 40 00 	mov	r9,16384
8001582e:	91 09       	st.w	r8[0x0],r9
	uhd_unfreeze_pipe(0);
80015830:	e2 69 00 00 	mov	r9,131072
80015834:	91 09       	st.w	r8[0x0],r9
80015836:	fe 9f fc 85 	bral	80015140 <otg_interrupt+0x18>
		uhd_sleep_mode(UHD_STATE_IDLE);
		return;
	}

	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
8001583a:	fe 69 08 04 	mov	r9,-129020
8001583e:	72 08       	ld.w	r8,r9[0x0]
80015840:	ed b8 00 01 	bld	r8,0x1
80015844:	fe 91 fc 7e 	brne	80015140 <otg_interrupt+0x18>
		otg_ack_vbus_transition();
80015848:	30 2a       	mov	r10,2
8001584a:	fe 68 08 08 	mov	r8,-129016
8001584e:	91 0a       	st.w	r8[0x0],r10
		if (Is_otg_vbus_high()) {
80015850:	72 0c       	ld.w	r12,r9[0x0]
80015852:	e2 1c 08 00 	andl	r12,0x800,COH
80015856:	e0 81 01 81 	brne	80015b58 <otg_interrupt+0xa30>
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
		} else {
			uhd_sleep_mode(UHD_STATE_NO_VBUS);
			otg_freeze_clock();
8001585a:	fe 69 08 00 	mov	r9,-129024
8001585e:	72 08       	ld.w	r8,r9[0x0]
80015860:	af a8       	sbr	r8,0xe
80015862:	93 08       	st.w	r9[0x0],r8
			UHC_VBUS_CHANGE(false);
80015864:	e0 a0 26 39 	rcall	8001a4d6 <usb_vbus_change>
80015868:	fe 9f fc 6c 	bral	80015140 <otg_interrupt+0x18>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_stall(0)) {
8001586c:	72 08       	ld.w	r8,r9[0x0]
8001586e:	e2 18 00 40 	andl	r8,0x40,COH
80015872:	e0 81 01 94 	brne	80015b9a <otg_interrupt+0xa72>
		// Stall Handshake received
		uhd_ack_stall(0);
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
80015876:	72 09       	ld.w	r9,r9[0x0]
80015878:	ed b9 00 03 	bld	r9,0x3
8001587c:	fe 91 fc 62 	brne	80015140 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
80015880:	fe 69 06 80 	mov	r9,-129408
80015884:	72 0a       	ld.w	r10,r9[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
80015886:	93 08       	st.w	r9[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80015888:	f1 da c0 04 	bfextu	r8,r10,0x0,0x4
8001588c:	20 18       	sub	r8,1
8001588e:	58 28       	cp.w	r8,2
80015890:	e0 88 01 80 	brls	80015b90 <otg_interrupt+0xa68>
80015894:	30 6c       	mov	r12,6
80015896:	ce ca       	rjmp	8001566e <otg_interrupt+0x546>
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
80015898:	fe 68 05 30 	mov	r8,-129744
8001589c:	e0 67 2d 08 	mov	r7,11528
800158a0:	70 05       	ld.w	r5,r8[0x0]
	//! In HUB mode, the control pipe is always configured to 64B
	//! thus the short packet flag must be computed
	b_short_packet = (nb_byte_received != uhd_get_pipe_size(0));
	uhd_ack_short_packet(0);
#else
	b_short_packet = Is_uhd_short_packet(0);
800158a2:	fc 12 e0 00 	movh	r2,0xe000
800158a6:	70 08       	ld.w	r8,r8[0x0]
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
800158a8:	eb d5 c2 88 	bfextu	r5,r5,0x14,0x8
	//! In HUB mode, the control pipe is always configured to 64B
	//! thus the short packet flag must be computed
	b_short_packet = (nb_byte_received != uhd_get_pipe_size(0));
	uhd_ack_short_packet(0);
#else
	b_short_packet = Is_uhd_short_packet(0);
800158ac:	50 08       	stdsp	sp[0x0],r8
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800158ae:	0e 91       	mov	r1,r7
800158b0:	30 06       	mov	r6,0
800158b2:	30 04       	mov	r4,0
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
800158b4:	e0 63 2d 0c 	mov	r3,11532
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800158b8:	6e 0a       	ld.w	r10,r7[0x0]
800158ba:	ec 05 18 00 	cp.b	r5,r6
800158be:	5f 18       	srne	r8
800158c0:	f5 09 00 10 	ld.sh	r9,r10[16]
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
800158c4:	ea ce 00 01 	sub	lr,r5,1
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800158c8:	e8 09 19 00 	cp.h	r9,r4
800158cc:	5f 1c       	srne	r12
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800158ce:	f4 cb ff f4 	sub	r11,r10,-12
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
800158d2:	f1 ec 00 0c 	and	r12,r8,r12
800158d6:	ec 0c 18 00 	cp.b	r12,r6
800158da:	c2 51       	brne	80015924 <otg_interrupt+0x7fc>
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
800158dc:	e8 09 19 00 	cp.h	r9,r4
800158e0:	5f 09       	sreq	r9
800158e2:	12 68       	and	r8,r9
800158e4:	ec 08 18 00 	cp.b	r8,r6
800158e8:	e0 80 01 3d 	breq	80015b62 <otg_interrupt+0xa3a>
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
				|| !uhd_ctrl_request_first->callback_run(
800158ec:	74 58       	ld.w	r8,r10[0x14]
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800158ee:	58 08       	cp.w	r8,0
800158f0:	c0 90       	breq	80015902 <otg_interrupt+0x7da>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800158f2:	fe 69 04 24 	mov	r9,-130012
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800158f6:	2f 0a       	sub	r10,-16
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800158f8:	72 0c       	ld.w	r12,r9[0x0]
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
800158fa:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800158fe:	5d 18       	icall	r8
80015900:	cd c1       	brne	800158b8 <otg_interrupt+0x790>
 * \internal
 * \brief Starts the ZLP OUT phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_out(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
80015902:	30 48       	mov	r8,4
80015904:	81 08       	st.w	r0[0x0],r8
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80015906:	fe 69 05 00 	mov	r9,-129792
8001590a:	72 08       	ld.w	r8,r9[0x0]
8001590c:	e0 18 fc ff 	andl	r8,0xfcff
80015910:	a9 b8       	sbr	r8,0x9
80015912:	93 08       	st.w	r9[0x0],r8
	uhd_ack_out_ready(0);
80015914:	30 28       	mov	r8,2
80015916:	fe 69 05 60 	mov	r9,-129696
8001591a:	93 08       	st.w	r9[0x0],r8
	uhd_enable_out_ready_interrupt(0);
8001591c:	fe 69 05 f0 	mov	r9,-129552
80015920:	93 08       	st.w	r9[0x0],r8
80015922:	c8 2b       	rjmp	80015826 <otg_interrupt+0x6fe>

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
80015924:	05 39       	ld.ub	r9,r2++
80015926:	74 38       	ld.w	r8,r10[0xc]
80015928:	10 c9       	st.b	r8++,r9
8001592a:	95 38       	st.w	r10[0xc],r8
		uhd_ctrl_nb_trans++;
8001592c:	86 08       	ld.sh	r8,r3[0x0]
8001592e:	2f f8       	sub	r8,-1
80015930:	a6 08       	st.h	r3[0x0],r8
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
80015932:	eb de c0 08 	bfextu	r5,lr,0x0,0x8
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
80015936:	62 08       	ld.w	r8,r1[0x0]
80015938:	f1 09 00 10 	ld.sh	r9,r8[16]
8001593c:	20 19       	sub	r9,1
8001593e:	f1 59 00 10 	st.h	r8[16],r9
80015942:	cb bb       	rjmp	800158b8 <otg_interrupt+0x790>
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80015944:	fe 6c 05 00 	mov	r12,-129792
80015948:	78 0a       	ld.w	r10,r12[0x0]
8001594a:	e0 1a fc ff 	andl	r10,0xfcff
8001594e:	a9 aa       	sbr	r10,0x8
80015950:	99 0a       	st.w	r12[0x0],r10
	uhd_ack_in_received(0);
80015952:	30 1a       	mov	r10,1
80015954:	91 0a       	st.w	r8[0x0],r10
	uhd_ack_short_packet(0);
80015956:	e0 6c 00 80 	mov	r12,128
8001595a:	91 0c       	st.w	r8[0x0],r12
	uhd_enable_in_received_interrupt(0);
8001595c:	97 0a       	st.w	r11[0x0],r10
	uhd_ack_fifocon(0);
8001595e:	fe 68 06 20 	mov	r8,-129504
80015962:	e0 6a 40 00 	mov	r10,16384
80015966:	91 0a       	st.w	r8[0x0],r10
	uhd_unfreeze_pipe(0);
80015968:	91 09       	st.w	r8[0x0],r9
 * \internal
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
8001596a:	30 29       	mov	r9,2
8001596c:	e0 68 2d 04 	mov	r8,11524
80015970:	91 09       	st.w	r8[0x0],r9
80015972:	fe 9f fb e7 	bral	80015140 <otg_interrupt+0x18>
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
		uhd_ack_vbus_error_interrupt();
80015976:	30 89       	mov	r9,8
80015978:	fe 68 08 08 	mov	r8,-129016
8001597c:	91 09       	st.w	r8[0x0],r9
		UHC_VBUS_ERROR();
8001597e:	e0 a0 25 ad 	rcall	8001a4d8 <usb_vbus_error>
80015982:	fe 9f fb df 	bral	80015140 <otg_interrupt+0x18>
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80015986:	30 38       	mov	r8,3
80015988:	81 08       	st.w	r0[0x0],r8
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
8001598a:	fe 69 05 00 	mov	r9,-129792
8001598e:	72 08       	ld.w	r8,r9[0x0]
80015990:	e0 18 fc ff 	andl	r8,0xfcff
80015994:	a9 a8       	sbr	r8,0x8
80015996:	93 08       	st.w	r9[0x0],r8
	uhd_ack_in_received(0);
80015998:	fe 69 05 60 	mov	r9,-129696
8001599c:	30 18       	mov	r8,1
8001599e:	93 08       	st.w	r9[0x0],r8
	uhd_ack_short_packet(0);
800159a0:	e0 6a 00 80 	mov	r10,128
800159a4:	93 0a       	st.w	r9[0x0],r10
	uhd_enable_in_received_interrupt(0);
800159a6:	fe 69 05 f0 	mov	r9,-129552
800159aa:	93 08       	st.w	r9[0x0],r8
800159ac:	c3 db       	rjmp	80015826 <otg_interrupt+0x6fe>
static void uhd_ctrl_phase_data_out(void)
{
	uint8_t *ptr_ep_data;
	uint8_t ep_ctrl_size;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
800159ae:	81 08       	st.w	r0[0x0],r8

	if (uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength) {
800159b0:	e0 67 2d 08 	mov	r7,11528
800159b4:	e0 66 2d 0c 	mov	r6,11532
800159b8:	6e 0a       	ld.w	r10,r7[0x0]
800159ba:	8c 0b       	ld.sh	r11,r6[0x0]
800159bc:	15 f3       	ld.ub	r3,r10[0x7]
800159be:	f5 39 00 08 	ld.ub	r9,r10[8]
800159c2:	f3 e3 10 89 	or	r9,r9,r3<<0x8
800159c6:	5c 89       	casts.h	r9
800159c8:	f6 09 19 00 	cp.h	r9,r11
800159cc:	e0 80 00 f6 	breq	80015bb8 <otg_interrupt+0xa90>
		// End of DATA phase
		uhd_ctrl_phase_zlp_in();
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
800159d0:	f5 08 00 10 	ld.sh	r8,r10[16]
800159d4:	f8 08 19 00 	cp.h	r8,r12
800159d8:	c1 51       	brne	80015a02 <otg_interrupt+0x8da>
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
				|| !uhd_ctrl_request_first->callback_run(
800159da:	74 58       	ld.w	r8,r10[0x14]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800159dc:	58 08       	cp.w	r8,0
800159de:	cd 40       	breq	80015986 <otg_interrupt+0x85e>
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800159e0:	fe 69 04 24 	mov	r9,-130012
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800159e4:	f4 cb ff f4 	sub	r11,r10,-12
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
800159e8:	72 0c       	ld.w	r12,r9[0x0]
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
800159ea:	2f 0a       	sub	r10,-16
800159ec:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800159f0:	5d 18       	icall	r8
800159f2:	cc a0       	breq	80015986 <otg_interrupt+0x85e>
800159f4:	6e 0a       	ld.w	r10,r7[0x0]
800159f6:	8c 0b       	ld.sh	r11,r6[0x0]
800159f8:	15 f9       	ld.ub	r9,r10[0x7]
800159fa:	f5 38 00 08 	ld.ub	r8,r10[8]
800159fe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80015a02:	fe 6c 05 00 	mov	r12,-129792
80015a06:	78 0e       	ld.w	lr,r12[0x0]
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
80015a08:	78 08       	ld.w	r8,r12[0x0]
80015a0a:	e0 18 fc ff 	andl	r8,0xfcff
80015a0e:	a9 b8       	sbr	r8,0x9
80015a10:	99 08       	st.w	r12[0x0],r8
	uhd_ack_out_ready(0);
80015a12:	fe 68 05 60 	mov	r8,-129696
80015a16:	30 2c       	mov	r12,2
80015a18:	91 0c       	st.w	r8[0x0],r12
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80015a1a:	f1 de c0 83 	bfextu	r8,lr,0x4,0x3

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
80015a1e:	f2 0b 19 00 	cp.h	r11,r9
80015a22:	5f 3b       	srlo	r11
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80015a24:	30 8c       	mov	r12,8
80015a26:	f8 08 09 4c 	lsl	r12,r12,r8

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
80015a2a:	30 08       	mov	r8,0
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80015a2c:	5c 5c       	castu.b	r12

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
80015a2e:	f0 0c 18 00 	cp.b	r12,r8
80015a32:	5f 19       	srne	r9
80015a34:	f7 e9 00 09 	and	r9,r11,r9
80015a38:	f0 09 18 00 	cp.b	r9,r8
80015a3c:	fe 90 fe f1 	breq	8001581e <otg_interrupt+0x6f6>
80015a40:	f5 09 00 10 	ld.sh	r9,r10[16]
80015a44:	30 08       	mov	r8,0
80015a46:	f0 09 19 00 	cp.h	r9,r8
80015a4a:	fe 90 fe ea 	breq	8001581e <otg_interrupt+0x6f6>
80015a4e:	10 9e       	mov	lr,r8
80015a50:	fc 19 e0 00 	movh	r9,0xe000
80015a54:	c0 78       	rjmp	80015a62 <otg_interrupt+0x93a>
80015a56:	f5 0b 00 10 	ld.sh	r11,r10[16]
80015a5a:	fc 0b 19 00 	cp.h	r11,lr
80015a5e:	fe 90 fe e0 	breq	8001581e <otg_interrupt+0x6f6>
			&& ep_ctrl_size && uhd_ctrl_request_first->payload_size) {
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
80015a62:	74 3b       	ld.w	r11,r10[0xc]
80015a64:	17 35       	ld.ub	r5,r11++
80015a66:	12 c5       	st.b	r9++,r5
80015a68:	95 3b       	st.w	r10[0xc],r11
		uhd_ctrl_nb_trans++;
80015a6a:	8c 0a       	ld.sh	r10,r6[0x0]
80015a6c:	2f fa       	sub	r10,-1
80015a6e:	ac 0a       	st.h	r6[0x0],r10
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
80015a70:	6e 0a       	ld.w	r10,r7[0x0]
80015a72:	f5 0b 00 10 	ld.sh	r11,r10[16]
80015a76:	20 1b       	sub	r11,1
80015a78:	f5 5b 00 10 	st.h	r10[16],r11

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
80015a7c:	f8 09 01 0a 	sub	r10,r12,r9
80015a80:	8c 04       	ld.sh	r4,r6[0x0]
80015a82:	f0 0a 18 00 	cp.b	r10,r8
80015a86:	5f 15       	srne	r5
80015a88:	6e 0a       	ld.w	r10,r7[0x0]
80015a8a:	15 f3       	ld.ub	r3,r10[0x7]
80015a8c:	f5 3b 00 08 	ld.ub	r11,r10[8]
80015a90:	f7 e3 10 8b 	or	r11,r11,r3<<0x8
80015a94:	f6 04 19 00 	cp.h	r4,r11
80015a98:	5f 3b       	srlo	r11
80015a9a:	eb eb 00 0b 	and	r11,r5,r11
80015a9e:	f0 0b 18 00 	cp.b	r11,r8
80015aa2:	cd a1       	brne	80015a56 <otg_interrupt+0x92e>
80015aa4:	cb da       	rjmp	8001581e <otg_interrupt+0x6f6>
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
			// Stop request
			uhd_freeze_pipe(0);
80015aa6:	e2 69 00 00 	mov	r9,131072
80015aaa:	fe 68 05 f0 	mov	r8,-129552
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
80015aae:	30 7c       	mov	r12,7
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
			// Stop request
			uhd_freeze_pipe(0);
80015ab0:	91 09       	st.w	r8[0x0],r9
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
80015ab2:	fe b0 f6 c3 	rcall	80014838 <uhd_ctrl_request_end>
80015ab6:	fe 9f fc f3 	bral	8001549c <otg_interrupt+0x374>
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
		uhd_ack_disconnection();
80015aba:	30 2a       	mov	r10,2
80015abc:	fe 6b 04 08 	mov	r11,-130040
80015ac0:	97 0a       	st.w	r11[0x0],r10
		uhd_disable_disconnection_int();
80015ac2:	fe 6b 04 14 	mov	r11,-130028
80015ac6:	97 0a       	st.w	r11[0x0],r10
		// Stop reset signal, in case of disconnection during reset
		uhd_stop_reset();
80015ac8:	fe 6b 04 00 	mov	r11,-130048
80015acc:	76 0a       	ld.w	r10,r11[0x0]
80015ace:	a9 da       	cbr	r10,0x9
80015ad0:	97 0a       	st.w	r11[0x0],r10
		// Disable wakeup/resumes interrupts,
		// in case of disconnection during suspend mode
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
80015ad2:	35 8a       	mov	r10,88
80015ad4:	f3 4a 04 14 	st.w	r9[1044],r10
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_sleep_mode(UHD_STATE_DISCONNECT);
		uhd_enable_connection_int();
80015ad8:	fe 69 04 18 	mov	r9,-130024
80015adc:	30 1a       	mov	r10,1
80015ade:	93 0a       	st.w	r9[0x0],r10
		uhd_suspend_start = 0;
80015ae0:	e0 69 07 28 	mov	r9,1832
		uhd_resume_start = 0;
80015ae4:	b2 88       	st.b	r9[0x0],r8
		uhc_notify_connection(false);
80015ae6:	e0 69 07 2a 	mov	r9,1834
80015aea:	10 9c       	mov	r12,r8
80015aec:	b2 88       	st.b	r9[0x0],r8
80015aee:	e0 a0 05 cb 	rcall	80016684 <uhc_notify_connection>
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
80015af2:	fe 9f fb 27 	bral	80015140 <otg_interrupt+0x18>
80015af6:	fe 68 04 08 	mov	r8,-130040
		uhd_disable_connection_int();
80015afa:	30 1c       	mov	r12,1
80015afc:	91 0c       	st.w	r8[0x0],r12
80015afe:	fe 68 04 14 	mov	r8,-130028
		uhd_enable_disconnection_int();
80015b02:	91 0c       	st.w	r8[0x0],r12
		uhd_enable_sof();
80015b04:	fe 68 04 18 	mov	r8,-130024
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
		uhd_disable_connection_int();
		uhd_enable_disconnection_int();
80015b08:	fe 6a 04 00 	mov	r10,-130048
		uhd_enable_sof();
80015b0c:	30 29       	mov	r9,2
80015b0e:	91 09       	st.w	r8[0x0],r9
80015b10:	74 08       	ld.w	r8,r10[0x0]
		uhd_sleep_mode(UHD_STATE_IDLE);
		uhd_suspend_start = 0;
80015b12:	a9 a8       	sbr	r8,0x8
80015b14:	95 08       	st.w	r10[0x0],r8
80015b16:	e0 68 07 28 	mov	r8,1832
		uhd_resume_start = 0;
80015b1a:	30 09       	mov	r9,0
		uhc_notify_connection(true);
80015b1c:	b0 89       	st.b	r8[0x0],r9
80015b1e:	e0 68 07 2a 	mov	r8,1834
80015b22:	b0 89       	st.b	r8[0x0],r9
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80015b24:	e0 a0 05 b0 	rcall	80016684 <uhc_notify_connection>
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80015b28:	fe 9f fb 0c 	bral	80015140 <otg_interrupt+0x18>
80015b2c:	30 3a       	mov	r10,3
80015b2e:	81 0a       	st.w	r0[0x0],r10
80015b30:	fe 6c 05 00 	mov	r12,-129792
80015b34:	78 0a       	ld.w	r10,r12[0x0]
	uhd_ack_in_received(0);
80015b36:	e0 1a fc ff 	andl	r10,0xfcff
	uhd_ack_short_packet(0);
80015b3a:	a9 aa       	sbr	r10,0x8
80015b3c:	99 0a       	st.w	r12[0x0],r10
	uhd_enable_in_received_interrupt(0);
80015b3e:	91 04       	st.w	r8[0x0],r4
	uhd_ack_fifocon(0);
80015b40:	e0 6a 00 80 	mov	r10,128
80015b44:	91 0a       	st.w	r8[0x0],r10
80015b46:	97 04       	st.w	r11[0x0],r4
80015b48:	fe 68 06 20 	mov	r8,-129504
	uhd_unfreeze_pipe(0);
80015b4c:	e0 6a 40 00 	mov	r10,16384
	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
		otg_ack_vbus_transition();
		if (Is_otg_vbus_high()) {
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
80015b50:	91 0a       	st.w	r8[0x0],r10
80015b52:	91 09       	st.w	r8[0x0],r9
80015b54:	fe 9f fa f6 	bral	80015140 <otg_interrupt+0x18>
80015b58:	30 1c       	mov	r12,1
		// thus the data load can restart.
		goto uhd_ctrl_receiv_in_read_data;
	}

	// Test short packet
	if ((uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength)
80015b5a:	e0 a0 24 be 	rcall	8001a4d6 <usb_vbus_change>
80015b5e:	fe 9f fa f1 	bral	80015140 <otg_interrupt+0x18>
80015b62:	15 f9       	ld.ub	r9,r10[0x7]
80015b64:	f5 38 00 08 	ld.ub	r8,r10[8]
80015b68:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80015b6c:	e0 69 2d 0c 	mov	r9,11532
80015b70:	92 09       	ld.sh	r9,r9[0x0]
80015b72:	f0 09 19 00 	cp.h	r9,r8
80015b76:	fe 90 fe c6 	breq	80015902 <otg_interrupt+0x7da>
		uhd_ctrl_phase_zlp_out();
		return;
	}

	// Send a new IN packet request
	uhd_enable_in_received_interrupt(0);
80015b7a:	40 08       	lddsp	r8,sp[0x0]
80015b7c:	ed b8 00 07 	bld	r8,0x7
80015b80:	fe 90 fe c1 	breq	80015902 <otg_interrupt+0x7da>
80015b84:	30 19       	mov	r9,1
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80015b86:	fe 68 05 f0 	mov	r8,-129552
80015b8a:	91 09       	st.w	r8[0x0],r9
80015b8c:	fe 9f fe 4d 	bral	80015826 <otg_interrupt+0x6fe>
		}
		return;
	}
	if (Is_uhd_stall(0)) {
		// Stall Handshake received
		uhd_ack_stall(0);
80015b90:	4a 49       	lddpc	r9,80015c20 <otg_interrupt+0xaf8>
80015b92:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		uhd_ctrl_request_end(UHD_TRANS_STALL);
80015b96:	fe 9f fd 6c 	bral	8001566e <otg_interrupt+0x546>
80015b9a:	34 09       	mov	r9,64
80015b9c:	fe 68 05 60 	mov	r8,-129696
80015ba0:	30 4c       	mov	r12,4
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
80015ba2:	91 09       	st.w	r8[0x0],r9
80015ba4:	fe b0 f6 4a 	rcall	80014838 <uhd_ctrl_request_end>
80015ba8:	fe 9f fa cc 	bral	80015140 <otg_interrupt+0x18>
80015bac:	30 7b       	mov	r11,7
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80015bae:	30 6c       	mov	r12,6
80015bb0:	fe b0 f7 b8 	rcall	80014b20 <uhd_ep_abort_pipe>
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80015bb4:	fe 9f fc cc 	bral	8001554c <otg_interrupt+0x424>
80015bb8:	30 39       	mov	r9,3
80015bba:	81 09       	st.w	r0[0x0],r9
80015bbc:	fe 6a 05 00 	mov	r10,-129792
	uhd_ack_in_received(0);
80015bc0:	74 09       	ld.w	r9,r10[0x0]
	uhd_ack_short_packet(0);
80015bc2:	e0 19 fc ff 	andl	r9,0xfcff
80015bc6:	a9 a9       	sbr	r9,0x8
	uhd_enable_in_received_interrupt(0);
80015bc8:	95 09       	st.w	r10[0x0],r9
	uhd_ack_fifocon(0);
80015bca:	9d 08       	st.w	lr[0x0],r8
80015bcc:	e0 69 00 80 	mov	r9,128
80015bd0:	9d 09       	st.w	lr[0x0],r9
80015bd2:	89 08       	st.w	r4[0x0],r8
	uhd_unfreeze_pipe(0);
80015bd4:	e0 69 40 00 	mov	r9,16384
80015bd8:	fe 68 06 20 	mov	r8,-129504
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
80015bdc:	91 09       	st.w	r8[0x0],r9
80015bde:	91 05       	st.w	r8[0x0],r5
80015be0:	fe 9f fa b0 	bral	80015140 <otg_interrupt+0x18>
80015be4:	30 7b       	mov	r11,7
80015be6:	30 1c       	mov	r12,1
80015be8:	fe b0 f7 9c 	rcall	80014b20 <uhd_ep_abort_pipe>
80015bec:	fe 9f fc 65 	bral	800154b6 <otg_interrupt+0x38e>
80015bf0:	30 7b       	mov	r11,7
80015bf2:	30 2c       	mov	r12,2
80015bf4:	fe b0 f7 96 	rcall	80014b20 <uhd_ep_abort_pipe>
80015bf8:	fe 9f fc 6e 	bral	800154d4 <otg_interrupt+0x3ac>
80015bfc:	30 7b       	mov	r11,7
80015bfe:	30 3c       	mov	r12,3
80015c00:	fe b0 f7 90 	rcall	80014b20 <uhd_ep_abort_pipe>
80015c04:	fe 9f fc 77 	bral	800154f2 <otg_interrupt+0x3ca>
80015c08:	30 7b       	mov	r11,7
80015c0a:	30 4c       	mov	r12,4
80015c0c:	fe b0 f7 8a 	rcall	80014b20 <uhd_ep_abort_pipe>
80015c10:	fe 9f fc 80 	bral	80015510 <otg_interrupt+0x3e8>
80015c14:	30 7b       	mov	r11,7
80015c16:	30 5c       	mov	r12,5
80015c18:	fe b0 f7 84 	rcall	80014b20 <uhd_ep_abort_pipe>
80015c1c:	fe 9f fc 89 	bral	8001552e <otg_interrupt+0x406>
80015c20:	80 02       	ld.sh	r2,r0[0x0]
80015c22:	40 14       	lddsp	r4,sp[0x4]

80015c24 <osc_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015c24:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80015c28:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint32_t   oscctrl;

	flags = cpu_irq_save();

	switch (id) {
80015c2a:	58 0c       	cp.w	r12,0
80015c2c:	c0 f0       	breq	80015c4a <osc_enable+0x26>
80015c2e:	30 29       	mov	r9,2
80015c30:	f2 0c 18 00 	cp.b	r12,r9
80015c34:	c0 61       	brne	80015c40 <osc_enable+0x1c>
	case OSC_ID_OSC32:
		oscctrl = OSC32_STARTUP_VALUE
				<< AVR32_PM_OSCCTRL32_STARTUP_OFFSET;
		oscctrl |= OSC32_MODE_VALUE << AVR32_PM_OSCCTRL32_MODE_OFFSET;
		oscctrl |= 1 << AVR32_PM_OSCCTRL32_OSC32EN_OFFSET;
		AVR32_PM.oscctrl32 = oscctrl;
80015c36:	e2 6a 01 01 	mov	r10,131329
80015c3a:	fe 79 0c 00 	mov	r9,-62464
80015c3e:	93 ca       	st.w	r9[0x30],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015c40:	ed b8 00 10 	bld	r8,0x10
80015c44:	c0 20       	breq	80015c48 <osc_enable+0x24>
      cpu_irq_enable();
80015c46:	d5 03       	csrf	0x10
		/* unhandled_case(id); */
		break;
	}

	cpu_irq_restore(flags);
}
80015c48:	5e fc       	retal	r12
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
80015c4a:	fe 79 0c 00 	mov	r9,-62464
80015c4e:	e0 6a 03 07 	mov	r10,775
80015c52:	93 aa       	st.w	r9[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80015c54:	72 0a       	ld.w	r10,r9[0x0]
80015c56:	a3 aa       	sbr	r10,0x2
80015c58:	93 0a       	st.w	r9[0x0],r10
		break;
80015c5a:	cf 3b       	rjmp	80015c40 <osc_enable+0x1c>

80015c5c <sysclk_priv_disable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015c5c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80015c60:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015c62:	fe 79 0c 00 	mov	r9,-62464
80015c66:	73 58       	ld.w	r8,r9[0x54]
80015c68:	ed b8 00 06 	bld	r8,0x6
80015c6c:	cf d1       	brne	80015c66 <sysclk_priv_disable_module+0xa>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015c6e:	a3 6c       	lsl	r12,0x2
	mask &= ~(1U << module_index);
80015c70:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015c72:	e0 2c f3 f8 	sub	r12,62456
	mask &= ~(1U << module_index);
80015c76:	f0 0b 09 48 	lsl	r8,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015c7a:	78 09       	ld.w	r9,r12[0x0]
	mask &= ~(1U << module_index);
80015c7c:	5c d8       	com	r8
80015c7e:	12 68       	and	r8,r9
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015c80:	99 08       	st.w	r12[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015c82:	ed ba 00 10 	bld	r10,0x10
80015c86:	c0 20       	breq	80015c8a <sysclk_priv_disable_module+0x2e>
      cpu_irq_enable();
80015c88:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80015c8a:	5e fc       	retal	r12

80015c8c <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015c8c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80015c90:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015c92:	fe 79 0c 00 	mov	r9,-62464
80015c96:	73 58       	ld.w	r8,r9[0x54]
80015c98:	ed b8 00 06 	bld	r8,0x6
80015c9c:	cf d1       	brne	80015c96 <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
80015c9e:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015ca0:	a3 6c       	lsl	r12,0x2
	mask |= 1U << module_index;
80015ca2:	f0 0b 09 4b 	lsl	r11,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015ca6:	e0 2c f3 f8 	sub	r12,62456
80015caa:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
80015cac:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015cae:	99 0b       	st.w	r12[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015cb0:	ed ba 00 10 	bld	r10,0x10
80015cb4:	c0 20       	breq	80015cb8 <sysclk_priv_enable_module+0x2c>
      cpu_irq_enable();
80015cb6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80015cb8:	5e fc       	retal	r12
80015cba:	d7 03       	nop

80015cbc <sysclk_disable_usb>:

/**
 * \brief Disable the USB generic clock
 */
void sysclk_disable_usb(void)
{
80015cbc:	eb cd 40 80 	pushm	r7,lr
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
}

static inline void genclk_disable(unsigned int id)
{
	AVR32_PM.gcctrl[id] = 0;
80015cc0:	fe 79 0c 00 	mov	r9,-62464
80015cc4:	30 08       	mov	r8,0
80015cc6:	f3 48 00 70 	st.w	r9[112],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015cca:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80015cce:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015cd0:	73 58       	ld.w	r8,r9[0x54]
80015cd2:	ed b8 00 06 	bld	r8,0x6
80015cd6:	cf d1       	brne	80015cd0 <sysclk_disable_usb+0x14>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015cd8:	fe 79 0c 0c 	mov	r9,-62452
80015cdc:	72 08       	ld.w	r8,r9[0x0]
	mask &= ~(1U << module_index);
80015cde:	a3 d8       	cbr	r8,0x3
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015ce0:	93 08       	st.w	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015ce2:	ed ba 00 10 	bld	r10,0x10
80015ce6:	c0 20       	breq	80015cea <sysclk_disable_usb+0x2e>
      cpu_irq_enable();
80015ce8:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015cea:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80015cee:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015cf0:	fe 79 0c 00 	mov	r9,-62464
80015cf4:	73 58       	ld.w	r8,r9[0x54]
80015cf6:	ed b8 00 06 	bld	r8,0x6
80015cfa:	cf d1       	brne	80015cf4 <sysclk_disable_usb+0x38>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015cfc:	fe 79 0c 14 	mov	r9,-62444
80015d00:	72 08       	ld.w	r8,r9[0x0]
	mask &= ~(1U << module_index);
80015d02:	a1 d8       	cbr	r8,0x1
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015d04:	93 08       	st.w	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015d06:	ed ba 00 10 	bld	r10,0x10
80015d0a:	c0 20       	breq	80015d0e <sysclk_disable_usb+0x52>
      cpu_irq_enable();
80015d0c:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015d0e:	e1 b7 00 00 	mfsr	r7,0x0
	cpu_irq_disable();
80015d12:	d3 03       	ssrf	0x10
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_PBB, index);

	/* Disable the bridge if possible */
	flags = cpu_irq_save();

	sysclk_pbb_refcount--;
80015d14:	e0 69 07 2c 	mov	r9,1836
80015d18:	13 88       	ld.ub	r8,r9[0x0]
80015d1a:	20 18       	sub	r8,1
80015d1c:	5c 58       	castu.b	r8
	if (!sysclk_pbb_refcount)
80015d1e:	b2 88       	st.b	r9[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015d20:	c0 70       	breq	80015d2e <sysclk_disable_usb+0x72>
80015d22:	e6 17 00 01 	andh	r7,0x1,COH
      cpu_irq_enable();
80015d26:	c0 21       	brne	80015d2a <sysclk_disable_usb+0x6e>
void sysclk_disable_usb(void)
{
	genclk_disable(AVR32_PM_GCLK_USBB);
	sysclk_disable_hsb_module(SYSCLK_USBB_DATA);
	sysclk_disable_pbb_module(SYSCLK_USBB_REGS);
}
80015d28:	d5 03       	csrf	0x10
80015d2a:	e3 cd 80 80 	ldm	sp++,r7,pc
 * \brief Disable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_disable_hsb_module(unsigned int index)
{
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_HSB, index);
80015d2e:	30 2b       	mov	r11,2
80015d30:	30 1c       	mov	r12,1
80015d32:	c9 5f       	rcall	80015c5c <sysclk_priv_disable_module>
80015d34:	cf 7b       	rjmp	80015d22 <sysclk_disable_usb+0x66>
80015d36:	d7 03       	nop

80015d38 <sysclk_enable_pbb_module>:
80015d38:	d4 01       	pushm	lr
80015d3a:	e1 bb 00 00 	mfsr	r11,0x0
80015d3e:	d3 03       	ssrf	0x10
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_pbb_refcount)
80015d40:	e0 69 07 2c 	mov	r9,1836
80015d44:	13 88       	ld.ub	r8,r9[0x0]
80015d46:	58 08       	cp.w	r8,0
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);

	sysclk_pbb_refcount++;
80015d48:	c1 d0       	breq	80015d82 <sysclk_enable_pbb_module+0x4a>
80015d4a:	2f f8       	sub	r8,-1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015d4c:	b2 88       	st.b	r9[0x0],r8
80015d4e:	ed bb 00 10 	bld	r11,0x10
      cpu_irq_enable();
80015d52:	c0 20       	breq	80015d56 <sysclk_enable_pbb_module+0x1e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015d54:	d5 03       	csrf	0x10
80015d56:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015d5a:	d3 03       	ssrf	0x10
80015d5c:	fe 79 0c 00 	mov	r9,-62464
80015d60:	73 58       	ld.w	r8,r9[0x54]
80015d62:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
80015d66:	cf d1       	brne	80015d60 <sysclk_enable_pbb_module+0x28>
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015d68:	30 19       	mov	r9,1
80015d6a:	fe 78 0c 14 	mov	r8,-62444
	mask |= 1U << module_index;
80015d6e:	f2 0c 09 4c 	lsl	r12,r9,r12
80015d72:	70 09       	ld.w	r9,r8[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015d74:	12 4c       	or	r12,r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015d76:	91 0c       	st.w	r8[0x0],r12
80015d78:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
80015d7c:	c0 20       	breq	80015d80 <sysclk_enable_pbb_module+0x48>

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
}
80015d7e:	d5 03       	csrf	0x10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015d80:	d8 02       	popm	pc
80015d82:	e1 be 00 00 	mfsr	lr,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015d86:	d3 03       	ssrf	0x10
80015d88:	fe 7a 0c 00 	mov	r10,-62464
80015d8c:	75 58       	ld.w	r8,r10[0x54]
80015d8e:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015d92:	cf d1       	brne	80015d8c <sysclk_enable_pbb_module+0x54>
80015d94:	fe 7a 0c 0c 	mov	r10,-62452
	mask |= 1U << module_index;
80015d98:	74 08       	ld.w	r8,r10[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015d9a:	a3 a8       	sbr	r8,0x2
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015d9c:	95 08       	st.w	r10[0x0],r8
80015d9e:	ed be 00 10 	bld	lr,0x10
      cpu_irq_enable();
   }

	barrier();
80015da2:	c0 31       	brne	80015da8 <sysclk_enable_pbb_module+0x70>
80015da4:	13 88       	ld.ub	r8,r9[0x0]
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
80015da6:	cd 2b       	rjmp	80015d4a <sysclk_enable_pbb_module+0x12>
   }

	barrier();
80015da8:	d5 03       	csrf	0x10
80015daa:	13 88       	ld.ub	r8,r9[0x0]
80015dac:	cc fb       	rjmp	80015d4a <sysclk_enable_pbb_module+0x12>
80015dae:	d7 03       	nop

80015db0 <sysclk_enable_usb>:
 * \pre The USB generic clock must be configured to 48MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80015db0:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015db4:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80015db8:	d3 03       	ssrf	0x10
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_pbb_refcount)
80015dba:	e0 67 07 2c 	mov	r7,1836
80015dbe:	0f 88       	ld.ub	r8,r7[0x0]
80015dc0:	58 08       	cp.w	r8,0
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);

	sysclk_pbb_refcount++;
80015dc2:	c4 e0       	breq	80015e5e <sysclk_enable_usb+0xae>
80015dc4:	2f f8       	sub	r8,-1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015dc6:	ae 88       	st.b	r7[0x0],r8
80015dc8:	e6 16 00 01 	andh	r6,0x1,COH
      cpu_irq_enable();
80015dcc:	c0 21       	brne	80015dd0 <sysclk_enable_usb+0x20>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015dce:	d5 03       	csrf	0x10
80015dd0:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015dd4:	d3 03       	ssrf	0x10
80015dd6:	fe 79 0c 00 	mov	r9,-62464
80015dda:	73 58       	ld.w	r8,r9[0x54]
80015ddc:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015de0:	cf d1       	brne	80015dda <sysclk_enable_usb+0x2a>
80015de2:	fe 79 0c 14 	mov	r9,-62444
	mask |= 1U << module_index;
80015de6:	72 08       	ld.w	r8,r9[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015de8:	a1 b8       	sbr	r8,0x1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015dea:	93 08       	st.w	r9[0x0],r8
80015dec:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
80015df0:	c0 20       	breq	80015df4 <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015df2:	d5 03       	csrf	0x10
80015df4:	e1 ba 00 00 	mfsr	r10,0x0

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80015df8:	d3 03       	ssrf	0x10
80015dfa:	fe 79 0c 00 	mov	r9,-62464
80015dfe:	73 58       	ld.w	r8,r9[0x54]
80015e00:	ed b8 00 06 	bld	r8,0x6
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80015e04:	cf d1       	brne	80015dfe <sysclk_enable_usb+0x4e>
80015e06:	fe 79 0c 0c 	mov	r9,-62452
	mask |= 1U << module_index;
80015e0a:	72 08       	ld.w	r8,r9[0x0]
	*(&AVR32_PM.cpumask + bus_id) = mask;
80015e0c:	a3 b8       	sbr	r8,0x3
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015e0e:	93 08       	st.w	r9[0x0],r8
80015e10:	ed ba 00 10 	bld	r10,0x10
      cpu_irq_enable();
80015e14:	c0 20       	breq	80015e18 <sysclk_enable_usb+0x68>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80015e16:	d5 03       	csrf	0x10
80015e18:	fe 77 0c 00 	mov	r7,-62464

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
80015e1c:	6f 58       	ld.w	r8,r7[0x54]
80015e1e:	ed b8 00 01 	bld	r8,0x1
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC0RDY));
80015e22:	c1 10       	breq	80015e44 <sysclk_enable_usb+0x94>

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80015e24:	6f 5c       	ld.w	r12,r7[0x54]
80015e26:	e2 1c 00 80 	andl	r12,0x80,COH
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80015e2a:	c1 40       	breq	80015e52 <sysclk_enable_usb+0xa2>
80015e2c:	fe 78 0c 00 	mov	r8,-62464
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80015e30:	e0 6a 02 0d 	mov	r10,525
80015e34:	ea 1a 3f 0f 	orh	r10,0x3f0f
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80015e38:	10 99       	mov	r9,r8

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80015e3a:	91 9a       	st.w	r8[0x24],r10
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80015e3c:	73 58       	ld.w	r8,r9[0x54]
80015e3e:	ed b8 00 01 	bld	r8,0x1
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80015e42:	cf d1       	brne	80015e3c <sysclk_enable_usb+0x8c>
80015e44:	30 79       	mov	r9,7
80015e46:	fe 78 0c 00 	mov	r8,-62464
80015e4a:	f1 49 00 70 	st.w	r8[112],r9
void sysclk_enable_usb(void)
{
	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
	sysclk_enable_hsb_module(SYSCLK_USBB_DATA);
	genclk_enable_config(AVR32_PM_GCLK_USBB, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
}
80015e4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
80015e52:	ce 9e       	rcall	80015c24 <osc_enable>
80015e54:	6f 58       	ld.w	r8,r7[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80015e56:	ed b8 00 07 	bld	r8,0x7
80015e5a:	cf d1       	brne	80015e54 <sysclk_enable_usb+0xa4>
80015e5c:	ce 8b       	rjmp	80015e2c <sysclk_enable_usb+0x7c>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
80015e5e:	30 2b       	mov	r11,2
80015e60:	30 1c       	mov	r12,1
80015e62:	c1 5f       	rcall	80015c8c <sysclk_priv_enable_module>
80015e64:	0f 88       	ld.ub	r8,r7[0x0]
80015e66:	ca fb       	rjmp	80015dc4 <sysclk_enable_usb+0x14>

80015e68 <sysclk_init>:
80015e68:	eb cd 40 80 	pushm	r7,lr
80015e6c:	fe 77 0c 00 	mov	r7,-62464
80015e70:	6f 58       	ld.w	r8,r7[0x54]
80015e72:	ed b8 00 00 	bld	r8,0x0
80015e76:	c1 10       	breq	80015e98 <sysclk_init+0x30>
80015e78:	6f 5c       	ld.w	r12,r7[0x54]

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80015e7a:	e2 1c 00 80 	andl	r12,0x80,COH
80015e7e:	c2 c0       	breq	80015ed6 <sysclk_init+0x6e>
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80015e80:	fe 78 0c 00 	mov	r8,-62464
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80015e84:	e0 6a 02 05 	mov	r10,517
80015e88:	ea 1a 3f 0a 	orh	r10,0x3f0a

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80015e8c:	10 99       	mov	r9,r8
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80015e8e:	91 8a       	st.w	r8[0x20],r10

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80015e90:	73 58       	ld.w	r8,r9[0x54]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80015e92:	ed b8 00 00 	bld	r8,0x0
80015e96:	cf d1       	brne	80015e90 <sysclk_init+0x28>

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80015e98:	e0 6c 14 80 	mov	r12,5248
80015e9c:	ea 1c 03 ef 	orh	r12,0x3ef
80015ea0:	fe b0 e1 0d 	rcall	800120ba <flashc_set_bus_freq>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80015ea4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80015ea8:	d3 03       	ssrf	0x10
	uint32_t   mcctrl;

	Assert(src <= SYSCLK_SRC_PLL0);

	flags = cpu_irq_save();
	mcctrl = AVR32_PM.mcctrl & ~AVR32_PM_MCCTRL_MCSEL_MASK;
80015eaa:	fe 7a 0c 00 	mov	r10,-62464
80015eae:	74 08       	ld.w	r8,r10[0x0]
80015eb0:	e0 18 ff fc 	andl	r8,0xfffc
	mcctrl |= src << AVR32_PM_MCCTRL_MCSEL;
80015eb4:	a1 b8       	sbr	r8,0x1
	AVR32_PM.mcctrl = mcctrl;
80015eb6:	95 08       	st.w	r10[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80015eb8:	ed b9 00 10 	bld	r9,0x10
80015ebc:	c0 20       	breq	80015ec0 <sysclk_init+0x58>
      cpu_irq_enable();
80015ebe:	d5 03       	csrf	0x10
	/* If the user has specified clock masks, enable only requested clocks */
#if defined(CONFIG_SYSCLK_INIT_CPUMASK)
	AVR32_PM.cpumask = SYSCLK_INIT_MINIMAL_CPUMASK | CONFIG_SYSCLK_INIT_CPUMASK;
#endif
#if defined(CONFIG_SYSCLK_INIT_PBAMASK)
	AVR32_PM.pbamask = SYSCLK_INIT_MINIMAL_PBAMASK | CONFIG_SYSCLK_INIT_PBAMASK;
80015ec0:	fe 78 0c 00 	mov	r8,-62464
80015ec4:	e0 69 43 6f 	mov	r9,17263
80015ec8:	91 49       	st.w	r8[0x10],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_PBBMASK)
	AVR32_PM.pbbmask = SYSCLK_INIT_MINIMAL_PBBMASK | CONFIG_SYSCLK_INIT_PBBMASK;
80015eca:	31 59       	mov	r9,21
80015ecc:	91 59       	st.w	r8[0x14],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_HSBMASK)
	AVR32_PM.hsbmask = SYSCLK_INIT_MINIMAL_HSBMASK | CONFIG_SYSCLK_INIT_HSBMASK;
80015ece:	36 39       	mov	r9,99
80015ed0:	91 39       	st.w	r8[0xc],r9

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80015ed2:	e3 cd 80 80 	ldm	sp++,r7,pc
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
80015ed6:	ca 7e       	rcall	80015c24 <osc_enable>
80015ed8:	6f 58       	ld.w	r8,r7[0x54]
80015eda:	ed b8 00 07 	bld	r8,0x7
80015ede:	cf d1       	brne	80015ed8 <sysclk_init+0x70>
80015ee0:	cd 0b       	rjmp	80015e80 <sysclk_init+0x18>
80015ee2:	d7 03       	nop

80015ee4 <uhc_enumeration_step2>:
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80015ee4:	fe c9 ff 5c 	sub	r9,pc,-164
80015ee8:	e0 68 07 50 	mov	r8,1872
  uhc_sof_timeout = timeout;
80015eec:	91 09       	st.w	r8[0x0],r9
80015eee:	31 49       	mov	r9,20
 * Lets USB line in IDLE state during 20ms.
 */
static void uhc_enumeration_step2(void)
{
  uhc_enable_timeout_callback(20, uhc_enumeration_step3);
}
80015ef0:	e0 68 2d 16 	mov	r8,11542
80015ef4:	b0 89       	st.b	r8[0x0],r9
80015ef6:	5e fc       	retal	r12

80015ef8 <uhc_enumeration_step8>:
80015ef8:	fe c9 fe 30 	sub	r9,pc,-464
80015efc:	e0 68 07 50 	mov	r8,1872
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
  uhc_sof_timeout = timeout;
80015f00:	91 09       	st.w	r8[0x0],r9
80015f02:	36 49       	mov	r9,100
 */
static void uhc_enumeration_step8(void)
{
  // Wait 100ms
  uhc_enable_timeout_callback(100, uhc_enumeration_step9);
}
80015f04:	e0 68 2d 16 	mov	r8,11542
80015f08:	b0 89       	st.b	r8[0x0],r9
80015f0a:	5e fc       	retal	r12

80015f0c <uhc_notify_sof>:
80015f0c:	eb cd 40 c0 	pushm	r6-r7,lr
80015f10:	49 47       	lddpc	r7,80015f60 <uhc_notify_sof+0x54>
80015f12:	18 96       	mov	r6,r12

void uhc_notify_sof(bool b_micro)
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    if (uhc_uhis[i].sof_notify != NULL) {
80015f14:	6e 38       	ld.w	r8,r7[0xc]
80015f16:	58 08       	cp.w	r8,0
80015f18:	c0 20       	breq	80015f1c <uhc_notify_sof+0x10>
      uhc_uhis[i].sof_notify(b_micro);
80015f1a:	5d 18       	icall	r8

void uhc_notify_sof(bool b_micro)
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    if (uhc_uhis[i].sof_notify != NULL) {
80015f1c:	6e 78       	ld.w	r8,r7[0x1c]
80015f1e:	58 08       	cp.w	r8,0
80015f20:	c0 30       	breq	80015f26 <uhc_notify_sof+0x1a>
      uhc_uhis[i].sof_notify(b_micro);
80015f22:	0c 9c       	mov	r12,r6
80015f24:	5d 18       	icall	r8

void uhc_notify_sof(bool b_micro)
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    if (uhc_uhis[i].sof_notify != NULL) {
80015f26:	6e b8       	ld.w	r8,r7[0x2c]
80015f28:	58 08       	cp.w	r8,0
80015f2a:	c0 30       	breq	80015f30 <uhc_notify_sof+0x24>
      uhc_uhis[i].sof_notify(b_micro);
80015f2c:	0c 9c       	mov	r12,r6
80015f2e:	5d 18       	icall	r8

void uhc_notify_sof(bool b_micro)
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    if (uhc_uhis[i].sof_notify != NULL) {
80015f30:	6e f8       	ld.w	r8,r7[0x3c]
80015f32:	58 08       	cp.w	r8,0
80015f34:	c0 30       	breq	80015f3a <uhc_notify_sof+0x2e>
      uhc_uhis[i].sof_notify(b_micro);
80015f36:	0c 9c       	mov	r12,r6
80015f38:	5d 18       	icall	r8
    }
  }

  if (!b_micro) {
80015f3a:	58 06       	cp.w	r6,0
80015f3c:	c0 a1       	brne	80015f50 <uhc_notify_sof+0x44>
    // Manage SOF timeout
    if (uhc_sof_timeout) {
80015f3e:	e0 68 2d 16 	mov	r8,11542
80015f42:	11 89       	ld.ub	r9,r8[0x0]
80015f44:	58 09       	cp.w	r9,0
      if (--uhc_sof_timeout == 0) {
80015f46:	c0 50       	breq	80015f50 <uhc_notify_sof+0x44>
80015f48:	20 19       	sub	r9,1
80015f4a:	5c 59       	castu.b	r9
80015f4c:	b0 89       	st.b	r8[0x0],r9
80015f4e:	c0 30       	breq	80015f54 <uhc_notify_sof+0x48>
80015f50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	uhc_sof_timeout_callback();
80015f54:	e0 68 07 50 	mov	r8,1872
80015f58:	70 08       	ld.w	r8,r8[0x0]
80015f5a:	5d 18       	icall	r8
80015f5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80015f60:	80 02       	ld.sh	r2,r0[0x0]
80015f62:	43 90       	lddsp	r0,sp[0xe4]

80015f64 <uhc_stop>:
80015f64:	d4 01       	pushm	lr
80015f66:	fe b0 f4 13 	rcall	8001478c <uhd_disable>

void uhc_stop(bool b_id_stop)
{
  // Stop UHD
  uhd_disable(b_id_stop);
}
80015f6a:	d8 02       	popm	pc

80015f6c <uhc_start>:
80015f6c:	d4 01       	pushm	lr
80015f6e:	3f f9       	mov	r9,-1
 *
 * @{
 */
void uhc_start(void)
{
  g_uhc_device_root.address = UHC_USB_ADD_NOT_VALID;
80015f70:	e0 68 07 30 	mov	r8,1840
80015f74:	f1 69 00 12 	st.b	r8[18],r9
  uhc_sof_timeout = 0; // No callback registered on a SOF timeout
80015f78:	30 09       	mov	r9,0
80015f7a:	e0 68 2d 16 	mov	r8,11542
  uhd_enable();
80015f7e:	b0 89       	st.b	r8[0x0],r9
}
80015f80:	fe b0 f3 a2 	rcall	800146c4 <uhd_enable>
80015f84:	d8 02       	popm	pc
80015f86:	d7 03       	nop

80015f88 <uhc_enumeration_step3>:
80015f88:	d4 01       	pushm	lr
80015f8a:	fe cc ff ea 	sub	r12,pc,-22
80015f8e:	fe b0 f1 d9 	rcall	80014340 <uhd_send_reset>
 * Reset USB line.
 */
static void uhc_enumeration_step3(void)
{
  uhc_enumeration_reset(uhc_enumeration_step4);
}
80015f92:	d8 02       	popm	pc

80015f94 <uhc_enumeration_step7>:
80015f94:	d4 01       	pushm	lr
80015f96:	fe cc 00 9e 	sub	r12,pc,158
80015f9a:	fe b0 f1 d3 	rcall	80014340 <uhd_send_reset>
 * Reset USB line.
 */
static void uhc_enumeration_step7(void)
{
  uhc_enumeration_reset(uhc_enumeration_step8);
}
80015f9e:	d8 02       	popm	pc

80015fa0 <uhc_enumeration_step4>:
80015fa0:	d4 01       	pushm	lr
80015fa2:	fe b0 f1 c1 	rcall	80014324 <uhd_get_speed>
80015fa6:	e0 68 07 30 	mov	r8,1840
 * \brief Device enumeration step 4
 * Lets USB line in IDLE state during 100ms.
 */
static void uhc_enumeration_step4(void)
{
  uhc_dev_enum->speed = uhd_get_speed();
80015faa:	fe c9 ff 82 	sub	r9,pc,-126
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80015fae:	91 5c       	st.w	r8[0x14],r12
  uhc_sof_timeout = timeout;
80015fb0:	e0 68 07 50 	mov	r8,1872
80015fb4:	91 09       	st.w	r8[0x0],r9
 */
static void uhc_enumeration_step4(void)
{
  uhc_dev_enum->speed = uhd_get_speed();
  uhc_enable_timeout_callback(100, uhc_enumeration_step5);
}
80015fb6:	36 49       	mov	r9,100
80015fb8:	e0 68 2d 16 	mov	r8,11542
80015fbc:	b0 89       	st.b	r8[0x0],r9
80015fbe:	d8 02       	popm	pc

80015fc0 <uhc_enumeration_error>:
80015fc0:	d4 21       	pushm	r4-r7,lr
80015fc2:	18 96       	mov	r6,r12
80015fc4:	58 7c       	cp.w	r12,7
80015fc6:	c2 c0       	breq	8001601e <uhc_enumeration_error+0x5e>
80015fc8:	e0 67 07 30 	mov	r7,1840
{
  if (status == UHC_ENUM_DISCONNECT) {
    uhc_enum_try = 0;
    return; // Abort enumeration process
  }
  uhd_ep_free(uhc_dev_enum->address, 0xFF);
80015fcc:	e0 6b 00 ff 	mov	r11,255
80015fd0:	ef 3c 00 12 	ld.ub	r12,r7[18]
80015fd4:	fe b0 f6 0c 	rcall	80014bec <uhd_ep_free>

  // Free USB configuration descriptor buffer
  if (uhc_dev_enum->conf_desc != NULL) {
80015fd8:	6e 6c       	ld.w	r12,r7[0x18]
80015fda:	58 0c       	cp.w	r12,0
    free(uhc_dev_enum->conf_desc);
80015fdc:	c0 50       	breq	80015fe6 <uhc_enumeration_error+0x26>
80015fde:	e0 a0 69 49 	rcall	80023270 <free>
    uhc_dev_enum->conf_desc = NULL;
80015fe2:	30 08       	mov	r8,0
  }
  uhc_dev_enum->address = 0;
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
80015fe4:	8f 68       	st.w	r7[0x18],r8
  // Free USB configuration descriptor buffer
  if (uhc_dev_enum->conf_desc != NULL) {
    free(uhc_dev_enum->conf_desc);
    uhc_dev_enum->conf_desc = NULL;
  }
  uhc_dev_enum->address = 0;
80015fe6:	e0 65 07 4c 	mov	r5,1868
80015fea:	30 04       	mov	r4,0
80015fec:	0b 88       	ld.ub	r8,r5[0x0]
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
80015fee:	ef 64 00 12 	st.b	r7[18],r4
80015ff2:	f0 c9 ff ff 	sub	r9,r8,-1
80015ff6:	aa 89       	st.b	r5[0x0],r9
80015ff8:	30 39       	mov	r9,3
80015ffa:	f2 08 18 00 	cp.b	r8,r9
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80015ffe:	e0 88 00 0b 	brls	80016014 <uhc_enumeration_error+0x54>
    uhc_enumeration_step1();
    return;
  }
  // Abort enumeration, set line in suspend mode
  uhc_enumeration_suspend();
  UHC_ENUM_EVENT(uhc_dev_enum, status);
80016002:	fe b0 f1 a9 	rcall	80014354 <uhd_suspend>
80016006:	0c 9b       	mov	r11,r6
80016008:	e0 6c 07 30 	mov	r12,1840
  uhc_enum_try = 0;
8001600c:	e0 a0 22 6a 	rcall	8001a4e0 <usb_enum>
    // Device connected on USB hub
    uhi_hub_send_reset(uhc_dev_enum, callback);
  } else
#endif
    {
      uhd_send_reset(callback);
80016010:	aa 84       	st.b	r5[0x0],r4
80016012:	d8 22       	popm	r4-r7,pc
  }
  uhc_dev_enum->address = 0;
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
    // Restart enumeration at beginning
    uhc_enumeration_step1();
    return;
80016014:	fe cc 01 30 	sub	r12,pc,304
 * \param status        Enumeration error occurred
 */
static void uhc_enumeration_error(uhc_enum_status_t status)
{
  if (status == UHC_ENUM_DISCONNECT) {
    uhc_enum_try = 0;
80016018:	fe b0 f1 94 	rcall	80014340 <uhd_send_reset>
    return; // Abort enumeration process
8001601c:	d8 22       	popm	r4-r7,pc
8001601e:	30 09       	mov	r9,0
80016020:	e0 68 07 4c 	mov	r8,1868
80016024:	b0 89       	st.b	r8[0x0],r9
80016026:	d8 22       	popm	r4-r7,pc

80016028 <uhc_enumeration_step5>:
80016028:	d4 01       	pushm	lr
8001602a:	20 2d       	sub	sp,8
8001602c:	38 08       	mov	r8,-128
8001602e:	ba 88       	st.b	sp[0x0],r8
80016030:	30 68       	mov	r8,6
80016032:	ba 98       	st.b	sp[0x1],r8
80016034:	e0 68 01 00 	mov	r8,256
80016038:	ba 18       	st.h	sp[0x2],r8
8001603a:	30 08       	mov	r8,0
8001603c:	ba 28       	st.h	sp[0x4],r8
8001603e:	30 88       	mov	r8,8
  req.wValue = (USB_DT_DEVICE << 8);
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
80016040:	34 0b       	mov	r11,64

  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_DEVICE << 8);
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
80016042:	ba 38       	st.h	sp[0x6],r8
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
80016044:	30 0c       	mov	r12,0
80016046:	fe b0 f2 b4 	rcall	800145ae <uhd_ep0_alloc>
8001604a:	c1 60       	breq	80016076 <uhc_enumeration_step5+0x4e>
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }
  if (!uhd_setup_request(0,
8001604c:	fe c9 ff cc 	sub	r9,pc,-52
80016050:	30 08       	mov	r8,0
80016052:	1a d9       	st.w	--sp,r9
80016054:	e0 6a 07 30 	mov	r10,1840
80016058:	fa cb ff fc 	sub	r11,sp,-4
8001605c:	31 29       	mov	r9,18
8001605e:	10 9c       	mov	r12,r8
80016060:	fe b0 f4 ca 	rcall	800149f4 <uhd_setup_request>
80016064:	2f fd       	sub	sp,-4
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80016066:	58 0c       	cp.w	r12,0
80016068:	c0 30       	breq	8001606e <uhc_enumeration_step5+0x46>
			 &req,
			 (uint8_t*)&uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
8001606a:	2f ed       	sub	sp,-8
8001606c:	d8 02       	popm	pc
8001606e:	30 6c       	mov	r12,6
    return;
  }
}
80016070:	ca 8f       	rcall	80015fc0 <uhc_enumeration_error>
80016072:	2f ed       	sub	sp,-8
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80016074:	d8 02       	popm	pc
80016076:	30 4c       	mov	r12,4
80016078:	ca 4f       	rcall	80015fc0 <uhc_enumeration_error>
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
8001607a:	2f ed       	sub	sp,-8
8001607c:	d8 02       	popm	pc
8001607e:	d7 03       	nop

80016080 <uhc_enumeration_step6>:
80016080:	d4 01       	pushm	lr
80016082:	30 79       	mov	r9,7
80016084:	58 0b       	cp.w	r11,0
80016086:	5f 18       	srne	r8
80016088:	f2 0a 19 00 	cp.h	r10,r9
8001608c:	5f 89       	srls	r9
8001608e:	f3 e8 10 08 	or	r8,r9,r8
80016092:	c0 b1       	brne	800160a8 <uhc_enumeration_step6+0x28>
				  usb_add_t add,
				  uhd_trans_status_t status,
				  uint16_t payload_trans)
{
  UNUSED(add);
  if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
80016094:	e0 68 07 30 	mov	r8,1840
80016098:	11 99       	ld.ub	r9,r8[0x1]
8001609a:	30 18       	mov	r8,1
8001609c:	f0 09 18 00 	cp.b	r9,r8
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
800160a0:	c0 90       	breq	800160b2 <uhc_enumeration_step6+0x32>
800160a2:	30 3c       	mov	r12,3
800160a4:	c8 ef       	rcall	80015fc0 <uhc_enumeration_error>
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
800160a6:	d8 02       	popm	pc
				  uint16_t payload_trans)
{
  UNUSED(add);
  if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
800160a8:	58 1b       	cp.w	r11,1
800160aa:	cf c1       	brne	800160a2 <uhc_enumeration_step6+0x22>
800160ac:	30 7c       	mov	r12,7
800160ae:	c8 9f       	rcall	80015fc0 <uhc_enumeration_error>
800160b0:	d8 02       	popm	pc
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
800160b2:	fe c9 01 1e 	sub	r9,pc,286
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
800160b6:	e0 68 07 50 	mov	r8,1872
  uhc_sof_timeout = timeout;
800160ba:	91 09       	st.w	r8[0x0],r9
800160bc:	31 49       	mov	r9,20
800160be:	e0 68 2d 16 	mov	r8,11542
800160c2:	b0 89       	st.b	r8[0x0],r9
800160c4:	d8 02       	popm	pc
800160c6:	d7 03       	nop

800160c8 <uhc_enumeration_step9>:
800160c8:	eb cd 40 80 	pushm	r7,lr
800160cc:	20 2d       	sub	sp,8
800160ce:	30 18       	mov	r8,1
800160d0:	e0 67 07 30 	mov	r7,1840
800160d4:	ba 18       	st.h	sp[0x2],r8
800160d6:	ef 68 00 12 	st.b	r7[18],r8
#else
  req.wValue = UHC_DEVICE_ENUM_ADD;
  uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
  req.wIndex = 0;
  req.wLength = 0;
800160da:	30 08       	mov	r8,0
  uhc_dev_enum->address = usb_addr_free;
#else
  req.wValue = UHC_DEVICE_ENUM_ADD;
  uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
  req.wIndex = 0;
800160dc:	ba 38       	st.h	sp[0x6],r8
 */
static void uhc_enumeration_step9(void)
{
  usb_setup_req_t req;

  req.bmRequestType = USB_REQ_RECIP_DEVICE
800160de:	ba 28       	st.h	sp[0x4],r8
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_ADDRESS;
800160e0:	ba 88       	st.b	sp[0x0],r8
#endif
  req.wIndex = 0;
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
800160e2:	30 58       	mov	r8,5
{
  usb_setup_req_t req;

  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_ADDRESS;
800160e4:	30 0b       	mov	r11,0
#endif
  req.wIndex = 0;
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
800160e6:	ba 98       	st.b	sp[0x1],r8
800160e8:	16 9c       	mov	r12,r11
800160ea:	fe b0 f5 81 	rcall	80014bec <uhd_ep_free>
  if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
800160ee:	0f fb       	ld.ub	r11,r7[0x7]
800160f0:	30 0c       	mov	r12,0
800160f2:	fe b0 f2 5e 	rcall	800145ae <uhd_ep0_alloc>
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }

  if (!uhd_setup_request(0,
800160f6:	c1 70       	breq	80016124 <uhc_enumeration_step9+0x5c>
800160f8:	fe c9 ff c8 	sub	r9,pc,-56
800160fc:	30 08       	mov	r8,0
800160fe:	1a d9       	st.w	--sp,r9
80016100:	0e 9a       	mov	r10,r7
80016102:	fa cb ff fc 	sub	r11,sp,-4
80016106:	31 29       	mov	r9,18
80016108:	10 9c       	mov	r12,r8
8001610a:	fe b0 f4 75 	rcall	800149f4 <uhd_setup_request>
8001610e:	2f fd       	sub	sp,-4
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80016110:	58 0c       	cp.w	r12,0
80016112:	c0 40       	breq	8001611a <uhc_enumeration_step9+0x52>
80016114:	2f ed       	sub	sp,-8
			 &req,
			 (uint8_t*)&uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80016116:	e3 cd 80 80 	ldm	sp++,r7,pc
8001611a:	30 6c       	mov	r12,6
    return;
  }
}
8001611c:	c5 2f       	rcall	80015fc0 <uhc_enumeration_error>
8001611e:	2f ed       	sub	sp,-8
80016120:	e3 cd 80 80 	ldm	sp++,r7,pc
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
  if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80016124:	30 4c       	mov	r12,4
80016126:	c4 df       	rcall	80015fc0 <uhc_enumeration_error>
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80016128:	2f ed       	sub	sp,-8
8001612a:	e3 cd 80 80 	ldm	sp++,r7,pc
8001612e:	d7 03       	nop

80016130 <uhc_enumeration_step10>:
80016130:	d4 01       	pushm	lr
80016132:	58 0b       	cp.w	r11,0
80016134:	c0 80       	breq	80016144 <uhc_enumeration_step10+0x14>
80016136:	58 1b       	cp.w	r11,1
80016138:	f9 bc 00 07 	moveq	r12,7
8001613c:	f9 bc 01 03 	movne	r12,3
80016140:	c4 0f       	rcall	80015fc0 <uhc_enumeration_error>
80016142:	d8 02       	popm	pc
80016144:	fe c9 ff ec 	sub	r9,pc,-20
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80016148:	e0 68 07 50 	mov	r8,1872
  uhc_sof_timeout = timeout;
8001614c:	91 09       	st.w	r8[0x0],r9
8001614e:	31 49       	mov	r9,20
80016150:	e0 68 2d 16 	mov	r8,11542
80016154:	b0 89       	st.b	r8[0x0],r9
80016156:	d8 02       	popm	pc

80016158 <uhc_enumeration_step11>:
80016158:	eb cd 40 80 	pushm	r7,lr
8001615c:	20 2d       	sub	sp,8
8001615e:	30 0b       	mov	r11,0
80016160:	16 9c       	mov	r12,r11
80016162:	fe b0 f5 45 	rcall	80014bec <uhd_ep_free>

  // Free address 0 used to start enumeration
  uhd_ep_free(0, 0);

  // Alloc control endpoint with the new USB address
  if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
80016166:	30 1c       	mov	r12,1
80016168:	e0 67 07 30 	mov	r7,1840
8001616c:	0f fb       	ld.ub	r11,r7[0x7]
8001616e:	fe b0 f2 20 	rcall	800145ae <uhd_ep0_alloc>
		     uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80016172:	c2 20       	breq	800161b6 <uhc_enumeration_step11+0x5e>
80016174:	38 08       	mov	r8,-128
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
80016176:	ba 88       	st.b	sp[0x0],r8
80016178:	30 68       	mov	r8,6
  req.wValue = (USB_DT_DEVICE << 8);
8001617a:	ba 98       	st.b	sp[0x1],r8
8001617c:	e0 68 01 00 	mov	r8,256
  req.wIndex = 0;
80016180:	ba 18       	st.h	sp[0x2],r8
80016182:	30 08       	mov	r8,0
  req.wLength = sizeof(usb_dev_desc_t);
80016184:	ba 28       	st.h	sp[0x4],r8
80016186:	31 28       	mov	r8,18
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80016188:	ba 38       	st.h	sp[0x6],r8
8001618a:	fe c8 ff ca 	sub	r8,pc,-54
8001618e:	0e 9a       	mov	r10,r7
80016190:	1a d8       	st.w	--sp,r8
80016192:	31 29       	mov	r9,18
80016194:	fa cb ff fc 	sub	r11,sp,-4
80016198:	30 08       	mov	r8,0
8001619a:	30 1c       	mov	r12,1
8001619c:	fe b0 f4 2c 	rcall	800149f4 <uhd_setup_request>
800161a0:	2f fd       	sub	sp,-4
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
800161a2:	58 0c       	cp.w	r12,0
800161a4:	c0 40       	breq	800161ac <uhc_enumeration_step11+0x54>
800161a6:	2f ed       	sub	sp,-8
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) & uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
800161a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800161ac:	30 6c       	mov	r12,6
    return;
  }
}
800161ae:	c0 9f       	rcall	80015fc0 <uhc_enumeration_error>
800161b0:	2f ed       	sub	sp,-8
800161b2:	e3 cd 80 80 	ldm	sp++,r7,pc
  uhd_ep_free(0, 0);

  // Alloc control endpoint with the new USB address
  if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
		     uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
800161b6:	30 4c       	mov	r12,4
800161b8:	c0 4f       	rcall	80015fc0 <uhc_enumeration_error>
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
800161ba:	2f ed       	sub	sp,-8
800161bc:	e3 cd 80 80 	ldm	sp++,r7,pc

800161c0 <uhc_enumeration_step12>:
800161c0:	eb cd 40 80 	pushm	r7,lr
800161c4:	20 2d       	sub	sp,8
800161c6:	31 29       	mov	r9,18
800161c8:	58 0b       	cp.w	r11,0
800161ca:	5f 18       	srne	r8
800161cc:	f2 0a 19 00 	cp.h	r10,r9
800161d0:	5f 19       	srne	r9
800161d2:	f3 e8 10 08 	or	r8,r9,r8
800161d6:	c0 d1       	brne	800161f0 <uhc_enumeration_step12+0x30>
{
  usb_setup_req_t req;
  uint8_t conf_num;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
800161d8:	e0 67 07 30 	mov	r7,1840
800161dc:	30 18       	mov	r8,1
800161de:	0f 99       	ld.ub	r9,r7[0x1]
800161e0:	f0 09 18 00 	cp.b	r9,r8
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
800161e4:	c0 a0       	breq	800161f8 <uhc_enumeration_step12+0x38>
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 sizeof(usb_conf_desc_t),
			 NULL, uhc_enumeration_step13)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
800161e6:	30 3c       	mov	r12,3
800161e8:	ce ce       	rcall	80015fc0 <uhc_enumeration_error>
    return;
  }
}
800161ea:	2f ed       	sub	sp,-8
800161ec:	e3 cd 80 80 	ldm	sp++,r7,pc
  uint8_t conf_num;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
800161f0:	58 1b       	cp.w	r11,1
800161f2:	cf a1       	brne	800161e6 <uhc_enumeration_step12+0x26>
800161f4:	30 7c       	mov	r12,7
800161f6:	cf 9b       	rjmp	800161e8 <uhc_enumeration_step12+0x28>
    conf_num = UHC_DEVICE_CONF(uhc_dev_enum);
  } else {
    conf_num = 1;
  }

  uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
800161f8:	30 9c       	mov	r12,9
800161fa:	e0 a0 68 43 	rcall	80023280 <malloc>
800161fe:	8f 6c       	st.w	r7[0x18],r12
  if (uhc_dev_enum->conf_desc == NULL) {
80016200:	c1 c0       	breq	80016238 <uhc_enumeration_step12+0x78>
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80016202:	38 08       	mov	r8,-128
80016204:	ba 88       	st.b	sp[0x0],r8
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
80016206:	30 68       	mov	r8,6
80016208:	ba 98       	st.b	sp[0x1],r8
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
8001620a:	e0 68 02 00 	mov	r8,512
8001620e:	ba 18       	st.h	sp[0x2],r8
  req.wIndex = 0;
80016210:	30 08       	mov	r8,0
80016212:	ba 28       	st.h	sp[0x4],r8
  req.wLength = sizeof(usb_conf_desc_t);
80016214:	30 98       	mov	r8,9
80016216:	ba 38       	st.h	sp[0x6],r8
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80016218:	fe c8 ff d8 	sub	r8,pc,-40
8001621c:	18 9a       	mov	r10,r12
8001621e:	1a d8       	st.w	--sp,r8
80016220:	30 99       	mov	r9,9
80016222:	fa cb ff fc 	sub	r11,sp,-4
80016226:	30 08       	mov	r8,0
80016228:	30 1c       	mov	r12,1
8001622a:	fe b0 f3 e5 	rcall	800149f4 <uhd_setup_request>
8001622e:	2f fd       	sub	sp,-4
80016230:	58 0c       	cp.w	r12,0
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 sizeof(usb_conf_desc_t),
			 NULL, uhc_enumeration_step13)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80016232:	cd c1       	brne	800161ea <uhc_enumeration_step12+0x2a>
80016234:	30 6c       	mov	r12,6
  }

  uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
  if (uhc_dev_enum->conf_desc == NULL) {
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80016236:	cd 9b       	rjmp	800161e8 <uhc_enumeration_step12+0x28>
80016238:	30 6c       	mov	r12,6
8001623a:	cc 3e       	rcall	80015fc0 <uhc_enumeration_error>
    return;
8001623c:	cd 7b       	rjmp	800161ea <uhc_enumeration_step12+0x2a>
8001623e:	d7 03       	nop

80016240 <uhc_enumeration_step13>:
80016240:	eb cd 40 e0 	pushm	r5-r7,lr
80016244:	20 2d       	sub	sp,8
80016246:	30 99       	mov	r9,9
80016248:	58 0b       	cp.w	r11,0
8001624a:	5f 18       	srne	r8
8001624c:	f2 0a 19 00 	cp.h	r10,r9
80016250:	5f 19       	srne	r9
80016252:	f3 e8 10 08 	or	r8,r9,r8
  uint8_t conf_num, conf_size;
  uint16_t bus_power = 0;
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
80016256:	c0 e1       	brne	80016272 <uhc_enumeration_step13+0x32>
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
80016258:	e0 67 07 30 	mov	r7,1840
8001625c:	30 29       	mov	r9,2
  uint8_t conf_num, conf_size;
  uint16_t bus_power = 0;
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
8001625e:	6e 68       	ld.w	r8,r7[0x18]
80016260:	11 9a       	ld.ub	r10,r8[0x1]
80016262:	f2 0a 18 00 	cp.b	r10,r9
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80016266:	c0 a0       	breq	8001627a <uhc_enumeration_step13+0x3a>
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 conf_size,
			 NULL, uhc_enumeration_step14)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80016268:	30 3c       	mov	r12,3
8001626a:	ca be       	rcall	80015fc0 <uhc_enumeration_error>
    return;
  }
}
8001626c:	2f ed       	sub	sp,-8
8001626e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80016272:	58 1b       	cp.w	r11,1
80016274:	cf a1       	brne	80016268 <uhc_enumeration_step13+0x28>
80016276:	30 7c       	mov	r12,7
80016278:	cf 9b       	rjmp	8001626a <uhc_enumeration_step13+0x2a>
    }
    // Go to USB HUB parent
    dev = dev->hub;
  }
#else
  if (!(uhc_dev_enum->conf_desc->bmAttributes
8001627a:	11 f9       	ld.ub	r9,r8[0x7]
8001627c:	ed b9 00 06 	bld	r9,0x6
80016280:	c1 10       	breq	800162a2 <uhc_enumeration_step13+0x62>
	&USB_CONFIG_ATTR_SELF_POWERED)) {
    bus_power = uhc_dev_enum->conf_desc->bMaxPower * 2;
80016282:	f1 3a 00 08 	ld.ub	r10,r8[8]
80016286:	e0 69 01 f4 	mov	r9,500
8001628a:	a1 7a       	lsl	r10,0x1
8001628c:	f2 0a 19 00 	cp.h	r10,r9
80016290:	e0 88 00 09 	brls	800162a2 <uhc_enumeration_step13+0x62>
  }
#endif
  if ((bus_power + uhc_power_running) > USB_HOST_POWER_MAX) {
    // USB interfaces consumption too high
    UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_OVERCURRENT);
80016294:	0e 9c       	mov	r12,r7
80016296:	30 2b       	mov	r11,2
80016298:	e0 a0 21 24 	rcall	8001a4e0 <usb_enum>
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
8001629c:	fe b0 f0 5c 	rcall	80014354 <uhd_suspend>
800162a0:	ce 6b       	rjmp	8001626c <uhc_enumeration_step13+0x2c>
  uhc_dev_enum->power = bus_power;
  uhc_power_running += bus_power;
#endif

  // Save information about USB configuration descriptor size
  conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
800162a2:	11 a6       	ld.ub	r6,r8[0x2]
  conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
800162a4:	6e 68       	ld.w	r8,r7[0x18]
  Assert(conf_num);
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
800162a6:	10 9c       	mov	r12,r8
  uhc_power_running += bus_power;
#endif

  // Save information about USB configuration descriptor size
  conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
  conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
800162a8:	11 d5       	ld.ub	r5,r8[0x5]
  Assert(conf_num);
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
800162aa:	e0 a0 67 e3 	rcall	80023270 <free>
  uhc_dev_enum->conf_desc = malloc(conf_size);
800162ae:	0c 9c       	mov	r12,r6
800162b0:	e0 a0 67 e8 	rcall	80023280 <malloc>
800162b4:	8f 6c       	st.w	r7[0x18],r12
  if (uhc_dev_enum->conf_desc == NULL) {
800162b6:	c1 b0       	breq	800162ec <uhc_enumeration_step13+0xac>
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType =
800162b8:	38 08       	mov	r8,-128
800162ba:	ba 88       	st.b	sp[0x0],r8
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
800162bc:	30 68       	mov	r8,6
800162be:	ba 98       	st.b	sp[0x1],r8
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
  req.wIndex = 0;
800162c0:	30 08       	mov	r8,0
800162c2:	ba 28       	st.h	sp[0x4],r8
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
800162c4:	fe c8 ff d0 	sub	r8,pc,-48
800162c8:	ba 36       	st.h	sp[0x6],r6
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
800162ca:	18 9a       	mov	r10,r12
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
800162cc:	20 15       	sub	r5,1
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
800162ce:	0c 99       	mov	r9,r6
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
800162d0:	a9 b5       	sbr	r5,0x9
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
800162d2:	30 1c       	mov	r12,1
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
800162d4:	ba 15       	st.h	sp[0x2],r5
800162d6:	1a d8       	st.w	--sp,r8
800162d8:	30 08       	mov	r8,0
800162da:	fa cb ff fc 	sub	r11,sp,-4
800162de:	fe b0 f3 8b 	rcall	800149f4 <uhd_setup_request>
800162e2:	2f fd       	sub	sp,-4
800162e4:	58 0c       	cp.w	r12,0
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 conf_size,
			 NULL, uhc_enumeration_step14)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
800162e6:	cc 31       	brne	8001626c <uhc_enumeration_step13+0x2c>
800162e8:	30 6c       	mov	r12,6
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
  uhc_dev_enum->conf_desc = malloc(conf_size);
  if (uhc_dev_enum->conf_desc == NULL) {
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
800162ea:	cc 0b       	rjmp	8001626a <uhc_enumeration_step13+0x2a>
800162ec:	30 6c       	mov	r12,6
800162ee:	c6 9e       	rcall	80015fc0 <uhc_enumeration_error>
    return;
800162f0:	cb eb       	rjmp	8001626c <uhc_enumeration_step13+0x2c>
800162f2:	d7 03       	nop

800162f4 <uhc_enumeration_step14>:
800162f4:	eb cd 40 e0 	pushm	r5-r7,lr
800162f8:	20 2d       	sub	sp,8
800162fa:	fe fc 02 5a 	ld.w	r12,pc[602]
800162fe:	16 97       	mov	r7,r11
80016300:	14 95       	mov	r5,r10
80016302:	fe b0 e6 4d 	rcall	80012f9c <print_dbg>
80016306:	fe fc 02 52 	ld.w	r12,pc[594]
8001630a:	fe b0 e6 49 	rcall	80012f9c <print_dbg>
8001630e:	e0 66 07 30 	mov	r6,1840
80016312:	ed 3c 00 12 	ld.ub	r12,r6[18]
  ///// TESTING
#if UHC_PRINT_DBG
  print_dbg("\r\n received device descriptor. ");

  print_dbg("\r\n address: ");
  print_dbg_hex(uhc_dev_enum -> address);
80016316:	fe b0 e6 6b 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n speed: ");
8001631a:	fe fc 02 42 	ld.w	r12,pc[578]
8001631e:	fe b0 e6 3f 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum -> speed);
80016322:	6c 5c       	ld.w	r12,r6[0x14]
80016324:	fe b0 e6 64 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n\r\n");
80016328:	fe fc 02 38 	ld.w	r12,pc[568]
8001632c:	fe b0 e6 38 	rcall	80012f9c <print_dbg>

  print_dbg("\r\n dev desc -> bLength : ");
80016330:	fe fc 02 34 	ld.w	r12,pc[564]
80016334:	fe b0 e6 34 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bLength);
80016338:	0d 8c       	ld.ub	r12,r6[0x0]
8001633a:	fe b0 e6 59 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bDescriptorType : ");
8001633e:	fe fc 02 2a 	ld.w	r12,pc[554]
80016342:	fe b0 e6 2d 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDescriptorType);
80016346:	0d 9c       	ld.ub	r12,r6[0x1]
80016348:	fe b0 e6 52 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bcdUSB : ");
8001634c:	fe fc 02 20 	ld.w	r12,pc[544]
80016350:	fe b0 e6 26 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bcdUSB);
80016354:	8c 9c       	ld.uh	r12,r6[0x2]
80016356:	fe b0 e6 4b 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bDeviceClass : ");
8001635a:	fe fc 02 16 	ld.w	r12,pc[534]
8001635e:	fe b0 e6 1f 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceClass);
80016362:	0d cc       	ld.ub	r12,r6[0x4]
80016364:	fe b0 e6 44 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bDeviceSubClass : ");
80016368:	fe fc 02 0c 	ld.w	r12,pc[524]
8001636c:	fe b0 e6 18 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceSubClass);
80016370:	0d dc       	ld.ub	r12,r6[0x5]
80016372:	fe b0 e6 3d 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bDeviceProtocol : ");
80016376:	fe fc 02 02 	ld.w	r12,pc[514]
8001637a:	fe b0 e6 11 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceProtocol);
8001637e:	0d ec       	ld.ub	r12,r6[0x6]
80016380:	fe b0 e6 36 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bMaxPacketSize0 : ");
80016384:	4f ec       	lddpc	r12,8001657c <uhc_enumeration_step14+0x288>
80016386:	fe b0 e6 0b 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bMaxPacketSize0);
8001638a:	0d fc       	ld.ub	r12,r6[0x7]
8001638c:	fe b0 e6 30 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> idVendor : ");
80016390:	4f cc       	lddpc	r12,80016580 <uhc_enumeration_step14+0x28c>
80016392:	fe b0 e6 05 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.idVendor);
80016396:	8c cc       	ld.uh	r12,r6[0x8]
80016398:	fe b0 e6 2a 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> idProduct : ");
8001639c:	4f ac       	lddpc	r12,80016584 <uhc_enumeration_step14+0x290>
8001639e:	fe b0 e5 ff 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.idProduct);
800163a2:	8c dc       	ld.uh	r12,r6[0xa]
800163a4:	fe b0 e6 24 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bcdDevice : ");
800163a8:	4f 8c       	lddpc	r12,80016588 <uhc_enumeration_step14+0x294>
800163aa:	fe b0 e5 f9 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bcdDevice);
800163ae:	8c ec       	ld.uh	r12,r6[0xc]
800163b0:	fe b0 e6 1e 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> iManufacturer : ");
800163b4:	4f 6c       	lddpc	r12,8001658c <uhc_enumeration_step14+0x298>
800163b6:	fe b0 e5 f3 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.iManufacturer);
800163ba:	ed 3c 00 0e 	ld.ub	r12,r6[14]
800163be:	fe b0 e6 17 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> iProduct : ");
800163c2:	4f 4c       	lddpc	r12,80016590 <uhc_enumeration_step14+0x29c>
800163c4:	fe b0 e5 ec 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.iProduct);
800163c8:	ed 3c 00 0f 	ld.ub	r12,r6[15]
800163cc:	fe b0 e6 10 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> iSerialNumber : ");
800163d0:	4f 1c       	lddpc	r12,80016594 <uhc_enumeration_step14+0x2a0>
800163d2:	fe b0 e5 e5 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.iSerialNumber);
800163d6:	ed 3c 00 10 	ld.ub	r12,r6[16]
800163da:	fe b0 e6 09 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n dev desc -> bNumConfigurations : ");
800163de:	4e fc       	lddpc	r12,80016598 <uhc_enumeration_step14+0x2a4>
800163e0:	fe b0 e5 de 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bNumConfigurations);
800163e4:	ed 3c 00 11 	ld.ub	r12,r6[17]
800163e8:	fe b0 e6 02 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n\r\n");
800163ec:	4d dc       	lddpc	r12,80016560 <uhc_enumeration_step14+0x26c>
800163ee:	fe b0 e5 d7 	rcall	80012f9c <print_dbg>
	
  print_dbg("\r\n conf desc -> bLength : ");
800163f2:	4e bc       	lddpc	r12,8001659c <uhc_enumeration_step14+0x2a8>
800163f4:	fe b0 e5 d4 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bLength);
800163f8:	6c 68       	ld.w	r8,r6[0x18]
800163fa:	11 8c       	ld.ub	r12,r8[0x0]
800163fc:	fe b0 e5 f8 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> bDescriptorType : ");
80016400:	4e 8c       	lddpc	r12,800165a0 <uhc_enumeration_step14+0x2ac>
80016402:	fe b0 e5 cd 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bDescriptorType);
80016406:	6c 68       	ld.w	r8,r6[0x18]
80016408:	11 9c       	ld.ub	r12,r8[0x1]
8001640a:	fe b0 e5 f1 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> wTotalLength : ");
8001640e:	4e 6c       	lddpc	r12,800165a4 <uhc_enumeration_step14+0x2b0>
80016410:	fe b0 e5 c6 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->wTotalLength);
80016414:	6c 68       	ld.w	r8,r6[0x18]
80016416:	11 b9       	ld.ub	r9,r8[0x3]
80016418:	11 ac       	ld.ub	r12,r8[0x2]
8001641a:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
8001641e:	fe b0 e5 e7 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> bNumInterfaces : ");
80016422:	4e 2c       	lddpc	r12,800165a8 <uhc_enumeration_step14+0x2b4>
80016424:	fe b0 e5 bc 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bNumInterfaces);
80016428:	6c 68       	ld.w	r8,r6[0x18]
8001642a:	11 cc       	ld.ub	r12,r8[0x4]
8001642c:	fe b0 e5 e0 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> bConfigurationValue : ");
80016430:	4d fc       	lddpc	r12,800165ac <uhc_enumeration_step14+0x2b8>
80016432:	fe b0 e5 b5 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bConfigurationValue);
80016436:	6c 68       	ld.w	r8,r6[0x18]
80016438:	11 dc       	ld.ub	r12,r8[0x5]
8001643a:	fe b0 e5 d9 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> iConfiguration : ");
8001643e:	4d dc       	lddpc	r12,800165b0 <uhc_enumeration_step14+0x2bc>
80016440:	fe b0 e5 ae 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->iConfiguration);
80016444:	6c 68       	ld.w	r8,r6[0x18]
80016446:	11 ec       	ld.ub	r12,r8[0x6]
80016448:	fe b0 e5 d2 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> bmAttributes : ");
8001644c:	4d ac       	lddpc	r12,800165b4 <uhc_enumeration_step14+0x2c0>
8001644e:	fe b0 e5 a7 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bmAttributes);
80016452:	6c 68       	ld.w	r8,r6[0x18]
80016454:	11 fc       	ld.ub	r12,r8[0x7]
80016456:	fe b0 e5 cb 	rcall	80012fec <print_dbg_hex>
  print_dbg("\r\n conf desc -> bMaxPower : ");
8001645a:	4d 8c       	lddpc	r12,800165b8 <uhc_enumeration_step14+0x2c4>
8001645c:	fe b0 e5 a0 	rcall	80012f9c <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
80016460:	6c 68       	ld.w	r8,r6[0x18]
80016462:	f1 3c 00 08 	ld.ub	r12,r8[8]
80016466:	fe b0 e5 c3 	rcall	80012fec <print_dbg_hex>
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
8001646a:	58 07       	cp.w	r7,0
8001646c:	5f 18       	srne	r8
8001646e:	30 89       	mov	r9,8
80016470:	f2 05 19 00 	cp.h	r5,r9
80016474:	5f 89       	srls	r9
80016476:	f3 e8 10 08 	or	r8,r9,r8
8001647a:	c0 d1       	brne	80016494 <uhc_enumeration_step14+0x1a0>
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
8001647c:	6c 68       	ld.w	r8,r6[0x18]
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
8001647e:	30 29       	mov	r9,2
80016480:	11 9a       	ld.ub	r10,r8[0x1]
80016482:	f2 0a 18 00 	cp.b	r10,r9
80016486:	c0 b0       	breq	8001649c <uhc_enumeration_step14+0x1a8>
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80016488:	30 3c       	mov	r12,3
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 NULL,
			 0,
			 NULL, uhc_enumeration_step15)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
8001648a:	fe b0 fd 9b 	rcall	80015fc0 <uhc_enumeration_error>
    return;
  }
}
8001648e:	2f ed       	sub	sp,-8
80016490:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

  if ((status != UHD_TRANS_NOERROR)
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80016494:	58 17       	cp.w	r7,1
80016496:	cf 91       	brne	80016488 <uhc_enumeration_step14+0x194>
80016498:	30 7c       	mov	r12,7
8001649a:	cf 8b       	rjmp	8001648a <uhc_enumeration_step14+0x196>
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
8001649c:	11 b9       	ld.ub	r9,r8[0x3]
8001649e:	11 a8       	ld.ub	r8,r8[0x2]
800164a0:	f3 e8 10 88 	or	r8,r9,r8<<0x8
800164a4:	5c c8       	swap.bh	r8
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
800164a6:	ea 08 19 00 	cp.h	r8,r5
800164aa:	ce f1       	brne	80016488 <uhc_enumeration_step14+0x194>
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    switch (uhc_uhis[i].install(uhc_dev_enum)) {
800164ac:	4c 47       	lddpc	r7,800165bc <uhc_enumeration_step14+0x2c8>
800164ae:	0c 9c       	mov	r12,r6
800164b0:	6e 08       	ld.w	r8,r7[0x0]
800164b2:	5d 18       	icall	r8
800164b4:	c2 21       	brne	800164f8 <uhc_enumeration_step14+0x204>
800164b6:	30 15       	mov	r5,1
800164b8:	6e 48       	ld.w	r8,r7[0x10]
800164ba:	e0 6c 07 30 	mov	r12,1840
800164be:	5d 18       	icall	r8
800164c0:	c2 01       	brne	80016500 <uhc_enumeration_step14+0x20c>
800164c2:	30 15       	mov	r5,1
800164c4:	6e 88       	ld.w	r8,r7[0x20]
800164c6:	e0 6c 07 30 	mov	r12,1840
800164ca:	5d 18       	icall	r8
800164cc:	c3 71       	brne	8001653a <uhc_enumeration_step14+0x246>
800164ce:	30 15       	mov	r5,1
800164d0:	6e c8       	ld.w	r8,r7[0x30]
800164d2:	e0 6c 07 30 	mov	r12,1840
800164d6:	5d 18       	icall	r8
    case UHC_ENUM_UNSUPPORTED:
      break;
    default:
      // USB host hardware limitation
      // Free all endpoints
      uhd_ep_free(UHC_DEVICE_ENUM_ADD,0xFF);
800164d8:	c1 70       	breq	80016506 <uhc_enumeration_step14+0x212>
800164da:	58 1c       	cp.w	r12,1
800164dc:	c3 20       	breq	80016540 <uhc_enumeration_step14+0x24c>
800164de:	e0 6b 00 ff 	mov	r11,255
      UHC_ENUM_EVENT(uhc_dev_enum,UHC_ENUM_HARDWARE_LIMIT);
800164e2:	30 1c       	mov	r12,1
800164e4:	fe b0 f3 84 	rcall	80014bec <uhd_ep_free>
800164e8:	30 4b       	mov	r11,4
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
800164ea:	e0 6c 07 30 	mov	r12,1840
800164ee:	e0 a0 1f f9 	rcall	8001a4e0 <usb_enum>
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    switch (uhc_uhis[i].install(uhc_dev_enum)) {
800164f2:	fe b0 ef 31 	rcall	80014354 <uhd_suspend>
800164f6:	cc cb       	rjmp	8001648e <uhc_enumeration_step14+0x19a>
800164f8:	58 1c       	cp.w	r12,1
800164fa:	cf 21       	brne	800164de <uhc_enumeration_step14+0x1ea>
800164fc:	30 05       	mov	r5,0
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
  req.wIndex = 0;
800164fe:	cd db       	rjmp	800164b8 <uhc_enumeration_step14+0x1c4>
    // Abort enumeration, set line in suspend mode
    uhc_enumeration_suspend();
    return;
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
80016500:	58 1c       	cp.w	r12,1
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
80016502:	ce e1       	brne	800164de <uhc_enumeration_step14+0x1ea>
    // Abort enumeration, set line in suspend mode
    uhc_enumeration_suspend();
    return;
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
80016504:	ce 0b       	rjmp	800164c4 <uhc_enumeration_step14+0x1d0>
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
80016506:	30 09       	mov	r9,0
80016508:	30 0b       	mov	r11,0
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
8001650a:	6c 6a       	ld.w	r10,r6[0x18]
  req.wIndex = 0;
  req.wLength = 0;
8001650c:	ba 8b       	st.b	sp[0x0],r11
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
  req.wIndex = 0;
8001650e:	30 9b       	mov	r11,9
  req.wLength = 0;
  //  print_dbg("\r\n device enumeration successful; calling uhd_setup_request in uhc.c");
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80016510:	ba 9b       	st.b	sp[0x1],r11
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
80016512:	15 da       	ld.ub	r10,r10[0x5]
  req.wIndex = 0;
  req.wLength = 0;
  //  print_dbg("\r\n device enumeration successful; calling uhd_setup_request in uhc.c");
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80016514:	ba 39       	st.h	sp[0x6],r9
80016516:	ba 29       	st.h	sp[0x4],r9
80016518:	fe c9 ff 58 	sub	r9,pc,-168
8001651c:	ba 1a       	st.h	sp[0x2],r10
8001651e:	30 08       	mov	r8,0
80016520:	1a d9       	st.w	--sp,r9
80016522:	10 9a       	mov	r10,r8
80016524:	fa cb ff fc 	sub	r11,sp,-4
80016528:	10 99       	mov	r9,r8
8001652a:	30 1c       	mov	r12,1
			 &req,
			 NULL,
			 0,
			 NULL, uhc_enumeration_step15)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
8001652c:	fe b0 f2 64 	rcall	800149f4 <uhd_setup_request>
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    switch (uhc_uhis[i].install(uhc_dev_enum)) {
80016530:	2f fd       	sub	sp,-4
80016532:	58 0c       	cp.w	r12,0
80016534:	ca d1       	brne	8001648e <uhc_enumeration_step14+0x19a>
      // Abort enumeration, set line in suspend mode
      uhc_enumeration_suspend();
      return;
    }
  }
  if (!b_conf_supported) {
80016536:	30 6c       	mov	r12,6
80016538:	ca 9b       	rjmp	8001648a <uhc_enumeration_step14+0x196>
    // No USB interface supported
    UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_UNSUPPORTED);
8001653a:	58 1c       	cp.w	r12,1
8001653c:	cd 11       	brne	800164de <uhc_enumeration_step14+0x1ea>
8001653e:	cc 9b       	rjmp	800164d0 <uhc_enumeration_step14+0x1dc>
80016540:	58 05       	cp.w	r5,0
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80016542:	ce 21       	brne	80016506 <uhc_enumeration_step14+0x212>
80016544:	18 9b       	mov	r11,r12
80016546:	e0 6c 07 30 	mov	r12,1840
8001654a:	e0 a0 1f cb 	rcall	8001a4e0 <usb_enum>
8001654e:	fe b0 ef 03 	rcall	80014354 <uhd_suspend>
80016552:	c9 eb       	rjmp	8001648e <uhc_enumeration_step14+0x19a>
80016554:	80 02       	ld.sh	r2,r0[0x0]
80016556:	40 64       	lddsp	r4,sp[0x18]
80016558:	80 02       	ld.sh	r2,r0[0x0]
8001655a:	40 84       	lddsp	r4,sp[0x20]
8001655c:	80 02       	ld.sh	r2,r0[0x0]
8001655e:	40 94       	lddsp	r4,sp[0x24]
80016560:	80 02       	ld.sh	r2,r0[0x0]
80016562:	40 a0       	lddsp	r0,sp[0x28]
80016564:	80 02       	ld.sh	r2,r0[0x0]
80016566:	40 a8       	lddsp	r8,sp[0x28]
80016568:	80 02       	ld.sh	r2,r0[0x0]
8001656a:	40 c4       	lddsp	r4,sp[0x30]
8001656c:	80 02       	ld.sh	r2,r0[0x0]
8001656e:	40 e8       	lddsp	r8,sp[0x38]
80016570:	80 02       	ld.sh	r2,r0[0x0]
80016572:	41 04       	lddsp	r4,sp[0x40]
80016574:	80 02       	ld.sh	r2,r0[0x0]
80016576:	41 24       	lddsp	r4,sp[0x48]
80016578:	80 02       	ld.sh	r2,r0[0x0]
8001657a:	41 48       	lddsp	r8,sp[0x50]
8001657c:	80 02       	ld.sh	r2,r0[0x0]
8001657e:	41 6c       	lddsp	r12,sp[0x58]
80016580:	80 02       	ld.sh	r2,r0[0x0]
80016582:	41 90       	lddsp	r0,sp[0x64]
80016584:	80 02       	ld.sh	r2,r0[0x0]
80016586:	41 ac       	lddsp	r12,sp[0x68]
80016588:	80 02       	ld.sh	r2,r0[0x0]
8001658a:	41 c8       	lddsp	r8,sp[0x70]
8001658c:	80 02       	ld.sh	r2,r0[0x0]
8001658e:	41 e4       	lddsp	r4,sp[0x78]
80016590:	80 02       	ld.sh	r2,r0[0x0]
80016592:	42 04       	lddsp	r4,sp[0x80]
80016594:	80 02       	ld.sh	r2,r0[0x0]
80016596:	42 20       	lddsp	r0,sp[0x88]
80016598:	80 02       	ld.sh	r2,r0[0x0]
8001659a:	42 40       	lddsp	r0,sp[0x90]
8001659c:	80 02       	ld.sh	r2,r0[0x0]
8001659e:	42 68       	lddsp	r8,sp[0x98]
800165a0:	80 02       	ld.sh	r2,r0[0x0]
800165a2:	42 84       	lddsp	r4,sp[0xa0]
800165a4:	80 02       	ld.sh	r2,r0[0x0]
800165a6:	42 a8       	lddsp	r8,sp[0xa8]
800165a8:	80 02       	ld.sh	r2,r0[0x0]
800165aa:	42 c8       	lddsp	r8,sp[0xb0]
800165ac:	80 02       	ld.sh	r2,r0[0x0]
800165ae:	42 ec       	lddsp	r12,sp[0xb8]
800165b0:	80 02       	ld.sh	r2,r0[0x0]
800165b2:	43 14       	lddsp	r4,sp[0xc4]
800165b4:	80 02       	ld.sh	r2,r0[0x0]
800165b6:	43 38       	lddsp	r8,sp[0xcc]
800165b8:	80 02       	ld.sh	r2,r0[0x0]
800165ba:	43 58       	lddsp	r8,sp[0xd4]
800165bc:	80 02       	ld.sh	r2,r0[0x0]
800165be:	43 90       	lddsp	r0,sp[0xe4]

800165c0 <uhc_enumeration_step15>:
800165c0:	eb cd 40 c0 	pushm	r6-r7,lr
800165c4:	20 1d       	sub	sp,4
800165c6:	30 08       	mov	r8,0
800165c8:	58 0b       	cp.w	r11,0
800165ca:	5f 19       	srne	r9
800165cc:	f0 0a 19 00 	cp.h	r10,r8
800165d0:	5f 17       	srne	r7
800165d2:	12 47       	or	r7,r9
800165d4:	f0 07 18 00 	cp.b	r7,r8
				   usb_add_t add,
				   uhd_trans_status_t status,
				   uint16_t payload_trans)
{
  UNUSED(add);
  if ((status!=UHD_TRANS_NOERROR) || (payload_trans!=0)) {
800165d8:	c1 e0       	breq	80016614 <uhc_enumeration_step15+0x54>
    for(uint8_t i = 0; i < UHC_NB_UHI; i++) {
      uhc_uhis[i].uninstall(uhc_dev_enum);
800165da:	4a 97       	lddpc	r7,8001667c <uhc_enumeration_step15+0xbc>
800165dc:	50 0b       	stdsp	sp[0x0],r11
800165de:	6e 28       	ld.w	r8,r7[0x8]
800165e0:	e0 6c 07 30 	mov	r12,1840
800165e4:	5d 18       	icall	r8
800165e6:	6e 68       	ld.w	r8,r7[0x18]
800165e8:	e0 6c 07 30 	mov	r12,1840
800165ec:	5d 18       	icall	r8
800165ee:	6e a8       	ld.w	r8,r7[0x28]
800165f0:	e0 6c 07 30 	mov	r12,1840
800165f4:	5d 18       	icall	r8
    }
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
800165f6:	6e e8       	ld.w	r8,r7[0x38]
800165f8:	e0 6c 07 30 	mov	r12,1840
800165fc:	5d 18       	icall	r8
800165fe:	40 0b       	lddsp	r11,sp[0x0]
80016600:	58 1b       	cp.w	r11,1
80016602:	f9 bc 00 07 	moveq	r12,7
    uhc_uhis[i].enable(uhc_dev_enum);
  }
  uhc_enum_try = 0;
	
  UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
}
80016606:	f9 bc 01 03 	movne	r12,3
8001660a:	fe b0 fc db 	rcall	80015fc0 <uhc_enumeration_error>
  }

  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
8001660e:	2f fd       	sub	sp,-4
80016610:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80016614:	49 bc       	lddpc	r12,80016680 <uhc_enumeration_step15+0xc0>
80016616:	fe b0 e4 c3 	rcall	80012f9c <print_dbg>
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
8001661a:	30 0c       	mov	r12,0
8001661c:	fe b0 e4 c6 	rcall	80012fa8 <print_dbg_ulong>
  }

  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
80016620:	49 76       	lddpc	r6,8001667c <uhc_enumeration_step15+0xbc>
80016622:	e0 6c 07 30 	mov	r12,1840
80016626:	6c 18       	ld.w	r8,r6[0x4]
80016628:	5d 18       	icall	r8
8001662a:	49 6c       	lddpc	r12,80016680 <uhc_enumeration_step15+0xc0>
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
8001662c:	fe b0 e4 b8 	rcall	80012f9c <print_dbg>
80016630:	30 1c       	mov	r12,1
  }

  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
80016632:	fe b0 e4 bb 	rcall	80012fa8 <print_dbg_ulong>
80016636:	6c 58       	ld.w	r8,r6[0x14]
80016638:	e0 6c 07 30 	mov	r12,1840
8001663c:	5d 18       	icall	r8
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
8001663e:	49 1c       	lddpc	r12,80016680 <uhc_enumeration_step15+0xc0>
80016640:	fe b0 e4 ae 	rcall	80012f9c <print_dbg>
  }

  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
80016644:	30 2c       	mov	r12,2
80016646:	fe b0 e4 b1 	rcall	80012fa8 <print_dbg_ulong>
8001664a:	6c 98       	ld.w	r8,r6[0x24]
8001664c:	e0 6c 07 30 	mov	r12,1840
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
80016650:	5d 18       	icall	r8
80016652:	48 cc       	lddpc	r12,80016680 <uhc_enumeration_step15+0xc0>
80016654:	fe b0 e4 a4 	rcall	80012f9c <print_dbg>
  }
  uhc_enum_try = 0;
	
  UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
80016658:	30 3c       	mov	r12,3
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
  }
  uhc_enum_try = 0;
8001665a:	fe b0 e4 a7 	rcall	80012fa8 <print_dbg_ulong>
	
  UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
8001665e:	6c d8       	ld.w	r8,r6[0x34]
80016660:	e0 6c 07 30 	mov	r12,1840
}
80016664:	5d 18       	icall	r8
80016666:	e0 68 07 4c 	mov	r8,1868
8001666a:	30 0b       	mov	r11,0
8001666c:	b0 87       	st.b	r8[0x0],r7
8001666e:	e0 6c 07 30 	mov	r12,1840
80016672:	e0 a0 1f 37 	rcall	8001a4e0 <usb_enum>
80016676:	2f fd       	sub	sp,-4
80016678:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001667c:	80 02       	ld.sh	r2,r0[0x0]
8001667e:	43 90       	lddsp	r0,sp[0xe4]
80016680:	80 02       	ld.sh	r2,r0[0x0]
80016682:	43 78       	lddsp	r8,sp[0xdc]

80016684 <uhc_notify_connection>:
80016684:	d4 21       	pushm	r4-r7,lr
80016686:	18 96       	mov	r6,r12
 * \name Callbacks used by USB Host Driver (UHD) to notify events
 * @{
 */
void uhc_notify_connection(bool b_plug)
{
  if (b_plug) {
80016688:	58 0c       	cp.w	r12,0
8001668a:	c2 91       	brne	800166dc <uhc_notify_connection+0x58>

#ifdef USB_HOST_HUB_SUPPORT
    uhc_power_running = 0;
#endif
  } else {
    if (g_uhc_device_root.address == UHC_USB_ADD_NOT_VALID) {
8001668c:	e0 67 07 30 	mov	r7,1840
80016690:	3f f5       	mov	r5,-1
80016692:	ef 3c 00 12 	ld.ub	r12,r7[18]
80016696:	ea 0c 18 00 	cp.b	r12,r5
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
    uhc_enumeration_step1();
  } else {
    if (uhc_dev_enum == dev) {
      // Eventually stop enumeration timeout on-going on this device
      uhc_sof_timeout = 0;
8001669a:	c3 40       	breq	80016702 <uhc_notify_connection+0x7e>
    }
    // Abort all transfers (endpoint control and other) and free pipe(s)
    uhd_ep_free(dev->address, 0xFF);
8001669c:	e0 68 2d 16 	mov	r8,11542
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
    uhc_enumeration_step1();
  } else {
    if (uhc_dev_enum == dev) {
      // Eventually stop enumeration timeout on-going on this device
      uhc_sof_timeout = 0;
800166a0:	e0 6b 00 ff 	mov	r11,255
    }
    // Abort all transfers (endpoint control and other) and free pipe(s)
    uhd_ep_free(dev->address, 0xFF);
800166a4:	b0 86       	st.b	r8[0x0],r6

    // Disable all USB interfaces (this includes HUB interface)
    for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
      uhc_uhis[i].uninstall(dev);
800166a6:	fe b0 f2 a3 	rcall	80014bec <uhd_ep_free>
800166aa:	49 74       	lddpc	r4,80016704 <uhc_notify_connection+0x80>
800166ac:	0e 9c       	mov	r12,r7
800166ae:	68 28       	ld.w	r8,r4[0x8]
800166b0:	5d 18       	icall	r8
800166b2:	0e 9c       	mov	r12,r7
800166b4:	68 68       	ld.w	r8,r4[0x18]
800166b6:	5d 18       	icall	r8
800166b8:	0e 9c       	mov	r12,r7
800166ba:	68 a8       	ld.w	r8,r4[0x28]
800166bc:	5d 18       	icall	r8
800166be:	68 e8       	ld.w	r8,r4[0x38]
    }

    UHC_CONNECTION_EVENT(dev, false);
800166c0:	0e 9c       	mov	r12,r7
800166c2:	5d 18       	icall	r8
800166c4:	0e 9c       	mov	r12,r7
800166c6:	0c 9b       	mov	r11,r6
    dev->address = UHC_USB_ADD_NOT_VALID;
800166c8:	e0 a0 1f 09 	rcall	8001a4da <usb_connection>
    // Free USB configuration descriptor buffer
    if (dev->conf_desc != NULL) {
800166cc:	ef 65 00 12 	st.b	r7[18],r5
800166d0:	6e 6c       	ld.w	r12,r7[0x18]
      free(dev->conf_desc);
800166d2:	58 0c       	cp.w	r12,0
800166d4:	c0 30       	breq	800166da <uhc_notify_connection+0x56>
800166d6:	e0 a0 65 cd 	rcall	80023270 <free>
  if (b_plug) {
    uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
800166da:	d8 22       	popm	r4-r7,pc
    uhc_dev_enum->address = 0;
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
800166dc:	e0 68 07 30 	mov	r8,1840
    uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
    uhc_dev_enum->address = 0;
800166e0:	30 09       	mov	r9,0
  if (b_plug) {
    uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
800166e2:	10 9c       	mov	r12,r8
 * \param dev      Information about device connected or disconnected
 */
static void uhc_connection_tree(bool b_plug, uhc_device_t* dev)
{
  if (b_plug) {
    uhc_enum_try = 1;
800166e4:	f1 69 00 12 	st.b	r8[18],r9
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
    uhc_dev_enum->address = 0;
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
800166e8:	91 69       	st.w	r8[0x18],r9
 * \param dev      Information about device connected or disconnected
 */
static void uhc_connection_tree(bool b_plug, uhc_device_t* dev)
{
  if (b_plug) {
    uhc_enum_try = 1;
800166ea:	30 19       	mov	r9,1
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
    uhc_dev_enum->address = 0;
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
800166ec:	e0 68 07 4c 	mov	r8,1868
    // Device connected on USB hub
    uhi_hub_send_reset(uhc_dev_enum, callback);
  } else
#endif
    {
      uhd_send_reset(callback);
800166f0:	30 1b       	mov	r11,1
800166f2:	b0 89       	st.b	r8[0x0],r9
800166f4:	e0 a0 1e f3 	rcall	8001a4da <usb_connection>
800166f8:	fe cc 08 14 	sub	r12,pc,2068
800166fc:	fe b0 ee 22 	rcall	80014340 <uhd_send_reset>
80016700:	d8 22       	popm	r4-r7,pc
80016702:	d8 22       	popm	r4-r7,pc
80016704:	80 02       	ld.sh	r2,r0[0x0]
80016706:	43 90       	lddsp	r0,sp[0xe4]

80016708 <uhc_notify_resume>:
80016708:	d4 01       	pushm	lr
8001670a:	20 2d       	sub	sp,8
8001670c:	e0 69 07 30 	mov	r9,1840
80016710:	72 68       	ld.w	r8,r9[0x18]
80016712:	11 f8       	ld.ub	r8,r8[0x7]
80016714:	ed b8 00 05 	bld	r8,0x5
80016718:	c1 61       	brne	80016744 <uhc_notify_resume+0x3c>
8001671a:	f3 3c 00 12 	ld.ub	r12,r9[18]
8001671e:	30 08       	mov	r8,0
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
      req.wIndex = 0;
      req.wLength = 0;
80016720:	30 09       	mov	r9,0
	req.bRequest = USB_REQ_CLEAR_FEATURE;
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
      req.wIndex = 0;
80016722:	ba 38       	st.h	sp[0x6],r8
      req.wLength = 0;
      uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80016724:	ba 28       	st.h	sp[0x4],r8
80016726:	1a d9       	st.w	--sp,r9
  while(1) {
    if (dev->conf_desc->bmAttributes & USB_CONFIG_ATTR_REMOTE_WAKEUP) {
      if (b_enable) {
	req.bRequest = USB_REQ_SET_FEATURE;
      } else {
	req.bRequest = USB_REQ_CLEAR_FEATURE;
80016728:	12 98       	mov	r8,r9
8001672a:	30 19       	mov	r9,1
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
8001672c:	ba d9       	st.b	sp[0x5],r9
8001672e:	30 09       	mov	r9,0
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
80016730:	ba c9       	st.b	sp[0x4],r9
      req.wIndex = 0;
      req.wLength = 0;
      uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80016732:	30 19       	mov	r9,1
80016734:	fa cb ff fc 	sub	r11,sp,-4
80016738:	ba 39       	st.h	sp[0x6],r9
8001673a:	10 9a       	mov	r10,r8
8001673c:	10 99       	mov	r9,r8
8001673e:	fe b0 f1 5b 	rcall	800149f4 <uhd_setup_request>
}

void uhc_notify_resume(void)
{
  uhc_remotewakeup(false);
  UHC_WAKEUP_EVENT();
80016742:	2f fd       	sub	sp,-4
80016744:	e0 a0 1e cc 	rcall	8001a4dc <usb_wakeup>
}
80016748:	2f ed       	sub	sp,-8
8001674a:	d8 02       	popm	pc

8001674c <init_adc>:

  //  cpu_irq_enable();
}

// setup ad7923
void init_adc(void) {
8001674c:	eb cd 40 80 	pushm	r7,lr
  u16 cmd;

  //  cpu_irq_disable();

  // at powerup, the part wants a dummy conversion with DIN high
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80016750:	30 1b       	mov	r11,1
80016752:	fe 7c 28 00 	mov	r12,-55296
80016756:	fe b0 e1 d3 	rcall	80012afc <spi_selectChip>
  spi_write(ADC_SPI, 0xffff);
8001675a:	e0 6b ff ff 	mov	r11,65535
8001675e:	fe 7c 28 00 	mov	r12,-55296
80016762:	fe b0 e2 62 	rcall	80012c26 <spi_write>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
80016766:	30 1b       	mov	r11,1
80016768:	fe 7c 28 00 	mov	r12,-55296
8001676c:	fe b0 e1 f0 	rcall	80012b4c <spi_unselectChip>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80016770:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80016774:	ee 78 42 40 	mov	r8,1000000
80016778:	30 09       	mov	r9,0
8001677a:	e0 6a a8 bf 	mov	r10,43199
8001677e:	ea 1a 13 ba 	orh	r10,0x13ba
80016782:	30 0b       	mov	r11,0
80016784:	e0 a0 64 27 	rcall	80022fd2 <__avr32_udiv64>
80016788:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001678c:	e1 b8 00 42 	mfsr	r8,0x108
80016790:	14 37       	cp.w	r7,r10
80016792:	e0 8b 00 1b 	brhi	800167c8 <init_adc+0x7c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80016796:	10 37       	cp.w	r7,r8
80016798:	e0 8b 00 04 	brhi	800167a0 <init_adc+0x54>
8001679c:	10 3a       	cp.w	r10,r8
8001679e:	c1 b2       	brcc	800167d4 <init_adc+0x88>
  // wait for powerup time (5us in datasheet)
  delay_us(5);
  
  // write base configuration
  cmd = AD7923_CMD_BASE << 4;
  spi_selectChip( ADC_SPI, ADC_SPI_NPCS );
800167a0:	30 1b       	mov	r11,1
800167a2:	fe 7c 28 00 	mov	r12,-55296
800167a6:	fe b0 e1 ab 	rcall	80012afc <spi_selectChip>
  spi_write( ADC_SPI, cmd );
800167aa:	e0 6b 83 10 	mov	r11,33552
800167ae:	fe 7c 28 00 	mov	r12,-55296
800167b2:	fe b0 e2 3a 	rcall	80012c26 <spi_write>
  spi_unselectChip( ADC_SPI, ADC_SPI_NPCS );
800167b6:	30 1b       	mov	r11,1
800167b8:	fe 7c 28 00 	mov	r12,-55296
800167bc:	fe b0 e1 c8 	rcall	80012b4c <spi_unselectChip>

  //  cpu_irq_enable();
}
800167c0:	e3 cd 80 80 	ldm	sp++,r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800167c4:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800167c8:	10 37       	cp.w	r7,r8
800167ca:	fe 98 ff fd 	brls	800167c4 <init_adc+0x78>
800167ce:	10 3a       	cp.w	r10,r8
800167d0:	cf a2       	brcc	800167c4 <init_adc+0x78>
800167d2:	ce 7b       	rjmp	800167a0 <init_adc+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800167d4:	e1 b8 00 42 	mfsr	r8,0x108
800167d8:	cd fb       	rjmp	80016796 <init_adc+0x4a>
800167da:	d7 03       	nop

800167dc <app_resume>:
  // disable pdca interrupt
  //  cpu_irq_disable_level(SYS_IRQ_PRIORITY);
  
  //  print_dbg("\r\n enabling tc/ui irq...");
  
  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
800167dc:	d5 43       	csrf	0x14
  cpu_irq_enable_level(UI_IRQ_PRIORITY);
800167de:	d5 33       	csrf	0x13
  
  //  }
  
  //  notifyMsg = 0;
  //  inNotify = 0;
}
800167e0:	5e fc       	retal	r12
800167e2:	d7 03       	nop

800167e4 <app_pause>:
/*   screen_clear(); */
/*   //  screen_line(0, 0, (char*)msg, 0xf); */
/*   screen_refresh(); */
/* } */

void app_pause(void) {
800167e4:	eb cd 40 80 	pushm	r7,lr
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800167e8:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800167ec:	e0 68 03 e8 	mov	r8,1000
800167f0:	30 09       	mov	r9,0
800167f2:	e0 6a d0 e7 	mov	r10,53479
800167f6:	ea 1a 27 56 	orh	r10,0x2756
800167fa:	30 0b       	mov	r11,0
800167fc:	e0 a0 63 eb 	rcall	80022fd2 <__avr32_udiv64>
80016800:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80016804:	e1 b8 00 42 	mfsr	r8,0x108
80016808:	14 37       	cp.w	r7,r10
8001680a:	e0 8b 00 0d 	brhi	80016824 <app_pause+0x40>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001680e:	10 37       	cp.w	r7,r8
80016810:	e0 8b 00 04 	brhi	80016818 <app_pause+0x34>
80016814:	10 3a       	cp.w	r10,r8
80016816:	c1 02       	brcc	80016836 <app_pause+0x52>
  //  print_pending_events();

  //  delay_ns(100);
  delay_ms(10);

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80016818:	d3 43       	ssrf	0x14
  cpu_irq_disable_level(UI_IRQ_PRIORITY);
8001681a:	d3 33       	ssrf	0x13

  /// disable all interrupts and save flags 
  //  flags = cpu_irq_save();
    // enable pdca interrupt
  //  cpu_irq_enable_level(SYS_IRQ_PRIORITY);
}
8001681c:	e3 cd 80 80 	ldm	sp++,r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80016820:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80016824:	10 37       	cp.w	r7,r8
80016826:	fe 98 ff fd 	brls	80016820 <app_pause+0x3c>
8001682a:	10 3a       	cp.w	r10,r8
8001682c:	cf a2       	brcc	80016820 <app_pause+0x3c>
  //  print_pending_events();

  //  delay_ns(100);
  delay_ms(10);

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
8001682e:	d3 43       	ssrf	0x14
  cpu_irq_disable_level(UI_IRQ_PRIORITY);
80016830:	d3 33       	ssrf	0x13

  /// disable all interrupts and save flags 
  //  flags = cpu_irq_save();
    // enable pdca interrupt
  //  cpu_irq_enable_level(SYS_IRQ_PRIORITY);
}
80016832:	e3 cd 80 80 	ldm	sp++,r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80016836:	e1 b8 00 42 	mfsr	r8,0x108
8001683a:	ce ab       	rjmp	8001680e <app_pause+0x2a>

8001683c <init_sys_timers>:
  ctl_perform_all_changes();
}


//====== external
void init_sys_timers(void) {
8001683c:	d4 01       	pushm	lr
  set_timer(&encTimer,           eEncTimerTag,           20,  &enc_timer_callback,    1);
8001683e:	30 18       	mov	r8,1
80016840:	fe c9 ff d4 	sub	r9,pc,-44
80016844:	31 4a       	mov	r10,20
80016846:	30 0b       	mov	r11,0
80016848:	e0 6c 07 6c 	mov	r12,1900
  set_timer(&paramChangeTimer,   eParamChangeTimerTag,      1,  &param_change_timer_callback, 1);
8001684c:	e0 a0 1c 54 	rcall	8001a0f4 <set_timer>
80016850:	30 18       	mov	r8,1
80016852:	fe c9 ff ee 	sub	r9,pc,-18
80016856:	10 9a       	mov	r10,r8
80016858:	10 9b       	mov	r11,r8
}
8001685a:	e0 6c 07 58 	mov	r12,1880
8001685e:	e0 a0 1c 4b 	rcall	8001a0f4 <set_timer>
80016862:	d8 02       	popm	pc

80016864 <param_change_timer_callback>:
80016864:	d4 01       	pushm	lr
80016866:	e0 a0 05 a5 	rcall	800173b0 <ctl_perform_all_changes>
8001686a:	d8 02       	popm	pc

8001686c <enc_timer_callback>:
8001686c:	eb cd 40 fc 	pushm	r2-r7,lr

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80016870:	30 08       	mov	r8,0
80016872:	30 0b       	mov	r11,0
80016874:	e0 66 07 54 	mov	r6,1876
80016878:	e0 67 2d 18 	mov	r7,11544
8001687c:	ac 88       	st.b	r6[0x0],r8
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
8001687e:	e0 63 07 56 	mov	r3,1878

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80016882:	16 98       	mov	r8,r11
80016884:	e0 65 07 80 	mov	r5,1920
    val = enc[i].val;
80016888:	16 92       	mov	r2,r11
8001688a:	30 34       	mov	r4,3
8001688c:	c0 28       	rjmp	80016890 <enc_timer_callback+0x24>
8001688e:	10 9b       	mov	r11,r8
80016890:	f0 08 00 18 	add	r8,r8,r8<<0x1
80016894:	f0 ca ff ff 	sub	r10,r8,-1
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
80016898:	ee 0a 04 29 	ld.sh	r9,r7[r10<<0x2]
8001689c:	a6 09       	st.h	r3[0x0],r9
8001689e:	ee 0a 00 2a 	add	r10,r7,r10<<0x2
800168a2:	94 1a       	ld.sh	r10,r10[0x2]
800168a4:	f4 09 19 00 	cp.h	r9,r10
800168a8:	e0 89 00 05 	brgt	800168b2 <enc_timer_callback+0x46>
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
      e.eventData = val;
      enc[i].val = 0;
800168ac:	5c 3a       	neg	r10
800168ae:	14 39       	cp.w	r9,r10
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
800168b0:	c0 f4       	brge	800168ce <enc_timer_callback+0x62>
800168b2:	8b 19       	st.w	r5[0x4],r9
800168b4:	f0 c9 ff ff 	sub	r9,r8,-1
      e.eventData = val;
      enc[i].val = 0;
800168b8:	ee 08 00 28 	add	r8,r7,r8<<0x2
      post_event(&e);
800168bc:	70 28       	ld.w	r8,r8[0x8]
800168be:	ee 09 0a 22 	st.h	r7[r9<<0x2],r2
800168c2:	8b 08       	st.w	r5[0x0],r8

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
800168c4:	e0 6c 07 80 	mov	r12,1920
800168c8:	e0 a0 05 a4 	rcall	80017410 <post_event>
800168cc:	0d 8b       	ld.ub	r11,r6[0x0]
800168ce:	f6 c8 ff ff 	sub	r8,r11,-1
800168d2:	5c 58       	castu.b	r8
800168d4:	ac 88       	st.b	r6[0x0],r8
800168d6:	e8 08 18 00 	cp.b	r8,r4
800168da:	fe 98 ff da 	brls	8001688e <enc_timer_callback+0x22>
800168de:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800168e2:	d7 03       	nop

800168e4 <bfin_enable>:
  

/*   bfin_enable(); */
/* } */

void bfin_enable(void) {
800168e4:	d4 01       	pushm	lr
  // enable audio processing
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800168e6:	30 0b       	mov	r11,0
800168e8:	fe 7c 24 00 	mov	r12,-56320
800168ec:	fe b0 e1 08 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, MSG_ENABLE_AUDIO);
800168f0:	30 6b       	mov	r11,6
800168f2:	fe 7c 24 00 	mov	r12,-56320
800168f6:	fe b0 e1 98 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800168fa:	30 0b       	mov	r11,0
800168fc:	fe 7c 24 00 	mov	r12,-56320
80016900:	fe b0 e1 26 	rcall	80012b4c <spi_unselectChip>
}
80016904:	d8 02       	popm	pc
80016906:	d7 03       	nop

80016908 <bfin_get_module_name>:
80016908:	eb cd 40 e0 	pushm	r5-r7,lr
8001690c:	20 1d       	sub	sp,4
8001690e:	18 95       	mov	r5,r12
80016910:	c6 af       	rcall	800167e4 <app_pause>
80016912:	30 0b       	mov	r11,0
  u8 i;

  app_pause();

  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016914:	fe 7c 24 00 	mov	r12,-56320
80016918:	fe b0 e0 f2 	rcall	80012afc <spi_selectChip>
8001691c:	30 4b       	mov	r11,4
  spi_write(BFIN_SPI, MSG_GET_MODULE_NAME_COM);
8001691e:	fe 7c 24 00 	mov	r12,-56320
80016922:	fe b0 e1 82 	rcall	80012c26 <spi_write>
80016926:	30 0b       	mov	r11,0
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016928:	fe 7c 24 00 	mov	r12,-56320
8001692c:	fa c6 ff fe 	sub	r6,sp,-2
80016930:	fe b0 e1 0e 	rcall	80012b4c <spi_unselectChip>
80016934:	30 07       	mov	r7,0
80016936:	30 0b       	mov	r11,0
  for(i=0; i<MODULE_NAME_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016938:	fe 7c 24 00 	mov	r12,-56320
8001693c:	fe b0 e0 e0 	rcall	80012afc <spi_selectChip>
80016940:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016942:	fe 7c 24 00 	mov	r12,-56320
80016946:	fe b0 e1 70 	rcall	80012c26 <spi_write>
8001694a:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
8001694c:	fe 7c 24 00 	mov	r12,-56320
80016950:	fe b0 e1 79 	rcall	80012c42 <spi_read>
80016954:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016956:	fe 7c 24 00 	mov	r12,-56320
8001695a:	fe b0 e0 f9 	rcall	80012b4c <spi_unselectChip>
8001695e:	ea 07 00 08 	add	r8,r5,r7
80016962:	1b b9       	ld.ub	r9,sp[0x3]
    buf[i] = (char)(x & 0xff);
80016964:	b0 89       	st.b	r8[0x0],r9
80016966:	2f f7       	sub	r7,-1
80016968:	59 87       	cp.w	r7,24

  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, MSG_GET_MODULE_NAME_COM);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  for(i=0; i<MODULE_NAME_LEN; i++) {
8001696a:	ce 61       	brne	80016936 <bfin_get_module_name+0x2e>
8001696c:	c3 8f       	rcall	800167dc <app_resume>
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    buf[i] = (char)(x & 0xff);
  }

  app_resume();
8001696e:	2f fd       	sub	sp,-4
80016970:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80016974 <bfin_get_param_desc>:
}
80016974:	eb cd 40 e0 	pushm	r5-r7,lr
80016978:	20 2d       	sub	sp,8
8001697a:	16 97       	mov	r7,r11
8001697c:	18 96       	mov	r6,r12
8001697e:	c3 3f       	rcall	800167e4 <app_pause>
80016980:	30 0b       	mov	r11,0
80016982:	fe 7c 24 00 	mov	r12,-56320
80016986:	fe b0 e0 bb 	rcall	80012afc <spi_selectChip>
8001698a:	30 3b       	mov	r11,3
8001698c:	fe 7c 24 00 	mov	r12,-56320
  u8 i;

  app_pause();
  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, MSG_GET_PARAM_DESC_COM);
80016990:	fe b0 e1 4b 	rcall	80012c26 <spi_write>
80016994:	30 0b       	mov	r11,0
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016996:	fe 7c 24 00 	mov	r12,-56320
8001699a:	fe b0 e0 d9 	rcall	80012b4c <spi_unselectChip>
8001699e:	30 0b       	mov	r11,0
  // idx
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169a0:	fe 7c 24 00 	mov	r12,-56320
800169a4:	fe b0 e0 ac 	rcall	80012afc <spi_selectChip>
800169a8:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
  spi_write(BFIN_SPI, paramIdx);
800169ac:	fe 7c 24 00 	mov	r12,-56320
800169b0:	fe b0 e1 3b 	rcall	80012c26 <spi_write>
800169b4:	30 0b       	mov	r11,0
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169b6:	fe 7c 24 00 	mov	r12,-56320
800169ba:	fe b0 e0 c9 	rcall	80012b4c <spi_unselectChip>
800169be:	30 0b       	mov	r11,0
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169c0:	fe 7c 24 00 	mov	r12,-56320
800169c4:	fe b0 e0 9c 	rcall	80012afc <spi_selectChip>
800169c8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
800169ca:	fe 7c 24 00 	mov	r12,-56320
800169ce:	fe b0 e1 2c 	rcall	80012c26 <spi_write>
800169d2:	fa c6 ff fa 	sub	r6,sp,-6
    spi_read(BFIN_SPI, &x);
800169d6:	fe 7c 24 00 	mov	r12,-56320
800169da:	0c 9b       	mov	r11,r6
800169dc:	fe b0 e1 33 	rcall	80012c42 <spi_read>
800169e0:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169e2:	fe 7c 24 00 	mov	r12,-56320
800169e6:	fe b0 e0 b3 	rcall	80012b4c <spi_unselectChip>
800169ea:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
800169ec:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169ee:	ae 88       	st.b	r7[0x0],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
800169f0:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800169f4:	fe b0 e0 84 	rcall	80012afc <spi_selectChip>
800169f8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
800169fa:	fe 7c 24 00 	mov	r12,-56320
800169fe:	fe b0 e1 14 	rcall	80012c26 <spi_write>
80016a02:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016a04:	fe 7c 24 00 	mov	r12,-56320
80016a08:	fe b0 e1 1d 	rcall	80012c42 <spi_read>
80016a0c:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a0e:	fe 7c 24 00 	mov	r12,-56320
80016a12:	fe b0 e0 9d 	rcall	80012b4c <spi_unselectChip>
80016a16:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016a18:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a1a:	ae 98       	st.b	r7[0x1],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016a1c:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a20:	fe b0 e0 6e 	rcall	80012afc <spi_selectChip>
80016a24:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016a26:	fe 7c 24 00 	mov	r12,-56320
80016a2a:	fe b0 e0 fe 	rcall	80012c26 <spi_write>
80016a2e:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016a30:	fe 7c 24 00 	mov	r12,-56320
80016a34:	fe b0 e1 07 	rcall	80012c42 <spi_read>
80016a38:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a3a:	fe 7c 24 00 	mov	r12,-56320
80016a3e:	fe b0 e0 87 	rcall	80012b4c <spi_unselectChip>
80016a42:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016a44:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a46:	ae a8       	st.b	r7[0x2],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016a48:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a4c:	fe b0 e0 58 	rcall	80012afc <spi_selectChip>
80016a50:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016a52:	fe 7c 24 00 	mov	r12,-56320
80016a56:	fe b0 e0 e8 	rcall	80012c26 <spi_write>
80016a5a:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016a5c:	fe 7c 24 00 	mov	r12,-56320
80016a60:	fe b0 e0 f1 	rcall	80012c42 <spi_read>
80016a64:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a66:	fe 7c 24 00 	mov	r12,-56320
80016a6a:	fe b0 e0 71 	rcall	80012b4c <spi_unselectChip>
80016a6e:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016a70:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a72:	ae b8       	st.b	r7[0x3],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016a74:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a78:	fe b0 e0 42 	rcall	80012afc <spi_selectChip>
80016a7c:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016a7e:	fe 7c 24 00 	mov	r12,-56320
80016a82:	fe b0 e0 d2 	rcall	80012c26 <spi_write>
80016a86:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016a88:	fe 7c 24 00 	mov	r12,-56320
80016a8c:	fe b0 e0 db 	rcall	80012c42 <spi_read>
80016a90:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a92:	fe 7c 24 00 	mov	r12,-56320
80016a96:	fe b0 e0 5b 	rcall	80012b4c <spi_unselectChip>
80016a9a:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016a9c:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016a9e:	ae c8       	st.b	r7[0x4],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016aa0:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016aa4:	fe b0 e0 2c 	rcall	80012afc <spi_selectChip>
80016aa8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016aaa:	fe 7c 24 00 	mov	r12,-56320
80016aae:	fe b0 e0 bc 	rcall	80012c26 <spi_write>
80016ab2:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016ab4:	fe 7c 24 00 	mov	r12,-56320
80016ab8:	fe b0 e0 c5 	rcall	80012c42 <spi_read>
80016abc:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016abe:	fe 7c 24 00 	mov	r12,-56320
80016ac2:	fe b0 e0 45 	rcall	80012b4c <spi_unselectChip>
80016ac6:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016ac8:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016aca:	ae d8       	st.b	r7[0x5],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016acc:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016ad0:	fe b0 e0 16 	rcall	80012afc <spi_selectChip>
80016ad4:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016ad6:	fe 7c 24 00 	mov	r12,-56320
80016ada:	fe b0 e0 a6 	rcall	80012c26 <spi_write>
80016ade:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016ae0:	fe 7c 24 00 	mov	r12,-56320
80016ae4:	fe b0 e0 af 	rcall	80012c42 <spi_read>
80016ae8:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016aea:	fe 7c 24 00 	mov	r12,-56320
80016aee:	fe b0 e0 2f 	rcall	80012b4c <spi_unselectChip>
80016af2:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016af4:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016af6:	ae e8       	st.b	r7[0x6],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016af8:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016afc:	fe b0 e0 00 	rcall	80012afc <spi_selectChip>
80016b00:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016b02:	fe 7c 24 00 	mov	r12,-56320
80016b06:	fe b0 e0 90 	rcall	80012c26 <spi_write>
80016b0a:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016b0c:	fe 7c 24 00 	mov	r12,-56320
80016b10:	fe b0 e0 99 	rcall	80012c42 <spi_read>
80016b14:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b16:	fe 7c 24 00 	mov	r12,-56320
80016b1a:	fe b0 e0 19 	rcall	80012b4c <spi_unselectChip>
80016b1e:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016b20:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b22:	ae f8       	st.b	r7[0x7],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016b24:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b28:	fe b0 df ea 	rcall	80012afc <spi_selectChip>
80016b2c:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016b2e:	fe 7c 24 00 	mov	r12,-56320
80016b32:	fe b0 e0 7a 	rcall	80012c26 <spi_write>
80016b36:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016b38:	fe 7c 24 00 	mov	r12,-56320
80016b3c:	fe b0 e0 83 	rcall	80012c42 <spi_read>
80016b40:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b42:	fe 7c 24 00 	mov	r12,-56320
80016b46:	fe b0 e0 03 	rcall	80012b4c <spi_unselectChip>
80016b4a:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016b4c:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b4e:	ef 68 00 08 	st.b	r7[8],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016b52:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b56:	fe b0 df d3 	rcall	80012afc <spi_selectChip>
80016b5a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016b5c:	fe 7c 24 00 	mov	r12,-56320
80016b60:	fe b0 e0 63 	rcall	80012c26 <spi_write>
80016b64:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016b66:	fe 7c 24 00 	mov	r12,-56320
80016b6a:	fe b0 e0 6c 	rcall	80012c42 <spi_read>
80016b6e:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b70:	fe 7c 24 00 	mov	r12,-56320
80016b74:	fe b0 df ec 	rcall	80012b4c <spi_unselectChip>
80016b78:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016b7a:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b7c:	ef 68 00 09 	st.b	r7[9],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016b80:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b84:	fe b0 df bc 	rcall	80012afc <spi_selectChip>
80016b88:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016b8a:	fe 7c 24 00 	mov	r12,-56320
80016b8e:	fe b0 e0 4c 	rcall	80012c26 <spi_write>
80016b92:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016b94:	fe 7c 24 00 	mov	r12,-56320
80016b98:	fe b0 e0 55 	rcall	80012c42 <spi_read>
80016b9c:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016b9e:	fe 7c 24 00 	mov	r12,-56320
80016ba2:	fe b0 df d5 	rcall	80012b4c <spi_unselectChip>
80016ba6:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016ba8:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016baa:	ef 68 00 0a 	st.b	r7[10],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016bae:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016bb2:	fe b0 df a5 	rcall	80012afc <spi_selectChip>
80016bb6:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016bb8:	fe 7c 24 00 	mov	r12,-56320
80016bbc:	fe b0 e0 35 	rcall	80012c26 <spi_write>
80016bc0:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016bc2:	fe 7c 24 00 	mov	r12,-56320
80016bc6:	fe b0 e0 3e 	rcall	80012c42 <spi_read>
80016bca:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016bcc:	fe 7c 24 00 	mov	r12,-56320
80016bd0:	fe b0 df be 	rcall	80012b4c <spi_unselectChip>
80016bd4:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016bd6:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016bd8:	ef 68 00 0b 	st.b	r7[11],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016bdc:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016be0:	fe b0 df 8e 	rcall	80012afc <spi_selectChip>
80016be4:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016be6:	fe 7c 24 00 	mov	r12,-56320
80016bea:	fe b0 e0 1e 	rcall	80012c26 <spi_write>
80016bee:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016bf0:	fe 7c 24 00 	mov	r12,-56320
80016bf4:	fe b0 e0 27 	rcall	80012c42 <spi_read>
80016bf8:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016bfa:	fe 7c 24 00 	mov	r12,-56320
80016bfe:	fe b0 df a7 	rcall	80012b4c <spi_unselectChip>
80016c02:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016c04:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c06:	ef 68 00 0c 	st.b	r7[12],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016c0a:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c0e:	fe b0 df 77 	rcall	80012afc <spi_selectChip>
80016c12:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016c14:	fe 7c 24 00 	mov	r12,-56320
80016c18:	fe b0 e0 07 	rcall	80012c26 <spi_write>
80016c1c:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016c1e:	fe 7c 24 00 	mov	r12,-56320
80016c22:	fe b0 e0 10 	rcall	80012c42 <spi_read>
80016c26:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c28:	fe 7c 24 00 	mov	r12,-56320
80016c2c:	fe b0 df 90 	rcall	80012b4c <spi_unselectChip>
80016c30:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016c32:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c34:	ef 68 00 0d 	st.b	r7[13],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016c38:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c3c:	fe b0 df 60 	rcall	80012afc <spi_selectChip>
80016c40:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016c42:	fe 7c 24 00 	mov	r12,-56320
80016c46:	fe b0 df f0 	rcall	80012c26 <spi_write>
80016c4a:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016c4c:	fe 7c 24 00 	mov	r12,-56320
80016c50:	fe b0 df f9 	rcall	80012c42 <spi_read>
80016c54:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c56:	fe 7c 24 00 	mov	r12,-56320
80016c5a:	fe b0 df 79 	rcall	80012b4c <spi_unselectChip>
80016c5e:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016c60:	30 0b       	mov	r11,0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c62:	ef 68 00 0e 	st.b	r7[14],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016c66:	fe 7c 24 00 	mov	r12,-56320
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, paramIdx);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  // read label
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c6a:	fe b0 df 49 	rcall	80012afc <spi_selectChip>
80016c6e:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016c70:	fe 7c 24 00 	mov	r12,-56320
80016c74:	fe b0 df d9 	rcall	80012c26 <spi_write>
80016c78:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016c7a:	fe 7c 24 00 	mov	r12,-56320
80016c7e:	fe b0 df e2 	rcall	80012c42 <spi_read>
80016c82:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c84:	fe 7c 24 00 	mov	r12,-56320
80016c88:	fe b0 df 62 	rcall	80012b4c <spi_unselectChip>
80016c8c:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->label[i] = (char)(x & 0xff);
80016c8e:	30 0b       	mov	r11,0
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c90:	ef 68 00 0f 	st.b	r7[15],r8
  for(i=0; i<PARAM_LABEL_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
80016c94:	fe 7c 24 00 	mov	r12,-56320
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016c98:	fe b0 df 32 	rcall	80012afc <spi_selectChip>
80016c9c:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016c9e:	fe 7c 24 00 	mov	r12,-56320
80016ca2:	fe b0 df c2 	rcall	80012c26 <spi_write>
80016ca6:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016ca8:	fe 7c 24 00 	mov	r12,-56320
80016cac:	fe b0 df cb 	rcall	80012c42 <spi_read>
80016cb0:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016cb2:	fe 7c 24 00 	mov	r12,-56320
80016cb6:	fe b0 df 4b 	rcall	80012b4c <spi_unselectChip>
80016cba:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016cbc:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016cbe:	ef 68 00 10 	st.b	r7[16],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016cc2:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016cc6:	fe b0 df 1b 	rcall	80012afc <spi_selectChip>
80016cca:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016ccc:	fe 7c 24 00 	mov	r12,-56320
80016cd0:	fe b0 df ab 	rcall	80012c26 <spi_write>
80016cd4:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016cd6:	fe 7c 24 00 	mov	r12,-56320
80016cda:	fe b0 df b4 	rcall	80012c42 <spi_read>
80016cde:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016ce0:	fe 7c 24 00 	mov	r12,-56320
80016ce4:	fe b0 df 34 	rcall	80012b4c <spi_unselectChip>
80016ce8:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016cea:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016cec:	ef 68 00 11 	st.b	r7[17],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016cf0:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016cf4:	fe b0 df 04 	rcall	80012afc <spi_selectChip>
80016cf8:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016cfa:	fe 7c 24 00 	mov	r12,-56320
80016cfe:	fe b0 df 94 	rcall	80012c26 <spi_write>
80016d02:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016d04:	fe 7c 24 00 	mov	r12,-56320
80016d08:	fe b0 df 9d 	rcall	80012c42 <spi_read>
80016d0c:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d0e:	fe 7c 24 00 	mov	r12,-56320
80016d12:	fe b0 df 1d 	rcall	80012b4c <spi_unselectChip>
80016d16:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016d18:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d1a:	ef 68 00 12 	st.b	r7[18],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016d1e:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d22:	fe b0 de ed 	rcall	80012afc <spi_selectChip>
80016d26:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016d28:	fe 7c 24 00 	mov	r12,-56320
80016d2c:	fe b0 df 7d 	rcall	80012c26 <spi_write>
80016d30:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016d32:	fe 7c 24 00 	mov	r12,-56320
80016d36:	fe b0 df 86 	rcall	80012c42 <spi_read>
80016d3a:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d3c:	fe 7c 24 00 	mov	r12,-56320
80016d40:	fe b0 df 06 	rcall	80012b4c <spi_unselectChip>
80016d44:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016d46:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d48:	ef 68 00 13 	st.b	r7[19],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016d4c:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d50:	fe b0 de d6 	rcall	80012afc <spi_selectChip>
80016d54:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016d56:	fe 7c 24 00 	mov	r12,-56320
80016d5a:	fe b0 df 66 	rcall	80012c26 <spi_write>
80016d5e:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016d60:	fe 7c 24 00 	mov	r12,-56320
80016d64:	fe b0 df 6f 	rcall	80012c42 <spi_read>
80016d68:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d6a:	fe 7c 24 00 	mov	r12,-56320
80016d6e:	fe b0 de ef 	rcall	80012b4c <spi_unselectChip>
80016d72:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016d74:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d76:	ef 68 00 14 	st.b	r7[20],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016d7a:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d7e:	fe b0 de bf 	rcall	80012afc <spi_selectChip>
80016d82:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016d84:	fe 7c 24 00 	mov	r12,-56320
80016d88:	fe b0 df 4f 	rcall	80012c26 <spi_write>
80016d8c:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016d8e:	fe 7c 24 00 	mov	r12,-56320
80016d92:	fe b0 df 58 	rcall	80012c42 <spi_read>
80016d96:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016d98:	fe 7c 24 00 	mov	r12,-56320
80016d9c:	fe b0 de d8 	rcall	80012b4c <spi_unselectChip>
80016da0:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016da2:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016da4:	ef 68 00 15 	st.b	r7[21],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016da8:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016dac:	fe b0 de a8 	rcall	80012afc <spi_selectChip>
80016db0:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016db2:	fe 7c 24 00 	mov	r12,-56320
80016db6:	fe b0 df 38 	rcall	80012c26 <spi_write>
80016dba:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016dbc:	fe 7c 24 00 	mov	r12,-56320
80016dc0:	fe b0 df 41 	rcall	80012c42 <spi_read>
80016dc4:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016dc6:	fe 7c 24 00 	mov	r12,-56320
80016dca:	fe b0 de c1 	rcall	80012b4c <spi_unselectChip>
80016dce:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016dd0:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016dd2:	ef 68 00 16 	st.b	r7[22],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016dd6:	fe 7c 24 00 	mov	r12,-56320
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->label[i] = (char)(x & 0xff);
  }
  // read unit
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016dda:	fe b0 de 91 	rcall	80012afc <spi_selectChip>
80016dde:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016de0:	fe 7c 24 00 	mov	r12,-56320
80016de4:	fe b0 df 21 	rcall	80012c26 <spi_write>
80016de8:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016dea:	fe 7c 24 00 	mov	r12,-56320
80016dee:	fe b0 df 2a 	rcall	80012c42 <spi_read>
80016df2:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016df4:	fe 7c 24 00 	mov	r12,-56320
80016df8:	fe b0 de aa 	rcall	80012b4c <spi_unselectChip>
80016dfc:	1b f8       	ld.ub	r8,sp[0x7]
    pDesc->unit[i] = (char)(x & 0xff);
80016dfe:	30 0b       	mov	r11,0
  }
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e00:	ef 68 00 17 	st.b	r7[23],r8
  for(i=0; i<PARAM_UNIT_LEN; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pDesc->unit[i] = (char)(x & 0xff);
80016e04:	fe 7c 24 00 	mov	r12,-56320
  }
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e08:	fe b0 de 7a 	rcall	80012afc <spi_selectChip>
80016e0c:	30 0b       	mov	r11,0
  spi_write(BFIN_SPI, 0); //dont care
80016e0e:	fe 7c 24 00 	mov	r12,-56320
80016e12:	fe b0 df 0a 	rcall	80012c26 <spi_write>
80016e16:	0c 9b       	mov	r11,r6
  spi_read(BFIN_SPI, &x);
80016e18:	fe 7c 24 00 	mov	r12,-56320
80016e1c:	fe b0 df 13 	rcall	80012c42 <spi_read>
80016e20:	30 0b       	mov	r11,0
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e22:	fe 7c 24 00 	mov	r12,-56320
80016e26:	fe b0 de 93 	rcall	80012b4c <spi_unselectChip>
80016e2a:	1b f8       	ld.ub	r8,sp[0x7]
  pDesc->type = (U8)(x & 0xff);
80016e2c:	30 0b       	mov	r11,0
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e2e:	ef 68 00 18 	st.b	r7[24],r8
  // read type
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, 0); //dont care
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
80016e32:	fe 7c 24 00 	mov	r12,-56320
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e36:	fe b0 de 63 	rcall	80012afc <spi_selectChip>
80016e3a:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016e3c:	fe 7c 24 00 	mov	r12,-56320
80016e40:	fe b0 de f3 	rcall	80012c26 <spi_write>
80016e44:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016e46:	fe 7c 24 00 	mov	r12,-56320
80016e4a:	fe b0 de fc 	rcall	80012c42 <spi_read>
80016e4e:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e50:	fe 7c 24 00 	mov	r12,-56320
80016e54:	fe b0 de 7c 	rcall	80012b4c <spi_unselectChip>
80016e58:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016e5a:	30 0b       	mov	r11,0
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e5c:	ba a8       	st.b	sp[0x2],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016e5e:	fe 7c 24 00 	mov	r12,-56320
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e62:	fe b0 de 4d 	rcall	80012afc <spi_selectChip>
80016e66:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016e68:	fe 7c 24 00 	mov	r12,-56320
80016e6c:	fe b0 de dd 	rcall	80012c26 <spi_write>
80016e70:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016e72:	fe 7c 24 00 	mov	r12,-56320
80016e76:	fe b0 de e6 	rcall	80012c42 <spi_read>
80016e7a:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e7c:	fe 7c 24 00 	mov	r12,-56320
80016e80:	fe b0 de 66 	rcall	80012b4c <spi_unselectChip>
80016e84:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016e86:	30 0b       	mov	r11,0
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e88:	ba b8       	st.b	sp[0x3],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016e8a:	fe 7c 24 00 	mov	r12,-56320
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016e8e:	fe b0 de 37 	rcall	80012afc <spi_selectChip>
80016e92:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016e94:	fe 7c 24 00 	mov	r12,-56320
80016e98:	fe b0 de c7 	rcall	80012c26 <spi_write>
80016e9c:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016e9e:	fe 7c 24 00 	mov	r12,-56320
80016ea2:	fe b0 de d0 	rcall	80012c42 <spi_read>
80016ea6:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016ea8:	fe 7c 24 00 	mov	r12,-56320
80016eac:	fe b0 de 50 	rcall	80012b4c <spi_unselectChip>
80016eb0:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016eb2:	30 0b       	mov	r11,0
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016eb4:	ba c8       	st.b	sp[0x4],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016eb6:	fe 7c 24 00 	mov	r12,-56320
  spi_read(BFIN_SPI, &x);
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
  pDesc->type = (U8)(x & 0xff);
  // read min
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016eba:	fe b0 de 21 	rcall	80012afc <spi_selectChip>
80016ebe:	30 0b       	mov	r11,0
    spi_write(BFIN_SPI, 0); //dont care
80016ec0:	fe 7c 24 00 	mov	r12,-56320
80016ec4:	fe b0 de b1 	rcall	80012c26 <spi_write>
80016ec8:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016eca:	fe 7c 24 00 	mov	r12,-56320
80016ece:	fe b0 de ba 	rcall	80012c42 <spi_read>
80016ed2:	30 0b       	mov	r11,0
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016ed4:	fe 7c 24 00 	mov	r12,-56320
80016ed8:	fe b0 de 3a 	rcall	80012b4c <spi_unselectChip>
80016edc:	ef 38 00 19 	ld.ub	r8,r7[25]
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
80016ee0:	9a 38       	ld.sh	r8,sp[0x6]
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016ee2:	9a 99       	ld.uh	r9,sp[0x2]
  }
  pDesc->min = pval.asInt;
80016ee4:	ba d8       	st.b	sp[0x5],r8
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016ee6:	9a a8       	ld.uh	r8,sp[0x4]
  }
  pDesc->min = pval.asInt;
80016ee8:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80016eec:	f0 09 16 18 	lsr	r9,r8,0x18
80016ef0:	ef 69 00 19 	st.b	r7[25],r9
80016ef4:	ef 39 00 1a 	ld.ub	r9,r7[26]
80016ef8:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80016efc:	ef 69 00 1a 	st.b	r7[26],r9
80016f00:	ef 39 00 1b 	ld.ub	r9,r7[27]
80016f04:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80016f08:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80016f0c:	ef 69 00 1b 	st.b	r7[27],r9
80016f10:	ef 39 00 1c 	ld.ub	r9,r7[28]
80016f14:	30 05       	mov	r5,0
80016f16:	ef 68 00 1c 	st.b	r7[28],r8
80016f1a:	0a 9b       	mov	r11,r5
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f1c:	fe 7c 24 00 	mov	r12,-56320
80016f20:	fe b0 dd ee 	rcall	80012afc <spi_selectChip>
80016f24:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
80016f26:	fe 7c 24 00 	mov	r12,-56320
80016f2a:	fe b0 de 7e 	rcall	80012c26 <spi_write>
80016f2e:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016f30:	fe 7c 24 00 	mov	r12,-56320
80016f34:	fe b0 de 87 	rcall	80012c42 <spi_read>
80016f38:	0a 9b       	mov	r11,r5
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f3a:	fe 7c 24 00 	mov	r12,-56320
80016f3e:	fe b0 de 07 	rcall	80012b4c <spi_unselectChip>
80016f42:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016f44:	0a 9b       	mov	r11,r5
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f46:	ba a8       	st.b	sp[0x2],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016f48:	fe 7c 24 00 	mov	r12,-56320
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f4c:	fe b0 dd d8 	rcall	80012afc <spi_selectChip>
80016f50:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
80016f52:	fe 7c 24 00 	mov	r12,-56320
80016f56:	fe b0 de 68 	rcall	80012c26 <spi_write>
80016f5a:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016f5c:	fe 7c 24 00 	mov	r12,-56320
80016f60:	fe b0 de 71 	rcall	80012c42 <spi_read>
80016f64:	0a 9b       	mov	r11,r5
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f66:	fe 7c 24 00 	mov	r12,-56320
80016f6a:	fe b0 dd f1 	rcall	80012b4c <spi_unselectChip>
80016f6e:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016f70:	0a 9b       	mov	r11,r5
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f72:	ba b8       	st.b	sp[0x3],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016f74:	fe 7c 24 00 	mov	r12,-56320
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f78:	fe b0 dd c2 	rcall	80012afc <spi_selectChip>
80016f7c:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
80016f7e:	fe 7c 24 00 	mov	r12,-56320
80016f82:	fe b0 de 52 	rcall	80012c26 <spi_write>
80016f86:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016f88:	fe 7c 24 00 	mov	r12,-56320
80016f8c:	fe b0 de 5b 	rcall	80012c42 <spi_read>
80016f90:	0a 9b       	mov	r11,r5
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f92:	fe 7c 24 00 	mov	r12,-56320
80016f96:	fe b0 dd db 	rcall	80012b4c <spi_unselectChip>
80016f9a:	9a 38       	ld.sh	r8,sp[0x6]
    pval.asByte[i] = (u8)(x & 0xff);
80016f9c:	0a 9b       	mov	r11,r5
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016f9e:	ba c8       	st.b	sp[0x4],r8
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016fa0:	fe 7c 24 00 	mov	r12,-56320
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->min = pval.asInt;
  // read max
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016fa4:	fe b0 dd ac 	rcall	80012afc <spi_selectChip>
80016fa8:	0a 9b       	mov	r11,r5
    spi_write(BFIN_SPI, 0); //dont care
80016faa:	fe 7c 24 00 	mov	r12,-56320
80016fae:	fe b0 de 3c 	rcall	80012c26 <spi_write>
80016fb2:	0c 9b       	mov	r11,r6
    spi_read(BFIN_SPI, &x);
80016fb4:	fe 7c 24 00 	mov	r12,-56320
80016fb8:	fe b0 de 45 	rcall	80012c42 <spi_read>
80016fbc:	0a 9b       	mov	r11,r5
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80016fbe:	fe 7c 24 00 	mov	r12,-56320
80016fc2:	fe b0 dd c5 	rcall	80012b4c <spi_unselectChip>
80016fc6:	ef 38 00 1d 	ld.ub	r8,r7[29]
    pval.asByte[i] = (u8)(x & 0xff);
  }
  pDesc->max = pval.asInt;
80016fca:	9a 38       	ld.sh	r8,sp[0x6]
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016fcc:	9a 99       	ld.uh	r9,sp[0x2]
  }
  pDesc->max = pval.asInt;
80016fce:	ba d8       	st.b	sp[0x5],r8
  for(i=0; i<4; i++) {
    spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
    spi_write(BFIN_SPI, 0); //dont care
    spi_read(BFIN_SPI, &x);
    spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
    pval.asByte[i] = (u8)(x & 0xff);
80016fd0:	9a a8       	ld.uh	r8,sp[0x4]
  }
  pDesc->max = pval.asInt;
80016fd2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80016fd6:	f0 09 16 18 	lsr	r9,r8,0x18
80016fda:	ef 69 00 1d 	st.b	r7[29],r9
80016fde:	ef 39 00 1e 	ld.ub	r9,r7[30]
80016fe2:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80016fe6:	ef 69 00 1e 	st.b	r7[30],r9
80016fea:	ef 39 00 1f 	ld.ub	r9,r7[31]
80016fee:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80016ff2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80016ff6:	ef 69 00 1f 	st.b	r7[31],r9
80016ffa:	ef 39 00 20 	ld.ub	r9,r7[32]
80016ffe:	ef 68 00 20 	st.b	r7[32],r8
80017002:	fe b0 fb ed 	rcall	800167dc <app_resume>

  app_resume();
80017006:	2f ed       	sub	sp,-8
}
80017008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001700c <bfin_get_num_params>:
8001700c:	eb cd 40 80 	pushm	r7,lr
80017010:	20 1d       	sub	sp,4
80017012:	18 97       	mov	r7,r12
80017014:	fe b0 fb e8 	rcall	800167e4 <app_pause>
80017018:	30 0b       	mov	r11,0
8001701a:	fe 7c 24 00 	mov	r12,-56320
8001701e:	fe b0 dd 6f 	rcall	80012afc <spi_selectChip>
80017022:	30 2b       	mov	r11,2
80017024:	fe 7c 24 00 	mov	r12,-56320

  app_pause();

  // command 
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
  spi_write(BFIN_SPI, MSG_GET_NUM_PARAMS_COM);
80017028:	fe b0 dd ff 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8001702c:	30 0b       	mov	r11,0
8001702e:	fe 7c 24 00 	mov	r12,-56320
80017032:	fe b0 dd 8d 	rcall	80012b4c <spi_unselectChip>
  // read num
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017036:	30 0b       	mov	r11,0
80017038:	fe 7c 24 00 	mov	r12,-56320
8001703c:	fe b0 dd 60 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, 0); //dont care
80017040:	30 0b       	mov	r11,0
80017042:	fe 7c 24 00 	mov	r12,-56320
80017046:	fe b0 dd f0 	rcall	80012c26 <spi_write>
  spi_read(BFIN_SPI, &x);
8001704a:	fa cb ff fe 	sub	r11,sp,-2
8001704e:	fe 7c 24 00 	mov	r12,-56320
80017052:	fe b0 dd f8 	rcall	80012c42 <spi_read>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);  
80017056:	30 0b       	mov	r11,0
80017058:	fe 7c 24 00 	mov	r12,-56320
8001705c:	fe b0 dd 78 	rcall	80012b4c <spi_unselectChip>
  *num = (u8)(x & 0xff);
80017060:	1b b8       	ld.ub	r8,sp[0x3]
80017062:	8f 08       	st.w	r7[0x0],r8

  app_resume();
80017064:	fe b0 fb bc 	rcall	800167dc <app_resume>

}
80017068:	2f fd       	sub	sp,-4
8001706a:	e3 cd 80 80 	ldm	sp++,r7,pc
8001706e:	d7 03       	nop

80017070 <bfin_set_param>:
80017070:	eb cd 40 e0 	pushm	r5-r7,lr
80017074:	f6 08 16 18 	lsr	r8,r11,0x18
80017078:	e0 66 07 88 	mov	r6,1928
8001707c:	ac 88       	st.b	r6[0x0],r8
8001707e:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
80017082:	ac 98       	st.b	r6[0x1],r8
80017084:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {

  static ParamValue pval;
  pval.asInt = (s32)x;
80017088:	16 97       	mov	r7,r11
8001708a:	ac a8       	st.b	r6[0x2],r8
  
  app_resume();
}

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {
8001708c:	ac bb       	st.b	r6[0x3],r11

  static ParamValue pval;
  pval.asInt = (s32)x;

  print_dbg("\r\n bfin_set_param, idx: ");
8001708e:	18 95       	mov	r5,r12
80017090:	4b 5c       	lddpc	r12,80017164 <bfin_set_param+0xf4>
80017092:	fe b0 df 85 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(idx);
80017096:	0a 9c       	mov	r12,r5
80017098:	fe b0 df 88 	rcall	80012fa8 <print_dbg_ulong>

  print_dbg(", val: 0x");
8001709c:	4b 3c       	lddpc	r12,80017168 <bfin_set_param+0xf8>
8001709e:	fe b0 df 7f 	rcall	80012f9c <print_dbg>

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {

  static ParamValue pval;
  pval.asInt = (s32)x;
800170a2:	0e 9c       	mov	r12,r7

  print_dbg("\r\n bfin_set_param, idx: ");
  print_dbg_ulong(idx);

  print_dbg(", val: 0x");
  print_dbg_hex((u32)x);
800170a4:	30 07       	mov	r7,0
800170a6:	fe b0 df a3 	rcall	80012fec <print_dbg_hex>

  //  app_pause();

  // command
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170aa:	0e 9b       	mov	r11,r7
800170ac:	fe 7c 24 00 	mov	r12,-56320
800170b0:	fe b0 dd 26 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, MSG_SET_PARAM_COM);
800170b4:	0e 9b       	mov	r11,r7
800170b6:	fe 7c 24 00 	mov	r12,-56320
800170ba:	fe b0 dd b6 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170be:	0e 9b       	mov	r11,r7
800170c0:	fe 7c 24 00 	mov	r12,-56320
800170c4:	fe b0 dd 44 	rcall	80012b4c <spi_unselectChip>
  //idx
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170c8:	0e 9b       	mov	r11,r7
800170ca:	fe 7c 24 00 	mov	r12,-56320
800170ce:	fe b0 dd 17 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, idx);
800170d2:	0a 9b       	mov	r11,r5
800170d4:	fe 7c 24 00 	mov	r12,-56320
800170d8:	fe b0 dd a7 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170dc:	0e 9b       	mov	r11,r7
800170de:	fe 7c 24 00 	mov	r12,-56320
800170e2:	fe b0 dd 35 	rcall	80012b4c <spi_unselectChip>
  //val0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170e6:	0e 9b       	mov	r11,r7
800170e8:	fe 7c 24 00 	mov	r12,-56320
800170ec:	fe b0 dd 08 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[0]);
800170f0:	0d 8b       	ld.ub	r11,r6[0x0]
800170f2:	fe 7c 24 00 	mov	r12,-56320
800170f6:	fe b0 dd 98 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800170fa:	0e 9b       	mov	r11,r7
800170fc:	fe 7c 24 00 	mov	r12,-56320
80017100:	fe b0 dd 26 	rcall	80012b4c <spi_unselectChip>
  // val1
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017104:	0e 9b       	mov	r11,r7
80017106:	fe 7c 24 00 	mov	r12,-56320
8001710a:	fe b0 dc f9 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[1]);
8001710e:	0d 9b       	ld.ub	r11,r6[0x1]
80017110:	fe 7c 24 00 	mov	r12,-56320
80017114:	fe b0 dd 89 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017118:	0e 9b       	mov	r11,r7
8001711a:	fe 7c 24 00 	mov	r12,-56320
8001711e:	fe b0 dd 17 	rcall	80012b4c <spi_unselectChip>
  //val2
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017122:	0e 9b       	mov	r11,r7
80017124:	fe 7c 24 00 	mov	r12,-56320
80017128:	fe b0 dc ea 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[2]);
8001712c:	0d ab       	ld.ub	r11,r6[0x2]
8001712e:	fe 7c 24 00 	mov	r12,-56320
80017132:	fe b0 dd 7a 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017136:	0e 9b       	mov	r11,r7
80017138:	fe 7c 24 00 	mov	r12,-56320
8001713c:	fe b0 dd 08 	rcall	80012b4c <spi_unselectChip>
  //val3
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017140:	0e 9b       	mov	r11,r7
80017142:	fe 7c 24 00 	mov	r12,-56320
80017146:	fe b0 dc db 	rcall	80012afc <spi_selectChip>
  spi_write(BFIN_SPI, pval.asByte[3]);
8001714a:	0d bb       	ld.ub	r11,r6[0x3]
8001714c:	fe 7c 24 00 	mov	r12,-56320
80017150:	fe b0 dd 6b 	rcall	80012c26 <spi_write>
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017154:	0e 9b       	mov	r11,r7
80017156:	fe 7c 24 00 	mov	r12,-56320
8001715a:	fe b0 dc f9 	rcall	80012b4c <spi_unselectChip>

  //  app_resume();
}
8001715e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80017162:	d7 03       	nop
80017164:	80 02       	ld.sh	r2,r0[0x0]
80017166:	43 d0       	lddsp	r0,sp[0xf4]
80017168:	80 02       	ld.sh	r2,r0[0x0]
8001716a:	43 ec       	lddsp	r12,sp[0xf8]

8001716c <bfin_load_buf>:
8001716c:	d4 31       	pushm	r0-r7,lr
8001716e:	e0 65 0b 98 	mov	r5,2968
80017172:	6a 08       	ld.w	r8,r5[0x0]
80017174:	e0 58 00 00 	cp.w	r8,65536
80017178:	e0 8b 00 d0 	brhi	80017318 <bfin_load_buf+0x1ac>
8001717c:	fe b0 fb 34 	rcall	800167e4 <app_pause>
80017180:	30 6c       	mov	r12,6
80017182:	fe b0 da be 	rcall	800126fe <gpio_set_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80017186:	30 09       	mov	r9,0
80017188:	e0 68 03 e8 	mov	r8,1000
8001718c:	e0 6a 18 67 	mov	r10,6247
80017190:	ea 1a 03 ef 	orh	r10,0x3ef
80017194:	30 0b       	mov	r11,0
80017196:	e0 a0 5f 1e 	rcall	80022fd2 <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001719a:	14 94       	mov	r4,r10
8001719c:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800171a0:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800171a4:	e1 b8 00 42 	mfsr	r8,0x108
800171a8:	14 39       	cp.w	r9,r10
800171aa:	e0 8b 00 88 	brhi	800172ba <bfin_load_buf+0x14e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800171ae:	10 39       	cp.w	r9,r8
800171b0:	e0 8b 00 05 	brhi	800171ba <bfin_load_buf+0x4e>
800171b4:	10 3a       	cp.w	r10,r8
800171b6:	e0 82 00 a5 	brhs	80017300 <bfin_load_buf+0x194>
void bfin_start_transfer(void) {
  //  volatile u64 delay;
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
  //  delay = 30; while (--delay > 0) {;;}
  delay_ms(1);
  gpio_clr_gpio_pin(BFIN_RESET_PIN);
800171ba:	30 6c       	mov	r12,6
800171bc:	fe b0 da ae 	rcall	80012718 <gpio_clr_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800171c0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800171c4:	f0 04 00 0a 	add	r10,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800171c8:	e1 b9 00 42 	mfsr	r9,0x108
800171cc:	14 38       	cp.w	r8,r10
800171ce:	e0 8b 00 7f 	brhi	800172cc <bfin_load_buf+0x160>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800171d2:	10 39       	cp.w	r9,r8
800171d4:	c0 43       	brcs	800171dc <bfin_load_buf+0x70>
800171d6:	14 39       	cp.w	r9,r10
800171d8:	e0 88 00 97 	brls	80017306 <bfin_load_buf+0x19a>
  //  delay = 30; while (--delay > 0) {;;}
  delay_ms(1);
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
800171dc:	30 6c       	mov	r12,6
800171de:	fe b0 da 90 	rcall	800126fe <gpio_set_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800171e2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800171e6:	f0 04 00 04 	add	r4,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800171ea:	e1 b9 00 42 	mfsr	r9,0x108
800171ee:	08 38       	cp.w	r8,r4
800171f0:	e0 8b 00 76 	brhi	800172dc <bfin_load_buf+0x170>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800171f4:	12 38       	cp.w	r8,r9
800171f6:	e0 8b 00 05 	brhi	80017200 <bfin_load_buf+0x94>
800171fa:	12 34       	cp.w	r4,r9
800171fc:	e0 82 00 88 	brhs	8001730c <bfin_load_buf+0x1a0>
  //  delay = 3000; while (--delay > 0) {;;}
  delay_ms(1);
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017200:	30 0b       	mov	r11,0
80017202:	fe 7c 24 00 	mov	r12,-56320
80017206:	fe b0 dc 7b 	rcall	80012afc <spi_selectChip>

  app_pause();

  bfin_start_transfer();

  for(i=0; i<bfinLdrSize; i++) {
8001720a:	6a 08       	ld.w	r8,r5[0x0]
8001720c:	58 08       	cp.w	r8,0
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001720e:	c2 30       	breq	80017254 <bfin_load_buf+0xe8>
80017210:	30 02       	mov	r2,0
80017212:	30 03       	mov	r3,0
    bfin_transfer_byte(bfinLdrData[i]);
80017214:	e0 61 31 54 	mov	r1,12628
80017218:	62 08       	ld.w	r8,r1[0x0]
8001721a:	04 08       	add	r8,r2
//---------------------------------------------
//------ static function definition

static void bfin_transfer_byte(u8 data) {
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
      print_dbg("\r\n HWAIT asserted..."); 
8001721c:	11 80       	ld.ub	r0,r8[0x0]
8001721e:	c0 48       	rjmp	80017226 <bfin_load_buf+0xba>
80017220:	4c 2c       	lddpc	r12,80017328 <bfin_load_buf+0x1bc>

//---------------------------------------------
//------ static function definition

static void bfin_transfer_byte(u8 data) {
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
80017222:	fe b0 de bd 	rcall	80012f9c <print_dbg>
80017226:	30 5c       	mov	r12,5
80017228:	fe b0 da 60 	rcall	800126e8 <gpio_get_pin_value>
      print_dbg("\r\n HWAIT asserted..."); 
    }
    spi_write(BFIN_SPI, data);
8001722c:	18 94       	mov	r4,r12
8001722e:	cf 91       	brne	80017220 <bfin_load_buf+0xb4>
80017230:	00 9b       	mov	r11,r0
80017232:	fe 7c 24 00 	mov	r12,-56320

  app_pause();

  bfin_start_transfer();

  for(i=0; i<bfinLdrSize; i++) {
80017236:	fe b0 dc f8 	rcall	80012c26 <spi_write>
8001723a:	6a 08       	ld.w	r8,r5[0x0]
8001723c:	30 1a       	mov	r10,1
8001723e:	30 0b       	mov	r11,0
80017240:	10 96       	mov	r6,r8
80017242:	14 02       	add	r2,r10
80017244:	e6 0b 00 43 	adc	r3,r3,r11
80017248:	08 97       	mov	r7,r4
8001724a:	04 36       	cp.w	r6,r2
8001724c:	e6 07 13 00 	cpc	r7,r3
  delay_ms(1);
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
}

void bfin_end_transfer(void) {
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80017250:	fe 9b ff e4 	brhi	80017218 <bfin_load_buf+0xac>
80017254:	30 0b       	mov	r11,0
80017256:	fe 7c 24 00 	mov	r12,-56320
  print_dbg("\r\n done loading; waiting... ");
8001725a:	fe b0 dc 79 	rcall	80012b4c <spi_unselectChip>
8001725e:	4b 4c       	lddpc	r12,8001732c <bfin_load_buf+0x1c0>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80017260:	fe b0 de 9e 	rcall	80012f9c <print_dbg>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80017264:	e1 b7 00 42 	mfsr	r7,0x108
80017268:	e0 6a 14 80 	mov	r10,5248
8001726c:	ea 1a 03 ef 	orh	r10,0x3ef
80017270:	30 0b       	mov	r11,0
80017272:	36 49       	mov	r9,100
80017274:	f4 09 06 48 	mulu.d	r8,r10,r9
80017278:	f6 0a 10 64 	mul	r10,r11,100
8001727c:	30 0b       	mov	r11,0
8001727e:	f4 09 00 09 	add	r9,r10,r9
80017282:	e0 6a 03 e7 	mov	r10,999
80017286:	f0 0a 00 0a 	add	r10,r8,r10
8001728a:	f2 0b 00 4b 	adc	r11,r9,r11
8001728e:	e0 68 03 e8 	mov	r8,1000
80017292:	30 09       	mov	r9,0
80017294:	e0 a0 5e 9f 	rcall	80022fd2 <__avr32_udiv64>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80017298:	ee 0a 00 0a 	add	r10,r7,r10
8001729c:	e1 b8 00 42 	mfsr	r8,0x108
800172a0:	14 37       	cp.w	r7,r10
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800172a2:	e0 8b 00 27 	brhi	800172f0 <bfin_load_buf+0x184>
800172a6:	10 37       	cp.w	r7,r8
800172a8:	e0 8b 00 04 	brhi	800172b0 <bfin_load_buf+0x144>
    bfin_transfer_byte(bfinLdrData[i]);
  }

  bfin_end_transfer();
  
  app_resume();
800172ac:	10 3a       	cp.w	r10,r8
800172ae:	c3 22       	brcc	80017312 <bfin_load_buf+0x1a6>
800172b0:	fe b0 fa 96 	rcall	800167dc <app_resume>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800172b4:	d8 32       	popm	r0-r7,pc
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800172b6:	e1 b8 00 42 	mfsr	r8,0x108
800172ba:	10 39       	cp.w	r9,r8
800172bc:	fe 98 ff fd 	brls	800172b6 <bfin_load_buf+0x14a>
800172c0:	10 3a       	cp.w	r10,r8
800172c2:	fe 93 ff 7c 	brlo	800171ba <bfin_load_buf+0x4e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800172c6:	cf 8b       	rjmp	800172b6 <bfin_load_buf+0x14a>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800172c8:	e1 b9 00 42 	mfsr	r9,0x108
800172cc:	12 38       	cp.w	r8,r9
800172ce:	fe 98 ff fd 	brls	800172c8 <bfin_load_buf+0x15c>
800172d2:	12 3a       	cp.w	r10,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800172d4:	c8 43       	brcs	800171dc <bfin_load_buf+0x70>
800172d6:	cf 9b       	rjmp	800172c8 <bfin_load_buf+0x15c>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800172d8:	e1 b9 00 42 	mfsr	r9,0x108
800172dc:	10 39       	cp.w	r9,r8
800172de:	cf d2       	brcc	800172d8 <bfin_load_buf+0x16c>
800172e0:	08 39       	cp.w	r9,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800172e2:	fe 9b ff 8f 	brhi	80017200 <bfin_load_buf+0x94>
800172e6:	e1 b9 00 42 	mfsr	r9,0x108
800172ea:	cf 9b       	rjmp	800172dc <bfin_load_buf+0x170>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800172ec:	e1 b8 00 42 	mfsr	r8,0x108
800172f0:	10 37       	cp.w	r7,r8
800172f2:	fe 98 ff fd 	brls	800172ec <bfin_load_buf+0x180>
800172f6:	10 3a       	cp.w	r10,r8
800172f8:	cf a2       	brcc	800172ec <bfin_load_buf+0x180>
800172fa:	fe b0 fa 71 	rcall	800167dc <app_resume>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800172fe:	d8 32       	popm	r0-r7,pc
80017300:	e1 b8 00 42 	mfsr	r8,0x108
80017304:	c5 5b       	rjmp	800171ae <bfin_load_buf+0x42>
80017306:	e1 b9 00 42 	mfsr	r9,0x108
8001730a:	c6 4b       	rjmp	800171d2 <bfin_load_buf+0x66>
8001730c:	e1 b9 00 42 	mfsr	r9,0x108
80017310:	c7 2b       	rjmp	800171f4 <bfin_load_buf+0x88>
80017312:	e1 b8 00 42 	mfsr	r8,0x108
// load bfin executable from the RAM buffer
void bfin_load_buf(void) {
  u64 i; /// byte index in .ldr

  if(bfinLdrSize > BFIN_LDR_MAX_BYTES) {
    print_dbg("\r\n bfin load error: size : "); print_dbg_hex(bfinLdrSize);
80017316:	cc 8b       	rjmp	800172a6 <bfin_load_buf+0x13a>
80017318:	48 6c       	lddpc	r12,80017330 <bfin_load_buf+0x1c4>
8001731a:	fe b0 de 41 	rcall	80012f9c <print_dbg>
8001731e:	6a 0c       	ld.w	r12,r5[0x0]
    return;
80017320:	fe b0 de 66 	rcall	80012fec <print_dbg_hex>
80017324:	d8 32       	popm	r0-r7,pc
80017326:	d7 03       	nop
80017328:	80 02       	ld.sh	r2,r0[0x0]
8001732a:	44 14       	lddsp	r4,sp[0x104]
8001732c:	80 02       	ld.sh	r2,r0[0x0]
8001732e:	44 2c       	lddsp	r12,sp[0x108]
80017330:	80 02       	ld.sh	r2,r0[0x0]
80017332:	43 f8       	lddsp	r8,sp[0xfc]

80017334 <ctl_param_change>:
/* static void clear_all_param_dirty(void) { */
/*   memset(paramsDirty, 0, NUM_PARAMS); */
/* } */

// request a parameter change.
extern u8 ctl_param_change(u32 idx, u32 val) {
80017334:	eb cd 40 80 	pushm	r7,lr
// get dirty flag for param idx (inlined in header)
//extern u8 get_param_dirty(u32 idx);

static inline u8 get_param_dirty(u32 idx) {
  //return BITTEST(paramsDirty, idx);
  return paramsDirty[idx] > 0;
80017338:	e0 68 08 90 	mov	r8,2192
8001733c:	30 09       	mov	r9,0
8001733e:	f0 0c 07 0a 	ld.ub	r10,r8[r12]
80017342:	f2 0a 18 00 	cp.b	r10,r9
// request a parameter change.
extern u8 ctl_param_change(u32 idx, u32 val) {
  u32 i;
  if(get_param_dirty(idx)) {
    // search for event with this param idx
    for(i=0; i<evCount; i++) {
80017346:	c1 80       	breq	80017376 <ctl_param_change+0x42>
80017348:	e0 68 07 8c 	mov	r8,1932
8001734c:	70 0e       	ld.w	lr,r8[0x0]
      if(ctlBuf[i].idx == idx) {
8001734e:	58 0e       	cp.w	lr,0
80017350:	c1 10       	breq	80017372 <ctl_param_change+0x3e>
80017352:	e0 67 07 90 	mov	r7,1936
	ctlBuf[i].val.u = val;
	break;
80017356:	0f 88       	ld.ub	r8,r7[0x0]
80017358:	18 38       	cp.w	r8,r12
8001735a:	c2 20       	breq	8001739e <ctl_param_change+0x6a>
8001735c:	ee c9 ff f8 	sub	r9,r7,-8
extern u8 ctl_param_change(u32 idx, u32 val) {
  u32 i;
  if(get_param_dirty(idx)) {
    // search for event with this param idx
    for(i=0; i<evCount; i++) {
      if(ctlBuf[i].idx == idx) {
80017360:	30 08       	mov	r8,0
80017362:	c0 58       	rjmp	8001736c <ctl_param_change+0x38>
80017364:	13 8a       	ld.ub	r10,r9[0x0]
// request a parameter change.
extern u8 ctl_param_change(u32 idx, u32 val) {
  u32 i;
  if(get_param_dirty(idx)) {
    // search for event with this param idx
    for(i=0; i<evCount; i++) {
80017366:	2f 89       	sub	r9,-8
80017368:	18 3a       	cp.w	r10,r12
8001736a:	c1 b0       	breq	800173a0 <ctl_param_change+0x6c>
      ctlBuf[evCount].idx = idx;
      ctlBuf[evCount].val.u = val;
      evCount++; 
      // update dirty flag
      set_param_dirty(idx);
      return 0;
8001736c:	2f f8       	sub	r8,-1
8001736e:	1c 38       	cp.w	r8,lr
      }
    }
    return CTL_REQUEST_OK;
  } else {
    // add a new event
    if(evCount < CTL_BUF_SIZE_1) {
80017370:	cf a3       	brcs	80017364 <ctl_param_change+0x30>
80017372:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80017376:	e0 6a 07 8c 	mov	r10,1932
      ctlBuf[evCount].idx = idx;
8001737a:	74 09       	ld.w	r9,r10[0x0]
8001737c:	59 e9       	cp.w	r9,30
8001737e:	e0 8b 00 17 	brhi	800173ac <ctl_param_change+0x78>
      ctlBuf[evCount].val.u = val;
80017382:	e0 6e 07 90 	mov	lr,1936
80017386:	fc 09 0b 3c 	st.b	lr[r9<<0x3],r12
  //return BITTEST(paramsDirty, idx);
  return paramsDirty[idx] > 0;
}
static void set_param_dirty(u32 idx) {
  //      BITSET(paramsDirty, idx);
  paramsDirty[idx] = 1;
8001738a:	fc 09 00 3e 	add	lr,lr,r9<<0x3
8001738e:	2f f9       	sub	r9,-1
80017390:	9d 1b       	st.w	lr[0x4],r11
80017392:	95 09       	st.w	r10[0x0],r9
extern u8 ctl_param_change(u32 idx, u32 val) {
  u32 i;
  if(get_param_dirty(idx)) {
    // search for event with this param idx
    for(i=0; i<evCount; i++) {
      if(ctlBuf[i].idx == idx) {
80017394:	30 19       	mov	r9,1
	ctlBuf[i].val.u = val;
80017396:	f0 0c 0b 09 	st.b	r8[r12],r9
8001739a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	break;
8001739e:	30 08       	mov	r8,0
800173a0:	ee 08 00 38 	add	r8,r7,r8<<0x3
      }
    }
    return CTL_REQUEST_OK;
  } else {
    // add a new event
    if(evCount < CTL_BUF_SIZE_1) {
800173a4:	30 0c       	mov	r12,0
800173a6:	91 1b       	st.w	r8[0x4],r11
800173a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800173ac:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1

800173b0 <ctl_perform_all_changes>:
800173b0:	eb cd 40 fc 	pushm	r2-r7,lr

// attempt to execute all pending param changes
extern void ctl_perform_all_changes(void) {
  u32 idx, i;
  // execute in FIFO order
  for(i=0; i<evCount; i++) {
800173b4:	e0 64 07 8c 	mov	r4,1932
800173b8:	68 08       	ld.w	r8,r4[0x0]
800173ba:	58 08       	cp.w	r8,0
800173bc:	c1 30       	breq	800173e2 <ctl_perform_all_changes+0x32>
800173be:	30 06       	mov	r6,0
800173c0:	e0 67 07 90 	mov	r7,1936
    idx = ctlBuf[i].idx;
800173c4:	e0 62 08 90 	mov	r2,2192
    bfin_set_param(idx, ctlBuf[i].val.fix);
800173c8:	0c 93       	mov	r3,r6
800173ca:	0f 85       	ld.ub	r5,r7[0x0]
800173cc:	6e 1b       	ld.w	r11,r7[0x4]
  paramsDirty[idx] = 1;

}
// clear dirty flag
static void clear_param_dirty(u32 idx) {
  paramsDirty[idx] = 0;
800173ce:	0a 9c       	mov	r12,r5
800173d0:	c5 0e       	rcall	80017070 <bfin_set_param>

// attempt to execute all pending param changes
extern void ctl_perform_all_changes(void) {
  u32 idx, i;
  // execute in FIFO order
  for(i=0; i<evCount; i++) {
800173d2:	e4 05 0b 03 	st.b	r2[r5],r3
800173d6:	2f f6       	sub	r6,-1
800173d8:	2f 87       	sub	r7,-8
800173da:	68 08       	ld.w	r8,r4[0x0]
800173dc:	0c 38       	cp.w	r8,r6
    idx = ctlBuf[i].idx;
    bfin_set_param(idx, ctlBuf[i].val.fix);
    clear_param_dirty(idx);
  }
  evCount = 0;
800173de:	fe 9b ff f6 	brhi	800173ca <ctl_perform_all_changes+0x1a>
}
800173e2:	30 08       	mov	r8,0
800173e4:	89 08       	st.w	r4[0x0],r8
800173e6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800173ea:	d7 03       	nop

800173ec <init_events>:
// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
800173ec:	e0 6a 09 90 	mov	r10,2448
800173f0:	30 08       	mov	r8,0
  getIdx = 0;
800173f2:	95 08       	st.w	r10[0x0],r8

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
800173f4:	e0 6a 09 94 	mov	r10,2452
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;
800173f8:	10 99       	mov	r9,r8

// The system event queue is a circular array of event records.
static event_t sysEvents[ MAX_EVENTS ];

// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
800173fa:	95 08       	st.w	r10[0x0],r8
800173fc:	e0 68 09 98 	mov	r8,2456
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
80017400:	f0 ca fe 00 	sub	r10,r8,-512
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
80017404:	91 09       	st.w	r8[0x0],r9
80017406:	91 19       	st.w	r8[0x4],r9
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
  }
}
80017408:	2f 88       	sub	r8,-8
8001740a:	14 38       	cp.w	r8,r10
8001740c:	cf c1       	brne	80017404 <init_events+0x18>
8001740e:	5e fc       	retal	r12

80017410 <post_event>:
80017410:	d4 01       	pushm	lr
80017412:	d3 43       	ssrf	0x14
80017414:	e0 69 09 90 	mov	r9,2448
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // increment write idx, posbily wrapping
  saveIndex = putIdx;
  INCR_EVENT_INDEX( putIdx );
80017418:	72 0a       	ld.w	r10,r9[0x0]
8001741a:	f4 c8 ff ff 	sub	r8,r10,-1
8001741e:	93 08       	st.w	r9[0x0],r8
80017420:	e0 48 00 40 	cp.w	r8,64
80017424:	f9 b8 00 00 	moveq	r8,0
80017428:	f3 f8 0a 00 	st.weq	r9[0x0],r8
  if ( putIdx != getIdx  ) {
8001742c:	e0 6b 09 94 	mov	r11,2452
80017430:	76 0b       	ld.w	r11,r11[0x0]
    sysEvents[ putIdx ].eventType = e->eventType;
80017432:	10 3b       	cp.w	r11,r8
80017434:	c0 d0       	breq	8001744e <post_event+0x3e>
80017436:	78 0a       	ld.w	r10,r12[0x0]
80017438:	e0 69 09 98 	mov	r9,2456
    sysEvents[ putIdx ].eventData = e->eventData;
8001743c:	f2 08 09 3a 	st.w	r9[r8<<0x3],r10
80017440:	f2 08 00 38 	add	r8,r9,r8<<0x3
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
    print_dbg("\r\n event queue full!");
  } 

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80017444:	78 19       	ld.w	r9,r12[0x4]
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
80017446:	30 1c       	mov	r12,1
    sysEvents[ putIdx ].eventType = e->eventType;
    sysEvents[ putIdx ].eventData = e->eventData;
    status = true;
  } else {
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
80017448:	91 19       	st.w	r8[0x4],r9
    print_dbg("\r\n event queue full!");
8001744a:	d5 43       	csrf	0x14
8001744c:	d8 02       	popm	pc
8001744e:	93 0a       	st.w	r9[0x0],r10
80017450:	48 3c       	lddpc	r12,8001745c <post_event+0x4c>
  } 

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80017452:	fe b0 dd a5 	rcall	80012f9c <print_dbg>
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
80017456:	30 0c       	mov	r12,0
80017458:	d5 43       	csrf	0x14
8001745a:	d8 02       	popm	pc
8001745c:	80 02       	ld.sh	r2,r0[0x0]
8001745e:	44 90       	lddsp	r0,sp[0x124]

80017460 <get_next_event>:
80017460:	18 99       	mov	r9,r12
80017462:	d3 43       	ssrf	0x14
80017464:	e0 68 09 90 	mov	r8,2448
80017468:	e0 6a 09 94 	mov	r10,2452
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
8001746c:	70 0b       	ld.w	r11,r8[0x0]
8001746e:	74 08       	ld.w	r8,r10[0x0]
    INCR_EVENT_INDEX( getIdx );
80017470:	16 38       	cp.w	r8,r11
80017472:	c1 50       	breq	8001749c <get_next_event+0x3c>
80017474:	2f f8       	sub	r8,-1
80017476:	95 08       	st.w	r10[0x0],r8
80017478:	e0 48 00 40 	cp.w	r8,64
8001747c:	f9 b8 00 00 	moveq	r8,0
    e->eventType = sysEvents[ getIdx ].eventType;
80017480:	f5 f8 0a 00 	st.weq	r10[0x0],r8
    e->eventData = sysEvents[ getIdx ].eventData;
80017484:	e0 6a 09 98 	mov	r10,2456
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
80017488:	f4 08 00 3b 	add	r11,r10,r8<<0x3
    e->eventData = sysEvents[ getIdx ].eventData;
8001748c:	f4 08 03 38 	ld.w	r8,r10[r8<<0x3]
80017490:	99 08       	st.w	r12[0x0],r8
    e->eventType  = 0xff;
    e->eventData = 0;
    status = false;
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80017492:	76 18       	ld.w	r8,r11[0x4]
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
80017494:	99 18       	st.w	r12[0x4],r8
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
    e->eventData = 0;
80017496:	30 1c       	mov	r12,1
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
80017498:	d5 43       	csrf	0x14
8001749a:	5e fc       	retal	r12
    e->eventData = 0;
8001749c:	30 0c       	mov	r12,0
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
8001749e:	e0 68 00 ff 	mov	r8,255
  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
800174a2:	93 1c       	st.w	r9[0x4],r12
800174a4:	93 08       	st.w	r9[0x0],r8
800174a6:	d5 43       	csrf	0x14
800174a8:	5e fc       	retal	r12
800174aa:	d7 03       	nop

800174ac <process_enc>:
    enc[i].thresh = ENC_THRESH_DEFAULT;
  }
}

// apply pin mapping to deteremine movement
void process_enc( const U8 idx) {
800174ac:	eb cd 40 f8 	pushm	r3-r7,lr
  U8 pos;
  
  pos = gpio_get_pin_value(enc[idx].pin[0]) + (gpio_get_pin_value(enc[idx].pin[1]) << 1);
800174b0:	e0 65 2d 18 	mov	r5,11544
800174b4:	f8 0c 00 14 	add	r4,r12,r12<<0x1
800174b8:	ea 04 00 26 	add	r6,r5,r4<<0x2
800174bc:	0c 97       	mov	r7,r6
800174be:	0f 3c       	ld.ub	r12,r7++
800174c0:	fe b0 d9 14 	rcall	800126e8 <gpio_get_pin_value>
800174c4:	18 93       	mov	r3,r12
800174c6:	0f 8c       	ld.ub	r12,r7[0x0]
800174c8:	fe b0 d9 10 	rcall	800126e8 <gpio_get_pin_value>
800174cc:	0d a8       	ld.ub	r8,r6[0x2]
800174ce:	e6 0c 00 13 	add	r3,r3,r12<<0x1
  
  if (pos != enc[idx].pos) {
800174d2:	5c 53       	castu.b	r3
800174d4:	e6 08 18 00 	cp.b	r8,r3
    enc[idx].val -= enc_map[enc[idx].pos][pos];
800174d8:	c0 d0       	breq	800174f2 <process_enc+0x46>
800174da:	2f f4       	sub	r4,-1
800174dc:	e6 08 00 28 	add	r8,r3,r8<<0x2
800174e0:	ea 04 04 29 	ld.sh	r9,r5[r4<<0x2]
800174e4:	48 5a       	lddpc	r10,800174f8 <process_enc+0x4c>
800174e6:	f4 08 06 08 	ld.sb	r8,r10[r8]
800174ea:	10 19       	sub	r9,r8
800174ec:	ea 04 0a 29 	st.h	r5[r4<<0x2],r9
    enc[idx].pos = pos;
800174f0:	ac a3       	st.b	r6[0x2],r3
800174f2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800174f6:	d7 03       	nop
800174f8:	80 02       	ld.sh	r2,r0[0x0]
800174fa:	44 a5       	lddsp	r5,sp[0x128]

800174fc <init_encoders>:
800174fc:	eb cd 40 e0 	pushm	r5-r7,lr

// initialize encoder positions
void init_encoders(void) {
  U8 i;
  // constant data
  enc[0].pin[0] = ENC0_S0_PIN;
80017500:	32 28       	mov	r8,34
80017502:	e0 67 2d 18 	mov	r7,11544
  enc[0].pin[1] = ENC0_S1_PIN;
80017506:	ae 88       	st.b	r7[0x0],r8
80017508:	32 38       	mov	r8,35
  enc[0].event = kEventEncoder0;
8001750a:	ae 98       	st.b	r7[0x1],r8
8001750c:	30 98       	mov	r8,9
  enc[1].pin[0] = ENC1_S0_PIN;
8001750e:	8f 28       	st.w	r7[0x8],r8
80017510:	32 48       	mov	r8,36
80017512:	ef 68 00 0c 	st.b	r7[12],r8
  enc[1].pin[1] = ENC1_S1_PIN;
80017516:	32 58       	mov	r8,37
80017518:	ef 68 00 0d 	st.b	r7[13],r8
  enc[1].event = kEventEncoder1;
8001751c:	30 a8       	mov	r8,10
  enc[2].pin[0] = ENC2_S0_PIN;
8001751e:	8f 58       	st.w	r7[0x14],r8
80017520:	32 68       	mov	r8,38
80017522:	ef 68 00 18 	st.b	r7[24],r8
  enc[2].pin[1] = ENC2_S1_PIN;
80017526:	32 78       	mov	r8,39
80017528:	ef 68 00 19 	st.b	r7[25],r8
  enc[2].event = kEventEncoder2;
8001752c:	30 b8       	mov	r8,11
  enc[3].pin[0] = ENC3_S0_PIN;
8001752e:	8f 88       	st.w	r7[0x20],r8
80017530:	32 88       	mov	r8,40
80017532:	ef 68 00 24 	st.b	r7[36],r8
  enc[3].pin[1] = ENC3_S1_PIN;
80017536:	32 98       	mov	r8,41
80017538:	ef 68 00 25 	st.b	r7[37],r8
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
8001753c:	30 c8       	mov	r8,12
  enc[2].pin[0] = ENC2_S0_PIN;
  enc[2].pin[1] = ENC2_S1_PIN;
  enc[2].event = kEventEncoder2;
  enc[3].pin[0] = ENC3_S0_PIN;
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
8001753e:	32 2c       	mov	r12,34
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80017540:	8f b8       	st.w	r7[0x2c],r8
80017542:	fe b0 d8 d3 	rcall	800126e8 <gpio_get_pin_value>
80017546:	18 96       	mov	r6,r12
80017548:	0f 9c       	ld.ub	r12,r7[0x1]
8001754a:	fe b0 d8 cf 	rcall	800126e8 <gpio_get_pin_value>
8001754e:	ec 0c 00 1c 	add	r12,r6,r12<<0x1
80017552:	30 06       	mov	r6,0
    enc[i].thresh = ENC_THRESH_DEFAULT;
80017554:	ae ac       	st.b	r7[0x2],r12
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80017556:	ae 36       	st.h	r7[0x6],r6
80017558:	ef 3c 00 0c 	ld.ub	r12,r7[12]
8001755c:	fe b0 d8 c6 	rcall	800126e8 <gpio_get_pin_value>
80017560:	18 95       	mov	r5,r12
80017562:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80017566:	fe b0 d8 c1 	rcall	800126e8 <gpio_get_pin_value>
8001756a:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
    enc[i].thresh = ENC_THRESH_DEFAULT;
8001756e:	ef 56 00 12 	st.h	r7[18],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80017572:	ef 6c 00 0e 	st.b	r7[14],r12
80017576:	ef 3c 00 18 	ld.ub	r12,r7[24]
8001757a:	fe b0 d8 b7 	rcall	800126e8 <gpio_get_pin_value>
8001757e:	18 95       	mov	r5,r12
80017580:	ef 3c 00 19 	ld.ub	r12,r7[25]
80017584:	fe b0 d8 b2 	rcall	800126e8 <gpio_get_pin_value>
80017588:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
    enc[i].thresh = ENC_THRESH_DEFAULT;
8001758c:	ef 56 00 1e 	st.h	r7[30],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80017590:	ef 6c 00 1a 	st.b	r7[26],r12
80017594:	ef 3c 00 24 	ld.ub	r12,r7[36]
80017598:	fe b0 d8 a8 	rcall	800126e8 <gpio_get_pin_value>
8001759c:	18 95       	mov	r5,r12
8001759e:	ef 3c 00 25 	ld.ub	r12,r7[37]
800175a2:	fe b0 d8 a3 	rcall	800126e8 <gpio_get_pin_value>
    enc[i].thresh = ENC_THRESH_DEFAULT;
800175a6:	ef 56 00 2a 	st.h	r7[42],r6
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
800175aa:	ea 0c 00 1c 	add	r12,r5,r12<<0x1
800175ae:	ef 6c 00 26 	st.b	r7[38],r12
    enc[i].thresh = ENC_THRESH_DEFAULT;
  }
}
800175b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800175b6:	d7 03       	nop

800175b8 <fat_init>:


//=========
// extern

int fat_init(void) {
800175b8:	eb cd 40 80 	pushm	r7,lr
  // Initialise File IO Library
  print_dbg("\r\n beginning FAT library init.");
800175bc:	48 ec       	lddpc	r12,800175f4 <fat_init+0x3c>
800175be:	fe b0 dc ef 	rcall	80012f9c <print_dbg>
  fl_init();
800175c2:	e0 a0 23 3d 	rcall	8001bc3c <fl_init>
  print_dbg("\r\n finished FAT library init.");
800175c6:	48 dc       	lddpc	r12,800175f8 <fat_init+0x40>
800175c8:	fe b0 dc ea 	rcall	80012f9c <print_dbg>
  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
800175cc:	fe cb ff c8 	sub	r11,pc,-56
800175d0:	fe cc ff 64 	sub	r12,pc,-156
800175d4:	e0 a0 26 d8 	rcall	8001c384 <fl_attach_media>
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
    return 1;
  } else {
    print_dbg("\r\n attached media access functions to fat_io_lib");
800175d8:	18 97       	mov	r7,r12
800175da:	c0 71       	brne	800175e8 <fat_init+0x30>
800175dc:	48 8c       	lddpc	r12,800175fc <fat_init+0x44>
800175de:	fe b0 dc df 	rcall	80012f9c <print_dbg>
    return 0;
  }
}
800175e2:	0e 9c       	mov	r12,r7
  print_dbg("\r\n beginning FAT library init.");
  fl_init();
  print_dbg("\r\n finished FAT library init.");
  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
800175e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800175e8:	48 6c       	lddpc	r12,80017600 <fat_init+0x48>
800175ea:	fe b0 dc d9 	rcall	80012f9c <print_dbg>
800175ee:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800175f2:	d7 03       	nop
800175f4:	80 02       	ld.sh	r2,r0[0x0]
800175f6:	44 b8       	lddsp	r8,sp[0x12c]
800175f8:	80 02       	ld.sh	r2,r0[0x0]
800175fa:	44 d8       	lddsp	r8,sp[0x134]
800175fc:	80 02       	ld.sh	r2,r0[0x0]
800175fe:	45 34       	lddsp	r4,sp[0x14c]
80017600:	80 02       	ld.sh	r2,r0[0x0]
80017602:	44 f8       	lddsp	r8,sp[0x13c]

80017604 <media_write>:
80017604:	eb cd 40 f8 	pushm	r3-r7,lr
80017608:	16 97       	mov	r7,r11
8001760a:	14 94       	mov	r4,r10
8001760c:	18 93       	mov	r3,r12
8001760e:	fe b0 de 05 	rcall	80013218 <sd_mmc_spi_write_open>
80017612:	18 96       	mov	r6,r12
  // PDCA write isn't implemented in ASF... 
  // for the moment use slower blocking write.

  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
80017614:	c1 e0       	breq	80017650 <media_write+0x4c>
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
80017616:	58 04       	cp.w	r4,0
80017618:	c1 80       	breq	80017648 <media_write+0x44>
  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
8001761a:	30 06       	mov	r6,0
8001761c:	c0 48       	rjmp	80017624 <media_write+0x20>
  }

  for (i=0;i<sector_count;i++) {
8001761e:	0c 34       	cp.w	r4,r6
80017620:	e0 88 00 14 	brls	80017648 <media_write+0x44>
  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
80017624:	ec 03 00 05 	add	r5,r6,r3
  }

  for (i=0;i<sector_count;i++) {
    status = sd_mmc_spi_write_sector_from_ram(buffer);
80017628:	0e 9c       	mov	r12,r7
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
8001762a:	2f f6       	sub	r6,-1
      print_dbg("\r\n error writing sd_mmc_spi, sector: ");
      print_dbg_hex(sector);
    }
    //////////////
    sector++;
    buffer += 512;
8001762c:	ee c7 fe 00 	sub	r7,r7,-512
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
    status = sd_mmc_spi_write_sector_from_ram(buffer);
80017630:	fe b0 e0 0e 	rcall	8001364c <sd_mmc_spi_write_sector_from_ram>
    /////////// dbg
    if(status == false) {
80017634:	cf 51       	brne	8001761e <media_write+0x1a>
      print_dbg("\r\n error writing sd_mmc_spi, sector: ");
80017636:	48 cc       	lddpc	r12,80017664 <media_write+0x60>
80017638:	fe b0 dc b2 	rcall	80012f9c <print_dbg>
      print_dbg_hex(sector);
8001763c:	0a 9c       	mov	r12,r5
8001763e:	fe b0 dc d7 	rcall	80012fec <print_dbg_hex>
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
    print_dbg_hex(sector);
    return 0;
  }

  for (i=0;i<sector_count;i++) {
80017642:	0c 34       	cp.w	r4,r6
80017644:	fe 9b ff f0 	brhi	80017624 <media_write+0x20>
    }
    //////////////
    sector++;
    buffer += 512;
  }
  sd_mmc_spi_write_close();
80017648:	fe b0 dd 92 	rcall	8001316c <sd_mmc_spi_write_close>
8001764c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
  // for the moment use slower blocking write.

  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
80017650:	48 6c       	lddpc	r12,80017668 <media_write+0x64>
80017652:	fe b0 dc a5 	rcall	80012f9c <print_dbg>
    print_dbg_hex(sector);
80017656:	06 9c       	mov	r12,r3
80017658:	fe b0 dc ca 	rcall	80012fec <print_dbg_hex>
8001765c:	0c 9c       	mov	r12,r6
    return 0;
8001765e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80017662:	d7 03       	nop
80017664:	80 02       	ld.sh	r2,r0[0x0]
80017666:	45 90       	lddsp	r0,sp[0x164]
80017668:	80 02       	ld.sh	r2,r0[0x0]
8001766a:	45 68       	lddsp	r8,sp[0x158]

8001766c <media_read>:
8001766c:	d4 31       	pushm	r0-r7,lr
8001766e:	18 94       	mov	r4,r12
80017670:	16 97       	mov	r7,r11
80017672:	14 91       	mov	r1,r10
80017674:	58 0a       	cp.w	r10,0
80017676:	c5 30       	breq	8001771c <media_read+0xb0>
80017678:	30 03       	mov	r3,0
8001767a:	e0 66 2f 54 	mov	r6,12116
8001767e:	e0 65 2d 4c 	mov	r5,11596
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_RX,
80017682:	30 10       	mov	r0,1
80017684:	06 92       	mov	r2,r3
80017686:	e0 6a 02 00 	mov	r10,512
8001768a:	e0 6b 2f 54 	mov	r11,12116
		       &pdcaRxBuf,
		       FS_BUF_SIZE);
    
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_TX,
8001768e:	30 0c       	mov	r12,0
80017690:	fe b0 d9 97 	rcall	800129be <pdca_load_channel>
80017694:	30 1c       	mov	r12,1
80017696:	e0 6a 02 00 	mov	r10,512
		       (void *)&pdcaTxBuf,
		       FS_BUF_SIZE); //send dummy to activate the clock
    
    fsEndTransfer = false;
    
    if(sd_mmc_spi_read_open_PDCA (sector)) {
8001769a:	e0 6b 2d 54 	mov	r11,11604
8001769e:	fe b0 d9 90 	rcall	800129be <pdca_load_channel>
800176a2:	08 9c       	mov	r12,r4

      spi_write(SD_MMC_SPI,0xFF); // dummy byte synchronizes transfer
800176a4:	aa 82       	st.b	r5[0x0],r2
800176a6:	fe b0 df 0d 	rcall	800134c0 <sd_mmc_spi_read_open_PDCA>
800176aa:	c2 f0       	breq	80017708 <media_read+0x9c>
800176ac:	e0 6b 00 ff 	mov	r11,255

      pdca_enable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
800176b0:	fe 7c 28 00 	mov	r12,-55296
800176b4:	fe b0 da b9 	rcall	80012c26 <spi_write>
      pdcaRxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_RX);
800176b8:	30 0c       	mov	r12,0
800176ba:	fe b0 d9 5e 	rcall	80012976 <pdca_enable_interrupt_transfer_complete>
800176be:	30 0c       	mov	r12,0
      pdcaTxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_TX);
800176c0:	fe b0 d9 42 	rcall	80012944 <pdca_get_handler>
800176c4:	e0 63 2d 48 	mov	r3,11592
800176c8:	87 0c       	st.w	r3[0x0],r12
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
800176ca:	30 1c       	mov	r12,1
800176cc:	fe b0 d9 3c 	rcall	80012944 <pdca_get_handler>
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
800176d0:	e0 68 2d 50 	mov	r8,11600
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
800176d4:	91 0c       	st.w	r8[0x0],r12
800176d6:	66 09       	ld.w	r9,r3[0x0]
800176d8:	93 50       	st.w	r9[0x14],r0
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
800176da:	70 08       	ld.w	r8,r8[0x0]
800176dc:	91 50       	st.w	r8[0x14],r0
800176de:	0b 88       	ld.ub	r8,r5[0x0]
800176e0:	58 08       	cp.w	r8,0
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
800176e2:	cf e0       	breq	800176de <media_read+0x72>
800176e4:	30 08       	mov	r8,0
800176e6:	ec 08 07 09 	ld.ub	r9,r6[r8]
800176ea:	ee 08 0b 09 	st.b	r7[r8],r9
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
800176ee:	2f f8       	sub	r8,-1
800176f0:	e0 48 02 00 	cp.w	r8,512
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
      print_dbg_ulong(sector);
    }
    sector ++;
800176f4:	cf 91       	brne	800176e6 <media_read+0x7a>
    buffer += FS_BUF_SIZE;
800176f6:	e0 63 02 01 	mov	r3,513
800176fa:	06 31       	cp.w	r1,r3
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
800176fc:	e0 88 00 10 	brls	8001771c <media_read+0xb0>
80017700:	2f f4       	sub	r4,-1
      print_dbg_ulong(sector);
80017702:	ee c7 fe 00 	sub	r7,r7,-512
80017706:	cc 0b       	rjmp	80017686 <media_read+0x1a>
80017708:	48 6c       	lddpc	r12,80017720 <media_read+0xb4>
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
8001770a:	fe b0 dc 49 	rcall	80012f9c <print_dbg>
8001770e:	2f f3       	sub	r3,-1
    }
    sector ++;
    buffer += FS_BUF_SIZE;
  }
  return 1;
}
80017710:	08 9c       	mov	r12,r4
80017712:	fe b0 dc 4b 	rcall	80012fa8 <print_dbg_ulong>
80017716:	06 31       	cp.w	r1,r3
80017718:	fe 9b ff f4 	brhi	80017700 <media_read+0x94>
8001771c:	da 3a       	popm	r0-r7,pc,r12=1
8001771e:	d7 03       	nop
80017720:	80 02       	ld.sh	r2,r0[0x0]
80017722:	45 b8       	lddsp	r8,sp[0x16c]

80017724 <flash_clear_firstrun>:
extern void flash_write_firstrun(void) {
  flashc_memset32((void*)&(flash_nvram_data.firstRun), FIRSTRUN_MAGIC, 4, true);
}

// clear firstrun status
extern void flash_clear_firstrun(void) {
80017724:	d4 01       	pushm	lr
  flashc_memset32((void*)&(flash_nvram_data.firstRun), 0x00000000, 4, true);
80017726:	30 19       	mov	r9,1
80017728:	30 4a       	mov	r10,4
8001772a:	30 0b       	mov	r11,0
8001772c:	48 2c       	lddpc	r12,80017734 <flash_clear_firstrun+0x10>
8001772e:	fe b0 d7 c5 	rcall	800126b8 <flashc_memset32>
}
80017732:	d8 02       	popm	pc
80017734:	80 04       	ld.sh	r4,r0[0x0]
	...

80017738 <flash_write_firstrun>:
80017738:	d4 01       	pushm	lr
8001773a:	30 19       	mov	r9,1
  return (flash_nvram_data.firstRun == FIRSTRUN_MAGIC);
}

// write firstrun status
extern void flash_write_firstrun(void) {
  flashc_memset32((void*)&(flash_nvram_data.firstRun), FIRSTRUN_MAGIC, 4, true);
8001773c:	30 4a       	mov	r10,4
8001773e:	e0 6b 32 10 	mov	r11,12816
80017742:	ea 1b 76 54 	orh	r11,0x7654
80017746:	48 3c       	lddpc	r12,80017750 <flash_write_firstrun+0x18>
80017748:	fe b0 d7 b8 	rcall	800126b8 <flashc_memset32>
}
8001774c:	d8 02       	popm	pc
8001774e:	d7 03       	nop
80017750:	80 04       	ld.sh	r4,r0[0x0]
	...

80017754 <flash_write_ldr>:
80017754:	eb cd 40 fe 	pushm	r1-r7,lr
void flash_write_ldr(void) {
  //  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
  //  flashc_memcpy((void*)&(flash_nvram_data.ldrData), (const void*)bfinLdrData, bfinLdrSize, true);
  // seeing some missing pages, so try writing one page at a time
  u32 i;
  u32 nPages = bfinLdrSize / 0x200;
80017758:	e0 61 0b 98 	mov	r1,2968
8001775c:	30 4a       	mov	r10,4
  u32 rem;
  const u8* pSrc;
  u8* pDst;
  // write size
  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
8001775e:	62 07       	ld.w	r7,r1[0x0]
void flash_write_ldr(void) {
  //  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
  //  flashc_memcpy((void*)&(flash_nvram_data.ldrData), (const void*)bfinLdrData, bfinLdrSize, true);
  // seeing some missing pages, so try writing one page at a time
  u32 i;
  u32 nPages = bfinLdrSize / 0x200;
80017760:	4a a6       	lddpc	r6,80017808 <flash_write_ldr+0xb4>
  u32 rem;
  const u8* pSrc;
  u8* pDst;
  // write size
  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
80017762:	a9 97       	lsr	r7,0x9
80017764:	62 0b       	ld.w	r11,r1[0x0]
80017766:	30 19       	mov	r9,1
80017768:	ec 0a 00 0c 	add	r12,r6,r10
8001776c:	fe b0 d7 a6 	rcall	800126b8 <flashc_memset32>
  // write data 
  pSrc = (const void*)bfinLdrData;
80017770:	e0 68 31 54 	mov	r8,12628
  pDst = (void*)&(flash_nvram_data.ldrData);
  for(i=0; i<nPages; i++) {
80017774:	70 02       	ld.w	r2,r8[0x0]
80017776:	58 07       	cp.w	r7,0
80017778:	c4 60       	breq	80017804 <flash_write_ldr+0xb0>
8001777a:	e0 68 03 e8 	mov	r8,1000
8001777e:	30 09       	mov	r9,0
80017780:	e0 6a 18 67 	mov	r10,6247
80017784:	ea 1a 03 ef 	orh	r10,0x3ef
80017788:	30 0b       	mov	r11,0
8001778a:	2b 86       	sub	r6,-72
8001778c:	e0 a0 5c 23 	rcall	80022fd2 <__avr32_udiv64>
80017790:	04 95       	mov	r5,r2
    flashc_memcpy((void*)pDst, (const void*)pSrc, 0x200, true);
80017792:	14 93       	mov	r3,r10
80017794:	30 04       	mov	r4,0
80017796:	30 19       	mov	r9,1
80017798:	0a 9b       	mov	r11,r5
8001779a:	e0 6a 02 00 	mov	r10,512
    pDst += 0x200;
    pSrc += 0x200;
8001779e:	0c 9c       	mov	r12,r6
  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
  // write data 
  pSrc = (const void*)bfinLdrData;
  pDst = (void*)&(flash_nvram_data.ldrData);
  for(i=0; i<nPages; i++) {
    flashc_memcpy((void*)pDst, (const void*)pSrc, 0x200, true);
800177a0:	ea c5 fe 00 	sub	r5,r5,-512
    pDst += 0x200;
800177a4:	fe b0 d4 ac 	rcall	800120fc <flashc_memcpy>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800177a8:	ec c6 fe 00 	sub	r6,r6,-512
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800177ac:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800177b0:	f2 03 00 0a 	add	r10,r9,r3
800177b4:	e1 b8 00 42 	mfsr	r8,0x108
800177b8:	14 39       	cp.w	r9,r10
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800177ba:	e0 8b 00 1a 	brhi	800177ee <flash_write_ldr+0x9a>
800177be:	12 38       	cp.w	r8,r9
800177c0:	c0 83       	brcs	800177d0 <flash_write_ldr+0x7c>
800177c2:	14 38       	cp.w	r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800177c4:	e0 8b 00 06 	brhi	800177d0 <flash_write_ldr+0x7c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800177c8:	e1 b8 00 42 	mfsr	r8,0x108
  // write size
  flashc_memset32((void*)&(flash_nvram_data.ldrSize), bfinLdrSize, 4, true);
  // write data 
  pSrc = (const void*)bfinLdrData;
  pDst = (void*)&(flash_nvram_data.ldrData);
  for(i=0; i<nPages; i++) {
800177cc:	12 38       	cp.w	r8,r9
800177ce:	cf a2       	brcc	800177c2 <flash_write_ldr+0x6e>
800177d0:	2f f4       	sub	r4,-1
800177d2:	08 37       	cp.w	r7,r4
800177d4:	fe 9b ff e1 	brhi	80017796 <flash_write_ldr+0x42>
    pDst += 0x200;
    pSrc += 0x200;
    delay_ms(1);
  }
  // remaining bytes
  rem = bfinLdrSize - (nPages * 0x200);
800177d8:	a9 77       	lsl	r7,0x9
  flashc_memcpy((void*)pDst, (const void*)pSrc, rem, true);
800177da:	0e 02       	add	r2,r7
800177dc:	62 0a       	ld.w	r10,r1[0x0]
800177de:	04 9b       	mov	r11,r2
800177e0:	0e 1a       	sub	r10,r7
800177e2:	0c 9c       	mov	r12,r6
800177e4:	30 19       	mov	r9,1
}
800177e6:	fe b0 d4 8b 	rcall	800120fc <flashc_memcpy>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800177ea:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800177ee:	10 39       	cp.w	r9,r8
800177f0:	e0 88 00 04 	brls	800177f8 <flash_write_ldr+0xa4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800177f4:	10 3a       	cp.w	r10,r8
800177f6:	ce d3       	brcs	800177d0 <flash_write_ldr+0x7c>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800177f8:	e1 b8 00 42 	mfsr	r8,0x108
800177fc:	10 39       	cp.w	r9,r8
800177fe:	fe 98 ff fd 	brls	800177f8 <flash_write_ldr+0xa4>
80017802:	cf 9b       	rjmp	800177f4 <flash_write_ldr+0xa0>
80017804:	2b 86       	sub	r6,-72
80017806:	ce bb       	rjmp	800177dc <flash_write_ldr+0x88>
80017808:	80 04       	ld.sh	r4,r0[0x0]
	...

8001780c <flash_read_ldr>:
8001780c:	eb cd 40 c0 	pushm	r6-r7,lr
80017810:	48 b6       	lddpc	r6,8001783c <flash_read_ldr+0x30>
80017812:	6c 18       	ld.w	r8,r6[0x4]
80017814:	e0 67 0b 98 	mov	r7,2968
80017818:	48 ac       	lddpc	r12,80017840 <flash_read_ldr+0x34>
8001781a:	8f 08       	st.w	r7[0x0],r8
}

// read default blackfin
void flash_read_ldr(void) {
  bfinLdrSize = flash_nvram_data.ldrSize;
  print_dbg("\r\n read ldrSize from flash: ");
8001781c:	fe b0 db c0 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(bfinLdrSize);
80017820:	6e 0c       	ld.w	r12,r7[0x0]
80017822:	fe b0 db c3 	rcall	80012fa8 <print_dbg_ulong>
  memcpy((void*)bfinLdrData, (void*)flash_nvram_data.ldrData, bfinLdrSize); 
80017826:	e0 68 31 54 	mov	r8,12628
8001782a:	ec cb ff b8 	sub	r11,r6,-72
8001782e:	6e 0a       	ld.w	r10,r7[0x0]
80017830:	70 0c       	ld.w	r12,r8[0x0]
  //  print_flash((u32)flash_nvram_data.ldrData, bfinLdrSize);
}
80017832:	e0 a0 5f 47 	rcall	800236c0 <memcpy>
80017836:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001783a:	d7 03       	nop
8001783c:	80 04       	ld.sh	r4,r0[0x0]
8001783e:	00 00       	add	r0,r0
80017840:	80 02       	ld.sh	r2,r0[0x0]
80017842:	45 dc       	lddsp	r12,sp[0x174]

80017844 <init_flash>:
80017844:	d4 01       	pushm	lr
80017846:	49 5c       	lddpc	r12,80017898 <init_flash+0x54>
80017848:	fe b0 db aa 	rcall	80012f9c <print_dbg>
8001784c:	e0 7c 00 00 	mov	r12,65536
80017850:	e0 a0 05 ca 	rcall	800183e4 <alloc_mem>
  u32 i;

  print_dbg("\r\n init flash... ");

  // allocate bfin loader buf
  bfinLdrData = alloc_mem(BFIN_LDR_MAX_BYTES);
80017854:	e0 6a 31 54 	mov	r10,12628
80017858:	30 08       	mov	r8,0
  for(i=0; i<BFIN_LDR_MAX_BYTES; i++) { bfinLdrData[i] = 0; }
8001785a:	95 0c       	st.w	r10[0x0],r12
8001785c:	10 99       	mov	r9,r8
8001785e:	c0 28       	rjmp	80017862 <init_flash+0x1e>
80017860:	74 0c       	ld.w	r12,r10[0x0]
80017862:	10 0c       	add	r12,r8
80017864:	b8 89       	st.b	r12[0x0],r9
80017866:	2f f8       	sub	r8,-1
80017868:	e0 58 00 00 	cp.w	r8,65536

  if(flash_nvram_data.firstRun != FIRSTRUN_MAGIC) {
8001786c:	cf a1       	brne	80017860 <init_flash+0x1c>
8001786e:	48 cc       	lddpc	r12,8001789c <init_flash+0x58>
80017870:	e0 69 32 10 	mov	r9,12816
80017874:	ea 19 76 54 	orh	r9,0x7654
80017878:	78 08       	ld.w	r8,r12[0x0]
8001787a:	12 38       	cp.w	r8,r9
    // set size=0 so we won't attempt unitialized bfin load on next start
    bfinLdrSize = 0;
8001787c:	c0 c0       	breq	80017894 <init_flash+0x50>
8001787e:	30 08       	mov	r8,0
    flashc_memset32((void*)&(flash_nvram_data.ldrSize), 0x00000000, 4, true);
80017880:	e0 69 0b 98 	mov	r9,2968
80017884:	10 9b       	mov	r11,r8
80017886:	93 08       	st.w	r9[0x0],r8
80017888:	30 4a       	mov	r10,4
8001788a:	30 19       	mov	r9,1
8001788c:	2f cc       	sub	r12,-4
8001788e:	fe b0 d7 15 	rcall	800126b8 <flashc_memset32>

  // allocate bfin loader buf
  bfinLdrData = alloc_mem(BFIN_LDR_MAX_BYTES);
  for(i=0; i<BFIN_LDR_MAX_BYTES; i++) { bfinLdrData[i] = 0; }

  if(flash_nvram_data.firstRun != FIRSTRUN_MAGIC) {
80017892:	da 0a       	popm	pc,r12=1
80017894:	d8 0a       	popm	pc,r12=0
80017896:	d7 03       	nop
80017898:	80 02       	ld.sh	r2,r0[0x0]
8001789a:	45 fc       	lddsp	r12,sp[0x17c]
8001789c:	80 04       	ld.sh	r4,r0[0x0]
	...

800178a0 <font_glyph>:

// render single glyph to a flat buffer (1byte = 1px)
// given pointer to buffer, pixel offset, row length,
// foreground and background colors
// return columns used
extern u8* font_glyph(char ch, u8* buf, u8 w, u8 a, u8 b) {
800178a0:	d4 21       	pushm	r4-r7,lr
  u8 i=0;
  u8 j;
  u8 * p = buf;
  const glyph_t* gl = &(font_data[ch - FONT_ASCII_OFFSET]);
800178a2:	22 0c       	sub	r12,32
800178a4:	4b fe       	lddpc	lr,800179a0 <font_glyph+0x100>
800178a6:	fc 0c 00 3e 	add	lr,lr,r12<<0x3
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
800178aa:	1d 86       	ld.ub	r6,lr[0x0]
800178ac:	1d 9c       	ld.ub	r12,lr[0x1]
800178ae:	ec 05 11 00 	rsub	r5,r6,0
800178b2:	18 15       	sub	r5,r12
800178b4:	2f a5       	sub	r5,-6
800178b6:	5c 55       	castu.b	r5
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
800178b8:	c7 20       	breq	8001799c <font_glyph+0xfc>
800178ba:	16 9c       	mov	r12,r11
800178bc:	30 07       	mov	r7,0
800178be:	c0 28       	rjmp	800178c2 <font_glyph+0x22>
800178c0:	1d 86       	ld.ub	r6,lr[0x0]
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
800178c2:	fc 06 00 06 	add	r6,lr,r6
800178c6:	0e 06       	add	r6,r7
800178c8:	0d a6       	ld.ub	r6,r6[0x2]
800178ca:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800178ce:	f2 06 17 10 	movne	r6,r9
800178d2:	f0 06 17 00 	moveq	r6,r8
800178d6:	b8 86       	st.b	r12[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
800178d8:	f8 0a 00 04 	add	r4,r12,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
800178dc:	1d 86       	ld.ub	r6,lr[0x0]
800178de:	fc 07 00 0c 	add	r12,lr,r7
800178e2:	f8 06 00 06 	add	r6,r12,r6
800178e6:	0d a6       	ld.ub	r6,r6[0x2]
800178e8:	e2 16 00 02 	andl	r6,0x2,COH
800178ec:	f2 06 17 10 	movne	r6,r9
800178f0:	f0 06 17 00 	moveq	r6,r8
800178f4:	a8 86       	st.b	r4[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
800178f6:	14 04       	add	r4,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
800178f8:	1d 86       	ld.ub	r6,lr[0x0]
800178fa:	f8 06 00 06 	add	r6,r12,r6
800178fe:	0d a6       	ld.ub	r6,r6[0x2]
80017900:	e2 16 00 04 	andl	r6,0x4,COH
80017904:	f2 06 17 10 	movne	r6,r9
80017908:	f0 06 17 00 	moveq	r6,r8
8001790c:	a8 86       	st.b	r4[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
8001790e:	14 04       	add	r4,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017910:	1d 86       	ld.ub	r6,lr[0x0]
80017912:	f8 06 00 06 	add	r6,r12,r6
80017916:	0d a6       	ld.ub	r6,r6[0x2]
80017918:	e2 16 00 08 	andl	r6,0x8,COH
8001791c:	f2 06 17 10 	movne	r6,r9
80017920:	f0 06 17 00 	moveq	r6,r8
80017924:	a8 86       	st.b	r4[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017926:	14 04       	add	r4,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017928:	1d 86       	ld.ub	r6,lr[0x0]
8001792a:	f8 06 00 06 	add	r6,r12,r6
8001792e:	0d a6       	ld.ub	r6,r6[0x2]
80017930:	e2 16 00 10 	andl	r6,0x10,COH
80017934:	f2 06 17 10 	movne	r6,r9
80017938:	f0 06 17 00 	moveq	r6,r8
8001793c:	a8 86       	st.b	r4[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
8001793e:	14 04       	add	r4,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017940:	1d 86       	ld.ub	r6,lr[0x0]
80017942:	f8 06 00 06 	add	r6,r12,r6
80017946:	0d a6       	ld.ub	r6,r6[0x2]
80017948:	e2 16 00 20 	andl	r6,0x20,COH
8001794c:	f2 06 17 10 	movne	r6,r9
80017950:	f0 06 17 00 	moveq	r6,r8
80017954:	a8 86       	st.b	r4[0x0],r6
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017956:	14 04       	add	r4,r10
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017958:	1d 86       	ld.ub	r6,lr[0x0]
8001795a:	f8 06 00 06 	add	r6,r12,r6
8001795e:	0d a6       	ld.ub	r6,r6[0x2]
80017960:	e2 16 00 40 	andl	r6,0x40,COH
80017964:	f2 06 17 10 	movne	r6,r9
80017968:	f0 06 17 00 	moveq	r6,r8
8001796c:	a8 86       	st.b	r4[0x0],r6
8001796e:	1d 86       	ld.ub	r6,lr[0x0]
80017970:	0c 0c       	add	r12,r6
80017972:	19 ac       	ld.ub	r12,r12[0x2]
80017974:	e2 1c 00 80 	andl	r12,0x80,COH
80017978:	f2 0c 17 10 	movne	r12,r9
8001797c:	f0 0c 17 00 	moveq	r12,r8
80017980:	e8 0a 0b 0c 	st.b	r4[r10],r12
    }
    // print_dbg("\r\n");
    // increment column count
    i++;
    // reset pointer to row
    p = buf + i;
80017984:	0e 9c       	mov	r12,r7
80017986:	2f f7       	sub	r7,-1
80017988:	2f fc       	sub	r12,-1
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
8001798a:	0e 96       	mov	r6,r7
    }
    // print_dbg("\r\n");
    // increment column count
    i++;
    // reset pointer to row
    p = buf + i;
8001798c:	5c 5c       	castu.b	r12
8001798e:	f6 0c 00 0c 	add	r12,r11,r12
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
80017992:	ee 05 18 00 	cp.b	r5,r7
80017996:	fe 9b ff 95 	brhi	800178c0 <font_glyph+0x20>
    i++;
    // reset pointer to row
    p = buf + i;
  }
  return p;
}
8001799a:	d8 22       	popm	r4-r7,pc
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
8001799c:	16 9c       	mov	r12,r11
8001799e:	cf eb       	rjmp	8001799a <font_glyph+0xfa>
800179a0:	80 02       	ld.sh	r2,r0[0x0]
800179a2:	46 0e       	lddsp	lr,sp[0x180]

800179a4 <font_string>:
  return p;
}


// render a string of packed glyphs to a buffer
u8* font_string(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
800179a4:	eb cd 40 fe 	pushm	r1-r7,lr
800179a8:	40 8e       	lddsp	lr,sp[0x20]
  // u32 x = 0;  // columns processed
  // u32 off = 0; // offset
  u8* max = buf + size;
800179aa:	f6 0a 00 03 	add	r3,r11,r10
  while (buf < max) {
800179ae:	06 3b       	cp.w	r11,r3
800179b0:	e0 82 00 8c 	brhs	80017ac8 <font_string+0x124>
    if (*str == 0) {
800179b4:	19 8a       	ld.ub	r10,r12[0x0]
800179b6:	58 0a       	cp.w	r10,0
800179b8:	e0 80 00 88 	breq	80017ac8 <font_string+0x124>
800179bc:	4c 52       	lddpc	r2,80017ad0 <font_string+0x12c>
// return columns used
extern u8* font_glyph(char ch, u8* buf, u8 w, u8 a, u8 b) {
  u8 i=0;
  u8 j;
  u8 * p = buf;
  const glyph_t* gl = &(font_data[ch - FONT_ASCII_OFFSET]);
800179be:	22 0a       	sub	r10,32
800179c0:	e4 0a 00 3a 	add	r10,r2,r10<<0x3
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
800179c4:	15 85       	ld.ub	r5,r10[0x0]
800179c6:	15 97       	ld.ub	r7,r10[0x1]
800179c8:	ea 04 11 00 	rsub	r4,r5,0
800179cc:	0e 14       	sub	r4,r7
800179ce:	2f a4       	sub	r4,-6
800179d0:	5c 54       	castu.b	r4
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
800179d2:	c7 20       	breq	80017ab6 <font_string+0x112>
800179d4:	16 97       	mov	r7,r11
800179d6:	30 06       	mov	r6,0
800179d8:	c0 28       	rjmp	800179dc <font_string+0x38>
800179da:	15 85       	ld.ub	r5,r10[0x0]
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
800179dc:	f4 05 00 05 	add	r5,r10,r5
800179e0:	0c 05       	add	r5,r6
800179e2:	0b a5       	ld.ub	r5,r5[0x2]
800179e4:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
800179e8:	f0 05 17 10 	movne	r5,r8
800179ec:	fc 05 17 00 	moveq	r5,lr
800179f0:	ae 85       	st.b	r7[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
800179f2:	ee 09 00 01 	add	r1,r7,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
800179f6:	15 85       	ld.ub	r5,r10[0x0]
800179f8:	f4 06 00 07 	add	r7,r10,r6
800179fc:	ee 05 00 05 	add	r5,r7,r5
80017a00:	0b a5       	ld.ub	r5,r5[0x2]
80017a02:	e2 15 00 02 	andl	r5,0x2,COH
80017a06:	f0 05 17 10 	movne	r5,r8
80017a0a:	fc 05 17 00 	moveq	r5,lr
80017a0e:	a2 85       	st.b	r1[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017a10:	12 01       	add	r1,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017a12:	15 85       	ld.ub	r5,r10[0x0]
80017a14:	ee 05 00 05 	add	r5,r7,r5
80017a18:	0b a5       	ld.ub	r5,r5[0x2]
80017a1a:	e2 15 00 04 	andl	r5,0x4,COH
80017a1e:	f0 05 17 10 	movne	r5,r8
80017a22:	fc 05 17 00 	moveq	r5,lr
80017a26:	a2 85       	st.b	r1[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017a28:	12 01       	add	r1,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017a2a:	15 85       	ld.ub	r5,r10[0x0]
80017a2c:	ee 05 00 05 	add	r5,r7,r5
80017a30:	0b a5       	ld.ub	r5,r5[0x2]
80017a32:	e2 15 00 08 	andl	r5,0x8,COH
80017a36:	f0 05 17 10 	movne	r5,r8
80017a3a:	fc 05 17 00 	moveq	r5,lr
80017a3e:	a2 85       	st.b	r1[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017a40:	12 01       	add	r1,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017a42:	15 85       	ld.ub	r5,r10[0x0]
80017a44:	ee 05 00 05 	add	r5,r7,r5
80017a48:	0b a5       	ld.ub	r5,r5[0x2]
80017a4a:	e2 15 00 10 	andl	r5,0x10,COH
80017a4e:	f0 05 17 10 	movne	r5,r8
80017a52:	fc 05 17 00 	moveq	r5,lr
80017a56:	a2 85       	st.b	r1[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017a58:	12 01       	add	r1,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017a5a:	15 85       	ld.ub	r5,r10[0x0]
80017a5c:	ee 05 00 05 	add	r5,r7,r5
80017a60:	0b a5       	ld.ub	r5,r5[0x2]
80017a62:	e2 15 00 20 	andl	r5,0x20,COH
80017a66:	f0 05 17 10 	movne	r5,r8
80017a6a:	fc 05 17 00 	moveq	r5,lr
80017a6e:	a2 85       	st.b	r1[0x0],r5
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      p += w;
80017a70:	12 01       	add	r1,r9
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      *p = gl->data[i + gl->first] & (1 << j) ? a : b;
80017a72:	15 85       	ld.ub	r5,r10[0x0]
80017a74:	ee 05 00 05 	add	r5,r7,r5
80017a78:	0b a5       	ld.ub	r5,r5[0x2]
80017a7a:	e2 15 00 40 	andl	r5,0x40,COH
80017a7e:	f0 05 17 10 	movne	r5,r8
80017a82:	fc 05 17 00 	moveq	r5,lr
80017a86:	a2 85       	st.b	r1[0x0],r5
80017a88:	15 85       	ld.ub	r5,r10[0x0]
80017a8a:	0a 07       	add	r7,r5
80017a8c:	0f a7       	ld.ub	r7,r7[0x2]
80017a8e:	e2 17 00 80 	andl	r7,0x80,COH
80017a92:	f0 07 17 10 	movne	r7,r8
80017a96:	fc 07 17 00 	moveq	r7,lr
80017a9a:	e2 09 0b 07 	st.b	r1[r9],r7
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
80017a9e:	08 95       	mov	r5,r4
    }
    // print_dbg("\r\n");
    // increment column count
    i++;
    // reset pointer to row
    p = buf + i;
80017aa0:	ec c7 ff ff 	sub	r7,r6,-1
80017aa4:	2f f6       	sub	r6,-1
80017aa6:	5c 57       	castu.b	r7
80017aa8:	f6 07 00 07 	add	r7,r11,r7
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
  // hm...
  //  w >>= 1;
  //  print_dbg("\r\n");
  while(i < cols) {
80017aac:	ec 04 18 00 	cp.b	r4,r6
80017ab0:	fe 9b ff 95 	brhi	800179da <font_string+0x36>
80017ab4:	0e 9b       	mov	r11,r7
      // end of string
      break;
    }
    buf = font_glyph(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
80017ab6:	2f fb       	sub	r11,-1
// render a string of packed glyphs to a buffer
u8* font_string(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  // u32 x = 0;  // columns processed
  // u32 off = 0; // offset
  u8* max = buf + size;
  while (buf < max) {
80017ab8:	16 33       	cp.w	r3,r11
80017aba:	e0 88 00 07 	brls	80017ac8 <font_string+0x124>
      break;
    }
    buf = font_glyph(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
    str++;
80017abe:	2f fc       	sub	r12,-1
u8* font_string(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  // u32 x = 0;  // columns processed
  // u32 off = 0; // offset
  u8* max = buf + size;
  while (buf < max) {
    if (*str == 0) {
80017ac0:	19 8a       	ld.ub	r10,r12[0x0]
80017ac2:	58 0a       	cp.w	r10,0
80017ac4:	fe 91 ff 7d 	brne	800179be <font_string+0x1a>
    // 1-column space between chars
    buf++;
    str++;
  }
  return buf;
}
80017ac8:	16 9c       	mov	r12,r11
80017aca:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80017ace:	d7 03       	nop
80017ad0:	80 02       	ld.sh	r2,r0[0x0]
80017ad2:	46 0e       	lddsp	lr,sp[0x180]

80017ad4 <font_string_big>:

// same as font_string, double size
u8* font_string_big(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
80017ad4:	eb cd 40 fe 	pushm	r1-r7,lr
80017ad8:	40 8e       	lddsp	lr,sp[0x20]
  u8* max = buf + size;
80017ada:	f6 0a 00 03 	add	r3,r11,r10
  while (buf < max) {
80017ade:	06 3b       	cp.w	r11,r3
80017ae0:	e0 82 00 ac 	brhs	80017c38 <font_string_big+0x164>
    if (*str == 0) {
80017ae4:	19 8a       	ld.ub	r10,r12[0x0]
80017ae6:	58 0a       	cp.w	r10,0
80017ae8:	e0 80 00 a8 	breq	80017c38 <font_string_big+0x164>
80017aec:	4d 52       	lddpc	r2,80017c40 <font_string_big+0x16c>

// same as font_glyph, double size
extern u8* font_glyph_big(char ch, u8* buf, u8 w, u8 a, u8 b) {
  u8 i=0, j, val;
  u8* p = buf;
  const glyph_t* gl = &(font_data[ch - FONT_ASCII_OFFSET]);
80017aee:	22 0a       	sub	r10,32
80017af0:	e4 0a 00 3a 	add	r10,r2,r10<<0x3
  // columns to draw
  u8 cols = (FONT_CHARW - gl->first - gl->last);
80017af4:	15 85       	ld.ub	r5,r10[0x0]
80017af6:	15 97       	ld.ub	r7,r10[0x1]
80017af8:	ea 04 11 00 	rsub	r4,r5,0
80017afc:	0e 14       	sub	r4,r7
80017afe:	2f a4       	sub	r4,-6
80017b00:	5c 54       	castu.b	r4
  // byte offset produced by 1 full column
  //  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
80017b02:	e0 80 00 92 	breq	80017c26 <font_string_big+0x152>
80017b06:	16 91       	mov	r1,r11
80017b08:	30 06       	mov	r6,0
80017b0a:	c0 28       	rjmp	80017b0e <font_string_big+0x3a>
80017b0c:	15 85       	ld.ub	r5,r10[0x0]
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017b0e:	f4 06 00 07 	add	r7,r10,r6
80017b12:	ee 05 00 05 	add	r5,r7,r5
80017b16:	0b a5       	ld.ub	r5,r5[0x2]
80017b18:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80017b1c:	f0 05 17 10 	movne	r5,r8
80017b20:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017b24:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017b26:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017b28:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017b2a:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017b2c:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017b2e:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017b30:	15 85       	ld.ub	r5,r10[0x0]
80017b32:	ee 05 00 05 	add	r5,r7,r5
80017b36:	0b a5       	ld.ub	r5,r5[0x2]
80017b38:	e2 15 00 02 	andl	r5,0x2,COH
80017b3c:	f0 05 17 10 	movne	r5,r8
80017b40:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017b44:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017b46:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017b48:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017b4a:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017b4c:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017b4e:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017b50:	15 85       	ld.ub	r5,r10[0x0]
80017b52:	ee 05 00 05 	add	r5,r7,r5
80017b56:	0b a5       	ld.ub	r5,r5[0x2]
80017b58:	e2 15 00 04 	andl	r5,0x4,COH
80017b5c:	f0 05 17 10 	movne	r5,r8
80017b60:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017b64:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017b66:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017b68:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017b6a:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017b6c:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017b6e:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017b70:	15 85       	ld.ub	r5,r10[0x0]
80017b72:	ee 05 00 05 	add	r5,r7,r5
80017b76:	0b a5       	ld.ub	r5,r5[0x2]
80017b78:	e2 15 00 08 	andl	r5,0x8,COH
80017b7c:	f0 05 17 10 	movne	r5,r8
80017b80:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017b84:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017b86:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017b88:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017b8a:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017b8c:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017b8e:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017b90:	15 85       	ld.ub	r5,r10[0x0]
80017b92:	ee 05 00 05 	add	r5,r7,r5
80017b96:	0b a5       	ld.ub	r5,r5[0x2]
80017b98:	e2 15 00 10 	andl	r5,0x10,COH
80017b9c:	f0 05 17 10 	movne	r5,r8
80017ba0:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017ba4:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017ba6:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017ba8:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017baa:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017bac:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017bae:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017bb0:	15 85       	ld.ub	r5,r10[0x0]
80017bb2:	ee 05 00 05 	add	r5,r7,r5
80017bb6:	0b a5       	ld.ub	r5,r5[0x2]
80017bb8:	e2 15 00 20 	andl	r5,0x20,COH
80017bbc:	f0 05 17 10 	movne	r5,r8
80017bc0:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017bc4:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017bc6:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017bc8:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017bca:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017bcc:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017bce:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017bd0:	15 85       	ld.ub	r5,r10[0x0]
80017bd2:	ee 05 00 05 	add	r5,r7,r5
80017bd6:	0b a5       	ld.ub	r5,r5[0x2]
80017bd8:	e2 15 00 40 	andl	r5,0x40,COH
80017bdc:	f0 05 17 10 	movne	r5,r8
80017be0:	fc 05 17 00 	moveq	r5,lr
      *p = val;
80017be4:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
80017be6:	a2 95       	st.b	r1[0x1],r5
      // point at next row
      p += w;
80017be8:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017bea:	a2 95       	st.b	r1[0x1],r5
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017bec:	a2 85       	st.b	r1[0x0],r5
      *(p +1) = val;
      // point at next row
      p += w;
80017bee:	e2 09 00 05 	add	r5,r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017bf2:	15 81       	ld.ub	r1,r10[0x0]
80017bf4:	02 07       	add	r7,r1
80017bf6:	0f a7       	ld.ub	r7,r7[0x2]
80017bf8:	e2 17 00 80 	andl	r7,0x80,COH
80017bfc:	f0 07 17 10 	movne	r7,r8
80017c00:	fc 07 17 00 	moveq	r7,lr
      *p = val;
80017c04:	aa 87       	st.b	r5[0x0],r7
      *(p +1) = val;
80017c06:	aa 97       	st.b	r5[0x1],r7
      // point at next row
      p += w;
80017c08:	12 05       	add	r5,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
80017c0a:	aa 97       	st.b	r5[0x1],r7
      *p = val;
      *(p +1) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017c0c:	aa 87       	st.b	r5[0x0],r7
    // increment for next row
    //    buf += 2;
    // increment column count
    i++;
    // set pointer to next (pixel*2) in first row
    p = buf + (i*2);
80017c0e:	ec c1 ff ff 	sub	r1,r6,-1
  // byte offset produced by 1 full column
  //  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
80017c12:	08 97       	mov	r7,r4
    // increment for next row
    //    buf += 2;
    // increment column count
    i++;
    // set pointer to next (pixel*2) in first row
    p = buf + (i*2);
80017c14:	5c 51       	castu.b	r1
80017c16:	2f f6       	sub	r6,-1
80017c18:	f6 01 00 11 	add	r1,r11,r1<<0x1
  // byte offset produced by 1 full column
  //  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
80017c1c:	ec 04 18 00 	cp.b	r4,r6
80017c20:	fe 9b ff 76 	brhi	80017b0c <font_string_big+0x38>
80017c24:	02 9b       	mov	r11,r1
      // end of string
      break;
    }
    buf = font_glyph_big(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
80017c26:	2f fb       	sub	r11,-1
}

// same as font_string, double size
u8* font_string_big(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  u8* max = buf + size;
  while (buf < max) {
80017c28:	16 33       	cp.w	r3,r11
80017c2a:	e0 88 00 07 	brls	80017c38 <font_string_big+0x164>
      break;
    }
    buf = font_glyph_big(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
    str++;
80017c2e:	2f fc       	sub	r12,-1

// same as font_string, double size
u8* font_string_big(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  u8* max = buf + size;
  while (buf < max) {
    if (*str == 0) {
80017c30:	19 8a       	ld.ub	r10,r12[0x0]
80017c32:	58 0a       	cp.w	r10,0
80017c34:	fe 91 ff 5d 	brne	80017aee <font_string_big+0x1a>
    // 1-column space between chars
    buf++;
    str++;
  }
  return buf;
}
80017c38:	16 9c       	mov	r12,r11
80017c3a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80017c3e:	d7 03       	nop
80017c40:	80 02       	ld.sh	r2,r0[0x0]
80017c42:	46 0e       	lddsp	lr,sp[0x180]

80017c44 <font_string_bigbig>:

// same as font_string, 4x size
u8* font_string_bigbig(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
80017c44:	eb cd 40 fe 	pushm	r1-r7,lr
80017c48:	40 8e       	lddsp	lr,sp[0x20]
  u8* max = buf + size;
80017c4a:	f6 0a 00 04 	add	r4,r11,r10
  while (buf < max) {
80017c4e:	08 3b       	cp.w	r11,r4
80017c50:	e0 82 01 1c 	brhs	80017e88 <font_string_bigbig+0x244>
    if (*str == 0) {
80017c54:	19 8a       	ld.ub	r10,r12[0x0]
80017c56:	58 0a       	cp.w	r10,0
80017c58:	e0 80 01 18 	breq	80017e88 <font_string_bigbig+0x244>
80017c5c:	fe f3 02 34 	ld.w	r3,pc[564]

// same as font_glyph,m 4x size
extern u8* font_glyph_bigbig(char ch, u8* buf, u8 w, u8 a, u8 b) {
  u8 i=0, j, val;
  u8* p = buf;
  const glyph_t* gl = &(font_data[ch - FONT_ASCII_OFFSET]);
80017c60:	22 0a       	sub	r10,32
80017c62:	e6 0a 00 37 	add	r7,r3,r10<<0x3
  // columns to draw
  u8 cols = (FONT_CHARW - gl->first - gl->last);
80017c66:	0f 8a       	ld.ub	r10,r7[0x0]
80017c68:	0f 96       	ld.ub	r6,r7[0x1]
80017c6a:	f4 05 11 00 	rsub	r5,r10,0
80017c6e:	0c 15       	sub	r5,r6
80017c70:	2f a5       	sub	r5,-6
80017c72:	5c 55       	castu.b	r5
  // byte offset produced by 1 full column
  //  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
80017c74:	e0 80 01 01 	breq	80017e76 <font_string_bigbig+0x232>
80017c78:	16 91       	mov	r1,r11
80017c7a:	30 06       	mov	r6,0
80017c7c:	c0 28       	rjmp	80017c80 <font_string_bigbig+0x3c>
80017c7e:	0f 8a       	ld.ub	r10,r7[0x0]
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017c80:	ee 06 00 02 	add	r2,r7,r6
80017c84:	e4 0a 00 0a 	add	r10,r2,r10
80017c88:	15 aa       	ld.ub	r10,r10[0x2]
80017c8a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80017c8e:	f0 0a 17 10 	movne	r10,r8
80017c92:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017c96:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017c98:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017c9a:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017c9c:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017c9e:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017ca0:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017ca2:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017ca4:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017ca6:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017ca8:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017caa:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017cac:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017cae:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017cb0:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017cb2:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017cb4:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017cb6:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
      *(p +3) = val;
80017cb8:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
80017cba:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
      // point at next row
      p += w;
80017cbc:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017cbe:	0f 8a       	ld.ub	r10,r7[0x0]
80017cc0:	e4 0a 00 0a 	add	r10,r2,r10
80017cc4:	15 aa       	ld.ub	r10,r10[0x2]
80017cc6:	e2 1a 00 02 	andl	r10,0x2,COH
80017cca:	f0 0a 17 10 	movne	r10,r8
80017cce:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017cd2:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017cd4:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017cd6:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017cd8:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017cda:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017cdc:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017cde:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017ce0:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017ce2:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017ce4:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017ce6:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017ce8:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017cea:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017cec:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017cee:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017cf0:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017cf2:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017cf4:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017cf6:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017cf8:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017cfa:	0f 8a       	ld.ub	r10,r7[0x0]
80017cfc:	e4 0a 00 0a 	add	r10,r2,r10
80017d00:	15 aa       	ld.ub	r10,r10[0x2]
80017d02:	e2 1a 00 04 	andl	r10,0x4,COH
80017d06:	f0 0a 17 10 	movne	r10,r8
80017d0a:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017d0e:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d10:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d12:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d14:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d16:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d18:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d1a:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d1c:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d1e:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d20:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d22:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d24:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d26:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d28:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d2a:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
      *(p +3) = val;
80017d2c:	a2 ba       	st.b	r1[0x3],r10
      *(p +2) = val;
      *(p +3) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017d2e:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d30:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d32:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
      // point at next row
      p += w;
80017d34:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017d36:	0f 8a       	ld.ub	r10,r7[0x0]
80017d38:	e4 0a 00 0a 	add	r10,r2,r10
80017d3c:	15 aa       	ld.ub	r10,r10[0x2]
80017d3e:	e2 1a 00 08 	andl	r10,0x8,COH
80017d42:	f0 0a 17 10 	movne	r10,r8
80017d46:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017d4a:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d4c:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d4e:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d50:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d52:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d54:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d56:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d58:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d5a:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d5c:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d5e:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d60:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d62:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d64:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d66:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d68:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d6a:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
      *(p +3) = val;
80017d6c:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
80017d6e:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
      // point at next row
      p += w;
80017d70:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017d72:	0f 8a       	ld.ub	r10,r7[0x0]
80017d74:	e4 0a 00 0a 	add	r10,r2,r10
80017d78:	15 aa       	ld.ub	r10,r10[0x2]
80017d7a:	e2 1a 00 10 	andl	r10,0x10,COH
80017d7e:	f0 0a 17 10 	movne	r10,r8
80017d82:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017d86:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d88:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d8a:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d8c:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d8e:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d90:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d92:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d94:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017d96:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017d98:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017d9a:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017d9c:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017d9e:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017da0:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017da2:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017da4:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017da6:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
      *(p +3) = val;
80017da8:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
80017daa:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
      // point at next row
      p += w;
80017dac:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017dae:	0f 8a       	ld.ub	r10,r7[0x0]
80017db0:	e4 0a 00 0a 	add	r10,r2,r10
80017db4:	15 aa       	ld.ub	r10,r10[0x2]
80017db6:	e2 1a 00 20 	andl	r10,0x20,COH
80017dba:	f0 0a 17 10 	movne	r10,r8
80017dbe:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017dc2:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017dc4:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017dc6:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017dc8:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017dca:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017dcc:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017dce:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017dd0:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017dd2:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017dd4:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017dd6:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017dd8:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017dda:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017ddc:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017dde:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
      *(p +3) = val;
80017de0:	a2 ba       	st.b	r1[0x3],r10
      *(p +2) = val;
      *(p +3) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017de2:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017de4:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017de6:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
      // point at next row
      p += w;
80017de8:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017dea:	0f 8a       	ld.ub	r10,r7[0x0]
80017dec:	e4 0a 00 0a 	add	r10,r2,r10
80017df0:	15 aa       	ld.ub	r10,r10[0x2]
80017df2:	e2 1a 00 40 	andl	r10,0x40,COH
80017df6:	f0 0a 17 10 	movne	r10,r8
80017dfa:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017dfe:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017e00:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017e02:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017e04:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017e06:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017e08:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017e0a:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017e0c:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017e0e:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017e10:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
80017e12:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017e14:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017e16:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017e18:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017e1a:	12 01       	add	r1,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
      *(p +3) = val;
80017e1c:	a2 ba       	st.b	r1[0x3],r10
      *(p +2) = val;
      *(p +3) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017e1e:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017e20:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017e22:	a2 aa       	st.b	r1[0x2],r10
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017e24:	0f 8a       	ld.ub	r10,r7[0x0]
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
      *(p +3) = val;
      // point at next row
      p += w;
80017e26:	12 01       	add	r1,r9
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
      val = gl->data[i + gl->first] & (1 << j) ? a : b;
80017e28:	14 02       	add	r2,r10
80017e2a:	05 aa       	ld.ub	r10,r2[0x2]
80017e2c:	e2 1a 00 80 	andl	r10,0x80,COH
80017e30:	f0 0a 17 10 	movne	r10,r8
80017e34:	fc 0a 17 00 	moveq	r10,lr
      *p = val;
80017e38:	a2 8a       	st.b	r1[0x0],r10
      *(p +1) = val;
80017e3a:	a2 9a       	st.b	r1[0x1],r10
      *(p +2) = val;
80017e3c:	a2 aa       	st.b	r1[0x2],r10
      *(p +3) = val;
80017e3e:	a2 ba       	st.b	r1[0x3],r10
      // point at next row
      p += w;
80017e40:	e2 09 00 02 	add	r2,r1,r9
      // fill the next row as well
      *p = val;
80017e44:	a4 8a       	st.b	r2[0x0],r10
      *(p +1) = val;
80017e46:	a4 9a       	st.b	r2[0x1],r10
      *(p +2) = val;
80017e48:	a4 aa       	st.b	r2[0x2],r10
      *(p +3) = val;
80017e4a:	a4 ba       	st.b	r2[0x3],r10
      // point at next row
      p += w;
80017e4c:	12 02       	add	r2,r9
      // fill the next row as well
      *p = val;
80017e4e:	a4 8a       	st.b	r2[0x0],r10
      *(p +1) = val;
80017e50:	a4 9a       	st.b	r2[0x1],r10
      *(p +2) = val;
80017e52:	a4 aa       	st.b	r2[0x2],r10
      *(p +3) = val;
80017e54:	a4 ba       	st.b	r2[0x3],r10
      // point at next row
      p += w;
80017e56:	12 02       	add	r2,r9
      // fill the next row as well
      *p = val;
      *(p +1) = val;
      *(p +2) = val;
      *(p +3) = val;
80017e58:	a4 ba       	st.b	r2[0x3],r10
      *(p +2) = val;
      *(p +3) = val;
      // point at next row
      p += w;
      // fill the next row as well
      *p = val;
80017e5a:	a4 8a       	st.b	r2[0x0],r10
      *(p +1) = val;
80017e5c:	a4 9a       	st.b	r2[0x1],r10
      *(p +2) = val;
80017e5e:	a4 aa       	st.b	r2[0x2],r10
    // increment for next row
    //    buf += 2;
    // increment column count
    i++;
    // set pointer to next (pixel*2) in first row
    p = buf + (i*4);
80017e60:	ec c1 ff ff 	sub	r1,r6,-1
80017e64:	2f f6       	sub	r6,-1
80017e66:	5c 51       	castu.b	r1
80017e68:	f6 01 00 21 	add	r1,r11,r1<<0x2
  // byte offset produced by 1 full column
  //  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  pbuf = buf + (y*w + x);
  //  pbyf
  while(i < cols) {
80017e6c:	ec 05 18 00 	cp.b	r5,r6
80017e70:	fe 9b ff 07 	brhi	80017c7e <font_string_bigbig+0x3a>
80017e74:	02 9b       	mov	r11,r1
      // end of string
      break;
    }
    buf = font_glyph_bigbig(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
80017e76:	2f fb       	sub	r11,-1
}

// same as font_string, 4x size
u8* font_string_bigbig(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  u8* max = buf + size;
  while (buf < max) {
80017e78:	16 34       	cp.w	r4,r11
80017e7a:	e0 88 00 07 	brls	80017e88 <font_string_bigbig+0x244>
      break;
    }
    buf = font_glyph_bigbig(*str, buf, w, a, b);
    // 1-column space between chars
    buf++;
    str++;
80017e7e:	2f fc       	sub	r12,-1

// same as font_string, 4x size
u8* font_string_bigbig(const char* str, u8* buf, u32 size, u8 w, u8 a, u8 b) {
  u8* max = buf + size;
  while (buf < max) {
    if (*str == 0) {
80017e80:	19 8a       	ld.ub	r10,r12[0x0]
80017e82:	58 0a       	cp.w	r10,0
80017e84:	fe 91 fe ee 	brne	80017c60 <font_string_bigbig+0x1c>
    // 1-column space between chars
    buf++;
    str++;
  }
  return buf;
}
80017e88:	16 9c       	mov	r12,r11
80017e8a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80017e8e:	d7 03       	nop
80017e90:	80 02       	ld.sh	r2,r0[0x0]
80017e92:	46 0e       	lddsp	lr,sp[0x180]

80017e94 <init_usb_host>:
  gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
}


// initialize USB host stack
void init_usb_host (void) {
80017e94:	d4 01       	pushm	lr
  //  pm_configure_usb_clock();
  uhc_start();
80017e96:	fe b0 f0 6b 	rcall	80015f6c <uhc_start>
}
80017e9a:	d8 02       	popm	pc

80017e9c <init_bfin_resources>:
80017e9c:	eb cd 40 80 	pushm	r7,lr
  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
}

// intialize resources for bf533 communication: SPI, GPIO
void init_bfin_resources(void) {
80017ea0:	20 4d       	sub	sp,16
    //    .trans_delay  = 0,
    .trans_delay = 20,
    .stay_act     = 1,
    .spi_mode     = 1,
    .modfdis      = 1
  };
80017ea2:	49 78       	lddpc	r8,80017efc <init_bfin_resources+0x60>
80017ea4:	f0 ea 00 08 	ld.d	r10,r8[8]
80017ea8:	fa eb 00 08 	st.d	sp[8],r10
80017eac:	f0 e8 00 00 	ld.d	r8,r8[0]
80017eb0:	1a 97       	mov	r7,sp
80017eb2:	fa e9 00 00 	st.d	sp[0],r8

  // assign pins to SPI.
  gpio_enable_module(BFIN_SPI_GPIO_MAP,
80017eb6:	30 4b       	mov	r11,4
80017eb8:	49 2c       	lddpc	r12,80017f00 <init_bfin_resources+0x64>
80017eba:	fe b0 d4 81 	rcall	800127bc <gpio_enable_module>
		     sizeof(BFIN_SPI_GPIO_MAP) / sizeof(BFIN_SPI_GPIO_MAP[0]));

  // intialize as master
  spi_initMaster(BFIN_SPI, &spiOptions);
80017ebe:	1a 9b       	mov	r11,sp
80017ec0:	fe 7c 24 00 	mov	r12,-56320
80017ec4:	fe b0 d5 e8 	rcall	80012a94 <spi_initMaster>

  // set selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(BFIN_SPI, 0, 0, 0);
80017ec8:	30 09       	mov	r9,0
80017eca:	fe 7c 24 00 	mov	r12,-56320
80017ece:	12 9a       	mov	r10,r9
80017ed0:	12 9b       	mov	r11,r9
80017ed2:	fe b0 d6 00 	rcall	80012ad2 <spi_selectionMode>

  // enable SPI.
  spi_enable(BFIN_SPI);
80017ed6:	fe 7c 24 00 	mov	r12,-56320
80017eda:	fe b0 d6 a3 	rcall	80012c20 <spi_enable>

  // intialize the chip register
  spi_setupChipReg(BFIN_SPI, &spiOptions, FPBA_HZ);
80017ede:	1a 9b       	mov	r11,sp
80017ee0:	e0 6a 14 80 	mov	r10,5248
80017ee4:	ea 1a 03 ef 	orh	r10,0x3ef
80017ee8:	fe 7c 24 00 	mov	r12,-56320
80017eec:	fe b0 d6 44 	rcall	80012b74 <spi_setupChipReg>
  // enable pulldown on bfin HWAIT line
  //// shit! not implemented... 
  // gpio_enable_pin_pull_down(BFIN_HWAIT_PIN);
  
  // enable pullup on bfin RESET line
  gpio_enable_pin_pull_up(BFIN_RESET_PIN);
80017ef0:	30 6c       	mov	r12,6
80017ef2:	fe b0 d3 f1 	rcall	800126d4 <gpio_enable_pin_pull_up>
}
80017ef6:	2f cd       	sub	sp,-16
80017ef8:	e3 cd 80 80 	ldm	sp++,r7,pc
80017efc:	80 02       	ld.sh	r2,r0[0x0]
80017efe:	49 48       	lddpc	r8,80017f4c <init_local_pdca+0x48>
80017f00:	80 02       	ld.sh	r2,r0[0x0]
80017f02:	49 28       	lddpc	r8,80017f48 <init_local_pdca+0x44>

80017f04 <init_local_pdca>:
80017f04:	eb cd 40 b0 	pushm	r4-r5,r7,lr
80017f08:	20 cd       	sub	sp,48
80017f0a:	49 4a       	lddpc	r10,80017f58 <init_local_pdca+0x54>
80017f0c:	f4 e4 00 10 	ld.d	r4,r10[16]
80017f10:	fa c7 ff e8 	sub	r7,sp,-24
80017f14:	49 29       	lddpc	r9,80017f5c <init_local_pdca+0x58>
80017f16:	ee e5 00 10 	st.d	r7[16],r4
80017f1a:	f2 e4 00 10 	ld.d	r4,r9[16]
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80017f1e:	fa e5 00 10 	st.d	sp[16],r4
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_RX,        // select peripheral ID - SPI1 RX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80017f22:	f4 e4 00 00 	ld.d	r4,r10[0]
80017f26:	ee e5 00 00 	st.d	r7[0],r4
80017f2a:	f4 e4 00 08 	ld.d	r4,r10[8]
80017f2e:	ee e5 00 08 	st.d	r7[8],r4
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80017f32:	f2 e4 00 00 	ld.d	r4,r9[0]

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80017f36:	1a 9b       	mov	r11,sp
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80017f38:	fa e5 00 00 	st.d	sp[0],r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80017f3c:	30 1c       	mov	r12,1
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80017f3e:	f2 e4 00 08 	ld.d	r4,r9[8]
80017f42:	fa e5 00 08 	st.d	sp[8],r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80017f46:	fe b0 d5 54 	rcall	800129ee <pdca_init_channel>

  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
80017f4a:	0e 9b       	mov	r11,r7
80017f4c:	30 0c       	mov	r12,0
80017f4e:	fe b0 d5 50 	rcall	800129ee <pdca_init_channel>
}
80017f52:	2f 4d       	sub	sp,-48
80017f54:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc
80017f58:	80 02       	ld.sh	r2,r0[0x0]
80017f5a:	49 68       	lddpc	r8,80017fb0 <init_spi1+0x50>
80017f5c:	80 02       	ld.sh	r2,r0[0x0]
80017f5e:	49 10       	lddpc	r0,80017fa0 <init_spi1+0x40>

80017f60 <init_spi1>:
80017f60:	d4 21       	pushm	r4-r7,lr
80017f62:	20 4d       	sub	sp,16
    .trans_delay = 0,
    .spck_delay = 0,
    .stay_act = 1,
    .spi_mode = 3,
    .modfdis = 1
  };
80017f64:	4b 68       	lddpc	r8,8001803c <init_spi1+0xdc>
80017f66:	f0 ea 00 08 	ld.d	r10,r8[8]
80017f6a:	fa eb 00 08 	st.d	sp[8],r10
80017f6e:	f0 e8 00 00 	ld.d	r8,r8[0]
80017f72:	1a 97       	mov	r7,sp
80017f74:	fa e9 00 00 	st.d	sp[0],r8

  // Assign GPIO to SPI.
  gpio_enable_module(OLED_SPI_GPIO_MAP,
80017f78:	30 6b       	mov	r11,6
80017f7a:	4b 2c       	lddpc	r12,80018040 <init_spi1+0xe0>
80017f7c:	fe b0 d4 20 	rcall	800127bc <gpio_enable_module>
		     sizeof(OLED_SPI_GPIO_MAP) / sizeof(OLED_SPI_GPIO_MAP[0]));
  // Initialize as master.
  spi_initMaster(OLED_SPI, &spiOptions);
80017f80:	1a 9b       	mov	r11,sp
80017f82:	fe 7c 28 00 	mov	r12,-55296
80017f86:	fe b0 d5 87 	rcall	80012a94 <spi_initMaster>
  // Set SPI selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(OLED_SPI, 0, 0, 0);
80017f8a:	30 09       	mov	r9,0
80017f8c:	fe 7c 28 00 	mov	r12,-55296
80017f90:	12 9a       	mov	r10,r9
80017f92:	12 9b       	mov	r11,r9
80017f94:	fe b0 d5 9f 	rcall	80012ad2 <spi_selectionMode>
  // Enable SPI module.
  spi_enable(OLED_SPI);
80017f98:	fe 7c 28 00 	mov	r12,-55296
80017f9c:	fe b0 d6 42 	rcall	80012c20 <spi_enable>

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );
80017fa0:	1a 9b       	mov	r11,sp
80017fa2:	e0 6a 14 80 	mov	r10,5248
80017fa6:	ea 1a 03 ef 	orh	r10,0x3ef
80017faa:	fe 7c 28 00 	mov	r12,-55296
80017fae:	fe b0 d5 e3 	rcall	80012b74 <spi_setupChipReg>

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
80017fb2:	e0 68 2d 00 	mov	r8,11520
80017fb6:	ea 18 01 31 	orh	r8,0x131
80017fba:	50 18       	stdsp	sp[0x4],r8
  spiOptions.bits         = 16;
80017fbc:	31 08       	mov	r8,16
80017fbe:	fb 68 00 08 	st.b	sp[8],r8
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
80017fc2:	30 58       	mov	r8,5
  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
80017fc4:	30 06       	mov	r6,0

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
80017fc6:	30 15       	mov	r5,1
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80017fc8:	1a 9b       	mov	r11,sp
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
80017fca:	fb 68 00 0a 	st.b	sp[10],r8
  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
80017fce:	fb 66 00 09 	st.b	sp[9],r6
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
80017fd2:	fb 66 00 0b 	st.b	sp[11],r6
  spiOptions.modfdis      = 0;
80017fd6:	fb 66 00 0d 	st.b	sp[13],r6

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
80017fda:	ba 85       	st.b	sp[0x0],r5
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
80017fdc:	30 24       	mov	r4,2
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80017fde:	e0 6a 14 80 	mov	r10,5248
80017fe2:	ea 1a 03 ef 	orh	r10,0x3ef

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
80017fe6:	fb 64 00 0c 	st.b	sp[12],r4
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80017fea:	fe 7c 28 00 	mov	r12,-55296
80017fee:	fe b0 d5 c3 	rcall	80012b74 <spi_setupChipReg>

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
80017ff2:	e0 68 1b 00 	mov	r8,6912
80017ff6:	ea 18 00 b7 	orh	r8,0xb7
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
80017ffa:	ba 84       	st.b	sp[0x0],r4
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
  spiOptions.spck_delay  = 0;
  spiOptions.trans_delay = 0;
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
80017ffc:	fb 66 00 0c 	st.b	sp[12],r6
  spiOptions.modfdis     = 1;
80018000:	fb 65 00 0d 	st.b	sp[13],r5

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
80018004:	20 4d       	sub	sp,16

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
80018006:	50 58       	stdsp	sp[0x14],r8
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80018008:	30 88       	mov	r8,8
  spiOptions.spck_delay  = 0;
8001800a:	fb 66 00 19 	st.b	sp[25],r6
  spiOptions.trans_delay = 0;
8001800e:	fb 66 00 1a 	st.b	sp[26],r6
  spiOptions.stay_act    = 1;
80018012:	fb 65 00 1b 	st.b	sp[27],r5
  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80018016:	fb 68 00 18 	st.b	sp[24],r8
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
  spiOptions.modfdis     = 1;

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
8001801a:	ee e8 00 08 	ld.d	r8,r7[8]
8001801e:	fa e9 00 08 	st.d	sp[8],r8
80018022:	ee e8 00 00 	ld.d	r8,r7[0]
80018026:	e0 6c 14 80 	mov	r12,5248
8001802a:	ea 1c 03 ef 	orh	r12,0x3ef
8001802e:	fa e9 00 00 	st.d	sp[0],r8
80018032:	fe b0 e0 0b 	rcall	80014048 <sd_mmc_spi_init>
80018036:	2f cd       	sub	sp,-16
}
80018038:	2f cd       	sub	sp,-16
8001803a:	d8 22       	popm	r4-r7,pc
8001803c:	80 02       	ld.sh	r2,r0[0x0]
8001803e:	49 58       	lddpc	r8,80018090 <init_tc+0x24>
80018040:	80 02       	ld.sh	r2,r0[0x0]
80018042:	49 a0       	lddpc	r0,800180a8 <init_gpio+0x4>

80018044 <init_ftdi_usart>:
80018044:	d4 01       	pushm	lr
80018046:	30 2b       	mov	r11,2
80018048:	48 7c       	lddpc	r12,80018064 <init_ftdi_usart+0x20>
8001804a:	fe b0 d3 b9 	rcall	800127bc <gpio_enable_module>
8001804e:	e0 6a 14 80 	mov	r10,5248
80018052:	ea 1a 03 ef 	orh	r10,0x3ef
80018056:	48 5b       	lddpc	r11,80018068 <init_ftdi_usart+0x24>
80018058:	fe 7c 14 00 	mov	r12,-60416
  // Set up GPIO for FTDI_USART
  gpio_enable_module(FTDI_USART_GPIO_MAP,
                     sizeof(FTDI_USART_GPIO_MAP) / sizeof(FTDI_USART_GPIO_MAP[0]));

  // Initialize in RS232 mode.
  usart_init_rs232(FTDI_USART, &FTDI_USART_OPTIONS, FPBA_HZ);
8001805c:	fe b0 d7 2e 	rcall	80012eb8 <usart_init_rs232>
}
80018060:	d8 02       	popm	pc
80018062:	d7 03       	nop
80018064:	80 02       	ld.sh	r2,r0[0x0]
80018066:	49 90       	lddpc	r0,800180c8 <init_gpio+0x24>
80018068:	80 02       	ld.sh	r2,r0[0x0]
8001806a:	49 84       	lddpc	r4,800180c8 <init_gpio+0x24>

8001806c <init_tc>:
8001806c:	eb cd 40 80 	pushm	r7,lr
80018070:	48 bb       	lddpc	r11,8001809c <init_tc+0x30>
80018072:	18 97       	mov	r7,r12
    .cpas  = 0,
    .lovrs = 0,
    .covfs = 0
  };
  // Initialize the timer/counter.
  tc_init_waveform(tc, &waveform_opt);
80018074:	fe b0 d5 f8 	rcall	80012c64 <tc_init_waveform>

  // set timer compare trigger.
  // we want it to overflow and generate an interrupt every 1 ms
  // so (1 / fPBA / 128) * RC = 0.001
  // so RC = fPBA / 128 / 1000
  tc_write_rc(tc, APP_TC_CHANNEL, (FPBA_HZ / 128 / 1000));
80018078:	e0 6a 02 03 	mov	r10,515
8001807c:	30 0b       	mov	r11,0
8001807e:	0e 9c       	mov	r12,r7
80018080:	fe b0 d6 53 	rcall	80012d26 <tc_write_rc>
  // configure the timer interrupt
  tc_configure_interrupts(tc, APP_TC_CHANNEL, &tc_interrupt);
80018084:	30 0b       	mov	r11,0
80018086:	48 7a       	lddpc	r10,800180a0 <init_tc+0x34>
80018088:	0e 9c       	mov	r12,r7
8001808a:	fe b0 d6 6a 	rcall	80012d5e <tc_configure_interrupts>
  // Start the timer/counter.
  tc_start(tc, APP_TC_CHANNEL);
8001808e:	0e 9c       	mov	r12,r7
80018090:	30 0b       	mov	r11,0
80018092:	fe b0 d6 38 	rcall	80012d02 <tc_start>
}
80018096:	e3 cd 80 80 	ldm	sp++,r7,pc
8001809a:	d7 03       	nop
8001809c:	80 02       	ld.sh	r2,r0[0x0]
8001809e:	49 08       	lddpc	r8,800180dc <init_gpio+0x38>
800180a0:	80 02       	ld.sh	r2,r0[0x0]
800180a2:	49 80       	lddpc	r0,80018100 <register_interrupts+0x1c>

800180a4 <init_gpio>:
800180a4:	d4 01       	pushm	lr
800180a6:	32 2c       	mov	r12,34
800180a8:	fe b0 d3 16 	rcall	800126d4 <gpio_enable_pin_pull_up>
800180ac:	32 3c       	mov	r12,35
800180ae:	fe b0 d3 13 	rcall	800126d4 <gpio_enable_pin_pull_up>
800180b2:	32 4c       	mov	r12,36
// initialize non-peripheral GPIO
void init_gpio(void) {
  
  gpio_enable_pin_pull_up(ENC0_S0_PIN);
  gpio_enable_pin_pull_up(ENC0_S1_PIN);
  gpio_enable_pin_pull_up(ENC1_S0_PIN);
800180b4:	fe b0 d3 10 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC1_S1_PIN);
800180b8:	32 5c       	mov	r12,37
800180ba:	fe b0 d3 0d 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S0_PIN);
800180be:	32 6c       	mov	r12,38
800180c0:	fe b0 d3 0a 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S1_PIN);
800180c4:	32 7c       	mov	r12,39
800180c6:	fe b0 d3 07 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S0_PIN);
800180ca:	32 8c       	mov	r12,40
800180cc:	fe b0 d3 04 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S1_PIN);
800180d0:	32 9c       	mov	r12,41
800180d2:	fe b0 d3 01 	rcall	800126d4 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(SW2_PIN);
  gpio_enable_pin_pull_up(SW3_PIN);
  gpio_enable_pin_pull_up(SW_MODE_PIN);
#endif

  gpio_enable_pin_pull_up(SW_POWER_PIN);
800180d6:	33 0c       	mov	r12,48
800180d8:	fe b0 d2 fe 	rcall	800126d4 <gpio_enable_pin_pull_up>
  /// trying this...
  /* gpio_enable_pin_glitch_filter(SW0_PIN); */
  /* gpio_enable_pin_glitch_filter(SW1_PIN); */
  /* gpio_enable_pin_glitch_filter(SW2_PIN); */
  /* gpio_enable_pin_glitch_filter(SW3_PIN); */
  gpio_enable_pin_glitch_filter(SW_MODE_PIN); 
800180dc:	31 8c       	mov	r12,24
800180de:	fe b0 d3 2a 	rcall	80012732 <gpio_enable_pin_glitch_filter>
}
800180e2:	d8 02       	popm	pc

800180e4 <register_interrupts>:

  //-----------------------------
  //---- external function definitions

  // register interrupts
  void register_interrupts(void) {
800180e4:	d4 01       	pushm	lr
    // enable interrupts on GPIO inputs

    // BFIN_HWAIT
    // gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_PIN_CHANGE);
    gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_RISING_EDGE);
800180e6:	30 1b       	mov	r11,1
800180e8:	30 5c       	mov	r12,5
800180ea:	fe b0 d3 2e 	rcall	80012746 <gpio_enable_pin_interrupt>

    // encoders
    gpio_enable_pin_interrupt( ENC0_S0_PIN,	GPIO_PIN_CHANGE);
800180ee:	30 0b       	mov	r11,0
800180f0:	32 2c       	mov	r12,34
800180f2:	fe b0 d3 2a 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC0_S1_PIN,	GPIO_PIN_CHANGE);
800180f6:	30 0b       	mov	r11,0
800180f8:	32 3c       	mov	r12,35
800180fa:	fe b0 d3 26 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S0_PIN,	GPIO_PIN_CHANGE);
800180fe:	30 0b       	mov	r11,0
80018100:	32 4c       	mov	r12,36
80018102:	fe b0 d3 22 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S1_PIN,	GPIO_PIN_CHANGE);
80018106:	30 0b       	mov	r11,0
80018108:	32 5c       	mov	r12,37
8001810a:	fe b0 d3 1e 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S0_PIN,	GPIO_PIN_CHANGE);
8001810e:	30 0b       	mov	r11,0
80018110:	32 6c       	mov	r12,38
80018112:	fe b0 d3 1a 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S1_PIN,	GPIO_PIN_CHANGE);
80018116:	30 0b       	mov	r11,0
80018118:	32 7c       	mov	r12,39
8001811a:	fe b0 d3 16 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S0_PIN,	GPIO_PIN_CHANGE);
8001811e:	30 0b       	mov	r11,0
80018120:	32 8c       	mov	r12,40
80018122:	fe b0 d3 12 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S1_PIN,	GPIO_PIN_CHANGE);
80018126:	30 0b       	mov	r11,0
80018128:	32 9c       	mov	r12,41
8001812a:	fe b0 d3 0e 	rcall	80012746 <gpio_enable_pin_interrupt>

    // switches
    gpio_enable_pin_interrupt( SW0_PIN,	        GPIO_PIN_CHANGE);
8001812e:	30 0b       	mov	r11,0
80018130:	31 9c       	mov	r12,25
80018132:	fe b0 d3 0a 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW1_PIN,	        GPIO_PIN_CHANGE);
80018136:	30 0b       	mov	r11,0
80018138:	31 ac       	mov	r12,26
8001813a:	fe b0 d3 06 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW2_PIN,	        GPIO_PIN_CHANGE);
8001813e:	30 0b       	mov	r11,0
80018140:	31 bc       	mov	r12,27
80018142:	fe b0 d3 02 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW3_PIN,	        GPIO_PIN_CHANGE);
80018146:	30 0b       	mov	r11,0
80018148:	31 cc       	mov	r12,28
8001814a:	fe b0 d2 fe 	rcall	80012746 <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( FS0_PIN,	GPIO_PIN_CHANGE);
8001814e:	30 0b       	mov	r11,0
80018150:	33 ec       	mov	r12,62
80018152:	fe b0 d2 fa 	rcall	80012746 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( FS1_PIN,	GPIO_PIN_CHANGE);
80018156:	30 0b       	mov	r11,0
80018158:	33 fc       	mov	r12,63
8001815a:	fe b0 d2 f6 	rcall	80012746 <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( SW_MODE_PIN,	GPIO_PIN_CHANGE);
8001815e:	30 0b       	mov	r11,0
80018160:	31 8c       	mov	r12,24
80018162:	fe b0 d2 f2 	rcall	80012746 <gpio_enable_pin_interrupt>
    //  gpio_enable_pin_interrupt( SW_POWER_PIN,	GPIO_PIN_CHANGE);
 
    // PA24 - PA31
    INTC_register_interrupt( &irq_port0_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PA24 / 8), UI_IRQ_PRIORITY);
80018166:	30 2a       	mov	r10,2
80018168:	34 3b       	mov	r11,67
8001816a:	fe cc fe b2 	sub	r12,pc,-334
8001816e:	fe b0 d3 65 	rcall	80012838 <INTC_register_interrupt>

    // PB00 - PB07
    INTC_register_interrupt( &irq_port1_line0, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB00 / 8), UI_IRQ_PRIORITY );
80018172:	30 2a       	mov	r10,2
80018174:	34 4b       	mov	r11,68
80018176:	fe cc fe 1a 	sub	r12,pc,-486

    // PB08 - PB15
    INTC_register_interrupt( &irq_port1_line1, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB08 / 8), UI_IRQ_PRIORITY);
8001817a:	fe b0 d3 5f 	rcall	80012838 <INTC_register_interrupt>
8001817e:	30 2a       	mov	r10,2
80018180:	34 5b       	mov	r11,69
80018182:	fe cc fe 56 	sub	r12,pc,-426

    // PB16 - PB23
    //  INTC_register_interrupt( &irq_port1_line2, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB16 / 8), UI_IRQ_PRIORITY);

    // PB24 - PB31
    INTC_register_interrupt( &irq_port1_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB24 / 8), UI_IRQ_PRIORITY);
80018186:	fe b0 d3 59 	rcall	80012838 <INTC_register_interrupt>
8001818a:	30 2a       	mov	r10,2
8001818c:	34 7b       	mov	r11,71


    // register IRQ for PDCA transfer
    INTC_register_interrupt(&irq_pdca, AVR32_PDCA_IRQ_0, SYS_IRQ_PRIORITY);
8001818e:	fe cc ff 06 	sub	r12,pc,-250
80018192:	fe b0 d3 53 	rcall	80012838 <INTC_register_interrupt>
80018196:	30 1a       	mov	r10,1

    // register TC interrupt
    INTC_register_interrupt(&irq_tc, APP_TC_IRQ, APP_TC_IRQ_PRIORITY);
80018198:	36 0b       	mov	r11,96
8001819a:	fe cc ff 82 	sub	r12,pc,-126
8001819e:	fe b0 d3 4d 	rcall	80012838 <INTC_register_interrupt>
800181a2:	30 3a       	mov	r10,3
  }
800181a4:	e0 6b 01 c0 	mov	r11,448
800181a8:	fe cc ff f4 	sub	r12,pc,-12
800181ac:	fe b0 d3 46 	rcall	80012838 <INTC_register_interrupt>
800181b0:	d8 02       	popm	pc
800181b2:	d7 03       	nop

800181b4 <irq_tc>:
800181b4:	eb cd 40 c0 	pushm	r6-r7,lr
800181b8:	e0 68 0b a0 	mov	r8,2976
800181bc:	30 1a       	mov	r10,1
800181be:	f0 e6 00 00 	ld.d	r6,r8[0]
800181c2:	30 0b       	mov	r11,0
800181c4:	ec 0a 00 0a 	add	r10,r6,r10
}

// timer irq
__attribute__((__interrupt__))
static void irq_tc(void) {
  tcTicks++;
800181c8:	ee 0b 00 4b 	adc	r11,r7,r11
800181cc:	f0 eb 00 00 	st.d	r8[0],r10
  // overflow control
  if(tcTicks > tcMax) { 
800181d0:	e0 66 ff ff 	mov	r6,65535
800181d4:	ea 16 7f ff 	orh	r6,0x7fff
800181d8:	f0 ea 00 00 	ld.d	r10,r8[0]
800181dc:	30 07       	mov	r7,0
800181de:	0c 3a       	cp.w	r10,r6
800181e0:	ee 0b 13 00 	cpc	r11,r7
800181e4:	e0 8b 00 10 	brhi	80018204 <irq_tc+0x50>
    tcTicks = 0;
    tcOverflow = 1;
  } else {
    tcOverflow = 0;
800181e8:	30 09       	mov	r9,0
800181ea:	e0 68 0b 9c 	mov	r8,2972
  }
  process_timers();
800181ee:	b0 89       	st.b	r8[0x0],r9
  // clear interrupt flag by reading timer SR
  tc_read_sr(APP_TC, APP_TC_CHANNEL);
800181f0:	e0 a0 0e 50 	rcall	80019e90 <process_timers>
800181f4:	30 0b       	mov	r11,0
800181f6:	fe 7c 38 00 	mov	r12,-51200
}
800181fa:	fe b0 d5 8d 	rcall	80012d14 <tc_read_sr>
800181fe:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
__attribute__((__interrupt__))
static void irq_tc(void) {
  tcTicks++;
  // overflow control
  if(tcTicks > tcMax) { 
    tcTicks = 0;
80018202:	d6 03       	rete
80018204:	30 0a       	mov	r10,0
80018206:	30 0b       	mov	r11,0
    tcOverflow = 1;
80018208:	f0 eb 00 00 	st.d	r8[0],r10
8001820c:	30 19       	mov	r9,1
8001820e:	e0 68 0b 9c 	mov	r8,2972
80018212:	b0 89       	st.b	r8[0x0],r9
80018214:	ce eb       	rjmp	800181f0 <irq_tc+0x3c>
80018216:	d7 03       	nop

80018218 <irq_pdca>:
80018218:	d4 01       	pushm	lr
8001821a:	d3 03       	ssrf	0x10
8001821c:	30 0c       	mov	r12,0
8001821e:	fe b0 d3 bb 	rcall	80012994 <pdca_disable_interrupt_transfer_complete>
  //  Disable_global_interrupt();
  cpu_irq_disable();
  // Disable interrupt channel.
  pdca_disable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
  //unselects the SD/MMC memory.
  sd_mmc_spi_read_close_PDCA();
80018222:	fe b0 d7 a7 	rcall	80013170 <sd_mmc_spi_read_close_PDCA>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80018226:	30 09       	mov	r9,0
80018228:	e0 68 03 e8 	mov	r8,1000
8001822c:	e0 6a d0 e7 	mov	r10,53479
80018230:	ea 1a 27 56 	orh	r10,0x2756
80018234:	30 0b       	mov	r11,0
80018236:	e0 a0 56 ce 	rcall	80022fd2 <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001823a:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001823e:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80018242:	e1 b8 00 42 	mfsr	r8,0x108
80018246:	14 39       	cp.w	r9,r10
80018248:	e0 8b 00 16 	brhi	80018274 <irq_pdca+0x5c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001824c:	10 39       	cp.w	r9,r8
8001824e:	e0 8b 00 04 	brhi	80018256 <irq_pdca+0x3e>
80018252:	10 3a       	cp.w	r10,r8
80018254:	c1 62       	brcc	80018280 <irq_pdca+0x68>
  //.... example has a 5000 clock gimpy delay here.
  // using delay_us instead
  delay_ms(10);
  //  delay_ms(2);
  // Disable unnecessary channel
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
80018256:	30 1c       	mov	r12,1
80018258:	fe b0 d3 80 	rcall	80012958 <pdca_disable>
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_RX);
8001825c:	30 0c       	mov	r12,0
8001825e:	fe b0 d3 7d 	rcall	80012958 <pdca_disable>
  // Enable all interrupts.
  cpu_irq_enable();
80018262:	d5 03       	csrf	0x10
  //  Enable_global_interrupt();
  //  print_dbg("\r\n handled PDCA interrupt. \r\n");
  fsEndTransfer = true;
80018264:	30 19       	mov	r9,1
80018266:	e0 68 2d 4c 	mov	r8,11596
}
8001826a:	b0 89       	st.b	r8[0x0],r9
8001826c:	d4 02       	popm	lr
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001826e:	d6 03       	rete
80018270:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80018274:	10 39       	cp.w	r9,r8
80018276:	fe 98 ff fd 	brls	80018270 <irq_pdca+0x58>
8001827a:	10 3a       	cp.w	r10,r8
8001827c:	cf a2       	brcc	80018270 <irq_pdca+0x58>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001827e:	ce cb       	rjmp	80018256 <irq_pdca+0x3e>
80018280:	e1 b8 00 42 	mfsr	r8,0x108
80018284:	ce 4b       	rjmp	8001824c <irq_pdca+0x34>
80018286:	d7 03       	nop

80018288 <irq_port1_line3>:
80018288:	d4 01       	pushm	lr
8001828a:	33 ec       	mov	r12,62
8001828c:	fe b0 d2 82 	rcall	80012790 <gpio_get_pin_interrupt_flag>
80018290:	c0 d1       	brne	800182aa <irq_port1_line3+0x22>
80018292:	33 fc       	mov	r12,63
80018294:	fe b0 d2 7e 	rcall	80012790 <gpio_get_pin_interrupt_flag>
  //  print_dbg("\r\n irq_port1_line3");
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
    process_sw(6);
  }
  if(gpio_get_pin_interrupt_flag(FS1_PIN)) {
80018298:	c0 70       	breq	800182a6 <irq_port1_line3+0x1e>
    gpio_clear_pin_interrupt_flag(FS1_PIN);
8001829a:	33 fc       	mov	r12,63
8001829c:	fe b0 d2 86 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(7);
800182a0:	30 7c       	mov	r12,7
800182a2:	e0 a0 0d df 	rcall	80019e60 <process_sw>
  }
}
800182a6:	d4 02       	popm	lr
800182a8:	d6 03       	rete
// interrupt handler for PB24-PB31
__attribute__((__interrupt__))
static void irq_port1_line3(void) {
  //  print_dbg("\r\n irq_port1_line3");
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
800182aa:	33 ec       	mov	r12,62
800182ac:	fe b0 d2 7e 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(6);
800182b0:	30 6c       	mov	r12,6
800182b2:	e0 a0 0d d7 	rcall	80019e60 <process_sw>
800182b6:	ce eb       	rjmp	80018292 <irq_port1_line3+0xa>

800182b8 <irq_port0_line3>:
800182b8:	d4 01       	pushm	lr
800182ba:	31 9c       	mov	r12,25
800182bc:	fe b0 d2 6a 	rcall	80012790 <gpio_get_pin_interrupt_flag>
800182c0:	c2 e1       	brne	8001831c <irq_port0_line3+0x64>
800182c2:	31 ac       	mov	r12,26
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
800182c4:	fe b0 d2 66 	rcall	80012790 <gpio_get_pin_interrupt_flag>
800182c8:	c2 31       	brne	8001830e <irq_port0_line3+0x56>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
800182ca:	31 bc       	mov	r12,27
800182cc:	fe b0 d2 62 	rcall	80012790 <gpio_get_pin_interrupt_flag>
800182d0:	c1 81       	brne	80018300 <irq_port0_line3+0x48>
    gpio_clear_pin_interrupt_flag(SW2_PIN);
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
800182d2:	31 cc       	mov	r12,28
800182d4:	fe b0 d2 5e 	rcall	80012790 <gpio_get_pin_interrupt_flag>
800182d8:	c0 d1       	brne	800182f2 <irq_port0_line3+0x3a>
    gpio_clear_pin_interrupt_flag(SW3_PIN);
    process_sw(3);
  }
  // SW_MODE
  if(gpio_get_pin_interrupt_flag(SW_MODE_PIN)) {
800182da:	31 8c       	mov	r12,24
800182dc:	fe b0 d2 5a 	rcall	80012790 <gpio_get_pin_interrupt_flag>
800182e0:	c0 70       	breq	800182ee <irq_port0_line3+0x36>
    gpio_clear_pin_interrupt_flag(SW_MODE_PIN);
800182e2:	31 8c       	mov	r12,24
800182e4:	fe b0 d2 62 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(4);
800182e8:	30 4c       	mov	r12,4
800182ea:	e0 a0 0d bb 	rcall	80019e60 <process_sw>
  }
}
800182ee:	d4 02       	popm	lr
800182f0:	d6 03       	rete
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
    gpio_clear_pin_interrupt_flag(SW3_PIN);
800182f2:	31 cc       	mov	r12,28
800182f4:	fe b0 d2 5a 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(3);
800182f8:	30 3c       	mov	r12,3
800182fa:	e0 a0 0d b3 	rcall	80019e60 <process_sw>
800182fe:	ce eb       	rjmp	800182da <irq_port0_line3+0x22>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
    gpio_clear_pin_interrupt_flag(SW2_PIN);
80018300:	31 bc       	mov	r12,27
80018302:	fe b0 d2 53 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(2);
80018306:	30 2c       	mov	r12,2
80018308:	e0 a0 0d ac 	rcall	80019e60 <process_sw>
8001830c:	ce 3b       	rjmp	800182d2 <irq_port0_line3+0x1a>
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
    gpio_clear_pin_interrupt_flag(SW1_PIN);
8001830e:	31 ac       	mov	r12,26
80018310:	fe b0 d2 4c 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    process_sw(1);
80018314:	30 1c       	mov	r12,1
80018316:	e0 a0 0d a5 	rcall	80019e60 <process_sw>
8001831a:	cd 8b       	rjmp	800182ca <irq_port0_line3+0x12>
__attribute__((__interrupt__))
static void irq_port0_line3(void) {
  //  print_dbg("\r\n interrupt on port0_line3");
  //SW_F0
  if(gpio_get_pin_interrupt_flag(SW0_PIN)) {
    gpio_clear_pin_interrupt_flag(SW0_PIN);
8001831c:	31 9c       	mov	r12,25
8001831e:	fe b0 d2 45 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
    /// process_sw() will post an event, which calls cpu_irq_disable().
    /// apparently, this also clears the GPIO interrupt flags (!?)
    /// so clear the flag first to avoid triggering an infinite series of interrupts.
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
80018322:	30 0c       	mov	r12,0
80018324:	e0 a0 0d 9e 	rcall	80019e60 <process_sw>
80018328:	cc db       	rjmp	800182c2 <irq_port0_line3+0xa>
8001832a:	d7 03       	nop

8001832c <irq_port1_line1>:
8001832c:	d4 01       	pushm	lr
8001832e:	32 8c       	mov	r12,40
80018330:	fe b0 d2 30 	rcall	80012790 <gpio_get_pin_interrupt_flag>
80018334:	c0 d1       	brne	8001834e <irq_port1_line1+0x22>
80018336:	32 9c       	mov	r12,41
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
  }  
  // ENC3_1
  if(gpio_get_pin_interrupt_flag(ENC3_S1_PIN)) {
80018338:	fe b0 d2 2c 	rcall	80012790 <gpio_get_pin_interrupt_flag>
8001833c:	c0 70       	breq	8001834a <irq_port1_line1+0x1e>
    process_enc(3);
8001833e:	30 3c       	mov	r12,3
80018340:	fe b0 f8 b6 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S1_PIN);
80018344:	32 9c       	mov	r12,41
80018346:	fe b0 d2 31 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
  }

}
8001834a:	d4 02       	popm	lr
8001834c:	d6 03       	rete
__attribute__((__interrupt__))
static void irq_port1_line1(void) {
  //    print_dbg("\r\b\interrupt on PB08-PB15.");
  // ENC3_0
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
8001834e:	30 3c       	mov	r12,3
80018350:	fe b0 f8 ae 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
80018354:	32 8c       	mov	r12,40
80018356:	fe b0 d2 29 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
8001835a:	ce eb       	rjmp	80018336 <irq_port1_line1+0xa>

8001835c <irq_port1_line0>:
8001835c:	d4 01       	pushm	lr
8001835e:	32 2c       	mov	r12,34
80018360:	fe b0 d2 18 	rcall	80012790 <gpio_get_pin_interrupt_flag>
80018364:	c3 91       	brne	800183d6 <irq_port1_line0+0x7a>
80018366:	32 3c       	mov	r12,35
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
80018368:	fe b0 d2 14 	rcall	80012790 <gpio_get_pin_interrupt_flag>
8001836c:	c2 e1       	brne	800183c8 <irq_port1_line0+0x6c>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
8001836e:	32 4c       	mov	r12,36
80018370:	fe b0 d2 10 	rcall	80012790 <gpio_get_pin_interrupt_flag>
80018374:	c2 31       	brne	800183ba <irq_port1_line0+0x5e>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
80018376:	32 5c       	mov	r12,37
80018378:	fe b0 d2 0c 	rcall	80012790 <gpio_get_pin_interrupt_flag>
8001837c:	c1 81       	brne	800183ac <irq_port1_line0+0x50>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
8001837e:	32 6c       	mov	r12,38
80018380:	fe b0 d2 08 	rcall	80012790 <gpio_get_pin_interrupt_flag>
80018384:	c0 d1       	brne	8001839e <irq_port1_line0+0x42>
    process_enc(2);
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
  }  
  // ENC2_1
  if(gpio_get_pin_interrupt_flag(ENC2_S1_PIN)) {
80018386:	32 7c       	mov	r12,39
80018388:	fe b0 d2 04 	rcall	80012790 <gpio_get_pin_interrupt_flag>
8001838c:	c0 70       	breq	8001839a <irq_port1_line0+0x3e>
    process_enc(2);
8001838e:	30 2c       	mov	r12,2
80018390:	fe b0 f8 8e 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S1_PIN);
80018394:	32 7c       	mov	r12,39
80018396:	fe b0 d2 09 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
  }
}
8001839a:	d4 02       	popm	lr
8001839c:	d6 03       	rete
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
    process_enc(2);
8001839e:	30 2c       	mov	r12,2
800183a0:	fe b0 f8 86 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
800183a4:	32 6c       	mov	r12,38
800183a6:	fe b0 d2 01 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
800183aa:	ce eb       	rjmp	80018386 <irq_port1_line0+0x2a>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
    process_enc(1);
800183ac:	30 1c       	mov	r12,1
800183ae:	fe b0 f8 7f 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
800183b2:	32 5c       	mov	r12,37
800183b4:	fe b0 d1 fa 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
800183b8:	ce 3b       	rjmp	8001837e <irq_port1_line0+0x22>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
    process_enc(1);
800183ba:	30 1c       	mov	r12,1
800183bc:	fe b0 f8 78 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
800183c0:	32 4c       	mov	r12,36
800183c2:	fe b0 d1 f3 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
800183c6:	cd 8b       	rjmp	80018376 <irq_port1_line0+0x1a>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
    process_enc(0);
800183c8:	30 0c       	mov	r12,0
800183ca:	fe b0 f8 71 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
800183ce:	32 3c       	mov	r12,35
800183d0:	fe b0 d1 ec 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
800183d4:	cc db       	rjmp	8001836e <irq_port1_line0+0x12>
__attribute__((__interrupt__))
static void irq_port1_line0(void) {
  // print_dbg("\r\b\interrupt on PB00-PB07.");
  // ENC0_0
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
800183d6:	30 0c       	mov	r12,0
800183d8:	fe b0 f8 6a 	rcall	800174ac <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
800183dc:	32 2c       	mov	r12,34
800183de:	fe b0 d1 e5 	rcall	800127a8 <gpio_clear_pin_interrupt_flag>
800183e2:	cc 2b       	rjmp	80018366 <irq_port1_line0+0xa>

800183e4 <alloc_mem>:
  print_dbg_hex(heapSize);

}

// allocate and return pointer
heap_t alloc_mem(u32 bytes) {
800183e4:	eb cd 40 c0 	pushm	r6-r7,lr
800183e8:	18 96       	mov	r6,r12
  print_dbg("\r\n allocating memory, bytes: 0x");
800183ea:	49 3c       	lddpc	r12,80018434 <alloc_mem+0x50>
800183ec:	fe b0 d5 d8 	rcall	80012f9c <print_dbg>
  print_dbg_hex(bytes);
800183f0:	0c 9c       	mov	r12,r6
800183f2:	fe b0 d5 fd 	rcall	80012fec <print_dbg_hex>

  print_dbg("\r\n location: 0x");
800183f6:	49 1c       	lddpc	r12,80018438 <alloc_mem+0x54>
800183f8:	fe b0 d5 d2 	rcall	80012f9c <print_dbg>
  print_dbg_hex(heapOffset);
800183fc:	e0 67 0b ac 	mov	r7,2988
80018400:	6e 0c       	ld.w	r12,r7[0x0]
80018402:	fe b0 d5 f5 	rcall	80012fec <print_dbg_hex>

  heap_t ret = pHeapStart + heapOffset;
80018406:	e0 68 0b a8 	mov	r8,2984

  u32 tmp = heapOffset + bytes;
8001840a:	70 0c       	ld.w	r12,r8[0x0]
  u8 mtmp = tmp % 4;
8001840c:	6e 08       	ld.w	r8,r7[0x0]
8001840e:	10 06       	add	r6,r8

  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
80018410:	f3 d6 c0 02 	bfextu	r9,r6,0x0,0x2
80018414:	f7 b6 01 fc 	subne	r6,-4
  }
  if (tmp < heapSize) {
80018418:	ed d9 e1 16 	subne	r6,r6,r9
8001841c:	e0 69 0b b0 	mov	r9,2992
80018420:	72 09       	ld.w	r9,r9[0x0]
    heapOffset = tmp;
80018422:	12 36       	cp.w	r6,r9
80018424:	f9 bc 02 ff 	movhs	r12,-1
  print_dbg_hex(bytes);

  print_dbg("\r\n location: 0x");
  print_dbg_hex(heapOffset);

  heap_t ret = pHeapStart + heapOffset;
80018428:	ef f6 3a 00 	st.wcs	r7[0x0],r6
    //    ret = pHeapStart + heapOffset;
  } else {
    ret = (heap_t)ALLOC_FAIL;
  }
  return ret;
}
8001842c:	f9 d8 e3 0c 	addcs	r12,r12,r8
80018430:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80018434:	80 02       	ld.sh	r2,r0[0x0]
80018436:	49 d0       	lddpc	r0,800184a8 <monome_grid_refresh>
80018438:	80 02       	ld.sh	r2,r0[0x0]
8001843a:	49 f0       	lddpc	r0,800184b4 <monome_grid_refresh+0xc>

8001843c <init_mem>:
8001843c:	eb cd 40 80 	pushm	r7,lr
80018440:	30 1c       	mov	r12,1
80018442:	fe b0 cd e3 	rcall	80012008 <smc_get_cs_size>
80018446:	fc 18 d0 00 	movh	r8,0xd000
8001844a:	30 19       	mov	r9,1


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
8001844c:	e0 6a 0b a8 	mov	r10,2984
static u32 heapSize;


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
80018450:	f2 0c 09 4c 	lsl	r12,r9,r12
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
80018454:	95 08       	st.w	r10[0x0],r8
80018456:	f8 08 00 09 	add	r9,r12,r8
8001845a:	e0 68 0b b4 	mov	r8,2996
  heapOffset = 0;
8001845e:	91 09       	st.w	r8[0x0],r9
static u32 heapSize;


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
80018460:	30 09       	mov	r9,0
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
  heapOffset = 0;
80018462:	e0 68 0b ac 	mov	r8,2988

  print_dbg("\r\n SRAM size: 0x");
80018466:	e0 67 0b b0 	mov	r7,2992
8001846a:	91 09       	st.w	r8[0x0],r9
  print_dbg_hex(heapSize);
8001846c:	8f 0c       	st.w	r7[0x0],r12
8001846e:	48 5c       	lddpc	r12,80018480 <init_mem+0x44>
80018470:	fe b0 d5 96 	rcall	80012f9c <print_dbg>

}
80018474:	6e 0c       	ld.w	r12,r7[0x0]
80018476:	fe b0 d5 bb 	rcall	80012fec <print_dbg_hex>
8001847a:	e3 cd 80 80 	ldm	sp++,r7,pc
8001847e:	d7 03       	nop
80018480:	80 02       	ld.sh	r2,r0[0x0]
80018482:	4a 00       	lddpc	r0,80018500 <monome_grid_refresh+0x58>

80018484 <read_serial_dummy>:
  u8 tilt;  // has tilt (??)  
} monomeDesc;


//// dummy functions
static void read_serial_dummy(void) { return; }
80018484:	5e fc       	retal	r12
80018486:	d7 03       	nop

80018488 <init_monome>:

//================================================
//----- extern function definitions

// init
void init_monome(void) {
80018488:	e0 68 31 64 	mov	r8,12644
8001848c:	48 4a       	lddpc	r10,8001849c <init_monome+0x14>
8001848e:	f0 c9 ff 00 	sub	r9,r8,-256
  u32 i;
  for(i=0; i<MONOME_MAX_LED_BYTES; i++) {
    monomeLedBuffer[i] = 0;
80018492:	10 aa       	st.w	r8++,r10
80018494:	12 38       	cp.w	r8,r9
  }
  //  print_dbg("\r\n finished monome class init");
}
80018496:	cf e1       	brne	80018492 <init_monome+0xa>
80018498:	5e fc       	retal	r12
8001849a:	d7 03       	nop
8001849c:	00 00       	add	r0,r0
	...

800184a0 <read_serial_40h>:
/// parse serial input from device
/// should be called when read is complete
/// (e.g. from usb transfer callback )

static void read_serial_40h(void) {
}
800184a0:	5e fc       	retal	r12

800184a2 <grid_map_40h>:
}


static void grid_map_40h(u8 x, u8 y, const u8* data) {
  // TODO : (use 8 row commands and ignore x/y)
}
800184a2:	5e fc       	retal	r12

800184a4 <ring_map_mext>:
/*   // TODO */
/* } */

static void ring_map_mext(u8 n, u8* data) {
  // TODO
}
800184a4:	5e fc       	retal	r12
800184a6:	d7 03       	nop

800184a8 <monome_grid_refresh>:
    return setup_mext();
  }
}

// check dirty flags and refresh leds
void monome_grid_refresh(void) {
800184a8:	eb cd 40 80 	pushm	r7,lr
  // may need to wait after each quad until tx transfer is complete
  u8 busy = ftdi_tx_busy();

  // check quad 0
  if( monomeFrameDirty & 0b0001 ) {
800184ac:	e0 67 0b cd 	mov	r7,3021
}

// check dirty flags and refresh leds
void monome_grid_refresh(void) {
  // may need to wait after each quad until tx transfer is complete
  u8 busy = ftdi_tx_busy();
800184b0:	e0 a0 12 d8 	rcall	8001aa60 <ftdi_tx_busy>
800184b4:	0f 88       	ld.ub	r8,r7[0x0]

  // check quad 0
  if( monomeFrameDirty & 0b0001 ) {
800184b6:	18 99       	mov	r9,r12
800184b8:	ed b8 00 00 	bld	r8,0x0
    (*monome_grid_map)(0, 0, monomeLedBuffer);
    monomeFrameDirty &= 0b1110;
    busy = 1;
  }
  // check quad 1
  if( monomeFrameDirty & 0b0010 ) {
800184bc:	c5 10       	breq	8001855e <monome_grid_refresh+0xb6>
800184be:	ed b8 00 01 	bld	r8,0x1
    if ( mdesc.cols > 8 ) {
800184c2:	c1 c1       	brne	800184fa <monome_grid_refresh+0x52>
800184c4:	31 0a       	mov	r10,16
800184c6:	f5 3b 00 08 	ld.ub	r11,r10[8]
800184ca:	30 8a       	mov	r10,8
800184cc:	f4 0b 18 00 	cp.b	r11,r10
800184d0:	e0 88 00 15 	brls	800184fa <monome_grid_refresh+0x52>
      while( busy ) { busy = ftdi_tx_busy(); }
800184d4:	58 09       	cp.w	r9,0
800184d6:	c0 40       	breq	800184de <monome_grid_refresh+0x36>
800184d8:	e0 a0 12 c4 	rcall	8001aa60 <ftdi_tx_busy>
      (*monome_grid_map)(8, 0, monomeLedBuffer + 8);
800184dc:	cf e1       	brne	800184d8 <monome_grid_refresh+0x30>
800184de:	e0 68 31 5c 	mov	r8,12636
800184e2:	e0 6a 31 64 	mov	r10,12644
800184e6:	70 08       	ld.w	r8,r8[0x0]
800184e8:	2f 8a       	sub	r10,-8
      monomeFrameDirty &= 0b1101;
800184ea:	30 0b       	mov	r11,0
800184ec:	30 8c       	mov	r12,8
800184ee:	5d 18       	icall	r8
800184f0:	0f 88       	ld.ub	r8,r7[0x0]
800184f2:	30 19       	mov	r9,1
      busy = 1;
    }
  }
  // check quad 2
  if( monomeFrameDirty &  0b0100 ) { 
800184f4:	e2 18 00 0d 	andl	r8,0xd,COH
800184f8:	ae 88       	st.b	r7[0x0],r8
    if( mdesc.rows > 8 ) {
800184fa:	ed b8 00 02 	bld	r8,0x2
800184fe:	c1 c1       	brne	80018536 <monome_grid_refresh+0x8e>
80018500:	31 0a       	mov	r10,16
80018502:	f5 3b 00 09 	ld.ub	r11,r10[9]
80018506:	30 8a       	mov	r10,8
80018508:	f4 0b 18 00 	cp.b	r11,r10
      while( busy ) { busy = ftdi_tx_busy(); }
8001850c:	e0 88 00 15 	brls	80018536 <monome_grid_refresh+0x8e>
80018510:	58 09       	cp.w	r9,0
80018512:	c0 40       	breq	8001851a <monome_grid_refresh+0x72>
      (*monome_grid_map)(0, 8, monomeLedBuffer + 128);
80018514:	e0 a0 12 a6 	rcall	8001aa60 <ftdi_tx_busy>
80018518:	cf e1       	brne	80018514 <monome_grid_refresh+0x6c>
8001851a:	e0 68 31 5c 	mov	r8,12636
8001851e:	e0 6a 31 64 	mov	r10,12644
      monomeFrameDirty &= 0b1011;
80018522:	70 08       	ld.w	r8,r8[0x0]
80018524:	28 0a       	sub	r10,-128
80018526:	30 8b       	mov	r11,8
80018528:	30 0c       	mov	r12,0
8001852a:	5d 18       	icall	r8
      busy = 1;
    }
  }
  // check quad 3
  if( monomeFrameDirty & 0b1000 ) {
8001852c:	0f 88       	ld.ub	r8,r7[0x0]
8001852e:	30 19       	mov	r9,1
80018530:	e2 18 00 0b 	andl	r8,0xb,COH
    if( (mdesc.rows > 8) && (mdesc.cols > 8) )  {
80018534:	ae 88       	st.b	r7[0x0],r8
80018536:	ed b8 00 03 	bld	r8,0x3
8001853a:	c0 91       	brne	8001854c <monome_grid_refresh+0xa4>
8001853c:	31 0a       	mov	r10,16
8001853e:	30 88       	mov	r8,8
80018540:	f5 3b 00 09 	ld.ub	r11,r10[9]
      (*monome_grid_map)(8, 8, monomeLedBuffer + 136);
      monomeFrameDirty &= 0b0111;
      busy = 1;
    }
  }
  while( busy ) { busy = ftdi_tx_busy(); }
80018544:	f0 0b 18 00 	cp.b	r11,r8
80018548:	e0 8b 00 1b 	brhi	8001857e <monome_grid_refresh+0xd6>
8001854c:	58 09       	cp.w	r9,0
8001854e:	c0 40       	breq	80018556 <monome_grid_refresh+0xae>
  // may need to wait after each quad until tx transfer is complete
  u8 busy = ftdi_tx_busy();

  // check quad 0
  if( monomeFrameDirty & 0b0001 ) {
    while( busy ) { busy = ftdi_tx_busy(); }
80018550:	e0 a0 12 88 	rcall	8001aa60 <ftdi_tx_busy>
80018554:	cf e1       	brne	80018550 <monome_grid_refresh+0xa8>
80018556:	e3 cd 80 80 	ldm	sp++,r7,pc
    (*monome_grid_map)(0, 0, monomeLedBuffer);
8001855a:	e0 a0 12 83 	rcall	8001aa60 <ftdi_tx_busy>
8001855e:	58 0c       	cp.w	r12,0
80018560:	cf d1       	brne	8001855a <monome_grid_refresh+0xb2>
80018562:	30 0b       	mov	r11,0
    monomeFrameDirty &= 0b1110;
80018564:	e0 68 31 5c 	mov	r8,12636
80018568:	e0 6a 31 64 	mov	r10,12644
8001856c:	70 08       	ld.w	r8,r8[0x0]
8001856e:	16 9c       	mov	r12,r11
      busy = 1;
    }
  }
  // check quad 3
  if( monomeFrameDirty & 0b1000 ) {
    if( (mdesc.rows > 8) && (mdesc.cols > 8) )  {
80018570:	5d 18       	icall	r8
80018572:	0f 88       	ld.ub	r8,r7[0x0]
80018574:	30 19       	mov	r9,1
80018576:	e2 18 00 0e 	andl	r8,0xe,COH
8001857a:	ae 88       	st.b	r7[0x0],r8
      while( busy ) { busy = ftdi_tx_busy(); }
8001857c:	ca 1b       	rjmp	800184be <monome_grid_refresh+0x16>
8001857e:	f5 3a 00 08 	ld.ub	r10,r10[8]
80018582:	f0 0a 18 00 	cp.b	r10,r8
      (*monome_grid_map)(8, 8, monomeLedBuffer + 136);
80018586:	fe 98 ff e3 	brls	8001854c <monome_grid_refresh+0xa4>
8001858a:	58 09       	cp.w	r9,0
8001858c:	c0 40       	breq	80018594 <monome_grid_refresh+0xec>
8001858e:	e0 a0 12 69 	rcall	8001aa60 <ftdi_tx_busy>
80018592:	cf e1       	brne	8001858e <monome_grid_refresh+0xe6>
80018594:	30 8b       	mov	r11,8
      monomeFrameDirty &= 0b0111;
80018596:	e0 68 31 5c 	mov	r8,12636
8001859a:	e0 6a 31 64 	mov	r10,12644
8001859e:	70 08       	ld.w	r8,r8[0x0]
800185a0:	f4 ca ff 78 	sub	r10,r10,-136
800185a4:	16 9c       	mov	r12,r11
800185a6:	5d 18       	icall	r8
800185a8:	0f 88       	ld.ub	r8,r7[0x0]
800185aa:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800185ae:	ae 88       	st.b	r7[0x0],r8
800185b0:	cd 0b       	rjmp	80018550 <monome_grid_refresh+0xa8>
800185b2:	d7 03       	nop

800185b4 <grid_map_mext>:

// update a whole frame
// . note that our input data is one byte per led!!
// this will hopefully help optimize operator routines,
// which cannot be called less often than refresh/tx, and are therefore prioritized.
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
800185b4:	eb cd 40 80 	pushm	r7,lr
  //  static u8 tx[11] = { 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
800185b8:	e0 68 0b dc 	mov	r8,3036
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
800185bc:	30 09       	mov	r9,0
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
  txBuf[1] = x;
  txBuf[2] = y;
800185be:	b0 ab       	st.b	r8[0x2],r11
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
800185c0:	b0 b9       	st.b	r8[0x3],r9
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
  //  static u8 tx[11] = { 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
800185c2:	31 4b       	mov	r11,20
  txBuf[1] = x;
800185c4:	b0 9c       	st.b	r8[0x1],r12
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
  //  static u8 tx[11] = { 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
800185c6:	b0 8b       	st.b	r8[0x0],r11
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800185c8:	14 9b       	mov	r11,r10
800185ca:	17 3c       	ld.ub	r12,r11++
800185cc:	f2 0c 18 00 	cp.b	r12,r9
800185d0:	5f 1c       	srne	r12
800185d2:	b0 bc       	st.b	r8[0x3],r12
800185d4:	17 3e       	ld.ub	lr,r11++
800185d6:	f2 0e 18 00 	cp.b	lr,r9
800185da:	f9 be 01 02 	movne	lr,2
800185de:	f9 be 00 00 	moveq	lr,0
800185e2:	1c 4c       	or	r12,lr
800185e4:	b0 bc       	st.b	r8[0x3],r12
800185e6:	17 3e       	ld.ub	lr,r11++
800185e8:	f2 0e 18 00 	cp.b	lr,r9
800185ec:	f9 be 01 04 	movne	lr,4
800185f0:	f9 be 00 00 	moveq	lr,0
800185f4:	1c 4c       	or	r12,lr
800185f6:	b0 bc       	st.b	r8[0x3],r12
800185f8:	17 3e       	ld.ub	lr,r11++
800185fa:	f2 0e 18 00 	cp.b	lr,r9
800185fe:	f9 be 01 08 	movne	lr,8
80018602:	f9 be 00 00 	moveq	lr,0
80018606:	1c 4c       	or	r12,lr
80018608:	b0 bc       	st.b	r8[0x3],r12
8001860a:	17 3e       	ld.ub	lr,r11++
8001860c:	f2 0e 18 00 	cp.b	lr,r9
80018610:	f9 be 01 10 	movne	lr,16
80018614:	f9 be 00 00 	moveq	lr,0
80018618:	1c 4c       	or	r12,lr
8001861a:	b0 bc       	st.b	r8[0x3],r12
8001861c:	17 3e       	ld.ub	lr,r11++
8001861e:	f2 0e 18 00 	cp.b	lr,r9
80018622:	f9 be 01 20 	movne	lr,32
80018626:	f9 be 00 00 	moveq	lr,0
8001862a:	1c 4c       	or	r12,lr
8001862c:	b0 bc       	st.b	r8[0x3],r12
8001862e:	17 8e       	ld.ub	lr,r11[0x0]
80018630:	f2 0e 18 00 	cp.b	lr,r9
80018634:	f9 be 01 40 	movne	lr,64
80018638:	f9 be 00 00 	moveq	lr,0
8001863c:	1c 4c       	or	r12,lr
8001863e:	b0 bc       	st.b	r8[0x3],r12
80018640:	17 9b       	ld.ub	r11,r11[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018642:	b0 c9       	st.b	r8[0x4],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018644:	f2 0b 18 00 	cp.b	r11,r9
80018648:	5f 1b       	srne	r11
8001864a:	f9 eb 10 7c 	or	r12,r12,r11<<0x7
8001864e:	b0 bc       	st.b	r8[0x3],r12
80018650:	f4 cc ff f8 	sub	r12,r10,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018654:	f8 cb ff f8 	sub	r11,r12,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018658:	17 8e       	ld.ub	lr,r11[0x0]
8001865a:	f2 0e 18 00 	cp.b	lr,r9
8001865e:	5f 1e       	srne	lr
80018660:	b0 ce       	st.b	r8[0x4],lr
80018662:	f5 37 00 11 	ld.ub	r7,r10[17]
80018666:	f2 07 18 00 	cp.b	r7,r9
8001866a:	f9 b7 01 02 	movne	r7,2
8001866e:	f9 b7 00 00 	moveq	r7,0
80018672:	0e 4e       	or	lr,r7
80018674:	b0 ce       	st.b	r8[0x4],lr
80018676:	f5 37 00 12 	ld.ub	r7,r10[18]
8001867a:	f2 07 18 00 	cp.b	r7,r9
8001867e:	f9 b7 01 04 	movne	r7,4
80018682:	f9 b7 00 00 	moveq	r7,0
80018686:	0e 4e       	or	lr,r7
80018688:	b0 ce       	st.b	r8[0x4],lr
8001868a:	f5 37 00 13 	ld.ub	r7,r10[19]
8001868e:	f2 07 18 00 	cp.b	r7,r9
80018692:	f9 b7 01 08 	movne	r7,8
80018696:	f9 b7 00 00 	moveq	r7,0
8001869a:	0e 4e       	or	lr,r7
8001869c:	b0 ce       	st.b	r8[0x4],lr
8001869e:	f5 37 00 14 	ld.ub	r7,r10[20]
800186a2:	f2 07 18 00 	cp.b	r7,r9
800186a6:	f9 b7 01 10 	movne	r7,16
800186aa:	f9 b7 00 00 	moveq	r7,0
800186ae:	0e 4e       	or	lr,r7
800186b0:	b0 ce       	st.b	r8[0x4],lr
800186b2:	f5 37 00 15 	ld.ub	r7,r10[21]
800186b6:	f2 07 18 00 	cp.b	r7,r9
800186ba:	f9 b7 01 20 	movne	r7,32
800186be:	f9 b7 00 00 	moveq	r7,0
800186c2:	0e 4e       	or	lr,r7
800186c4:	b0 ce       	st.b	r8[0x4],lr
      data++;
800186c6:	2e aa       	sub	r10,-22
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800186c8:	15 87       	ld.ub	r7,r10[0x0]
800186ca:	f2 07 18 00 	cp.b	r7,r9
800186ce:	f9 b7 01 40 	movne	r7,64
800186d2:	f9 b7 00 00 	moveq	r7,0
800186d6:	0e 4e       	or	lr,r7
800186d8:	b0 ce       	st.b	r8[0x4],lr
800186da:	15 9a       	ld.ub	r10,r10[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
800186dc:	b0 d9       	st.b	r8[0x5],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800186de:	f2 0a 18 00 	cp.b	r10,r9
800186e2:	5f 1a       	srne	r10
800186e4:	fd ea 10 7e 	or	lr,lr,r10<<0x7
800186e8:	f6 ca ff f8 	sub	r10,r11,-8
800186ec:	b0 ce       	st.b	r8[0x4],lr
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
800186ee:	f4 cb ff f8 	sub	r11,r10,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800186f2:	17 8e       	ld.ub	lr,r11[0x0]
800186f4:	f2 0e 18 00 	cp.b	lr,r9
800186f8:	5f 1e       	srne	lr
800186fa:	b0 de       	st.b	r8[0x5],lr
800186fc:	f9 37 00 19 	ld.ub	r7,r12[25]
80018700:	f2 07 18 00 	cp.b	r7,r9
80018704:	f9 b7 01 02 	movne	r7,2
80018708:	f9 b7 00 00 	moveq	r7,0
8001870c:	0e 4e       	or	lr,r7
8001870e:	b0 de       	st.b	r8[0x5],lr
80018710:	f9 37 00 1a 	ld.ub	r7,r12[26]
80018714:	f2 07 18 00 	cp.b	r7,r9
80018718:	f9 b7 01 04 	movne	r7,4
8001871c:	f9 b7 00 00 	moveq	r7,0
80018720:	0e 4e       	or	lr,r7
80018722:	b0 de       	st.b	r8[0x5],lr
80018724:	f9 37 00 1b 	ld.ub	r7,r12[27]
80018728:	f2 07 18 00 	cp.b	r7,r9
8001872c:	f9 b7 01 08 	movne	r7,8
80018730:	f9 b7 00 00 	moveq	r7,0
80018734:	0e 4e       	or	lr,r7
80018736:	b0 de       	st.b	r8[0x5],lr
80018738:	f9 37 00 1c 	ld.ub	r7,r12[28]
8001873c:	f2 07 18 00 	cp.b	r7,r9
80018740:	f9 b7 01 10 	movne	r7,16
80018744:	f9 b7 00 00 	moveq	r7,0
80018748:	0e 4e       	or	lr,r7
8001874a:	b0 de       	st.b	r8[0x5],lr
8001874c:	f9 37 00 1d 	ld.ub	r7,r12[29]
80018750:	f2 07 18 00 	cp.b	r7,r9
80018754:	f9 b7 01 20 	movne	r7,32
80018758:	f9 b7 00 00 	moveq	r7,0
8001875c:	0e 4e       	or	lr,r7
8001875e:	b0 de       	st.b	r8[0x5],lr
      data++;
80018760:	2e 2c       	sub	r12,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018762:	19 87       	ld.ub	r7,r12[0x0]
80018764:	f2 07 18 00 	cp.b	r7,r9
80018768:	f9 b7 01 40 	movne	r7,64
8001876c:	f9 b7 00 00 	moveq	r7,0
80018770:	0e 4e       	or	lr,r7
80018772:	b0 de       	st.b	r8[0x5],lr
80018774:	19 9c       	ld.ub	r12,r12[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018776:	b0 e9       	st.b	r8[0x6],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018778:	f2 0c 18 00 	cp.b	r12,r9
8001877c:	5f 1c       	srne	r12
8001877e:	fd ec 10 7e 	or	lr,lr,r12<<0x7
80018782:	2f 8b       	sub	r11,-8
80018784:	b0 de       	st.b	r8[0x5],lr
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018786:	f6 cc ff f8 	sub	r12,r11,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
8001878a:	19 8e       	ld.ub	lr,r12[0x0]
8001878c:	f2 0e 18 00 	cp.b	lr,r9
80018790:	5f 1e       	srne	lr
80018792:	b0 ee       	st.b	r8[0x6],lr
80018794:	f5 37 00 19 	ld.ub	r7,r10[25]
80018798:	f2 07 18 00 	cp.b	r7,r9
8001879c:	f9 b7 01 02 	movne	r7,2
800187a0:	f9 b7 00 00 	moveq	r7,0
800187a4:	0e 4e       	or	lr,r7
800187a6:	b0 ee       	st.b	r8[0x6],lr
800187a8:	f5 37 00 1a 	ld.ub	r7,r10[26]
800187ac:	f2 07 18 00 	cp.b	r7,r9
800187b0:	f9 b7 01 04 	movne	r7,4
800187b4:	f9 b7 00 00 	moveq	r7,0
800187b8:	0e 4e       	or	lr,r7
800187ba:	b0 ee       	st.b	r8[0x6],lr
800187bc:	f5 37 00 1b 	ld.ub	r7,r10[27]
800187c0:	f2 07 18 00 	cp.b	r7,r9
800187c4:	f9 b7 01 08 	movne	r7,8
800187c8:	f9 b7 00 00 	moveq	r7,0
800187cc:	0e 4e       	or	lr,r7
800187ce:	b0 ee       	st.b	r8[0x6],lr
800187d0:	f5 37 00 1c 	ld.ub	r7,r10[28]
800187d4:	f2 07 18 00 	cp.b	r7,r9
800187d8:	f9 b7 01 10 	movne	r7,16
800187dc:	f9 b7 00 00 	moveq	r7,0
800187e0:	0e 4e       	or	lr,r7
800187e2:	b0 ee       	st.b	r8[0x6],lr
800187e4:	f5 37 00 1d 	ld.ub	r7,r10[29]
800187e8:	f2 07 18 00 	cp.b	r7,r9
800187ec:	f9 b7 01 20 	movne	r7,32
800187f0:	f9 b7 00 00 	moveq	r7,0
800187f4:	0e 4e       	or	lr,r7
800187f6:	b0 ee       	st.b	r8[0x6],lr
      data++;
800187f8:	2e 2a       	sub	r10,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800187fa:	15 87       	ld.ub	r7,r10[0x0]
800187fc:	f2 07 18 00 	cp.b	r7,r9
80018800:	f9 b7 01 40 	movne	r7,64
80018804:	f9 b7 00 00 	moveq	r7,0
80018808:	0e 4e       	or	lr,r7
8001880a:	b0 ee       	st.b	r8[0x6],lr
8001880c:	15 9a       	ld.ub	r10,r10[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
8001880e:	b0 f9       	st.b	r8[0x7],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018810:	f2 0a 18 00 	cp.b	r10,r9
80018814:	5f 1a       	srne	r10
80018816:	fd ea 10 7e 	or	lr,lr,r10<<0x7
8001881a:	2f 8c       	sub	r12,-8
8001881c:	b0 ee       	st.b	r8[0x6],lr
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
8001881e:	f8 ca ff f8 	sub	r10,r12,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018822:	15 8e       	ld.ub	lr,r10[0x0]
80018824:	f2 0e 18 00 	cp.b	lr,r9
80018828:	5f 1e       	srne	lr
8001882a:	b0 fe       	st.b	r8[0x7],lr
8001882c:	f7 37 00 19 	ld.ub	r7,r11[25]
80018830:	f2 07 18 00 	cp.b	r7,r9
80018834:	f9 b7 01 02 	movne	r7,2
80018838:	f9 b7 00 00 	moveq	r7,0
8001883c:	0e 4e       	or	lr,r7
8001883e:	b0 fe       	st.b	r8[0x7],lr
80018840:	f7 37 00 1a 	ld.ub	r7,r11[26]
80018844:	f2 07 18 00 	cp.b	r7,r9
80018848:	f9 b7 01 04 	movne	r7,4
8001884c:	f9 b7 00 00 	moveq	r7,0
80018850:	0e 4e       	or	lr,r7
80018852:	b0 fe       	st.b	r8[0x7],lr
80018854:	f7 37 00 1b 	ld.ub	r7,r11[27]
80018858:	f2 07 18 00 	cp.b	r7,r9
8001885c:	f9 b7 01 08 	movne	r7,8
80018860:	f9 b7 00 00 	moveq	r7,0
80018864:	0e 4e       	or	lr,r7
80018866:	b0 fe       	st.b	r8[0x7],lr
80018868:	f7 37 00 1c 	ld.ub	r7,r11[28]
8001886c:	f2 07 18 00 	cp.b	r7,r9
80018870:	f9 b7 01 10 	movne	r7,16
80018874:	f9 b7 00 00 	moveq	r7,0
80018878:	0e 4e       	or	lr,r7
8001887a:	b0 fe       	st.b	r8[0x7],lr
8001887c:	f7 37 00 1d 	ld.ub	r7,r11[29]
80018880:	f2 07 18 00 	cp.b	r7,r9
80018884:	f9 b7 01 20 	movne	r7,32
80018888:	f9 b7 00 00 	moveq	r7,0
8001888c:	0e 4e       	or	lr,r7
8001888e:	b0 fe       	st.b	r8[0x7],lr
      data++;
80018890:	2e 2b       	sub	r11,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018892:	17 87       	ld.ub	r7,r11[0x0]
80018894:	f2 07 18 00 	cp.b	r7,r9
80018898:	f9 b7 01 40 	movne	r7,64
8001889c:	f9 b7 00 00 	moveq	r7,0
800188a0:	0e 4e       	or	lr,r7
800188a2:	b0 fe       	st.b	r8[0x7],lr
800188a4:	17 9b       	ld.ub	r11,r11[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
800188a6:	f1 69 00 08 	st.b	r8[8],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800188aa:	f2 0b 18 00 	cp.b	r11,r9
800188ae:	5f 1b       	srne	r11
800188b0:	fd eb 10 7e 	or	lr,lr,r11<<0x7
800188b4:	2f 8a       	sub	r10,-8
800188b6:	b0 fe       	st.b	r8[0x7],lr
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
800188b8:	f4 cb ff f8 	sub	r11,r10,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800188bc:	17 8e       	ld.ub	lr,r11[0x0]
800188be:	f2 0e 18 00 	cp.b	lr,r9
800188c2:	5f 1e       	srne	lr
800188c4:	f1 6e 00 08 	st.b	r8[8],lr
800188c8:	f9 37 00 19 	ld.ub	r7,r12[25]
800188cc:	f2 07 18 00 	cp.b	r7,r9
800188d0:	f9 b7 01 02 	movne	r7,2
800188d4:	f9 b7 00 00 	moveq	r7,0
800188d8:	0e 4e       	or	lr,r7
800188da:	f1 6e 00 08 	st.b	r8[8],lr
800188de:	f9 37 00 1a 	ld.ub	r7,r12[26]
800188e2:	f2 07 18 00 	cp.b	r7,r9
800188e6:	f9 b7 01 04 	movne	r7,4
800188ea:	f9 b7 00 00 	moveq	r7,0
800188ee:	0e 4e       	or	lr,r7
800188f0:	f1 6e 00 08 	st.b	r8[8],lr
800188f4:	f9 37 00 1b 	ld.ub	r7,r12[27]
800188f8:	f2 07 18 00 	cp.b	r7,r9
800188fc:	f9 b7 01 08 	movne	r7,8
80018900:	f9 b7 00 00 	moveq	r7,0
80018904:	0e 4e       	or	lr,r7
80018906:	f1 6e 00 08 	st.b	r8[8],lr
8001890a:	f9 37 00 1c 	ld.ub	r7,r12[28]
8001890e:	f2 07 18 00 	cp.b	r7,r9
80018912:	f9 b7 01 10 	movne	r7,16
80018916:	f9 b7 00 00 	moveq	r7,0
8001891a:	0e 4e       	or	lr,r7
8001891c:	f1 6e 00 08 	st.b	r8[8],lr
80018920:	f9 37 00 1d 	ld.ub	r7,r12[29]
80018924:	f2 07 18 00 	cp.b	r7,r9
80018928:	f9 b7 01 20 	movne	r7,32
8001892c:	f9 b7 00 00 	moveq	r7,0
80018930:	0e 4e       	or	lr,r7
80018932:	f1 6e 00 08 	st.b	r8[8],lr
      data++;
80018936:	2e 2c       	sub	r12,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018938:	19 87       	ld.ub	r7,r12[0x0]
8001893a:	f2 07 18 00 	cp.b	r7,r9
8001893e:	f9 b7 01 40 	movne	r7,64
80018942:	f9 b7 00 00 	moveq	r7,0
80018946:	0e 4e       	or	lr,r7
80018948:	f1 6e 00 08 	st.b	r8[8],lr
8001894c:	19 9c       	ld.ub	r12,r12[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
8001894e:	f1 69 00 09 	st.b	r8[9],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018952:	f2 0c 18 00 	cp.b	r12,r9
80018956:	5f 1c       	srne	r12
80018958:	fd ec 10 7e 	or	lr,lr,r12<<0x7
8001895c:	2f 8b       	sub	r11,-8
8001895e:	f1 6e 00 08 	st.b	r8[8],lr
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018962:	f6 cc ff f8 	sub	r12,r11,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018966:	19 8e       	ld.ub	lr,r12[0x0]
80018968:	f2 0e 18 00 	cp.b	lr,r9
8001896c:	5f 1e       	srne	lr
8001896e:	f1 6e 00 09 	st.b	r8[9],lr
80018972:	f5 37 00 19 	ld.ub	r7,r10[25]
80018976:	f2 07 18 00 	cp.b	r7,r9
8001897a:	f9 b7 01 02 	movne	r7,2
8001897e:	f9 b7 00 00 	moveq	r7,0
80018982:	0e 4e       	or	lr,r7
80018984:	f1 6e 00 09 	st.b	r8[9],lr
80018988:	f5 37 00 1a 	ld.ub	r7,r10[26]
8001898c:	f2 07 18 00 	cp.b	r7,r9
80018990:	f9 b7 01 04 	movne	r7,4
80018994:	f9 b7 00 00 	moveq	r7,0
80018998:	0e 4e       	or	lr,r7
8001899a:	f1 6e 00 09 	st.b	r8[9],lr
8001899e:	f5 37 00 1b 	ld.ub	r7,r10[27]
800189a2:	f2 07 18 00 	cp.b	r7,r9
800189a6:	f9 b7 01 08 	movne	r7,8
800189aa:	f9 b7 00 00 	moveq	r7,0
800189ae:	0e 4e       	or	lr,r7
800189b0:	f1 6e 00 09 	st.b	r8[9],lr
800189b4:	f5 37 00 1c 	ld.ub	r7,r10[28]
800189b8:	f2 07 18 00 	cp.b	r7,r9
800189bc:	f9 b7 01 10 	movne	r7,16
800189c0:	f9 b7 00 00 	moveq	r7,0
800189c4:	0e 4e       	or	lr,r7
800189c6:	f1 6e 00 09 	st.b	r8[9],lr
800189ca:	f5 37 00 1d 	ld.ub	r7,r10[29]
800189ce:	f2 07 18 00 	cp.b	r7,r9
800189d2:	f9 b7 01 20 	movne	r7,32
800189d6:	f9 b7 00 00 	moveq	r7,0
800189da:	0e 4e       	or	lr,r7
800189dc:	f1 6e 00 09 	st.b	r8[9],lr
      data++;
800189e0:	2e 2a       	sub	r10,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800189e2:	15 87       	ld.ub	r7,r10[0x0]
800189e4:	f2 07 18 00 	cp.b	r7,r9
800189e8:	f9 b7 01 40 	movne	r7,64
800189ec:	f9 b7 00 00 	moveq	r7,0
800189f0:	0e 4e       	or	lr,r7
800189f2:	f1 6e 00 09 	st.b	r8[9],lr
800189f6:	15 9a       	ld.ub	r10,r10[0x1]
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
800189f8:	f1 69 00 0a 	st.b	r8[10],r9
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
800189fc:	f2 0a 18 00 	cp.b	r10,r9
80018a00:	5f 1a       	srne	r10
80018a02:	fd ea 10 7e 	or	lr,lr,r10<<0x7
80018a06:	f1 6e 00 09 	st.b	r8[9],lr
80018a0a:	f9 3a 00 10 	ld.ub	r10,r12[16]
80018a0e:	f2 0a 18 00 	cp.b	r10,r9
80018a12:	5f 1a       	srne	r10
80018a14:	f1 6a 00 0a 	st.b	r8[10],r10
80018a18:	f7 3c 00 19 	ld.ub	r12,r11[25]
80018a1c:	f2 0c 18 00 	cp.b	r12,r9
80018a20:	f9 bc 01 02 	movne	r12,2
80018a24:	f9 bc 00 00 	moveq	r12,0
80018a28:	18 4a       	or	r10,r12
80018a2a:	f1 6a 00 0a 	st.b	r8[10],r10
80018a2e:	f7 3c 00 1a 	ld.ub	r12,r11[26]
80018a32:	f2 0c 18 00 	cp.b	r12,r9
80018a36:	f9 bc 01 04 	movne	r12,4
80018a3a:	f9 bc 00 00 	moveq	r12,0
80018a3e:	18 4a       	or	r10,r12
80018a40:	f1 6a 00 0a 	st.b	r8[10],r10
80018a44:	f7 3c 00 1b 	ld.ub	r12,r11[27]
80018a48:	f2 0c 18 00 	cp.b	r12,r9
80018a4c:	f9 bc 01 08 	movne	r12,8
80018a50:	f9 bc 00 00 	moveq	r12,0
80018a54:	18 4a       	or	r10,r12
80018a56:	f1 6a 00 0a 	st.b	r8[10],r10
80018a5a:	f7 3c 00 1c 	ld.ub	r12,r11[28]
80018a5e:	f2 0c 18 00 	cp.b	r12,r9
80018a62:	f9 bc 01 10 	movne	r12,16
80018a66:	f9 bc 00 00 	moveq	r12,0
80018a6a:	18 4a       	or	r10,r12
80018a6c:	f1 6a 00 0a 	st.b	r8[10],r10
80018a70:	f7 3c 00 1d 	ld.ub	r12,r11[29]
80018a74:	f2 0c 18 00 	cp.b	r12,r9
80018a78:	f9 bc 01 20 	movne	r12,32
80018a7c:	f9 bc 00 00 	moveq	r12,0
80018a80:	18 4a       	or	r10,r12
80018a82:	f1 6a 00 0a 	st.b	r8[10],r10
      data++;
80018a86:	2e 2b       	sub	r11,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018a88:	17 8e       	ld.ub	lr,r11[0x0]
80018a8a:	f2 0e 18 00 	cp.b	lr,r9
80018a8e:	f9 be 01 40 	movne	lr,64
80018a92:	f9 be 00 00 	moveq	lr,0
80018a96:	1c 4a       	or	r10,lr
80018a98:	f1 6a 00 0a 	st.b	r8[10],r10
80018a9c:	17 9b       	ld.ub	r11,r11[0x1]
80018a9e:	f2 0b 18 00 	cp.b	r11,r9
80018aa2:	5f 19       	srne	r9
80018aa4:	f5 e9 10 7a 	or	r10,r10,r9<<0x7
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 3);
80018aa8:	10 9c       	mov	r12,r8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018aaa:	f1 6a 00 0a 	st.b	r8[10],r10
80018aae:	e0 6a 0b ce 	mov	r10,3022
80018ab2:	2f 58       	sub	r8,-11
80018ab4:	30 89       	mov	r9,8
80018ab6:	b4 89       	st.b	r10[0x0],r9
80018ab8:	e0 6a 0b d8 	mov	r10,3032
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 3);
80018abc:	95 08       	st.w	r10[0x0],r8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018abe:	e0 68 0b cc 	mov	r8,3020
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 3);
80018ac2:	30 bb       	mov	r11,11
}
80018ac4:	b0 89       	st.b	r8[0x0],r9
80018ac6:	e0 a0 10 2b 	rcall	8001ab1c <ftdi_write>
80018aca:	e3 cd 80 80 	ldm	sp++,r7,pc
80018ace:	d7 03       	nop

80018ad0 <grid_map_series>:
80018ad0:	d4 21       	pushm	r4-r7,lr
80018ad2:	30 88       	mov	r8,8
80018ad4:	f0 0c 18 00 	cp.b	r12,r8
80018ad8:	5f b9       	srhi	r9
80018ada:	e0 6c 0b dc 	mov	r12,3036
  static u8 * ptx;
  static u8 i, j;
  // command (upper nibble)
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );
80018ade:	f0 0b 18 00 	cp.b	r11,r8
80018ae2:	e0 8b 02 7d 	brhi	80018fdc <grid_map_series+0x50c>
80018ae6:	ea 19 ff ff 	orh	r9,0xffff
80018aea:	e8 19 ff 80 	orl	r9,0xff80

  // pointer to tx data
  ptx = txBuf + 1;
80018aee:	e0 6e 0b c8 	mov	lr,3016
  static u8 * ptx;
  static u8 i, j;
  // command (upper nibble)
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );
80018af2:	18 c9       	st.b	r12++,r9

  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80018af4:	e0 67 0b d0 	mov	r7,3024
80018af8:	30 08       	mov	r8,0
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );

  // pointer to tx data
  ptx = txBuf + 1;
80018afa:	9d 0c       	st.w	lr[0x0],r12
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80018afc:	ae 88       	st.b	r7[0x0],r8
80018afe:	18 9b       	mov	r11,r12
    *ptx = 0;
80018b00:	30 08       	mov	r8,0
80018b02:	b6 88       	st.b	r11[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018b04:	14 99       	mov	r9,r10
80018b06:	13 3c       	ld.ub	r12,r9++
80018b08:	f0 0c 18 00 	cp.b	r12,r8
80018b0c:	5f 1c       	srne	r12
80018b0e:	b6 8c       	st.b	r11[0x0],r12
80018b10:	13 36       	ld.ub	r6,r9++
80018b12:	f0 06 18 00 	cp.b	r6,r8
80018b16:	f9 b6 01 02 	movne	r6,2
80018b1a:	f9 b6 00 00 	moveq	r6,0
80018b1e:	0c 4c       	or	r12,r6
80018b20:	b6 8c       	st.b	r11[0x0],r12
80018b22:	13 36       	ld.ub	r6,r9++
80018b24:	f0 06 18 00 	cp.b	r6,r8
80018b28:	f9 b6 01 04 	movne	r6,4
80018b2c:	f9 b6 00 00 	moveq	r6,0
80018b30:	0c 4c       	or	r12,r6
80018b32:	b6 8c       	st.b	r11[0x0],r12
80018b34:	13 36       	ld.ub	r6,r9++
80018b36:	f0 06 18 00 	cp.b	r6,r8
80018b3a:	f9 b6 01 08 	movne	r6,8
80018b3e:	f9 b6 00 00 	moveq	r6,0
80018b42:	0c 4c       	or	r12,r6
80018b44:	b6 8c       	st.b	r11[0x0],r12
80018b46:	13 36       	ld.ub	r6,r9++
80018b48:	f0 06 18 00 	cp.b	r6,r8
80018b4c:	f9 b6 01 10 	movne	r6,16
80018b50:	f9 b6 00 00 	moveq	r6,0
80018b54:	0c 4c       	or	r12,r6
80018b56:	b6 8c       	st.b	r11[0x0],r12
80018b58:	13 36       	ld.ub	r6,r9++
80018b5a:	f0 06 18 00 	cp.b	r6,r8
80018b5e:	f9 b6 01 20 	movne	r6,32
80018b62:	f9 b6 00 00 	moveq	r6,0
80018b66:	0c 4c       	or	r12,r6
80018b68:	b6 8c       	st.b	r11[0x0],r12
80018b6a:	13 86       	ld.ub	r6,r9[0x0]
80018b6c:	f0 06 18 00 	cp.b	r6,r8
80018b70:	f9 b6 01 40 	movne	r6,64
80018b74:	f9 b6 00 00 	moveq	r6,0
80018b78:	0c 4c       	or	r12,r6
80018b7a:	b6 8c       	st.b	r11[0x0],r12
80018b7c:	13 99       	ld.ub	r9,r9[0x1]
80018b7e:	f0 09 18 00 	cp.b	r9,r8
80018b82:	5f 19       	srne	r9
80018b84:	f9 e9 10 7c 	or	r12,r12,r9<<0x7
80018b88:	16 99       	mov	r9,r11
80018b8a:	12 cc       	st.b	r9++,r12
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018b8c:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018b8e:	f4 cc ff f8 	sub	r12,r10,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018b92:	f8 c6 ff f8 	sub	r6,r12,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018b96:	0d 85       	ld.ub	r5,r6[0x0]
80018b98:	f0 05 18 00 	cp.b	r5,r8
80018b9c:	5f 15       	srne	r5
80018b9e:	b2 85       	st.b	r9[0x0],r5
80018ba0:	f5 34 00 11 	ld.ub	r4,r10[17]
80018ba4:	f0 04 18 00 	cp.b	r4,r8
80018ba8:	f9 b4 01 02 	movne	r4,2
80018bac:	f9 b4 00 00 	moveq	r4,0
80018bb0:	08 45       	or	r5,r4
80018bb2:	b2 85       	st.b	r9[0x0],r5
80018bb4:	f5 34 00 12 	ld.ub	r4,r10[18]
80018bb8:	f0 04 18 00 	cp.b	r4,r8
80018bbc:	f9 b4 01 04 	movne	r4,4
80018bc0:	f9 b4 00 00 	moveq	r4,0
80018bc4:	08 45       	or	r5,r4
80018bc6:	b2 85       	st.b	r9[0x0],r5
80018bc8:	f5 34 00 13 	ld.ub	r4,r10[19]
80018bcc:	f0 04 18 00 	cp.b	r4,r8
80018bd0:	f9 b4 01 08 	movne	r4,8
80018bd4:	f9 b4 00 00 	moveq	r4,0
80018bd8:	08 45       	or	r5,r4
80018bda:	b2 85       	st.b	r9[0x0],r5
80018bdc:	f5 34 00 14 	ld.ub	r4,r10[20]
80018be0:	f0 04 18 00 	cp.b	r4,r8
80018be4:	f9 b4 01 10 	movne	r4,16
80018be8:	f9 b4 00 00 	moveq	r4,0
80018bec:	08 45       	or	r5,r4
80018bee:	b2 85       	st.b	r9[0x0],r5
80018bf0:	f5 34 00 15 	ld.ub	r4,r10[21]
80018bf4:	f0 04 18 00 	cp.b	r4,r8
80018bf8:	f9 b4 01 20 	movne	r4,32
80018bfc:	f9 b4 00 00 	moveq	r4,0
80018c00:	08 45       	or	r5,r4
80018c02:	b2 85       	st.b	r9[0x0],r5
      data++;
80018c04:	2e aa       	sub	r10,-22
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018c06:	15 84       	ld.ub	r4,r10[0x0]
80018c08:	f0 04 18 00 	cp.b	r4,r8
80018c0c:	f9 b4 01 40 	movne	r4,64
80018c10:	f9 b4 00 00 	moveq	r4,0
80018c14:	08 45       	or	r5,r4
80018c16:	b2 85       	st.b	r9[0x0],r5
80018c18:	15 9a       	ld.ub	r10,r10[0x1]
80018c1a:	f0 0a 18 00 	cp.b	r10,r8
80018c1e:	5f 1a       	srne	r10
80018c20:	eb ea 10 75 	or	r5,r5,r10<<0x7
80018c24:	12 c5       	st.b	r9++,r5
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018c26:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018c28:	ec ca ff f8 	sub	r10,r6,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018c2c:	f4 c6 ff f8 	sub	r6,r10,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018c30:	0d 85       	ld.ub	r5,r6[0x0]
80018c32:	f0 05 18 00 	cp.b	r5,r8
80018c36:	5f 15       	srne	r5
80018c38:	b2 85       	st.b	r9[0x0],r5
80018c3a:	f9 34 00 19 	ld.ub	r4,r12[25]
80018c3e:	f0 04 18 00 	cp.b	r4,r8
80018c42:	f9 b4 01 02 	movne	r4,2
80018c46:	f9 b4 00 00 	moveq	r4,0
80018c4a:	08 45       	or	r5,r4
80018c4c:	b2 85       	st.b	r9[0x0],r5
80018c4e:	f9 34 00 1a 	ld.ub	r4,r12[26]
80018c52:	f0 04 18 00 	cp.b	r4,r8
80018c56:	f9 b4 01 04 	movne	r4,4
80018c5a:	f9 b4 00 00 	moveq	r4,0
80018c5e:	08 45       	or	r5,r4
80018c60:	b2 85       	st.b	r9[0x0],r5
80018c62:	f9 34 00 1b 	ld.ub	r4,r12[27]
80018c66:	f0 04 18 00 	cp.b	r4,r8
80018c6a:	f9 b4 01 08 	movne	r4,8
80018c6e:	f9 b4 00 00 	moveq	r4,0
80018c72:	08 45       	or	r5,r4
80018c74:	b2 85       	st.b	r9[0x0],r5
80018c76:	f9 34 00 1c 	ld.ub	r4,r12[28]
80018c7a:	f0 04 18 00 	cp.b	r4,r8
80018c7e:	f9 b4 01 10 	movne	r4,16
80018c82:	f9 b4 00 00 	moveq	r4,0
80018c86:	08 45       	or	r5,r4
80018c88:	b2 85       	st.b	r9[0x0],r5
80018c8a:	f9 34 00 1d 	ld.ub	r4,r12[29]
80018c8e:	f0 04 18 00 	cp.b	r4,r8
80018c92:	f9 b4 01 20 	movne	r4,32
80018c96:	f9 b4 00 00 	moveq	r4,0
80018c9a:	08 45       	or	r5,r4
80018c9c:	b2 85       	st.b	r9[0x0],r5
      data++;
80018c9e:	2e 2c       	sub	r12,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018ca0:	19 84       	ld.ub	r4,r12[0x0]
80018ca2:	f0 04 18 00 	cp.b	r4,r8
80018ca6:	f9 b4 01 40 	movne	r4,64
80018caa:	f9 b4 00 00 	moveq	r4,0
80018cae:	08 45       	or	r5,r4
80018cb0:	b2 85       	st.b	r9[0x0],r5
80018cb2:	19 9c       	ld.ub	r12,r12[0x1]
80018cb4:	f0 0c 18 00 	cp.b	r12,r8
80018cb8:	5f 1c       	srne	r12
80018cba:	eb ec 10 75 	or	r5,r5,r12<<0x7
80018cbe:	12 c5       	st.b	r9++,r5
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018cc0:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018cc2:	ec cc ff f8 	sub	r12,r6,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018cc6:	f8 c6 ff f8 	sub	r6,r12,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018cca:	0d 85       	ld.ub	r5,r6[0x0]
80018ccc:	f0 05 18 00 	cp.b	r5,r8
80018cd0:	5f 15       	srne	r5
80018cd2:	b2 85       	st.b	r9[0x0],r5
80018cd4:	f5 34 00 19 	ld.ub	r4,r10[25]
80018cd8:	f0 04 18 00 	cp.b	r4,r8
80018cdc:	f9 b4 01 02 	movne	r4,2
80018ce0:	f9 b4 00 00 	moveq	r4,0
80018ce4:	08 45       	or	r5,r4
80018ce6:	b2 85       	st.b	r9[0x0],r5
80018ce8:	f5 34 00 1a 	ld.ub	r4,r10[26]
80018cec:	f0 04 18 00 	cp.b	r4,r8
80018cf0:	f9 b4 01 04 	movne	r4,4
80018cf4:	f9 b4 00 00 	moveq	r4,0
80018cf8:	08 45       	or	r5,r4
80018cfa:	b2 85       	st.b	r9[0x0],r5
80018cfc:	f5 34 00 1b 	ld.ub	r4,r10[27]
80018d00:	f0 04 18 00 	cp.b	r4,r8
80018d04:	f9 b4 01 08 	movne	r4,8
80018d08:	f9 b4 00 00 	moveq	r4,0
80018d0c:	08 45       	or	r5,r4
80018d0e:	b2 85       	st.b	r9[0x0],r5
80018d10:	f5 34 00 1c 	ld.ub	r4,r10[28]
80018d14:	f0 04 18 00 	cp.b	r4,r8
80018d18:	f9 b4 01 10 	movne	r4,16
80018d1c:	f9 b4 00 00 	moveq	r4,0
80018d20:	08 45       	or	r5,r4
80018d22:	b2 85       	st.b	r9[0x0],r5
80018d24:	f5 34 00 1d 	ld.ub	r4,r10[29]
80018d28:	f0 04 18 00 	cp.b	r4,r8
80018d2c:	f9 b4 01 20 	movne	r4,32
80018d30:	f9 b4 00 00 	moveq	r4,0
80018d34:	08 45       	or	r5,r4
80018d36:	b2 85       	st.b	r9[0x0],r5
      data++;
80018d38:	2e 2a       	sub	r10,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018d3a:	15 84       	ld.ub	r4,r10[0x0]
80018d3c:	f0 04 18 00 	cp.b	r4,r8
80018d40:	f9 b4 01 40 	movne	r4,64
80018d44:	f9 b4 00 00 	moveq	r4,0
80018d48:	08 45       	or	r5,r4
80018d4a:	b2 85       	st.b	r9[0x0],r5
80018d4c:	15 9a       	ld.ub	r10,r10[0x1]
80018d4e:	f0 0a 18 00 	cp.b	r10,r8
80018d52:	5f 1a       	srne	r10
80018d54:	eb ea 10 75 	or	r5,r5,r10<<0x7
80018d58:	12 c5       	st.b	r9++,r5
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018d5a:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018d5c:	ec ca ff f8 	sub	r10,r6,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018d60:	f4 c6 ff f8 	sub	r6,r10,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018d64:	0d 85       	ld.ub	r5,r6[0x0]
80018d66:	f0 05 18 00 	cp.b	r5,r8
80018d6a:	5f 15       	srne	r5
80018d6c:	b2 85       	st.b	r9[0x0],r5
80018d6e:	f9 34 00 19 	ld.ub	r4,r12[25]
80018d72:	f0 04 18 00 	cp.b	r4,r8
80018d76:	f9 b4 01 02 	movne	r4,2
80018d7a:	f9 b4 00 00 	moveq	r4,0
80018d7e:	08 45       	or	r5,r4
80018d80:	b2 85       	st.b	r9[0x0],r5
80018d82:	f9 34 00 1a 	ld.ub	r4,r12[26]
80018d86:	f0 04 18 00 	cp.b	r4,r8
80018d8a:	f9 b4 01 04 	movne	r4,4
80018d8e:	f9 b4 00 00 	moveq	r4,0
80018d92:	08 45       	or	r5,r4
80018d94:	b2 85       	st.b	r9[0x0],r5
80018d96:	f9 34 00 1b 	ld.ub	r4,r12[27]
80018d9a:	f0 04 18 00 	cp.b	r4,r8
80018d9e:	f9 b4 01 08 	movne	r4,8
80018da2:	f9 b4 00 00 	moveq	r4,0
80018da6:	08 45       	or	r5,r4
80018da8:	b2 85       	st.b	r9[0x0],r5
80018daa:	f9 34 00 1c 	ld.ub	r4,r12[28]
80018dae:	f0 04 18 00 	cp.b	r4,r8
80018db2:	f9 b4 01 10 	movne	r4,16
80018db6:	f9 b4 00 00 	moveq	r4,0
80018dba:	08 45       	or	r5,r4
80018dbc:	b2 85       	st.b	r9[0x0],r5
80018dbe:	f9 34 00 1d 	ld.ub	r4,r12[29]
80018dc2:	f0 04 18 00 	cp.b	r4,r8
80018dc6:	f9 b4 01 20 	movne	r4,32
80018dca:	f9 b4 00 00 	moveq	r4,0
80018dce:	08 45       	or	r5,r4
80018dd0:	b2 85       	st.b	r9[0x0],r5
      data++;
80018dd2:	2e 2c       	sub	r12,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018dd4:	19 84       	ld.ub	r4,r12[0x0]
80018dd6:	f0 04 18 00 	cp.b	r4,r8
80018dda:	f9 b4 01 40 	movne	r4,64
80018dde:	f9 b4 00 00 	moveq	r4,0
80018de2:	08 45       	or	r5,r4
80018de4:	b2 85       	st.b	r9[0x0],r5
80018de6:	19 9c       	ld.ub	r12,r12[0x1]
80018de8:	f0 0c 18 00 	cp.b	r12,r8
80018dec:	5f 1c       	srne	r12
80018dee:	eb ec 10 75 	or	r5,r5,r12<<0x7
80018df2:	12 c5       	st.b	r9++,r5
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018df4:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018df6:	ec cc ff f8 	sub	r12,r6,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018dfa:	f8 c6 ff f8 	sub	r6,r12,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018dfe:	0d 85       	ld.ub	r5,r6[0x0]
80018e00:	f0 05 18 00 	cp.b	r5,r8
80018e04:	5f 15       	srne	r5
80018e06:	b2 85       	st.b	r9[0x0],r5
80018e08:	f5 34 00 19 	ld.ub	r4,r10[25]
80018e0c:	f0 04 18 00 	cp.b	r4,r8
80018e10:	f9 b4 01 02 	movne	r4,2
80018e14:	f9 b4 00 00 	moveq	r4,0
80018e18:	08 45       	or	r5,r4
80018e1a:	b2 85       	st.b	r9[0x0],r5
80018e1c:	f5 34 00 1a 	ld.ub	r4,r10[26]
80018e20:	f0 04 18 00 	cp.b	r4,r8
80018e24:	f9 b4 01 04 	movne	r4,4
80018e28:	f9 b4 00 00 	moveq	r4,0
80018e2c:	08 45       	or	r5,r4
80018e2e:	b2 85       	st.b	r9[0x0],r5
80018e30:	f5 34 00 1b 	ld.ub	r4,r10[27]
80018e34:	f0 04 18 00 	cp.b	r4,r8
80018e38:	f9 b4 01 08 	movne	r4,8
80018e3c:	f9 b4 00 00 	moveq	r4,0
80018e40:	08 45       	or	r5,r4
80018e42:	b2 85       	st.b	r9[0x0],r5
80018e44:	f5 34 00 1c 	ld.ub	r4,r10[28]
80018e48:	f0 04 18 00 	cp.b	r4,r8
80018e4c:	f9 b4 01 10 	movne	r4,16
80018e50:	f9 b4 00 00 	moveq	r4,0
80018e54:	08 45       	or	r5,r4
80018e56:	b2 85       	st.b	r9[0x0],r5
80018e58:	f5 34 00 1d 	ld.ub	r4,r10[29]
80018e5c:	f0 04 18 00 	cp.b	r4,r8
80018e60:	f9 b4 01 20 	movne	r4,32
80018e64:	f9 b4 00 00 	moveq	r4,0
80018e68:	08 45       	or	r5,r4
80018e6a:	b2 85       	st.b	r9[0x0],r5
      data++;
80018e6c:	2e 2a       	sub	r10,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018e6e:	15 84       	ld.ub	r4,r10[0x0]
80018e70:	f0 04 18 00 	cp.b	r4,r8
80018e74:	f9 b4 01 40 	movne	r4,64
80018e78:	f9 b4 00 00 	moveq	r4,0
80018e7c:	08 45       	or	r5,r4
80018e7e:	b2 85       	st.b	r9[0x0],r5
80018e80:	15 9a       	ld.ub	r10,r10[0x1]
80018e82:	f0 0a 18 00 	cp.b	r10,r8
80018e86:	5f 1a       	srne	r10
80018e88:	eb ea 10 75 	or	r5,r5,r10<<0x7
80018e8c:	12 c5       	st.b	r9++,r5
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018e8e:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018e90:	ec ca ff f8 	sub	r10,r6,-8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
80018e94:	f4 c6 ff f8 	sub	r6,r10,-8
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018e98:	0d 85       	ld.ub	r5,r6[0x0]
80018e9a:	f0 05 18 00 	cp.b	r5,r8
80018e9e:	5f 15       	srne	r5
80018ea0:	b2 85       	st.b	r9[0x0],r5
80018ea2:	f9 34 00 19 	ld.ub	r4,r12[25]
80018ea6:	f0 04 18 00 	cp.b	r4,r8
80018eaa:	f9 b4 01 02 	movne	r4,2
80018eae:	f9 b4 00 00 	moveq	r4,0
80018eb2:	08 45       	or	r5,r4
80018eb4:	b2 85       	st.b	r9[0x0],r5
80018eb6:	f9 34 00 1a 	ld.ub	r4,r12[26]
80018eba:	f0 04 18 00 	cp.b	r4,r8
80018ebe:	f9 b4 01 04 	movne	r4,4
80018ec2:	f9 b4 00 00 	moveq	r4,0
80018ec6:	08 45       	or	r5,r4
80018ec8:	b2 85       	st.b	r9[0x0],r5
80018eca:	f9 34 00 1b 	ld.ub	r4,r12[27]
80018ece:	f0 04 18 00 	cp.b	r4,r8
80018ed2:	f9 b4 01 08 	movne	r4,8
80018ed6:	f9 b4 00 00 	moveq	r4,0
80018eda:	08 45       	or	r5,r4
80018edc:	b2 85       	st.b	r9[0x0],r5
80018ede:	f9 34 00 1c 	ld.ub	r4,r12[28]
80018ee2:	f0 04 18 00 	cp.b	r4,r8
80018ee6:	f9 b4 01 10 	movne	r4,16
80018eea:	f9 b4 00 00 	moveq	r4,0
80018eee:	08 45       	or	r5,r4
80018ef0:	b2 85       	st.b	r9[0x0],r5
80018ef2:	f9 34 00 1d 	ld.ub	r4,r12[29]
80018ef6:	f0 04 18 00 	cp.b	r4,r8
80018efa:	f9 b4 01 20 	movne	r4,32
80018efe:	f9 b4 00 00 	moveq	r4,0
80018f02:	eb e4 10 04 	or	r4,r5,r4
80018f06:	b2 84       	st.b	r9[0x0],r4
      data++;
80018f08:	f8 c5 ff e2 	sub	r5,r12,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018f0c:	0b 8c       	ld.ub	r12,r5[0x0]
80018f0e:	f0 0c 18 00 	cp.b	r12,r8
80018f12:	f9 bc 01 40 	movne	r12,64
80018f16:	f9 bc 00 00 	moveq	r12,0
80018f1a:	e9 ec 10 0c 	or	r12,r4,r12
80018f1e:	b2 8c       	st.b	r9[0x0],r12
80018f20:	0b 95       	ld.ub	r5,r5[0x1]
80018f22:	f0 05 18 00 	cp.b	r5,r8
80018f26:	5f 15       	srne	r5
80018f28:	f9 e5 10 7c 	or	r12,r12,r5<<0x7
80018f2c:	12 cc       	st.b	r9++,r12
  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80018f2e:	b2 88       	st.b	r9[0x0],r8
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018f30:	ed 3c 00 10 	ld.ub	r12,r6[16]
80018f34:	f0 0c 18 00 	cp.b	r12,r8
80018f38:	5f 1c       	srne	r12
80018f3a:	b2 8c       	st.b	r9[0x0],r12
80018f3c:	f5 36 00 19 	ld.ub	r6,r10[25]
80018f40:	f0 06 18 00 	cp.b	r6,r8
80018f44:	f9 b6 01 02 	movne	r6,2
80018f48:	f9 b6 00 00 	moveq	r6,0
80018f4c:	0c 4c       	or	r12,r6
80018f4e:	b2 8c       	st.b	r9[0x0],r12
80018f50:	f5 36 00 1a 	ld.ub	r6,r10[26]
80018f54:	f0 06 18 00 	cp.b	r6,r8
80018f58:	f9 b6 01 04 	movne	r6,4
80018f5c:	f9 b6 00 00 	moveq	r6,0
80018f60:	0c 4c       	or	r12,r6
80018f62:	b2 8c       	st.b	r9[0x0],r12
80018f64:	f5 36 00 1b 	ld.ub	r6,r10[27]
80018f68:	f0 06 18 00 	cp.b	r6,r8
80018f6c:	f9 b6 01 08 	movne	r6,8
80018f70:	f9 b6 00 00 	moveq	r6,0
80018f74:	0c 4c       	or	r12,r6
80018f76:	b2 8c       	st.b	r9[0x0],r12
80018f78:	f5 36 00 1c 	ld.ub	r6,r10[28]
80018f7c:	f0 06 18 00 	cp.b	r6,r8
80018f80:	f9 b6 01 10 	movne	r6,16
80018f84:	f9 b6 00 00 	moveq	r6,0
80018f88:	0c 4c       	or	r12,r6
80018f8a:	b2 8c       	st.b	r9[0x0],r12
80018f8c:	f5 36 00 1d 	ld.ub	r6,r10[29]
80018f90:	f0 06 18 00 	cp.b	r6,r8
80018f94:	f9 b6 01 20 	movne	r6,32
80018f98:	f9 b6 00 00 	moveq	r6,0
80018f9c:	0c 4c       	or	r12,r6
80018f9e:	b2 8c       	st.b	r9[0x0],r12
      data++;
80018fa0:	2e 2a       	sub	r10,-30
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80018fa2:	15 86       	ld.ub	r6,r10[0x0]
80018fa4:	f0 06 18 00 	cp.b	r6,r8
80018fa8:	f9 b6 01 40 	movne	r6,64
80018fac:	f9 b6 00 00 	moveq	r6,0
80018fb0:	0c 4c       	or	r12,r6
80018fb2:	b2 8c       	st.b	r9[0x0],r12
80018fb4:	15 9a       	ld.ub	r10,r10[0x1]
80018fb6:	f0 0a 18 00 	cp.b	r10,r8
80018fba:	5f 18       	srne	r8
80018fbc:	2f 8b       	sub	r11,-8
80018fbe:	f9 e8 10 7c 	or	r12,r12,r8<<0x7
80018fc2:	30 88       	mov	r8,8
80018fc4:	b2 8c       	st.b	r9[0x0],r12
80018fc6:	e0 69 0c 25 	mov	r9,3109
80018fca:	9d 0b       	st.w	lr[0x0],r11
80018fcc:	ae 88       	st.b	r7[0x0],r8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 1);  
80018fce:	b2 88       	st.b	r9[0x0],r8
80018fd0:	30 9b       	mov	r11,9
80018fd2:	e0 6c 0b dc 	mov	r12,3036
}
80018fd6:	e0 a0 0d a3 	rcall	8001ab1c <ftdi_write>
  static u8 * ptx;
  static u8 i, j;
  // command (upper nibble)
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );
80018fda:	d8 22       	popm	r4-r7,pc
80018fdc:	18 98       	mov	r8,r12
80018fde:	ea 19 ff ff 	orh	r9,0xffff
80018fe2:	e8 19 ff 82 	orl	r9,0xff82

  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80018fe6:	10 c9       	st.b	r8++,r9
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );

  // pointer to tx data
  ptx = txBuf + 1;
80018fe8:	e0 6e 0b c8 	mov	lr,3016
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80018fec:	e0 67 0b d0 	mov	r7,3024
80018ff0:	9d 08       	st.w	lr[0x0],r8
80018ff2:	30 08       	mov	r8,0
80018ff4:	7c 0b       	ld.w	r11,lr[0x0]
80018ff6:	ae 88       	st.b	r7[0x0],r8
80018ff8:	fe 9f fd 84 	bral	80018b00 <grid_map_series+0x30>

80018ffc <read_serial_series>:
80018ffc:	d4 31       	pushm	r0-r7,lr
80018ffe:	e0 a0 0d 25 	rcall	8001aa48 <ftdi_rx_buf>
80019002:	e0 64 0c 24 	mov	r4,3108
80019006:	18 97       	mov	r7,r12
}

static void read_serial_series(void) {
  u8* prx = ftdi_rx_buf();
  u8 i;
  rxBytes = ftdi_rx_bytes();
80019008:	e0 a0 0d 24 	rcall	8001aa50 <ftdi_rx_bytes>
  /* print_dbg_hex(prx[0]); */
  /* print_dbg(" , 0x"); */
  /* print_dbg_hex(prx[1]); */
  /* print_dbg(" ]");   */
  i = 0;
  while(i < rxBytes) {
8001900c:	a8 8c       	st.b	r4[0x0],r12
8001900e:	c2 30       	breq	80019054 <read_serial_series+0x58>
80019010:	e0 65 0b bc 	mov	r5,3004
80019014:	30 06       	mov	r6,0
80019016:	ea c0 ff fc 	sub	r0,r5,-4
8001901a:	ea c1 ff fb 	sub	r1,r5,-5
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
8001901e:	ea c2 ff fa 	sub	r2,r5,-6
    /* print_dbg("; y : 0x"); */
    /* print_dbg_hex(prx[1] & 0xf); */
    /* print_dbg(" ; z : 0x"); */
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
80019022:	31 53       	mov	r3,21

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
  data[1] = y;
80019024:	0f 99       	ld.ub	r9,r7[0x1]
80019026:	0f 88       	ld.ub	r8,r7[0x0]
80019028:	f5 d9 c0 04 	bfextu	r10,r9,0x0,0x4
    /* print_dbg("; y : 0x"); */
    /* print_dbg_hex(prx[1] & 0xf); */
    /* print_dbg(" ; z : 0x"); */
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
8001902c:	a2 8a       	st.b	r1[0x0],r10
8001902e:	e2 18 00 f0 	andl	r8,0xf0,COH
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
80019032:	5f 08       	sreq	r8
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
80019034:	a4 88       	st.b	r2[0x0],r8
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
				 ((prx[0] & 0xf0) == 0)
				 );
    i += 2;
    prx += 2;
80019036:	8b 03       	st.w	r5[0x0],r3
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
80019038:	a5 89       	lsr	r9,0x4
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
  post_event(&ev);
8001903a:	2f e7       	sub	r7,-2
8001903c:	a0 89       	st.b	r0[0x0],r9
8001903e:	e0 6c 0b bc 	mov	r12,3004
  /* print_dbg_hex(prx[0]); */
  /* print_dbg(" , 0x"); */
  /* print_dbg_hex(prx[1]); */
  /* print_dbg(" ]");   */
  i = 0;
  while(i < rxBytes) {
80019042:	fe b0 f1 e7 	rcall	80017410 <post_event>
80019046:	2f e6       	sub	r6,-2
80019048:	09 88       	ld.ub	r8,r4[0x0]
8001904a:	5c 56       	castu.b	r6
8001904c:	ec 08 18 00 	cp.b	r8,r6
80019050:	fe 9b ff ea 	brhi	80019024 <read_serial_series+0x28>
80019054:	d8 32       	popm	r0-r7,pc
80019056:	d7 03       	nop

80019058 <read_serial_mext>:
80019058:	d4 31       	pushm	r0-r7,lr
8001905a:	e0 64 0c 24 	mov	r4,3108
8001905e:	e0 a0 0c f9 	rcall	8001aa50 <ftdi_rx_bytes>
80019062:	a8 8c       	st.b	r4[0x0],r12
  static u8 nbp; // number of bytes processed
  static u8* prx; // pointer to rx buf
  static u8 com;
  
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
80019064:	c0 21       	brne	80019068 <read_serial_mext+0x10>
    nbp = 0;
80019066:	d8 32       	popm	r0-r7,pc
80019068:	30 08       	mov	r8,0
    prx = ftdi_rx_buf();
8001906a:	e0 65 0b b8 	mov	r5,3000
8001906e:	e0 67 0b d4 	mov	r7,3028

//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
80019072:	aa 88       	st.b	r5[0x0],r8
  static u8 com;
  
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
    nbp = 0;
    prx = ftdi_rx_buf();
80019074:	e0 a0 0c ea 	rcall	8001aa48 <ftdi_rx_buf>
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
80019078:	e0 61 0b bc 	mov	r1,3004
      nbp++;
      switch(com) {
8001907c:	8f 0c       	st.w	r7[0x0],r12

//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
8001907e:	0e 93       	mov	r3,r7
  static u8 com;
  
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
    nbp = 0;
    prx = ftdi_rx_buf();
80019080:	e0 62 0b c4 	mov	r2,3012
    while(nbp < rxBytes) {
80019084:	0a 90       	mov	r0,r5
80019086:	35 06       	mov	r6,80
80019088:	2f c1       	sub	r1,-4
8001908a:	0b 88       	ld.ub	r8,r5[0x0]
      com = (u8)(*(prx++));    
8001908c:	09 8c       	ld.ub	r12,r4[0x0]
      nbp++;
8001908e:	f0 0c 18 00 	cp.b	r12,r8
80019092:	fe 98 ff ea 	brls	80019066 <read_serial_mext+0xe>
80019096:	6e 0b       	ld.w	r11,r7[0x0]
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
    nbp = 0;
    prx = ftdi_rx_buf();
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
80019098:	2f f8       	sub	r8,-1
8001909a:	16 99       	mov	r9,r11
      nbp++;
      switch(com) {
8001909c:	5c 58       	castu.b	r8
8001909e:	13 3a       	ld.ub	r10,r9++
800190a0:	aa 88       	st.b	r5[0x0],r8
800190a2:	a4 8a       	st.b	r2[0x0],r10
800190a4:	8f 09       	st.w	r7[0x0],r9
800190a6:	ec 0a 18 00 	cp.b	r10,r6
800190aa:	c3 e0       	breq	80019126 <read_serial_mext+0xce>
800190ac:	e0 8b 00 20 	brhi	800190ec <read_serial_mext+0x94>
800190b0:	32 0b       	mov	r11,32
800190b2:	f6 0a 18 00 	cp.b	r10,r11
	monome_grid_key_write_event( *prx, *(prx+1), 0);
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
800190b6:	c2 c0       	breq	8001910e <read_serial_mext+0xb6>
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
800190b8:	32 18       	mov	r8,33
  data[1] = y;
800190ba:	f0 0a 18 00 	cp.b	r10,r8
  data[2] = val;
800190be:	cd 41       	brne	80019066 <read_serial_mext+0xe>
800190c0:	13 98       	ld.ub	r8,r9[0x1]
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800190c2:	13 8a       	ld.ub	r10,r9[0x0]
800190c4:	a2 98       	st.b	r1[0x1],r8
  post_event(&ev);
800190c6:	a2 8a       	st.b	r1[0x0],r10
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800190c8:	30 18       	mov	r8,1
  post_event(&ev);
800190ca:	a2 a8       	st.b	r1[0x2],r8
800190cc:	e0 6b 0b bc 	mov	r11,3004
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
	prx += 2;
800190d0:	31 58       	mov	r8,21
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
800190d2:	16 9c       	mov	r12,r11
	prx += 2;
800190d4:	97 08       	st.w	r11[0x0],r8
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
800190d6:	fe b0 f1 9d 	rcall	80017410 <post_event>
800190da:	01 88       	ld.ub	r8,r0[0x0]
	prx += 2;
800190dc:	66 09       	ld.w	r9,r3[0x0]
	break;
800190de:	2f e8       	sub	r8,-2
    nbp = 0;
    prx = ftdi_rx_buf();
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
      nbp++;
      switch(com) {
800190e0:	2f e9       	sub	r9,-2
800190e2:	5c 58       	castu.b	r8
800190e4:	87 09       	st.w	r3[0x0],r9
800190e6:	a0 88       	st.b	r0[0x0],r8
800190e8:	09 8c       	ld.ub	r12,r4[0x0]
800190ea:	cd 2b       	rjmp	8001908e <read_serial_mext+0x36>
800190ec:	35 1b       	mov	r11,81
800190ee:	f6 0a 18 00 	cp.b	r10,r11
	monome_ring_key_write_event( *prx++, 0);
	prx++;
	break;
      case 0x52 : // ring key down
	monome_ring_key_write_event( *prx++, 1);
	nbp++;
800190f2:	c0 b0       	breq	80019108 <read_serial_mext+0xb0>
      case 0x51 : // ring key up
	monome_ring_key_write_event( *prx++, 0);
	prx++;
	break;
      case 0x52 : // ring key down
	monome_ring_key_write_event( *prx++, 1);
800190f4:	35 2b       	mov	r11,82
	nbp++;
800190f6:	f6 0a 18 00 	cp.b	r10,r11
800190fa:	cb 61       	brne	80019066 <read_serial_mext+0xe>
	nbp += 2;
	prx += 2;
	break;
      case 0x51 : // ring key up
	monome_ring_key_write_event( *prx++, 0);
	prx++;
800190fc:	2f f9       	sub	r9,-1
800190fe:	2f f8       	sub	r8,-1
	break;
80019100:	87 09       	st.w	r3[0x0],r9
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
      nbp++;
      switch(com) {
      case 0x20: // grid key up
	monome_grid_key_write_event( *prx, *(prx+1), 0);
80019102:	5c 58       	castu.b	r8
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
80019104:	a0 88       	st.b	r0[0x0],r8
  data[1] = y;
80019106:	cc 4b       	rjmp	8001908e <read_serial_mext+0x36>
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
80019108:	2f e9       	sub	r9,-2
  data[1] = y;
  data[2] = val;
8001910a:	87 09       	st.w	r3[0x0],r9
8001910c:	cc 1b       	rjmp	8001908e <read_serial_mext+0x36>
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
8001910e:	13 98       	ld.ub	r8,r9[0x1]
80019110:	13 8a       	ld.ub	r10,r9[0x0]
  post_event(&ev);
80019112:	a2 98       	st.b	r1[0x1],r8
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
80019114:	a2 8a       	st.b	r1[0x0],r10
80019116:	30 08       	mov	r8,0
	nbp += 2;
	prx += 2;
	break;
	case 0x50: // ring delta
	monome_ring_enc_write_event( *prx, *(prx+1));
	nbp += 2;
80019118:	a2 a8       	st.b	r1[0x2],r8
	prx += 2;
8001911a:	e0 69 0b bc 	mov	r9,3004
8001911e:	31 58       	mov	r8,21
	nbp += 2;
	prx += 2;
	break;
	case 0x50: // ring delta
	monome_ring_enc_write_event( *prx, *(prx+1));
	nbp += 2;
80019120:	12 9c       	mov	r12,r9
	prx += 2;
	break;
80019122:	93 08       	st.w	r9[0x0],r8
80019124:	cd 9b       	rjmp	800190d6 <read_serial_mext+0x7e>
80019126:	2f e8       	sub	r8,-2
80019128:	2f db       	sub	r11,-3
8001912a:	5c 58       	castu.b	r8
8001912c:	87 0b       	st.w	r3[0x0],r11
8001912e:	a0 88       	st.b	r0[0x0],r8
80019130:	ca fb       	rjmp	8001908e <read_serial_mext+0x36>
80019132:	d7 03       	nop

80019134 <setup_series>:
80019134:	eb cd 40 c0 	pushm	r6-r7,lr
80019138:	49 8c       	lddpc	r12,80019198 <setup_series+0x64>
8001913a:	fe b0 cf 31 	rcall	80012f9c <print_dbg>
8001913e:	30 88       	mov	r8,8
80019140:	31 07       	mov	r7,16
80019142:	ef 68 00 09 	st.b	r7[9],r8
// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
80019146:	ef 68 00 08 	st.b	r7[8],r8

// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
  mdesc.device = eDeviceGrid;
8001914a:	30 08       	mov	r8,0
}

// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
8001914c:	30 16       	mov	r6,1
  mdesc.device = eDeviceGrid;
8001914e:	8f 18       	st.w	r7[0x4],r8
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80019150:	49 3c       	lddpc	r12,8001919c <setup_series+0x68>
}

// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
80019152:	8f 06       	st.w	r7[0x0],r6
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  mdesc.tilt = 1;
80019154:	ef 66 00 0b 	st.b	r7[11],r6
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80019158:	fe b0 cf 22 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(mdesc.protocol);
8001915c:	6e 0c       	ld.w	r12,r7[0x0]
8001915e:	fe b0 cf 25 	rcall	80012fa8 <print_dbg_ulong>
  monome_read_serial = readSerialFuncs[mdesc.protocol];
80019162:	49 09       	lddpc	r9,800191a0 <setup_series+0x6c>
80019164:	6e 08       	ld.w	r8,r7[0x0]
80019166:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8001916a:	30 c9       	mov	r9,12
8001916c:	93 0a       	st.w	r9[0x0],r10
  monome_grid_map = gridMapFuncs[mdesc.protocol];
8001916e:	e0 6a 31 5c 	mov	r10,12636
80019172:	48 d9       	lddpc	r9,800191a4 <setup_series+0x70>
80019174:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
80019178:	95 09       	st.w	r10[0x0],r9
8001917a:	e0 6a 32 64 	mov	r10,12900
  monome_ring_map = ringMapFuncs[mdesc.protocol];
8001917e:	95 09       	st.w	r10[0x0],r9
80019180:	48 a9       	lddpc	r9,800191a8 <setup_series+0x74>
80019182:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  mdesc.tilt = 1;
  set_funcs();
  monomeConnect = 1;
80019186:	e0 68 31 60 	mov	r8,12640
  test_draw();
}
8001918a:	91 09       	st.w	r8[0x0],r9
8001918c:	e0 68 0b cf 	mov	r8,3023
80019190:	b0 86       	st.b	r8[0x0],r6
80019192:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80019196:	d7 03       	nop
80019198:	80 02       	ld.sh	r2,r0[0x0]
8001919a:	4a 2c       	lddpc	r12,80019220 <check_monome_device_desc+0x74>
8001919c:	80 02       	ld.sh	r2,r0[0x0]
8001919e:	4a 44       	lddpc	r4,8001922c <check_monome_device_desc+0x80>
800191a0:	80 02       	ld.sh	r2,r0[0x0]
800191a2:	4b c4       	lddpc	r4,80019290 <check_monome_device_desc+0xe4>
800191a4:	80 02       	ld.sh	r2,r0[0x0]
800191a6:	4a 20       	lddpc	r0,8001922c <check_monome_device_desc+0x80>
800191a8:	80 02       	ld.sh	r2,r0[0x0]
800191aa:	4a 14       	lddpc	r4,8001922c <check_monome_device_desc+0x80>

800191ac <check_monome_device_desc>:
800191ac:	d4 21       	pushm	r4-r7,lr
800191ae:	20 5d       	sub	sp,20
800191b0:	f9 38 00 0a 	ld.ub	r8,r12[10]
800191b4:	ba d8       	st.b	sp[0x5],r8
800191b6:	19 88       	ld.ub	r8,r12[0x0]
800191b8:	ba 88       	st.b	sp[0x0],r8
800191ba:	19 a8       	ld.ub	r8,r12[0x2]
800191bc:	ba 98       	st.b	sp[0x1],r8
800191be:	19 c8       	ld.ub	r8,r12[0x4]
800191c0:	ba a8       	st.b	sp[0x2],r8
800191c2:	19 e8       	ld.ub	r8,r12[0x6]
  u8 matchMan = 0;
  u8 i;
  //-- source strings are unicode so we need to look at every other byte
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
800191c4:	ba b8       	st.b	sp[0x3],r8
800191c6:	f9 38 00 08 	ld.ub	r8,r12[8]
  }
  //  print_dbg("\r\n finished monome class init");
}

// determine if FTDI string descriptors match monome device pattern
u8 check_monome_device_desc(char* mstr, char* pstr, char* sstr) {
800191ca:	14 97       	mov	r7,r10
  u8 matchMan = 0;
  u8 i;
  //-- source strings are unicode so we need to look at every other byte
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
800191cc:	ba c8       	st.b	sp[0x4],r8
  }
  buf[i] = 0;
800191ce:	30 06       	mov	r6,0
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
800191d0:	30 6a       	mov	r10,6
  //-- source strings are unicode so we need to look at every other byte
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
  }
  buf[i] = 0;
800191d2:	ba e6       	st.b	sp[0x6],r6
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
800191d4:	fe fb 02 e4 	ld.w	r11,pc[740]
800191d8:	1a 9c       	mov	r12,sp
800191da:	e0 a0 53 90 	rcall	800238fa <strncmp>
 
  // serial number string
  for(i=0; i<MONOME_SERSTR_LEN; i++) {
    buf[i] = sstr[i*2];
  }
  buf[i] = 0;
800191de:	fb 66 00 09 	st.b	sp[9],r6
  /* print_dbg("\r\n manstring: "); */
  /* print_dbg(buf); */
 
  // serial number string
  for(i=0; i<MONOME_SERSTR_LEN; i++) {
    buf[i] = sstr[i*2];
800191e2:	ef 38 00 10 	ld.ub	r8,r7[16]
800191e6:	fb 68 00 08 	st.b	sp[8],r8
800191ea:	0f 88       	ld.ub	r8,r7[0x0]
800191ec:	ba 88       	st.b	sp[0x0],r8
800191ee:	0f a8       	ld.ub	r8,r7[0x2]
800191f0:	ba 98       	st.b	sp[0x1],r8
800191f2:	0f c8       	ld.ub	r8,r7[0x4]
800191f4:	ba a8       	st.b	sp[0x2],r8
800191f6:	0f e8       	ld.ub	r8,r7[0x6]
800191f8:	ba b8       	st.b	sp[0x3],r8
800191fa:	ef 38 00 08 	ld.ub	r8,r7[8]
800191fe:	ba c8       	st.b	sp[0x4],r8
80019200:	ef 38 00 0a 	ld.ub	r8,r7[10]
80019204:	ba d8       	st.b	sp[0x5],r8
80019206:	ef 38 00 0c 	ld.ub	r8,r7[12]
8001920a:	ba e8       	st.b	sp[0x6],r8
8001920c:	ef 38 00 0e 	ld.ub	r8,r7[14]
80019210:	ba f8       	st.b	sp[0x7],r8
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
  }
  buf[i] = 0;
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
80019212:	1a 95       	mov	r5,sp
80019214:	18 94       	mov	r4,r12
    buf[i] = sstr[i*2];
  }
  buf[i] = 0;
  /* print_dbg("\r\n serial string: "); */
  /* print_dbg(buf); */
  if(matchMan == 0) {
80019216:	c0 c0       	breq	8001922e <check_monome_device_desc+0x82>
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
80019218:	1a 9c       	mov	r12,sp
8001921a:	30 4a       	mov	r10,4
8001921c:	fe fb 02 a0 	ld.w	r11,pc[672]
80019220:	e0 a0 53 6d 	rcall	800238fa <strncmp>
80019224:	e0 80 00 88 	breq	80019334 <check_monome_device_desc+0x188>
  } else {
    return 0;
  }
  set_funcs();
  monomeConnect = 1;
  print_dbg("\r\n connected monome device, mext protocol");
80019228:	30 0c       	mov	r12,0
    // if we got here, serial number didn't match series or 40h patterns.
    // so this is probably an extended-protocol device.
    // we need to query for device attributes
    return setup_mext();
  }
}
8001922a:	2f bd       	sub	sp,-20
8001922c:	d8 22       	popm	r4-r7,pc
    } else {
      // not a monome
      return 0;
    }
  } else { // matched manufctrr string
    if(buf[0] != 'm') {
8001922e:	36 d8       	mov	r8,109
80019230:	1b 89       	ld.ub	r9,sp[0x0]
80019232:	f0 09 18 00 	cp.b	r9,r8
80019236:	cf 91       	brne	80019228 <check_monome_device_desc+0x7c>
      // not a monome, somehow. shouldn't happen
      return 0;
    }
    if(buf[3] == 'h') {
80019238:	36 88       	mov	r8,104
8001923a:	1b b9       	ld.ub	r9,sp[0x3]
8001923c:	f0 09 18 00 	cp.b	r9,r8
80019240:	e0 80 00 e5 	breq	8001940a <check_monome_device_desc+0x25e>
      // this is a 40h
      setup_40h(8, 8);
      return 1;
    }
    if( strncmp(buf, "m64-", 4) == 0 ) {
80019244:	30 4a       	mov	r10,4
80019246:	fe fb 02 7a 	ld.w	r11,pc[634]
8001924a:	1a 9c       	mov	r12,sp
8001924c:	e0 a0 53 57 	rcall	800238fa <strncmp>
80019250:	e0 80 00 d3 	breq	800193f6 <check_monome_device_desc+0x24a>
      // series 64
      setup_series(8, 8);
      return 1;
    }
    if( strncmp(buf, "m128-", 5) == 0 ) {
80019254:	1a 9c       	mov	r12,sp
80019256:	30 5a       	mov	r10,5
80019258:	fe fb 02 6c 	ld.w	r11,pc[620]
8001925c:	e0 a0 53 4f 	rcall	800238fa <strncmp>
80019260:	e0 80 00 d0 	breq	80019400 <check_monome_device_desc+0x254>
static u8 setup_mext(void) {
  u8* prx;
  u8 w = 0;
  u8 busy;

  print_dbg("\r\n setup mext device");
80019264:	fe fc 02 64 	ld.w	r12,pc[612]
}

// setup extended device, return success /failure of query
static u8 setup_mext(void) {
  u8* prx;
  u8 w = 0;
80019268:	fb 64 00 13 	st.b	sp[19],r4
  u8 busy;

  print_dbg("\r\n setup mext device");
8001926c:	fe b0 ce 98 	rcall	80012f9c <print_dbg>

  mdesc.protocol = eProtocolMext;
80019270:	30 28       	mov	r8,2
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80019272:	30 09       	mov	r9,0
80019274:	31 07       	mov	r7,16
80019276:	e0 6a d0 e7 	mov	r10,53479
8001927a:	ea 1a 27 56 	orh	r10,0x2756
8001927e:	8f 08       	st.w	r7[0x0],r8
80019280:	30 0b       	mov	r11,0
80019282:	e0 68 03 e8 	mov	r8,1000
80019286:	e0 a0 4e a6 	rcall	80022fd2 <__avr32_udiv64>
8001928a:	14 96       	mov	r6,r10
8001928c:	e1 b9 00 42 	mfsr	r9,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80019290:	f2 0a 00 0a 	add	r10,r9,r10
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80019294:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019298:	14 39       	cp.w	r9,r10
8001929a:	e0 8b 00 59 	brhi	8001934c <check_monome_device_desc+0x1a0>
8001929e:	10 39       	cp.w	r9,r8
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800192a0:	e0 8b 00 04 	brhi	800192a8 <check_monome_device_desc+0xfc>
800192a4:	10 3a       	cp.w	r10,r8
800192a6:	c6 c2       	brcc	8001937e <check_monome_device_desc+0x1d2>
800192a8:	30 1b       	mov	r11,1

  delay_ms(10);
  ftdi_write(&w, 1);	// query
800192aa:	fa cc ff ed 	sub	r12,sp,-19
800192ae:	e0 a0 0c 37 	rcall	8001ab1c <ftdi_write>
800192b2:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800192b6:	f0 06 00 0a 	add	r10,r8,r6
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800192ba:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800192be:	14 38       	cp.w	r8,r10
800192c0:	e0 8b 00 4e 	brhi	8001935c <check_monome_device_desc+0x1b0>
800192c4:	12 38       	cp.w	r8,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800192c6:	e0 8b 00 04 	brhi	800192ce <check_monome_device_desc+0x122>
800192ca:	12 3a       	cp.w	r10,r9
800192cc:	c5 c2       	brcc	80019384 <check_monome_device_desc+0x1d8>
800192ce:	e0 a0 0c 0f 	rcall	8001aaec <ftdi_read>
  
  delay_ms(10);

  ftdi_read();
800192d2:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800192d6:	f0 06 00 06 	add	r6,r8,r6
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800192da:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800192de:	0c 38       	cp.w	r8,r6
800192e0:	e0 8b 00 46 	brhi	8001936c <check_monome_device_desc+0x1c0>
800192e4:	12 38       	cp.w	r8,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800192e6:	e0 8b 00 04 	brhi	800192ee <check_monome_device_desc+0x142>
800192ea:	12 36       	cp.w	r6,r9
800192ec:	c4 62       	brcc	80019378 <check_monome_device_desc+0x1cc>
800192ee:	4f 8c       	lddpc	r12,800194cc <check_monome_device_desc+0x320>

  delay_ms(10);
  busy = 1;

  print_dbg("\r\n setup request ftdi read; waiting...");
800192f0:	fe b0 ce 56 	rcall	80012f9c <print_dbg>
800192f4:	e0 a0 0b b2 	rcall	8001aa58 <ftdi_rx_busy>

  //  while(ftdi_rx_busy()) {;;}
  while(busy) {
    busy = ftdi_rx_busy();
800192f8:	18 96       	mov	r6,r12
800192fa:	4f 6c       	lddpc	r12,800194d0 <check_monome_device_desc+0x324>
    print_dbg("\r\n waiting for transfer complete; busy flag: ");
800192fc:	fe b0 ce 50 	rcall	80012f9c <print_dbg>
80019300:	0c 9c       	mov	r12,r6
    print_dbg_ulong(busy);
80019302:	fe b0 ce 53 	rcall	80012fa8 <print_dbg_ulong>
80019306:	58 06       	cp.w	r6,0
  busy = 1;

  print_dbg("\r\n setup request ftdi read; waiting...");

  //  while(ftdi_rx_busy()) {;;}
  while(busy) {
80019308:	cf 61       	brne	800192f4 <check_monome_device_desc+0x148>
8001930a:	e0 a0 0b a3 	rcall	8001aa50 <ftdi_rx_bytes>
    busy = ftdi_rx_busy();
    print_dbg("\r\n waiting for transfer complete; busy flag: ");
    print_dbg_ulong(busy);
    
  }
  rxBytes = ftdi_rx_bytes();
8001930e:	e0 65 0c 24 	mov	r5,3108
80019312:	aa 8c       	st.b	r5[0x0],r12

  print_dbg(" done waiting. bytes read: ");
80019314:	4f 0c       	lddpc	r12,800194d4 <check_monome_device_desc+0x328>
80019316:	fe b0 ce 43 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(rxBytes);
8001931a:	0b 8c       	ld.ub	r12,r5[0x0]
8001931c:	fe b0 ce 46 	rcall	80012fa8 <print_dbg_ulong>

  if(rxBytes != 6 ){
80019320:	0b 89       	ld.ub	r9,r5[0x0]
80019322:	30 68       	mov	r8,6
80019324:	f0 09 18 00 	cp.b	r9,r8
80019328:	c3 10       	breq	8001938a <check_monome_device_desc+0x1de>
    print_dbg("\r\n got unexpected byte count in response to mext setup request; aborting");
8001932a:	4e cc       	lddpc	r12,800194d8 <check_monome_device_desc+0x32c>
8001932c:	fe b0 ce 38 	rcall	80012f9c <print_dbg>
80019330:	0c 9c       	mov	r12,r6
80019332:	c7 cb       	rjmp	8001922a <check_monome_device_desc+0x7e>
  /* print_dbg(buf); */
  if(matchMan == 0) {
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
80019334:	31 08       	mov	r8,16
      mdesc.device = eDeviceGrid;
      mdesc.cols = 8;
80019336:	30 89       	mov	r9,8
  if(matchMan == 0) {
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
      mdesc.device = eDeviceGrid;
80019338:	91 1c       	st.w	r8[0x4],r12
  /* print_dbg(buf); */
  if(matchMan == 0) {
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
8001933a:	91 0c       	st.w	r8[0x0],r12
      mdesc.device = eDeviceGrid;
      mdesc.cols = 8;
      mdesc.rows = 8;
8001933c:	f1 69 00 09 	st.b	r8[9],r9
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
      mdesc.device = eDeviceGrid;
      mdesc.cols = 8;
80019340:	f1 69 00 08 	st.b	r8[8],r9
      mdesc.rows = 8;
80019344:	2f bd       	sub	sp,-20
80019346:	da 2a       	popm	r4-r7,pc,r12=1
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019348:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001934c:	10 39       	cp.w	r9,r8
8001934e:	fe 98 ff fd 	brls	80019348 <check_monome_device_desc+0x19c>
80019352:	10 3a       	cp.w	r10,r8
80019354:	ca a3       	brcs	800192a8 <check_monome_device_desc+0xfc>
80019356:	cf 9b       	rjmp	80019348 <check_monome_device_desc+0x19c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019358:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001935c:	12 38       	cp.w	r8,r9
8001935e:	fe 98 ff fd 	brls	80019358 <check_monome_device_desc+0x1ac>
80019362:	12 3a       	cp.w	r10,r9
80019364:	cb 53       	brcs	800192ce <check_monome_device_desc+0x122>
80019366:	cf 9b       	rjmp	80019358 <check_monome_device_desc+0x1ac>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019368:	e1 b9 00 42 	mfsr	r9,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001936c:	12 38       	cp.w	r8,r9
8001936e:	fe 98 ff fd 	brls	80019368 <check_monome_device_desc+0x1bc>
80019372:	12 36       	cp.w	r6,r9
80019374:	cb d3       	brcs	800192ee <check_monome_device_desc+0x142>
80019376:	cf 9b       	rjmp	80019368 <check_monome_device_desc+0x1bc>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019378:	e1 b9 00 42 	mfsr	r9,0x108
8001937c:	cb 4b       	rjmp	800192e4 <check_monome_device_desc+0x138>
8001937e:	e1 b8 00 42 	mfsr	r8,0x108
80019382:	c8 eb       	rjmp	8001929e <check_monome_device_desc+0xf2>
80019384:	e1 b9 00 42 	mfsr	r9,0x108
80019388:	c9 eb       	rjmp	800192c4 <check_monome_device_desc+0x118>
  if(rxBytes != 6 ){
    print_dbg("\r\n got unexpected byte count in response to mext setup request; aborting");
    return 0;
  }
  
  prx = ftdi_rx_buf();
8001938a:	e0 a0 0b 5f 	rcall	8001aa48 <ftdi_rx_buf>
  prx++; // 1st returned byte is 0
  if(*prx == 1) {
8001938e:	30 19       	mov	r9,1
    print_dbg("\r\n got unexpected byte count in response to mext setup request; aborting");
    return 0;
  }
  
  prx = ftdi_rx_buf();
  prx++; // 1st returned byte is 0
80019390:	2f fc       	sub	r12,-1
  if(*prx == 1) {
80019392:	19 88       	ld.ub	r8,r12[0x0]
80019394:	f2 08 18 00 	cp.b	r8,r9
80019398:	c6 20       	breq	8001945c <check_monome_device_desc+0x2b0>
    else {
      return 0;
    }		
    mdesc.tilt = 1;
  }
  else if(*prx == 5) {
8001939a:	30 59       	mov	r9,5
8001939c:	f2 08 18 00 	cp.b	r8,r9
800193a0:	fe 91 ff 44 	brne	80019228 <check_monome_device_desc+0x7c>
    mdesc.device = eDeviceArc;
800193a4:	30 18       	mov	r8,1
800193a6:	8f 18       	st.w	r7[0x4],r8
    mdesc.encs = *(++prx);
800193a8:	19 98       	ld.ub	r8,r12[0x1]
800193aa:	ef 68 00 0a 	st.b	r7[10],r8
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
800193ae:	4c cc       	lddpc	r12,800194dc <check_monome_device_desc+0x330>
800193b0:	fe b0 cd f6 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(mdesc.protocol);
800193b4:	6e 0c       	ld.w	r12,r7[0x0]
800193b6:	fe b0 cd f9 	rcall	80012fa8 <print_dbg_ulong>
  monome_read_serial = readSerialFuncs[mdesc.protocol];
800193ba:	4c a9       	lddpc	r9,800194e0 <check_monome_device_desc+0x334>
800193bc:	6e 08       	ld.w	r8,r7[0x0]
800193be:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
800193c2:	30 c9       	mov	r9,12
800193c4:	93 0a       	st.w	r9[0x0],r10
  monome_grid_map = gridMapFuncs[mdesc.protocol];
800193c6:	e0 6a 31 5c 	mov	r10,12636
800193ca:	4c 79       	lddpc	r9,800194e4 <check_monome_device_desc+0x338>
800193cc:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
800193d0:	95 09       	st.w	r10[0x0],r9
800193d2:	e0 6a 32 64 	mov	r10,12900
  monome_ring_map = ringMapFuncs[mdesc.protocol];
800193d6:	95 09       	st.w	r10[0x0],r9
800193d8:	4c 49       	lddpc	r9,800194e8 <check_monome_device_desc+0x33c>
800193da:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
    mdesc.encs = *(++prx);
  } else {
    return 0;
  }
  set_funcs();
  monomeConnect = 1;
800193de:	e0 68 31 60 	mov	r8,12640
  print_dbg("\r\n connected monome device, mext protocol");
800193e2:	91 09       	st.w	r8[0x0],r9
    mdesc.encs = *(++prx);
  } else {
    return 0;
  }
  set_funcs();
  monomeConnect = 1;
800193e4:	30 19       	mov	r9,1
  print_dbg("\r\n connected monome device, mext protocol");
800193e6:	e0 68 0b cf 	mov	r8,3023
800193ea:	4c 1c       	lddpc	r12,800194ec <check_monome_device_desc+0x340>
800193ec:	b0 89       	st.b	r8[0x0],r9
      setup_40h(8, 8);
      return 1;
    }
    if( strncmp(buf, "m64-", 4) == 0 ) {
      // series 64
      setup_series(8, 8);
800193ee:	fe b0 cd d7 	rcall	80012f9c <print_dbg>
800193f2:	30 1c       	mov	r12,1
800193f4:	c1 bb       	rjmp	8001922a <check_monome_device_desc+0x7e>
800193f6:	30 8b       	mov	r11,8
      return 1;
800193f8:	16 9c       	mov	r12,r11
    }
    if( strncmp(buf, "m128-", 5) == 0 ) {
      // series 128
      setup_series(8, 16);
800193fa:	c9 de       	rcall	80019134 <setup_series>
800193fc:	30 1c       	mov	r12,1
800193fe:	c1 6b       	rjmp	8001922a <check_monome_device_desc+0x7e>
80019400:	30 8c       	mov	r12,8
80019402:	31 0b       	mov	r11,16
      return 1;
80019404:	c9 8e       	rcall	80019134 <setup_series>

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
80019406:	30 1c       	mov	r12,1
  monome_ring_map = ringMapFuncs[mdesc.protocol];
}

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
80019408:	c1 1b       	rjmp	8001922a <check_monome_device_desc+0x7e>
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
8001940a:	30 88       	mov	r8,8
8001940c:	31 07       	mov	r7,16

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
8001940e:	ef 68 00 09 	st.b	r7[9],r8
}

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
80019412:	ef 68 00 08 	st.b	r7[8],r8
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80019416:	8f 1c       	st.w	r7[0x4],r12
80019418:	8f 0c       	st.w	r7[0x0],r12
8001941a:	4b 1c       	lddpc	r12,800194dc <check_monome_device_desc+0x330>
  print_dbg_ulong(mdesc.protocol);
8001941c:	fe b0 cd c0 	rcall	80012f9c <print_dbg>
80019420:	6e 0c       	ld.w	r12,r7[0x0]
  monome_read_serial = readSerialFuncs[mdesc.protocol];
80019422:	fe b0 cd c3 	rcall	80012fa8 <print_dbg_ulong>
80019426:	4a f9       	lddpc	r9,800194e0 <check_monome_device_desc+0x334>
80019428:	6e 08       	ld.w	r8,r7[0x0]
8001942a:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
  monome_grid_map = gridMapFuncs[mdesc.protocol];
8001942e:	30 c9       	mov	r9,12
80019430:	93 0a       	st.w	r9[0x0],r10
80019432:	e0 6a 31 5c 	mov	r10,12636
80019436:	4a c9       	lddpc	r9,800194e4 <check_monome_device_desc+0x338>
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
80019438:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
  monome_ring_map = ringMapFuncs[mdesc.protocol];
8001943c:	95 09       	st.w	r10[0x0],r9
8001943e:	e0 6a 32 64 	mov	r10,12900
80019442:	95 09       	st.w	r10[0x0],r9
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  set_funcs();
  monomeConnect = 1;
80019444:	4a 99       	lddpc	r9,800194e8 <check_monome_device_desc+0x33c>
  print_dbg("\r\n setting monome functions, protocol idx: ");
  print_dbg_ulong(mdesc.protocol);
  monome_read_serial = readSerialFuncs[mdesc.protocol];
  monome_grid_map = gridMapFuncs[mdesc.protocol];
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
  monome_ring_map = ringMapFuncs[mdesc.protocol];
80019446:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  set_funcs();
  monomeConnect = 1;
8001944a:	e0 68 31 60 	mov	r8,12640
      return 0;
    }
    if(buf[3] == 'h') {
      // this is a 40h
      setup_40h(8, 8);
      return 1;
8001944e:	30 1c       	mov	r12,1
  }
  
  prx = ftdi_rx_buf();
  prx++; // 1st returned byte is 0
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
80019450:	91 09       	st.w	r8[0x0],r9
80019452:	30 19       	mov	r9,1
    prx++;
    if(*prx == 1) {
80019454:	e0 68 0b cf 	mov	r8,3023
80019458:	b0 89       	st.b	r8[0x0],r9
8001945a:	ce 8a       	rjmp	8001922a <check_monome_device_desc+0x7e>
      print_dbg("\r\n monome 64");
      mdesc.rows = 8;
      mdesc.cols = 8;
    }
    else if(*prx == 2) {
8001945c:	8f 16       	st.w	r7[0x4],r6
8001945e:	31 06       	mov	r6,16
80019460:	19 98       	ld.ub	r8,r12[0x1]
80019462:	f2 08 18 00 	cp.b	r8,r9
      print_dbg("\r\n monome 128");
      mdesc.rows = 8;
      mdesc.cols = 16;
    }
    else if(*prx == 4) {
80019466:	c1 60       	breq	80019492 <check_monome_device_desc+0x2e6>
80019468:	30 29       	mov	r9,2
8001946a:	f2 08 18 00 	cp.b	r8,r9
      print_dbg("\r\n monome 256");
8001946e:	c1 b0       	breq	800194a4 <check_monome_device_desc+0x2f8>
80019470:	30 49       	mov	r9,4
80019472:	f2 08 18 00 	cp.b	r8,r9
      mdesc.rows = 16; 
      mdesc.cols = 16;
80019476:	fe 91 fe d9 	brne	80019228 <check_monome_device_desc+0x7c>
      mdesc.rows = 8;
      mdesc.cols = 16;
    }
    else if(*prx == 4) {
      print_dbg("\r\n monome 256");
      mdesc.rows = 16; 
8001947a:	49 ec       	lddpc	r12,800194f0 <check_monome_device_desc+0x344>
8001947c:	fe b0 cd 90 	rcall	80012f9c <print_dbg>
      mdesc.cols = 16;
    }
    else {
      return 0;
    }		
    mdesc.tilt = 1;
80019480:	31 08       	mov	r8,16
80019482:	ed 68 00 08 	st.b	r6[8],r8
  prx++; // 1st returned byte is 0
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
    prx++;
    if(*prx == 1) {
      print_dbg("\r\n monome 64");
80019486:	ed 68 00 09 	st.b	r6[9],r8
8001948a:	30 18       	mov	r8,1
      mdesc.rows = 8;
8001948c:	ef 68 00 0b 	st.b	r7[11],r8
      mdesc.cols = 8;
80019490:	c8 fb       	rjmp	800193ae <check_monome_device_desc+0x202>
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
    prx++;
    if(*prx == 1) {
      print_dbg("\r\n monome 64");
      mdesc.rows = 8;
80019492:	49 9c       	lddpc	r12,800194f4 <check_monome_device_desc+0x348>
80019494:	fe b0 cd 84 	rcall	80012f9c <print_dbg>
      mdesc.cols = 8;
    }
    else if(*prx == 2) {
      print_dbg("\r\n monome 128");
80019498:	30 88       	mov	r8,8
8001949a:	ed 68 00 08 	st.b	r6[8],r8
      mdesc.rows = 8;
8001949e:	ed 68 00 09 	st.b	r6[9],r8
800194a2:	cf 4b       	rjmp	8001948a <check_monome_device_desc+0x2de>
      mdesc.cols = 16;
800194a4:	49 5c       	lddpc	r12,800194f8 <check_monome_device_desc+0x34c>
800194a6:	fe b0 cd 7b 	rcall	80012f9c <print_dbg>
800194aa:	30 88       	mov	r8,8
800194ac:	ed 68 00 09 	st.b	r6[9],r8
800194b0:	31 08       	mov	r8,16
800194b2:	ed 68 00 08 	st.b	r6[8],r8
800194b6:	ce ab       	rjmp	8001948a <check_monome_device_desc+0x2de>
800194b8:	80 02       	ld.sh	r2,r0[0x0]
800194ba:	4a 70       	lddpc	r0,80019554 <screen_startup+0x8>
800194bc:	80 02       	ld.sh	r2,r0[0x0]
800194be:	4a 78       	lddpc	r8,80019558 <screen_startup+0xc>
800194c0:	80 02       	ld.sh	r2,r0[0x0]
800194c2:	4a 80       	lddpc	r0,80019560 <screen_startup+0x14>
800194c4:	80 02       	ld.sh	r2,r0[0x0]
800194c6:	4a 88       	lddpc	r8,80019564 <screen_startup+0x18>
800194c8:	80 02       	ld.sh	r2,r0[0x0]
800194ca:	4a 90       	lddpc	r0,8001956c <screen_startup+0x20>
800194cc:	80 02       	ld.sh	r2,r0[0x0]
800194ce:	4b 9c       	lddpc	r12,800195b0 <screen_startup+0x64>
800194d0:	80 02       	ld.sh	r2,r0[0x0]
800194d2:	4a a8       	lddpc	r8,80019578 <screen_startup+0x2c>
800194d4:	80 02       	ld.sh	r2,r0[0x0]
800194d6:	4a d8       	lddpc	r8,80019588 <screen_startup+0x3c>
800194d8:	80 02       	ld.sh	r2,r0[0x0]
800194da:	4a f4       	lddpc	r4,80019594 <screen_startup+0x48>
800194dc:	80 02       	ld.sh	r2,r0[0x0]
800194de:	4a 44       	lddpc	r4,8001956c <screen_startup+0x20>
800194e0:	80 02       	ld.sh	r2,r0[0x0]
800194e2:	4b c4       	lddpc	r4,800195d0 <screen_startup+0x84>
800194e4:	80 02       	ld.sh	r2,r0[0x0]
800194e6:	4a 20       	lddpc	r0,8001956c <screen_startup+0x20>
800194e8:	80 02       	ld.sh	r2,r0[0x0]
800194ea:	4a 14       	lddpc	r4,8001956c <screen_startup+0x20>
800194ec:	80 02       	ld.sh	r2,r0[0x0]
800194ee:	4b 70       	lddpc	r0,800195c8 <screen_startup+0x7c>
800194f0:	80 02       	ld.sh	r2,r0[0x0]
800194f2:	4b 60       	lddpc	r0,800195c8 <screen_startup+0x7c>
800194f4:	80 02       	ld.sh	r2,r0[0x0]
800194f6:	4b 40       	lddpc	r0,800195c4 <screen_startup+0x78>
800194f8:	80 02       	ld.sh	r2,r0[0x0]
800194fa:	4b 50       	lddpc	r0,800195cc <screen_startup+0x80>

800194fc <screen_clear>:
}



 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
800194fc:	eb cd 40 e0 	pushm	r5-r7,lr
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019500:	30 0b       	mov	r11,0
80019502:	fe 7c 28 00 	mov	r12,-55296
80019506:	fe b0 ca fb 	rcall	80012afc <spi_selectChip>
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
8001950a:	30 9c       	mov	r12,9
8001950c:	fe b0 c8 f9 	rcall	800126fe <gpio_set_gpio_pin>
  for(i=0; i<GRAM_BYTES; i++) { 
80019510:	30 09       	mov	r9,0
80019512:	e0 67 0c 28 	mov	r7,3112
80019516:	12 98       	mov	r8,r9
80019518:	8f 09       	st.w	r7[0x0],r9
    screenBuf[i] = 0;
8001951a:	e0 65 0c 30 	mov	r5,3120
8001951e:	12 96       	mov	r6,r9
    spi_write(OLED_SPI, 0);
80019520:	ea 08 0b 06 	st.b	r5[r8],r6
80019524:	30 0b       	mov	r11,0
80019526:	fe 7c 28 00 	mov	r12,-55296
 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  for(i=0; i<GRAM_BYTES; i++) { 
8001952a:	fe b0 cb 7e 	rcall	80012c26 <spi_write>
8001952e:	6e 08       	ld.w	r8,r7[0x0]
80019530:	2f f8       	sub	r8,-1
80019532:	8f 08       	st.w	r7[0x0],r8
80019534:	e0 48 0f ff 	cp.w	r8,4095
    screenBuf[i] = 0;
    spi_write(OLED_SPI, 0);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019538:	fe 98 ff f4 	brls	80019520 <screen_clear+0x24>
8001953c:	30 0b       	mov	r11,0
8001953e:	fe 7c 28 00 	mov	r12,-55296
}
80019542:	fe b0 cb 05 	rcall	80012b4c <spi_unselectChip>
80019546:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001954a:	d7 03       	nop

8001954c <screen_startup>:
8001954c:	eb cd 40 c0 	pushm	r6-r7,lr
80019550:	e0 66 0c 30 	mov	r6,3120
80019554:	4a 59       	lddpc	r9,800195e8 <screen_startup+0x9c>
80019556:	0c 98       	mov	r8,r6
80019558:	ec c7 f0 00 	sub	r7,r6,-4096
8001955c:	10 a9       	st.w	r8++,r9
8001955e:	0e 38       	cp.w	r8,r7
  // fill screenbuffer with grey background
  for(i=0; i<GRAM_BYTES; i++) {
    screenBuf[i] = 0x22;
  }

  print_dbg("\r\n screen_startup");
80019560:	cf e1       	brne	8001955c <screen_startup+0x10>
80019562:	4a 1c       	lddpc	r12,800195e4 <screen_startup+0x98>
80019564:	fe b0 cd 1c 	rcall	80012f9c <print_dbg>

  // net art: draw glyphs to screen buf directly,
  // should be stretched out and upside down
  font_glyph('A', screenBuf + 80,      64, 0x55, 0x22);
80019568:	32 28       	mov	r8,34
8001956a:	35 59       	mov	r9,85
8001956c:	34 0a       	mov	r10,64
8001956e:	ec cb ff b0 	sub	r11,r6,-80
80019572:	34 1c       	mov	r12,65
80019574:	fe b0 f1 96 	rcall	800178a0 <font_glyph>
  font_glyph('L', screenBuf + 80 + 8,  64, 0x55, 0x22);
80019578:	32 28       	mov	r8,34
8001957a:	35 59       	mov	r9,85
8001957c:	34 0a       	mov	r10,64
8001957e:	ec cb ff a8 	sub	r11,r6,-88
80019582:	34 cc       	mov	r12,76
80019584:	fe b0 f1 8e 	rcall	800178a0 <font_glyph>
  font_glyph('E', screenBuf + 80 + 16, 64, 0x55, 0x22);
80019588:	32 28       	mov	r8,34
8001958a:	35 59       	mov	r9,85
8001958c:	34 0a       	mov	r10,64
8001958e:	ec cb ff a0 	sub	r11,r6,-96
80019592:	34 5c       	mov	r12,69
80019594:	fe b0 f1 86 	rcall	800178a0 <font_glyph>
  font_glyph('P', screenBuf + 80 + 24, 64, 0x55, 0x22);
80019598:	32 28       	mov	r8,34
8001959a:	35 59       	mov	r9,85
8001959c:	34 0a       	mov	r10,64
8001959e:	ec cb ff 98 	sub	r11,r6,-104
800195a2:	35 0c       	mov	r12,80
800195a4:	fe b0 f1 7e 	rcall	800178a0 <font_glyph>
  font_glyph('H', screenBuf + 80 + 32, 64, 0x55, 0x22);
800195a8:	32 28       	mov	r8,34
800195aa:	35 59       	mov	r9,85
800195ac:	34 0a       	mov	r10,64
800195ae:	ec cb ff 90 	sub	r11,r6,-112
800195b2:	34 8c       	mov	r12,72
800195b4:	fe b0 f1 76 	rcall	800178a0 <font_glyph>

    // send screenbuffer
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800195b8:	30 0b       	mov	r11,0
800195ba:	fe 7c 28 00 	mov	r12,-55296
800195be:	fe b0 ca 9f 	rcall	80012afc <spi_selectChip>
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
800195c2:	30 9c       	mov	r12,9
800195c4:	fe b0 c8 9d 	rcall	800126fe <gpio_set_gpio_pin>
  // send data
  for(i=0; i<GRAM_BYTES; i++) {
    spi_write(OLED_SPI, screenBuf[i]);
800195c8:	0d 3b       	ld.ub	r11,r6++
800195ca:	fe 7c 28 00 	mov	r12,-55296
800195ce:	fe b0 cb 2c 	rcall	80012c26 <spi_write>
    // send screenbuffer
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  // send data
  for(i=0; i<GRAM_BYTES; i++) {
800195d2:	0e 36       	cp.w	r6,r7
    spi_write(OLED_SPI, screenBuf[i]);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS); 
800195d4:	cf a1       	brne	800195c8 <screen_startup+0x7c>
800195d6:	30 0b       	mov	r11,0
800195d8:	fe 7c 28 00 	mov	r12,-55296
800195dc:	fe b0 ca b8 	rcall	80012b4c <spi_unselectChip>
}
800195e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800195e4:	80 02       	ld.sh	r2,r0[0x0]
800195e6:	4b d0       	lddpc	r0,800196d8 <screen_draw_region+0xbc>
800195e8:	22 22       	sub	r2,34
800195ea:	22 22       	sub	r2,34

800195ec <write_command>:
800195ec:	eb cd 40 80 	pushm	r7,lr
800195f0:	30 0b       	mov	r11,0
800195f2:	18 97       	mov	r7,r12
800195f4:	fe 7c 28 00 	mov	r12,-55296
800195f8:	fe b0 ca 82 	rcall	80012afc <spi_selectChip>
800195fc:	30 9c       	mov	r12,9
800195fe:	fe b0 c8 8d 	rcall	80012718 <gpio_clr_gpio_pin>
80019602:	0e 9b       	mov	r11,r7
80019604:	fe 7c 28 00 	mov	r12,-55296
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
80019608:	fe b0 cb 0f 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8001960c:	30 0b       	mov	r11,0
8001960e:	fe 7c 28 00 	mov	r12,-55296
80019612:	fe b0 ca 9d 	rcall	80012b4c <spi_unselectChip>
}
80019616:	e3 cd 80 80 	ldm	sp++,r7,pc
8001961a:	d7 03       	nop

8001961c <screen_draw_region>:
8001961c:	d4 31       	pushm	r0-r7,lr
8001961e:	20 2d       	sub	sp,8
80019620:	ed da c0 28 	bfextu	r6,r10,0x1,0x8
80019624:	f9 dc c0 28 	bfextu	r12,r12,0x1,0x8
80019628:	10 93       	mov	r3,r8
8001962a:	f2 06 02 48 	mul	r8,r9,r6
}


// draw data given target rect
// assume x-offset and width are both even!
extern void screen_draw_region(u8 x, u8 y, u8 w, u8 h, u8* data) {
8001962e:	12 97       	mov	r7,r9
80019630:	50 1b       	stdsp	sp[0x4],r11
  static u32 nb; // count of destination bytes
  //  static u32 off; // offset from end of screenbuffer
  // 1 row address = 2 horizontal pixels
  //  u32 wb = w >> 1;
  w >>= 1;
  x >>= 1;
80019632:	50 0c       	stdsp	sp[0x0],r12
  nb = w * h;
80019634:	e0 65 1c 34 	mov	r5,7220
80019638:	4f 8c       	lddpc	r12,80019818 <screen_draw_region+0x1fc>

  print_dbg("\r\n screen_draw_region: w:");
8001963a:	8b 08       	st.w	r5[0x0],r8
8001963c:	fe b0 cc b0 	rcall	80012f9c <print_dbg>
  // print_dbg("\r\n bytes in row: "); */
  print_dbg_ulong(w); 
80019640:	0c 9c       	mov	r12,r6
80019642:	fe b0 cc b3 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg(" , x:"); 
80019646:	4f 6c       	lddpc	r12,8001981c <screen_draw_region+0x200>
80019648:	fe b0 cc aa 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(x); 
8001964c:	40 0c       	lddsp	r12,sp[0x0]
8001964e:	fe b0 cc ad 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg(" , h:");
80019652:	4f 4c       	lddpc	r12,80019820 <screen_draw_region+0x204>
80019654:	fe b0 cc a4 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(h);
80019658:	0e 9c       	mov	r12,r7
8001965a:	fe b0 cc a7 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg(" , y:");
8001965e:	4f 2c       	lddpc	r12,80019824 <screen_draw_region+0x208>
80019660:	fe b0 cc 9e 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(y);
80019664:	40 1c       	lddsp	r12,sp[0x4]
80019666:	fe b0 cc a1 	rcall	80012fa8 <print_dbg_ulong>

  /// the screen is mounted upside down!'
  // copy, pack, and reverse into the top of the screen buffer
  // 2 bytes input -> 1 byte output
    pScr = (u8*)screenBuf + nb - 1;
8001966a:	e0 68 1c 30 	mov	r8,7216
  for(j=0; j<h; j++) {
8001966e:	e0 64 0c 30 	mov	r4,3120
  print_dbg_ulong(y);

  /// the screen is mounted upside down!'
  // copy, pack, and reverse into the top of the screen buffer
  // 2 bytes input -> 1 byte output
    pScr = (u8*)screenBuf + nb - 1;
80019672:	6a 02       	ld.w	r2,r5[0x0]
80019674:	30 0e       	mov	lr,0
80019676:	20 12       	sub	r2,1
  for(j=0; j<h; j++) {
80019678:	e8 02 00 02 	add	r2,r4,r2
8001967c:	91 02       	st.w	r8[0x0],r2
8001967e:	e0 68 0c 2c 	mov	r8,3116
    for(i=0; i<w; i++) {
80019682:	91 0e       	st.w	r8[0x0],lr
80019684:	58 07       	cp.w	r7,0
80019686:	e0 80 00 c6 	breq	80019812 <screen_draw_region+0x1f6>
8001968a:	ec 00 15 01 	lsl	r0,r6,0x1
8001968e:	ec 01 11 00 	rsub	r1,r6,0
80019692:	58 06       	cp.w	r6,0
      *pScr = (0xf0 & ((*data) << 4) );
80019694:	c1 50       	breq	800196be <screen_draw_region+0xa2>
80019696:	04 99       	mov	r9,r2
80019698:	06 98       	mov	r8,r3
8001969a:	30 0a       	mov	r10,0
      data++;
      *pScr |= ((*data) & 0xf);
8001969c:	11 8b       	ld.ub	r11,r8[0x0]
8001969e:	a5 6b       	lsl	r11,0x4
800196a0:	5c 5b       	castu.b	r11
800196a2:	b2 8b       	st.b	r9[0x0],r11
800196a4:	11 9c       	ld.ub	r12,r8[0x1]
}


// draw data given target rect
// assume x-offset and width are both even!
extern void screen_draw_region(u8 x, u8 y, u8 w, u8 h, u8* data) {
800196a6:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
800196aa:	18 4b       	or	r11,r12
  /// the screen is mounted upside down!'
  // copy, pack, and reverse into the top of the screen buffer
  // 2 bytes input -> 1 byte output
    pScr = (u8*)screenBuf + nb - 1;
  for(j=0; j<h; j++) {
    for(i=0; i<w; i++) {
800196ac:	b2 8b       	st.b	r9[0x0],r11
800196ae:	2f e8       	sub	r8,-2
800196b0:	2f fa       	sub	r10,-1
800196b2:	20 19       	sub	r9,1
800196b4:	14 36       	cp.w	r6,r10
800196b6:	fe 9b ff f3 	brhi	8001969c <screen_draw_region+0x80>

  /// the screen is mounted upside down!'
  // copy, pack, and reverse into the top of the screen buffer
  // 2 bytes input -> 1 byte output
    pScr = (u8*)screenBuf + nb - 1;
  for(j=0; j<h; j++) {
800196ba:	00 03       	add	r3,r0
800196bc:	02 02       	add	r2,r1
800196be:	2f fe       	sub	lr,-1
800196c0:	1c 37       	cp.w	r7,lr
800196c2:	fe 9b ff e8 	brhi	80019692 <screen_draw_region+0x76>
800196c6:	e0 68 1c 30 	mov	r8,7216
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800196ca:	e0 63 0c 28 	mov	r3,3112
    }
  }
  
  // flip the screen coordinates 
  x = SCREEN_ROW_BYTES - x -  w;
  y = SCREEN_COL_BYTES - y - h;
800196ce:	91 02       	st.w	r8[0x0],r2
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800196d0:	87 06       	st.w	r3[0x0],r6
800196d2:	e0 68 0c 2c 	mov	r8,3116
800196d6:	91 07       	st.w	r8[0x0],r7
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800196d8:	30 0b       	mov	r11,0
800196da:	40 01       	lddsp	r1,sp[0x0]
800196dc:	40 12       	lddsp	r2,sp[0x4]
  spi_write(OLED_SPI, c);
800196de:	fe 7c 28 00 	mov	r12,-55296
800196e2:	fe b0 ca 0d 	rcall	80012afc <spi_selectChip>
800196e6:	30 9c       	mov	r12,9
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800196e8:	fe b0 c8 18 	rcall	80012718 <gpio_clr_gpio_pin>
800196ec:	31 5b       	mov	r11,21
800196ee:	fe 7c 28 00 	mov	r12,-55296
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800196f2:	fe b0 ca 9a 	rcall	80012c26 <spi_write>
800196f6:	30 0b       	mov	r11,0
800196f8:	fe 7c 28 00 	mov	r12,-55296
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800196fc:	fe b0 ca 28 	rcall	80012b4c <spi_unselectChip>
80019700:	30 0b       	mov	r11,0
      pScr--;
    }
  }
  
  // flip the screen coordinates 
  x = SCREEN_ROW_BYTES - x -  w;
80019702:	fe 7c 28 00 	mov	r12,-55296
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
80019706:	fe b0 c9 fb 	rcall	80012afc <spi_selectChip>
      pScr--;
    }
  }
  
  // flip the screen coordinates 
  x = SCREEN_ROW_BYTES - x -  w;
8001970a:	30 9c       	mov	r12,9
8001970c:	fe b0 c8 06 	rcall	80012718 <gpio_clr_gpio_pin>
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
80019710:	5c 31       	neg	r1
80019712:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019716:	2c 01       	sub	r1,-64
80019718:	0c 11       	sub	r1,r6
8001971a:	5c 51       	castu.b	r1
8001971c:	02 9b       	mov	r11,r1
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8001971e:	fe b0 ca 84 	rcall	80012c26 <spi_write>
80019722:	30 0b       	mov	r11,0
80019724:	fe 7c 28 00 	mov	r12,-55296
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019728:	fe b0 ca 12 	rcall	80012b4c <spi_unselectChip>
8001972c:	30 0b       	mov	r11,0
  spi_write(OLED_SPI, c);
8001972e:	fe 7c 28 00 	mov	r12,-55296
80019732:	fe b0 c9 e5 	rcall	80012afc <spi_selectChip>
80019736:	30 9c       	mov	r12,9
80019738:	fe b0 c7 f0 	rcall	80012718 <gpio_clr_gpio_pin>
8001973c:	ec cb 00 01 	sub	r11,r6,1
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019740:	fe 7c 28 00 	mov	r12,-55296
80019744:	02 0b       	add	r11,r1
80019746:	5c 5b       	castu.b	r11
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019748:	fe b0 ca 6f 	rcall	80012c26 <spi_write>
8001974c:	30 0b       	mov	r11,0
8001974e:	fe 7c 28 00 	mov	r12,-55296
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019752:	fe b0 c9 fd 	rcall	80012b4c <spi_unselectChip>
80019756:	30 0b       	mov	r11,0
  spi_write(OLED_SPI, c);
80019758:	fe 7c 28 00 	mov	r12,-55296
8001975c:	fe b0 c9 d0 	rcall	80012afc <spi_selectChip>
80019760:	30 9c       	mov	r12,9
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019762:	fe b0 c7 db 	rcall	80012718 <gpio_clr_gpio_pin>
80019766:	37 5b       	mov	r11,117
80019768:	fe 7c 28 00 	mov	r12,-55296
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8001976c:	fe b0 ca 5d 	rcall	80012c26 <spi_write>
80019770:	30 0b       	mov	r11,0
80019772:	fe 7c 28 00 	mov	r12,-55296
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019776:	fe b0 c9 eb 	rcall	80012b4c <spi_unselectChip>
8001977a:	30 0b       	mov	r11,0
    }
  }
  
  // flip the screen coordinates 
  x = SCREEN_ROW_BYTES - x -  w;
  y = SCREEN_COL_BYTES - y - h;
8001977c:	fe 7c 28 00 	mov	r12,-55296
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
80019780:	fe b0 c9 be 	rcall	80012afc <spi_selectChip>
    }
  }
  
  // flip the screen coordinates 
  x = SCREEN_ROW_BYTES - x -  w;
  y = SCREEN_COL_BYTES - y - h;
80019784:	30 9c       	mov	r12,9
80019786:	fe b0 c7 c9 	rcall	80012718 <gpio_clr_gpio_pin>
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
8001978a:	5c 32       	neg	r2
8001978c:	fe 7c 28 00 	mov	r12,-55296
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019790:	2c 02       	sub	r2,-64
80019792:	0e 12       	sub	r2,r7
80019794:	5c 52       	castu.b	r2
80019796:	04 9b       	mov	r11,r2
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019798:	fe b0 ca 47 	rcall	80012c26 <spi_write>
8001979c:	30 0b       	mov	r11,0
8001979e:	fe 7c 28 00 	mov	r12,-55296
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800197a2:	fe b0 c9 d5 	rcall	80012b4c <spi_unselectChip>
800197a6:	30 0b       	mov	r11,0
  spi_write(OLED_SPI, c);
800197a8:	fe 7c 28 00 	mov	r12,-55296
800197ac:	fe b0 c9 a8 	rcall	80012afc <spi_selectChip>
800197b0:	30 9c       	mov	r12,9
800197b2:	fe b0 c7 b3 	rcall	80012718 <gpio_clr_gpio_pin>
800197b6:	0e 9b       	mov	r11,r7
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800197b8:	fe 7c 28 00 	mov	r12,-55296
800197bc:	20 1b       	sub	r11,1
800197be:	04 0b       	add	r11,r2
800197c0:	5c 5b       	castu.b	r11
  y = SCREEN_COL_BYTES - y - h;
  
  // set drawing region
  screen_set_rect(x, y, w, h);
  // select chip for data
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800197c2:	fe b0 ca 32 	rcall	80012c26 <spi_write>
800197c6:	30 0b       	mov	r11,0
800197c8:	fe 7c 28 00 	mov	r12,-55296
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
800197cc:	fe b0 c9 c0 	rcall	80012b4c <spi_unselectChip>
800197d0:	30 0b       	mov	r11,0
  // send data
  for(i=0; i<(nb); i++) {
800197d2:	fe 7c 28 00 	mov	r12,-55296
800197d6:	fe b0 c9 93 	rcall	80012afc <spi_selectChip>
800197da:	30 9c       	mov	r12,9
    spi_write(OLED_SPI, screenBuf[i]);
800197dc:	fe b0 c7 91 	rcall	800126fe <gpio_set_gpio_pin>
800197e0:	30 08       	mov	r8,0
800197e2:	87 08       	st.w	r3[0x0],r8
800197e4:	6a 09       	ld.w	r9,r5[0x0]
800197e6:	58 09       	cp.w	r9,0
  // select chip for data
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  // send data
  for(i=0; i<(nb); i++) {
800197e8:	c0 e0       	breq	80019804 <screen_draw_region+0x1e8>
800197ea:	e8 08 07 0b 	ld.ub	r11,r4[r8]
800197ee:	fe 7c 28 00 	mov	r12,-55296
800197f2:	fe b0 ca 1a 	rcall	80012c26 <spi_write>
    spi_write(OLED_SPI, screenBuf[i]);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800197f6:	66 08       	ld.w	r8,r3[0x0]
800197f8:	2f f8       	sub	r8,-1
800197fa:	87 08       	st.w	r3[0x0],r8
800197fc:	6a 09       	ld.w	r9,r5[0x0]
800197fe:	10 39       	cp.w	r9,r8
}
80019800:	fe 9b ff f5 	brhi	800197ea <screen_draw_region+0x1ce>
80019804:	30 0b       	mov	r11,0
80019806:	fe 7c 28 00 	mov	r12,-55296
8001980a:	fe b0 c9 a1 	rcall	80012b4c <spi_unselectChip>
8001980e:	2f ed       	sub	sp,-8
80019810:	d8 32       	popm	r0-r7,pc
80019812:	e0 63 0c 28 	mov	r3,3112
80019816:	c6 1b       	rjmp	800196d8 <screen_draw_region+0xbc>
80019818:	80 02       	ld.sh	r2,r0[0x0]
8001981a:	4b e4       	lddpc	r4,80019910 <init_oled+0xe8>
8001981c:	80 02       	ld.sh	r2,r0[0x0]
8001981e:	4c 00       	lddpc	r0,8001991c <init_oled+0xf4>
80019820:	80 02       	ld.sh	r2,r0[0x0]
80019822:	4c 08       	lddpc	r8,80019920 <init_oled+0xf8>
80019824:	80 02       	ld.sh	r2,r0[0x0]
80019826:	4c 10       	lddpc	r0,80019928 <init_oled+0x100>

80019828 <init_oled>:
80019828:	d4 21       	pushm	r4-r7,lr
8001982a:	d3 03       	ssrf	0x10
8001982c:	30 7c       	mov	r12,7
8001982e:	fe b0 c7 68 	rcall	800126fe <gpio_set_gpio_pin>
80019832:	30 09       	mov	r9,0
80019834:	e0 68 03 e8 	mov	r8,1000
80019838:	30 07       	mov	r7,0
8001983a:	e0 66 14 80 	mov	r6,5248
8001983e:	ea 16 03 ef 	orh	r6,0x3ef
80019842:	e0 6a 18 67 	mov	r10,6247
80019846:	ea 1a 03 ef 	orh	r10,0x3ef
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8001984a:	30 0b       	mov	r11,0
8001984c:	e0 a0 4b c3 	rcall	80022fd2 <__avr32_udiv64>
80019850:	14 95       	mov	r5,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80019852:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80019856:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001985a:	e1 b8 00 42 	mfsr	r8,0x108
8001985e:	14 39       	cp.w	r9,r10
80019860:	e0 8b 02 cf 	brhi	80019dfe <init_oled+0x5d6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80019864:	10 39       	cp.w	r9,r8
80019866:	e0 8b 00 05 	brhi	80019870 <init_oled+0x48>
8001986a:	10 3a       	cp.w	r10,r8
8001986c:	e0 82 02 eb 	brhs	80019e42 <init_oled+0x61a>
  Disable_global_interrupt();
  //  delay_ms(1);
  // flip the reset pin
  gpio_set_gpio_pin(OLED_RESET_PIN);
  delay_ms(1);
  gpio_clr_gpio_pin(OLED_RESET_PIN);
80019870:	30 7c       	mov	r12,7
80019872:	fe b0 c7 53 	rcall	80012718 <gpio_clr_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80019876:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001987a:	f0 05 00 05 	add	r5,r8,r5
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001987e:	e1 b9 00 42 	mfsr	r9,0x108
80019882:	0a 38       	cp.w	r8,r5
80019884:	e0 8b 02 c6 	brhi	80019e10 <init_oled+0x5e8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80019888:	12 38       	cp.w	r8,r9
8001988a:	e0 8b 00 05 	brhi	80019894 <init_oled+0x6c>
8001988e:	12 35       	cp.w	r5,r9
80019890:	e0 82 02 dd 	brhs	80019e4a <init_oled+0x622>
  delay_ms(1);
  gpio_set_gpio_pin(OLED_RESET_PIN);
80019894:	30 7c       	mov	r12,7
80019896:	fe b0 c7 34 	rcall	800126fe <gpio_set_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8001989a:	ee 0c 10 0a 	mul	r12,r7,10
8001989e:	e0 68 03 e8 	mov	r8,1000
800198a2:	30 07       	mov	r7,0
800198a4:	30 09       	mov	r9,0
800198a6:	30 ab       	mov	r11,10
800198a8:	ec 0b 06 4a 	mulu.d	r10,r6,r11
800198ac:	e0 66 03 e7 	mov	r6,999
800198b0:	f8 0b 00 0b 	add	r11,r12,r11
800198b4:	0c 0a       	add	r10,r6
800198b6:	f6 07 00 4b 	adc	r11,r11,r7
800198ba:	e0 a0 4b 8c 	rcall	80022fd2 <__avr32_udiv64>
800198be:	14 94       	mov	r4,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800198c0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800198c4:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800198c8:	e1 b9 00 42 	mfsr	r9,0x108
800198cc:	14 38       	cp.w	r8,r10
800198ce:	e0 8b 02 a9 	brhi	80019e20 <init_oled+0x5f8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800198d2:	12 38       	cp.w	r8,r9
800198d4:	e0 8b 00 05 	brhi	800198de <init_oled+0xb6>
800198d8:	12 3a       	cp.w	r10,r9
800198da:	e0 82 02 bc 	brhs	80019e52 <init_oled+0x62a>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800198de:	30 0b       	mov	r11,0
800198e0:	fe 7c 28 00 	mov	r12,-55296
800198e4:	fe b0 c9 0c 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800198e8:	30 9c       	mov	r12,9
800198ea:	fe b0 c7 17 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800198ee:	e0 6b 00 ae 	mov	r11,174
800198f2:	fe 7c 28 00 	mov	r12,-55296
800198f6:	fe b0 c9 98 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800198fa:	30 0b       	mov	r11,0
800198fc:	fe 7c 28 00 	mov	r12,-55296
80019900:	fe b0 c9 26 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019904:	30 0b       	mov	r11,0
80019906:	fe 7c 28 00 	mov	r12,-55296
8001990a:	fe b0 c8 f9 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8001990e:	30 9c       	mov	r12,9
80019910:	fe b0 c7 04 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019914:	e0 6b 00 b3 	mov	r11,179
80019918:	fe 7c 28 00 	mov	r12,-55296
8001991c:	fe b0 c9 85 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019920:	30 0b       	mov	r11,0
80019922:	fe 7c 28 00 	mov	r12,-55296
80019926:	fe b0 c9 13 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8001992a:	30 0b       	mov	r11,0
8001992c:	fe 7c 28 00 	mov	r12,-55296
80019930:	fe b0 c8 e6 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019934:	30 9c       	mov	r12,9
80019936:	fe b0 c6 f1 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
8001993a:	e0 6b 00 91 	mov	r11,145
8001993e:	fe 7c 28 00 	mov	r12,-55296
80019942:	fe b0 c9 72 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019946:	30 0b       	mov	r11,0
80019948:	fe 7c 28 00 	mov	r12,-55296
8001994c:	fe b0 c9 00 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019950:	30 0b       	mov	r11,0
80019952:	fe 7c 28 00 	mov	r12,-55296
80019956:	fe b0 c8 d3 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
8001995a:	30 9c       	mov	r12,9
8001995c:	fe b0 c6 de 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019960:	e0 6b 00 a8 	mov	r11,168
80019964:	fe 7c 28 00 	mov	r12,-55296
80019968:	fe b0 c9 5f 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
8001996c:	30 0b       	mov	r11,0
8001996e:	fe 7c 28 00 	mov	r12,-55296
80019972:	fe b0 c8 ed 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019976:	30 0b       	mov	r11,0
80019978:	fe 7c 28 00 	mov	r12,-55296
8001997c:	fe b0 c8 c0 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019980:	30 9c       	mov	r12,9
80019982:	fe b0 c6 cb 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019986:	33 fb       	mov	r11,63
80019988:	fe 7c 28 00 	mov	r12,-55296
8001998c:	fe b0 c9 4d 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019990:	30 0b       	mov	r11,0
80019992:	fe 7c 28 00 	mov	r12,-55296
80019996:	fe b0 c8 db 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
8001999a:	30 0b       	mov	r11,0
8001999c:	fe 7c 28 00 	mov	r12,-55296
800199a0:	fe b0 c8 ae 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800199a4:	30 9c       	mov	r12,9
800199a6:	fe b0 c6 b9 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800199aa:	e0 6b 00 86 	mov	r11,134
800199ae:	fe 7c 28 00 	mov	r12,-55296
800199b2:	fe b0 c9 3a 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800199b6:	30 0b       	mov	r11,0
800199b8:	fe 7c 28 00 	mov	r12,-55296
800199bc:	fe b0 c8 c8 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800199c0:	30 0b       	mov	r11,0
800199c2:	fe 7c 28 00 	mov	r12,-55296
800199c6:	fe b0 c8 9b 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800199ca:	30 9c       	mov	r12,9
800199cc:	fe b0 c6 a6 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800199d0:	e0 6b 00 81 	mov	r11,129
800199d4:	fe 7c 28 00 	mov	r12,-55296
800199d8:	fe b0 c9 27 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
800199dc:	30 0b       	mov	r11,0
800199de:	fe 7c 28 00 	mov	r12,-55296
800199e2:	fe b0 c8 b5 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
800199e6:	30 0b       	mov	r11,0
800199e8:	fe 7c 28 00 	mov	r12,-55296
800199ec:	fe b0 c8 88 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
800199f0:	30 9c       	mov	r12,9
800199f2:	fe b0 c6 93 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
800199f6:	37 fb       	mov	r11,127
800199f8:	fe 7c 28 00 	mov	r12,-55296
800199fc:	fe b0 c9 15 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019a00:	30 0b       	mov	r11,0
80019a02:	fe 7c 28 00 	mov	r12,-55296
80019a06:	fe b0 c8 a3 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019a0a:	30 0b       	mov	r11,0
80019a0c:	fe 7c 28 00 	mov	r12,-55296
80019a10:	fe b0 c8 76 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019a14:	30 9c       	mov	r12,9
80019a16:	fe b0 c6 81 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019a1a:	e0 6b 00 b2 	mov	r11,178
80019a1e:	fe 7c 28 00 	mov	r12,-55296
80019a22:	fe b0 c9 02 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019a26:	30 0b       	mov	r11,0
80019a28:	fe 7c 28 00 	mov	r12,-55296
80019a2c:	fe b0 c8 90 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019a30:	30 0b       	mov	r11,0
80019a32:	fe 7c 28 00 	mov	r12,-55296
80019a36:	fe b0 c8 63 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019a3a:	30 9c       	mov	r12,9
80019a3c:	fe b0 c6 6e 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019a40:	35 1b       	mov	r11,81
80019a42:	fe 7c 28 00 	mov	r12,-55296
80019a46:	fe b0 c8 f0 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019a4a:	30 0b       	mov	r11,0
80019a4c:	fe 7c 28 00 	mov	r12,-55296
80019a50:	fe b0 c8 7e 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019a54:	30 0b       	mov	r11,0
80019a56:	fe 7c 28 00 	mov	r12,-55296
80019a5a:	fe b0 c8 51 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019a5e:	30 9c       	mov	r12,9
80019a60:	fe b0 c6 5c 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019a64:	e0 6b 00 a8 	mov	r11,168
80019a68:	fe 7c 28 00 	mov	r12,-55296
80019a6c:	fe b0 c8 dd 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019a70:	30 0b       	mov	r11,0
80019a72:	fe 7c 28 00 	mov	r12,-55296
80019a76:	fe b0 c8 6b 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019a7a:	30 0b       	mov	r11,0
80019a7c:	fe 7c 28 00 	mov	r12,-55296
80019a80:	fe b0 c8 3e 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019a84:	30 9c       	mov	r12,9
80019a86:	fe b0 c6 49 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019a8a:	33 fb       	mov	r11,63
80019a8c:	fe 7c 28 00 	mov	r12,-55296
80019a90:	fe b0 c8 cb 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019a94:	30 0b       	mov	r11,0
80019a96:	fe 7c 28 00 	mov	r12,-55296
80019a9a:	fe b0 c8 59 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019a9e:	30 0b       	mov	r11,0
80019aa0:	fe 7c 28 00 	mov	r12,-55296
80019aa4:	fe b0 c8 2c 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019aa8:	30 9c       	mov	r12,9
80019aaa:	fe b0 c6 37 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019aae:	e0 6b 00 bc 	mov	r11,188
80019ab2:	fe 7c 28 00 	mov	r12,-55296
80019ab6:	fe b0 c8 b8 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019aba:	30 0b       	mov	r11,0
80019abc:	fe 7c 28 00 	mov	r12,-55296
80019ac0:	fe b0 c8 46 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019ac4:	30 0b       	mov	r11,0
80019ac6:	fe 7c 28 00 	mov	r12,-55296
80019aca:	fe b0 c8 19 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019ace:	30 9c       	mov	r12,9
80019ad0:	fe b0 c6 24 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019ad4:	31 0b       	mov	r11,16
80019ad6:	fe 7c 28 00 	mov	r12,-55296
80019ada:	fe b0 c8 a6 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019ade:	30 0b       	mov	r11,0
80019ae0:	fe 7c 28 00 	mov	r12,-55296
80019ae4:	fe b0 c8 34 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019ae8:	30 0b       	mov	r11,0
80019aea:	fe 7c 28 00 	mov	r12,-55296
80019aee:	fe b0 c8 07 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019af2:	30 9c       	mov	r12,9
80019af4:	fe b0 c6 12 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019af8:	e0 6b 00 be 	mov	r11,190
80019afc:	fe 7c 28 00 	mov	r12,-55296
80019b00:	fe b0 c8 93 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019b04:	30 0b       	mov	r11,0
80019b06:	fe 7c 28 00 	mov	r12,-55296
80019b0a:	fe b0 c8 21 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019b0e:	30 0b       	mov	r11,0
80019b10:	fe 7c 28 00 	mov	r12,-55296
80019b14:	fe b0 c7 f4 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019b18:	30 9c       	mov	r12,9
80019b1a:	fe b0 c5 ff 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019b1e:	31 cb       	mov	r11,28
80019b20:	fe 7c 28 00 	mov	r12,-55296
80019b24:	fe b0 c8 81 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019b28:	30 0b       	mov	r11,0
80019b2a:	fe 7c 28 00 	mov	r12,-55296
80019b2e:	fe b0 c8 0f 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019b32:	30 0b       	mov	r11,0
80019b34:	fe 7c 28 00 	mov	r12,-55296
80019b38:	fe b0 c7 e2 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019b3c:	30 9c       	mov	r12,9
80019b3e:	fe b0 c5 ed 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019b42:	e0 6b 00 ad 	mov	r11,173
80019b46:	fe 7c 28 00 	mov	r12,-55296
80019b4a:	fe b0 c8 6e 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019b4e:	30 0b       	mov	r11,0
80019b50:	fe 7c 28 00 	mov	r12,-55296
80019b54:	fe b0 c7 fc 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019b58:	30 0b       	mov	r11,0
80019b5a:	fe 7c 28 00 	mov	r12,-55296
80019b5e:	fe b0 c7 cf 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019b62:	30 9c       	mov	r12,9
80019b64:	fe b0 c5 da 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019b68:	30 2b       	mov	r11,2
80019b6a:	fe 7c 28 00 	mov	r12,-55296
80019b6e:	fe b0 c8 5c 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019b72:	30 0b       	mov	r11,0
80019b74:	fe 7c 28 00 	mov	r12,-55296
80019b78:	fe b0 c7 ea 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019b7c:	30 0b       	mov	r11,0
80019b7e:	fe 7c 28 00 	mov	r12,-55296
80019b82:	fe b0 c7 bd 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019b86:	30 9c       	mov	r12,9
80019b88:	fe b0 c5 c8 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019b8c:	e0 6b 00 a0 	mov	r11,160
80019b90:	fe 7c 28 00 	mov	r12,-55296
80019b94:	fe b0 c8 49 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019b98:	30 0b       	mov	r11,0
80019b9a:	fe 7c 28 00 	mov	r12,-55296
80019b9e:	fe b0 c7 d7 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019ba2:	30 0b       	mov	r11,0
80019ba4:	fe 7c 28 00 	mov	r12,-55296
80019ba8:	fe b0 c7 aa 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019bac:	30 9c       	mov	r12,9
80019bae:	fe b0 c5 b5 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019bb2:	35 0b       	mov	r11,80
80019bb4:	fe 7c 28 00 	mov	r12,-55296
80019bb8:	fe b0 c8 37 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019bbc:	30 0b       	mov	r11,0
80019bbe:	fe 7c 28 00 	mov	r12,-55296
80019bc2:	fe b0 c7 c5 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019bc6:	30 0b       	mov	r11,0
80019bc8:	fe 7c 28 00 	mov	r12,-55296
80019bcc:	fe b0 c7 98 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019bd0:	30 9c       	mov	r12,9
80019bd2:	fe b0 c5 a3 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019bd6:	e0 6b 00 a1 	mov	r11,161
80019bda:	fe 7c 28 00 	mov	r12,-55296
80019bde:	fe b0 c8 24 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019be2:	30 0b       	mov	r11,0
80019be4:	fe 7c 28 00 	mov	r12,-55296
80019be8:	fe b0 c7 b2 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019bec:	30 0b       	mov	r11,0
80019bee:	fe 7c 28 00 	mov	r12,-55296
80019bf2:	fe b0 c7 85 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019bf6:	30 9c       	mov	r12,9
80019bf8:	fe b0 c5 90 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019bfc:	30 0b       	mov	r11,0
80019bfe:	fe 7c 28 00 	mov	r12,-55296
80019c02:	fe b0 c8 12 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019c06:	30 0b       	mov	r11,0
80019c08:	fe 7c 28 00 	mov	r12,-55296
80019c0c:	fe b0 c7 a0 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019c10:	30 0b       	mov	r11,0
80019c12:	fe 7c 28 00 	mov	r12,-55296
80019c16:	fe b0 c7 73 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019c1a:	30 9c       	mov	r12,9
80019c1c:	fe b0 c5 7e 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019c20:	e0 6b 00 a2 	mov	r11,162
80019c24:	fe 7c 28 00 	mov	r12,-55296
80019c28:	fe b0 c7 ff 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019c2c:	30 0b       	mov	r11,0
80019c2e:	fe 7c 28 00 	mov	r12,-55296
80019c32:	fe b0 c7 8d 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019c36:	30 0b       	mov	r11,0
80019c38:	fe 7c 28 00 	mov	r12,-55296
80019c3c:	fe b0 c7 60 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019c40:	30 9c       	mov	r12,9
80019c42:	fe b0 c5 6b 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019c46:	34 cb       	mov	r11,76
80019c48:	fe 7c 28 00 	mov	r12,-55296
80019c4c:	fe b0 c7 ed 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019c50:	30 0b       	mov	r11,0
80019c52:	fe 7c 28 00 	mov	r12,-55296
80019c56:	fe b0 c7 7b 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019c5a:	30 0b       	mov	r11,0
80019c5c:	fe 7c 28 00 	mov	r12,-55296
80019c60:	fe b0 c7 4e 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019c64:	30 9c       	mov	r12,9
80019c66:	fe b0 c5 59 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019c6a:	e0 6b 00 b1 	mov	r11,177
80019c6e:	fe 7c 28 00 	mov	r12,-55296
80019c72:	fe b0 c7 da 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019c76:	30 0b       	mov	r11,0
80019c78:	fe 7c 28 00 	mov	r12,-55296
80019c7c:	fe b0 c7 68 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019c80:	30 0b       	mov	r11,0
80019c82:	fe 7c 28 00 	mov	r12,-55296
80019c86:	fe b0 c7 3b 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019c8a:	30 9c       	mov	r12,9
80019c8c:	fe b0 c5 46 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019c90:	35 5b       	mov	r11,85
80019c92:	fe 7c 28 00 	mov	r12,-55296
80019c96:	fe b0 c7 c8 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019c9a:	30 0b       	mov	r11,0
80019c9c:	fe 7c 28 00 	mov	r12,-55296
80019ca0:	fe b0 c7 56 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019ca4:	30 0b       	mov	r11,0
80019ca6:	fe 7c 28 00 	mov	r12,-55296
80019caa:	fe b0 c7 29 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019cae:	30 9c       	mov	r12,9
80019cb0:	fe b0 c5 34 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019cb4:	e0 6b 00 b4 	mov	r11,180
80019cb8:	fe 7c 28 00 	mov	r12,-55296
80019cbc:	fe b0 c7 b5 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019cc0:	30 0b       	mov	r11,0
80019cc2:	fe 7c 28 00 	mov	r12,-55296
80019cc6:	fe b0 c7 43 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019cca:	30 0b       	mov	r11,0
80019ccc:	fe 7c 28 00 	mov	r12,-55296
80019cd0:	fe b0 c7 16 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019cd4:	30 9c       	mov	r12,9
80019cd6:	fe b0 c5 21 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019cda:	30 2b       	mov	r11,2
80019cdc:	fe 7c 28 00 	mov	r12,-55296
80019ce0:	fe b0 c7 a3 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019ce4:	30 0b       	mov	r11,0
80019ce6:	fe 7c 28 00 	mov	r12,-55296
80019cea:	fe b0 c7 31 	rcall	80012b4c <spi_unselectChip>
// fixed-point text buffer
//static char buf[FIX_DIG_TOTAL];

static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019cee:	30 0b       	mov	r11,0
80019cf0:	fe 7c 28 00 	mov	r12,-55296
80019cf4:	fe b0 c7 04 	rcall	80012afc <spi_selectChip>
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
80019cf8:	30 9c       	mov	r12,9
80019cfa:	fe b0 c5 0f 	rcall	80012718 <gpio_clr_gpio_pin>
  spi_write(OLED_SPI, c);
80019cfe:	e0 6b 00 b0 	mov	r11,176
80019d02:	fe 7c 28 00 	mov	r12,-55296
80019d06:	fe b0 c7 90 	rcall	80012c26 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019d0a:	30 0b       	mov	r11,0
80019d0c:	fe 7c 28 00 	mov	r12,-55296
80019d10:	fe b0 c7 1e 	rcall	80012b4c <spi_unselectChip>
  write_command(0xB1);	// set phase
  write_command(0x55);
  write_command(0xB4);	// precharge
  write_command(0x02);
  write_command(0xB0);	// precharge
  write_command(0x28);
80019d14:	32 8c       	mov	r12,40
80019d16:	fe b0 fc 6b 	rcall	800195ec <write_command>
  write_command(0xBF);	// vsl
80019d1a:	e0 6c 00 bf 	mov	r12,191
80019d1e:	fe b0 fc 67 	rcall	800195ec <write_command>
  write_command(0x0F);
80019d22:	30 fc       	mov	r12,15
80019d24:	fe b0 fc 64 	rcall	800195ec <write_command>
  write_command(0xA4);	// normal display
80019d28:	e0 6c 00 a4 	mov	r12,164
80019d2c:	fe b0 fc 60 	rcall	800195ec <write_command>
  write_command(0xB8);	// greyscale table
80019d30:	e0 6c 00 b8 	mov	r12,184
80019d34:	fe b0 fc 5c 	rcall	800195ec <write_command>
  write_command(0x01);
80019d38:	30 1c       	mov	r12,1
80019d3a:	fe b0 fc 59 	rcall	800195ec <write_command>
  write_command(0x11);
80019d3e:	31 1c       	mov	r12,17
80019d40:	fe b0 fc 56 	rcall	800195ec <write_command>
  write_command(0x22);
80019d44:	32 2c       	mov	r12,34
80019d46:	fe b0 fc 53 	rcall	800195ec <write_command>
  write_command(0x32);
80019d4a:	33 2c       	mov	r12,50
80019d4c:	fe b0 fc 50 	rcall	800195ec <write_command>
  write_command(0x43);
80019d50:	34 3c       	mov	r12,67
80019d52:	fe b0 fc 4d 	rcall	800195ec <write_command>
  write_command(0x54);
80019d56:	35 4c       	mov	r12,84
80019d58:	fe b0 fc 4a 	rcall	800195ec <write_command>
  write_command(0x65);
80019d5c:	36 5c       	mov	r12,101
80019d5e:	fe b0 fc 47 	rcall	800195ec <write_command>
  write_command(0x76);	
80019d62:	37 6c       	mov	r12,118
80019d64:	fe b0 fc 44 	rcall	800195ec <write_command>
		
  // set update box (to full screen)
  write_command(0x15);
80019d68:	31 5c       	mov	r12,21
80019d6a:	fe b0 fc 41 	rcall	800195ec <write_command>
  write_command(0);
80019d6e:	30 0c       	mov	r12,0
80019d70:	fe b0 fc 3e 	rcall	800195ec <write_command>
  write_command(63);
80019d74:	33 fc       	mov	r12,63
80019d76:	fe b0 fc 3b 	rcall	800195ec <write_command>
  write_command(0x75);
80019d7a:	37 5c       	mov	r12,117
80019d7c:	fe b0 fc 38 	rcall	800195ec <write_command>
  write_command(0);
80019d80:	30 0c       	mov	r12,0
80019d82:	fe b0 fc 35 	rcall	800195ec <write_command>
  write_command(63); // ???
80019d86:	33 fc       	mov	r12,63
80019d88:	fe b0 fc 32 	rcall	800195ec <write_command>



 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80019d8c:	30 0b       	mov	r11,0
80019d8e:	fe 7c 28 00 	mov	r12,-55296
80019d92:	fe b0 c6 b5 	rcall	80012afc <spi_selectChip>
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
80019d96:	30 9c       	mov	r12,9
80019d98:	fe b0 c4 b3 	rcall	800126fe <gpio_set_gpio_pin>
  for(i=0; i<GRAM_BYTES; i++) { 
80019d9c:	30 09       	mov	r9,0
80019d9e:	e0 67 0c 28 	mov	r7,3112
80019da2:	12 98       	mov	r8,r9
80019da4:	8f 09       	st.w	r7[0x0],r9
    screenBuf[i] = 0;
80019da6:	e0 65 0c 30 	mov	r5,3120
80019daa:	12 96       	mov	r6,r9
    spi_write(OLED_SPI, 0);
80019dac:	ea 08 0b 06 	st.b	r5[r8],r6
80019db0:	30 0b       	mov	r11,0
80019db2:	fe 7c 28 00 	mov	r12,-55296
 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  for(i=0; i<GRAM_BYTES; i++) { 
80019db6:	fe b0 c7 38 	rcall	80012c26 <spi_write>
80019dba:	6e 08       	ld.w	r8,r7[0x0]
80019dbc:	2f f8       	sub	r8,-1
80019dbe:	8f 08       	st.w	r7[0x0],r8
80019dc0:	e0 48 0f ff 	cp.w	r8,4095
    screenBuf[i] = 0;
    spi_write(OLED_SPI, 0);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80019dc4:	fe 98 ff f4 	brls	80019dac <init_oled+0x584>
80019dc8:	30 0b       	mov	r11,0
80019dca:	fe 7c 28 00 	mov	r12,-55296
  write_command(0);
  write_command(63); // ???

  screen_clear();
  
  write_command(0xAF);	// on
80019dce:	fe b0 c6 bf 	rcall	80012b4c <spi_unselectChip>
80019dd2:	e0 6c 00 af 	mov	r12,175
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80019dd6:	fe b0 fc 0b 	rcall	800195ec <write_command>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80019dda:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019dde:	f2 04 00 04 	add	r4,r9,r4
80019de2:	e1 b8 00 42 	mfsr	r8,0x108
80019de6:	08 39       	cp.w	r9,r4
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80019de8:	e0 8b 00 26 	brhi	80019e34 <init_oled+0x60c>
80019dec:	10 39       	cp.w	r9,r8
80019dee:	e0 8b 00 04 	brhi	80019df6 <init_oled+0x5ce>
  delay_ms(10) ;
  //  cpu_irq_enable();
  Enable_global_interrupt();
80019df2:	10 34       	cp.w	r4,r8
}
80019df4:	c3 32       	brcc	80019e5a <init_oled+0x632>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019df6:	d5 03       	csrf	0x10
80019df8:	d8 22       	popm	r4-r7,pc
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80019dfa:	e1 b8 00 42 	mfsr	r8,0x108
80019dfe:	10 39       	cp.w	r9,r8
80019e00:	fe 98 ff fd 	brls	80019dfa <init_oled+0x5d2>
80019e04:	10 3a       	cp.w	r10,r8
80019e06:	fe 93 fd 35 	brlo	80019870 <init_oled+0x48>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019e0a:	cf 8b       	rjmp	80019dfa <init_oled+0x5d2>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80019e0c:	e1 b9 00 42 	mfsr	r9,0x108
80019e10:	10 39       	cp.w	r9,r8
80019e12:	cf d2       	brcc	80019e0c <init_oled+0x5e4>
80019e14:	0a 39       	cp.w	r9,r5
80019e16:	fe 9b fd 3f 	brhi	80019894 <init_oled+0x6c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019e1a:	cf 9b       	rjmp	80019e0c <init_oled+0x5e4>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80019e1c:	e1 b9 00 42 	mfsr	r9,0x108
80019e20:	10 39       	cp.w	r9,r8
80019e22:	cf d2       	brcc	80019e1c <init_oled+0x5f4>
80019e24:	14 39       	cp.w	r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019e26:	fe 9b fd 5c 	brhi	800198de <init_oled+0xb6>
80019e2a:	e1 b9 00 42 	mfsr	r9,0x108
80019e2e:	cf 9b       	rjmp	80019e20 <init_oled+0x5f8>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80019e30:	e1 b8 00 42 	mfsr	r8,0x108
80019e34:	12 38       	cp.w	r8,r9
80019e36:	cf d2       	brcc	80019e30 <init_oled+0x608>
80019e38:	08 38       	cp.w	r8,r4
  screen_clear();
  
  write_command(0xAF);	// on
  delay_ms(10) ;
  //  cpu_irq_enable();
  Enable_global_interrupt();
80019e3a:	fe 98 ff fb 	brls	80019e30 <init_oled+0x608>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80019e3e:	d5 03       	csrf	0x10
80019e40:	d8 22       	popm	r4-r7,pc
80019e42:	e1 b8 00 42 	mfsr	r8,0x108
80019e46:	fe 9f fd 0f 	bral	80019864 <init_oled+0x3c>
80019e4a:	e1 b9 00 42 	mfsr	r9,0x108
80019e4e:	fe 9f fd 1d 	bral	80019888 <init_oled+0x60>
80019e52:	e1 b9 00 42 	mfsr	r9,0x108
80019e56:	fe 9f fd 3e 	bral	800198d2 <init_oled+0xaa>
80019e5a:	e1 b8 00 42 	mfsr	r8,0x108
80019e5e:	cc 7b       	rjmp	80019dec <init_oled+0x5c4>

80019e60 <process_sw>:
  kEventSwitch7,
};


// generate events from switch interrupts
void process_sw( const U8 swIdx )  {
80019e60:	eb cd 40 80 	pushm	r7,lr
  static event_t e;   
  e.eventType = kSwitchEvents[swIdx];
80019e64:	48 98       	lddpc	r8,80019e88 <process_sw+0x28>
80019e66:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
80019e6a:	e0 67 1c 38 	mov	r7,7224
  e.eventData = gpio_get_pin_value(kSwitchPins[swIdx]);
80019e6e:	8f 08       	st.w	r7[0x0],r8
80019e70:	48 78       	lddpc	r8,80019e8c <process_sw+0x2c>
80019e72:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80019e76:	fe b0 c4 39 	rcall	800126e8 <gpio_get_pin_value>
  post_event(&e);
80019e7a:	8f 1c       	st.w	r7[0x4],r12
80019e7c:	0e 9c       	mov	r12,r7
80019e7e:	fe b0 ea c9 	rcall	80017410 <post_event>
}
80019e82:	e3 cd 80 80 	ldm	sp++,r7,pc
80019e86:	d7 03       	nop
80019e88:	80 02       	ld.sh	r2,r0[0x0]
80019e8a:	4c 18       	lddpc	r8,80019f8c <process_timers+0xfc>
80019e8c:	80 02       	ld.sh	r2,r0[0x0]
80019e8e:	4c 38       	lddpc	r8,80019f98 <process_timers+0x108>

80019e90 <process_timers>:


// process the list of timers.
// called from tc interrupt
/// FIXME: this is overly generalized for our purpose, i think.
void process_timers( void ) {
80019e90:	eb cd 40 c0 	pushm	r6-r7,lr
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019e94:	e0 67 1c 40 	mov	r7,7232
80019e98:	6e 06       	ld.w	r6,r7[0x0]
    if ( t == 0 ) { continue; }
80019e9a:	58 06       	cp.w	r6,0
80019e9c:	c0 90       	breq	80019eae <process_timers+0x1e>

    if ( t->timeout > 0 ) {
80019e9e:	6c 28       	ld.w	r8,r6[0x8]
80019ea0:	58 08       	cp.w	r8,0
80019ea2:	e0 8a 00 06 	brle	80019eae <process_timers+0x1e>
      // time remaining, decrement tick counter
      t->timeout--;
80019ea6:	20 18       	sub	r8,1
80019ea8:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019eaa:	e0 80 00 89 	breq	80019fbc <process_timers+0x12c>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019eae:	6e 16       	ld.w	r6,r7[0x4]
    if ( t == 0 ) { continue; }
80019eb0:	58 06       	cp.w	r6,0
80019eb2:	c0 90       	breq	80019ec4 <process_timers+0x34>

    if ( t->timeout > 0 ) {
80019eb4:	6c 28       	ld.w	r8,r6[0x8]
80019eb6:	58 08       	cp.w	r8,0
80019eb8:	e0 8a 00 06 	brle	80019ec4 <process_timers+0x34>
      // time remaining, decrement tick counter
      t->timeout--;
80019ebc:	20 18       	sub	r8,1
80019ebe:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019ec0:	e0 80 00 8c 	breq	80019fd8 <process_timers+0x148>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019ec4:	6e 26       	ld.w	r6,r7[0x8]
    if ( t == 0 ) { continue; }
80019ec6:	58 06       	cp.w	r6,0
80019ec8:	c0 90       	breq	80019eda <process_timers+0x4a>

    if ( t->timeout > 0 ) {
80019eca:	6c 28       	ld.w	r8,r6[0x8]
80019ecc:	58 08       	cp.w	r8,0
80019ece:	e0 8a 00 06 	brle	80019eda <process_timers+0x4a>
      // time remaining, decrement tick counter
      t->timeout--;
80019ed2:	20 18       	sub	r8,1
80019ed4:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019ed6:	e0 80 00 8f 	breq	80019ff4 <process_timers+0x164>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019eda:	6e 36       	ld.w	r6,r7[0xc]
    if ( t == 0 ) { continue; }
80019edc:	58 06       	cp.w	r6,0
80019ede:	c0 90       	breq	80019ef0 <process_timers+0x60>

    if ( t->timeout > 0 ) {
80019ee0:	6c 28       	ld.w	r8,r6[0x8]
80019ee2:	58 08       	cp.w	r8,0
80019ee4:	e0 8a 00 06 	brle	80019ef0 <process_timers+0x60>
      // time remaining, decrement tick counter
      t->timeout--;
80019ee8:	20 18       	sub	r8,1
80019eea:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019eec:	e0 80 00 92 	breq	8001a010 <process_timers+0x180>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019ef0:	6e 46       	ld.w	r6,r7[0x10]
    if ( t == 0 ) { continue; }
80019ef2:	58 06       	cp.w	r6,0
80019ef4:	c0 90       	breq	80019f06 <process_timers+0x76>

    if ( t->timeout > 0 ) {
80019ef6:	6c 28       	ld.w	r8,r6[0x8]
80019ef8:	58 08       	cp.w	r8,0
80019efa:	e0 8a 00 06 	brle	80019f06 <process_timers+0x76>
      // time remaining, decrement tick counter
      t->timeout--;
80019efe:	20 18       	sub	r8,1
80019f00:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f02:	e0 80 00 95 	breq	8001a02c <process_timers+0x19c>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f06:	6e 56       	ld.w	r6,r7[0x14]
    if ( t == 0 ) { continue; }
80019f08:	58 06       	cp.w	r6,0
80019f0a:	c0 90       	breq	80019f1c <process_timers+0x8c>

    if ( t->timeout > 0 ) {
80019f0c:	6c 28       	ld.w	r8,r6[0x8]
80019f0e:	58 08       	cp.w	r8,0
80019f10:	e0 8a 00 06 	brle	80019f1c <process_timers+0x8c>
      // time remaining, decrement tick counter
      t->timeout--;
80019f14:	20 18       	sub	r8,1
80019f16:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f18:	e0 80 00 98 	breq	8001a048 <process_timers+0x1b8>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f1c:	6e 66       	ld.w	r6,r7[0x18]
    if ( t == 0 ) { continue; }
80019f1e:	58 06       	cp.w	r6,0
80019f20:	c0 90       	breq	80019f32 <process_timers+0xa2>

    if ( t->timeout > 0 ) {
80019f22:	6c 28       	ld.w	r8,r6[0x8]
80019f24:	58 08       	cp.w	r8,0
80019f26:	e0 8a 00 06 	brle	80019f32 <process_timers+0xa2>
      // time remaining, decrement tick counter
      t->timeout--;
80019f2a:	20 18       	sub	r8,1
80019f2c:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f2e:	e0 80 00 9b 	breq	8001a064 <process_timers+0x1d4>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f32:	6e 76       	ld.w	r6,r7[0x1c]
    if ( t == 0 ) { continue; }
80019f34:	58 06       	cp.w	r6,0
80019f36:	c0 90       	breq	80019f48 <process_timers+0xb8>

    if ( t->timeout > 0 ) {
80019f38:	6c 28       	ld.w	r8,r6[0x8]
80019f3a:	58 08       	cp.w	r8,0
80019f3c:	e0 8a 00 06 	brle	80019f48 <process_timers+0xb8>
      // time remaining, decrement tick counter
      t->timeout--;
80019f40:	20 18       	sub	r8,1
80019f42:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f44:	e0 80 00 9e 	breq	8001a080 <process_timers+0x1f0>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f48:	6e 86       	ld.w	r6,r7[0x20]
    if ( t == 0 ) { continue; }
80019f4a:	58 06       	cp.w	r6,0
80019f4c:	c0 90       	breq	80019f5e <process_timers+0xce>

    if ( t->timeout > 0 ) {
80019f4e:	6c 28       	ld.w	r8,r6[0x8]
80019f50:	58 08       	cp.w	r8,0
80019f52:	e0 8a 00 06 	brle	80019f5e <process_timers+0xce>
      // time remaining, decrement tick counter
      t->timeout--;
80019f56:	20 18       	sub	r8,1
80019f58:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f5a:	e0 80 00 a1 	breq	8001a09c <process_timers+0x20c>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f5e:	6e 96       	ld.w	r6,r7[0x24]
    if ( t == 0 ) { continue; }
80019f60:	58 06       	cp.w	r6,0
80019f62:	c0 90       	breq	80019f74 <process_timers+0xe4>

    if ( t->timeout > 0 ) {
80019f64:	6c 28       	ld.w	r8,r6[0x8]
80019f66:	58 08       	cp.w	r8,0
80019f68:	e0 8a 00 06 	brle	80019f74 <process_timers+0xe4>
      // time remaining, decrement tick counter
      t->timeout--;
80019f6c:	20 18       	sub	r8,1
80019f6e:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f70:	e0 80 00 a4 	breq	8001a0b8 <process_timers+0x228>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f74:	6e a6       	ld.w	r6,r7[0x28]
    if ( t == 0 ) { continue; }
80019f76:	58 06       	cp.w	r6,0
80019f78:	c0 90       	breq	80019f8a <process_timers+0xfa>

    if ( t->timeout > 0 ) {
80019f7a:	6c 28       	ld.w	r8,r6[0x8]
80019f7c:	58 08       	cp.w	r8,0
80019f7e:	e0 8a 00 06 	brle	80019f8a <process_timers+0xfa>
      // time remaining, decrement tick counter
      t->timeout--;
80019f82:	20 18       	sub	r8,1
80019f84:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f86:	e0 80 00 a7 	breq	8001a0d4 <process_timers+0x244>
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
80019f8a:	6e b6       	ld.w	r6,r7[0x2c]
    if ( t == 0 ) { continue; }
80019f8c:	58 06       	cp.w	r6,0
80019f8e:	c0 80       	breq	80019f9e <process_timers+0x10e>

    if ( t->timeout > 0 ) {
80019f90:	6c 28       	ld.w	r8,r6[0x8]
80019f92:	58 08       	cp.w	r8,0
80019f94:	e0 8a 00 05 	brle	80019f9e <process_timers+0x10e>
      // time remaining, decrement tick counter
      t->timeout--;
80019f98:	20 18       	sub	r8,1
80019f9a:	8d 28       	st.w	r6[0x8],r8

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80019f9c:	c0 30       	breq	80019fa2 <process_timers+0x112>
80019f9e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	if ( t->callback != 0 ) {
80019fa2:	6c 48       	ld.w	r8,r6[0x10]
80019fa4:	58 08       	cp.w	r8,0
80019fa6:	c0 30       	breq	80019fac <process_timers+0x11c>
	  (*t->callback)( t->tag );
80019fa8:	6c 1c       	ld.w	r12,r6[0x4]
80019faa:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80019fac:	6c 08       	ld.w	r8,r6[0x0]
80019fae:	58 08       	cp.w	r8,0
80019fb0:	e0 80 00 a0 	breq	8001a0f0 <process_timers+0x260>
	  t->timeout = t->timeoutReload;
80019fb4:	6c 38       	ld.w	r8,r6[0xc]
80019fb6:	8d 28       	st.w	r6[0x8],r8
80019fb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
80019fbc:	6c 48       	ld.w	r8,r6[0x10]
80019fbe:	58 08       	cp.w	r8,0
80019fc0:	c0 30       	breq	80019fc6 <process_timers+0x136>
	  (*t->callback)( t->tag );
80019fc2:	6c 1c       	ld.w	r12,r6[0x4]
80019fc4:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80019fc6:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80019fc8:	58 08       	cp.w	r8,0
80019fca:	ef f8 0a 00 	st.weq	r7[0x0],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
80019fce:	ed f8 10 03 	ld.wne	r8,r6[0xc]
80019fd2:	ed f8 1a 02 	st.wne	r6[0x8],r8
80019fd6:	c6 cb       	rjmp	80019eae <process_timers+0x1e>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
80019fd8:	6c 48       	ld.w	r8,r6[0x10]
80019fda:	58 08       	cp.w	r8,0
80019fdc:	c0 30       	breq	80019fe2 <process_timers+0x152>
	  (*t->callback)( t->tag );
80019fde:	6c 1c       	ld.w	r12,r6[0x4]
80019fe0:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80019fe2:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80019fe4:	58 08       	cp.w	r8,0
80019fe6:	ef f8 0a 01 	st.weq	r7[0x4],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
80019fea:	ed f8 10 03 	ld.wne	r8,r6[0xc]
80019fee:	ed f8 1a 02 	st.wne	r6[0x8],r8
80019ff2:	c6 9b       	rjmp	80019ec4 <process_timers+0x34>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
80019ff4:	6c 48       	ld.w	r8,r6[0x10]
80019ff6:	58 08       	cp.w	r8,0
80019ff8:	c0 30       	breq	80019ffe <process_timers+0x16e>
	  (*t->callback)( t->tag );
80019ffa:	6c 1c       	ld.w	r12,r6[0x4]
80019ffc:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80019ffe:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a000:	58 08       	cp.w	r8,0
8001a002:	ef f8 0a 02 	st.weq	r7[0x8],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a006:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a00a:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a00e:	c6 6b       	rjmp	80019eda <process_timers+0x4a>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a010:	6c 48       	ld.w	r8,r6[0x10]
8001a012:	58 08       	cp.w	r8,0
8001a014:	c0 30       	breq	8001a01a <process_timers+0x18a>
	  (*t->callback)( t->tag );
8001a016:	6c 1c       	ld.w	r12,r6[0x4]
8001a018:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a01a:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a01c:	58 08       	cp.w	r8,0
8001a01e:	ef f8 0a 03 	st.weq	r7[0xc],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a022:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a026:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a02a:	c6 3b       	rjmp	80019ef0 <process_timers+0x60>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a02c:	6c 48       	ld.w	r8,r6[0x10]
8001a02e:	58 08       	cp.w	r8,0
8001a030:	c0 30       	breq	8001a036 <process_timers+0x1a6>
	  (*t->callback)( t->tag );
8001a032:	6c 1c       	ld.w	r12,r6[0x4]
8001a034:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a036:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a038:	58 08       	cp.w	r8,0
8001a03a:	ef f8 0a 04 	st.weq	r7[0x10],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a03e:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a042:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a046:	c6 0b       	rjmp	80019f06 <process_timers+0x76>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a048:	6c 48       	ld.w	r8,r6[0x10]
8001a04a:	58 08       	cp.w	r8,0
8001a04c:	c0 30       	breq	8001a052 <process_timers+0x1c2>
	  (*t->callback)( t->tag );
8001a04e:	6c 1c       	ld.w	r12,r6[0x4]
8001a050:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a052:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a054:	58 08       	cp.w	r8,0
8001a056:	ef f8 0a 05 	st.weq	r7[0x14],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a05a:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a05e:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a062:	c5 db       	rjmp	80019f1c <process_timers+0x8c>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a064:	6c 48       	ld.w	r8,r6[0x10]
8001a066:	58 08       	cp.w	r8,0
8001a068:	c0 30       	breq	8001a06e <process_timers+0x1de>
	  (*t->callback)( t->tag );
8001a06a:	6c 1c       	ld.w	r12,r6[0x4]
8001a06c:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a06e:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a070:	58 08       	cp.w	r8,0
8001a072:	ef f8 0a 06 	st.weq	r7[0x18],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a076:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a07a:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a07e:	c5 ab       	rjmp	80019f32 <process_timers+0xa2>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a080:	6c 48       	ld.w	r8,r6[0x10]
8001a082:	58 08       	cp.w	r8,0
8001a084:	c0 30       	breq	8001a08a <process_timers+0x1fa>
	  (*t->callback)( t->tag );
8001a086:	6c 1c       	ld.w	r12,r6[0x4]
8001a088:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a08a:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a08c:	58 08       	cp.w	r8,0
8001a08e:	ef f8 0a 07 	st.weq	r7[0x1c],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a092:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a096:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a09a:	c5 7b       	rjmp	80019f48 <process_timers+0xb8>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a09c:	6c 48       	ld.w	r8,r6[0x10]
8001a09e:	58 08       	cp.w	r8,0
8001a0a0:	c0 30       	breq	8001a0a6 <process_timers+0x216>
	  (*t->callback)( t->tag );
8001a0a2:	6c 1c       	ld.w	r12,r6[0x4]
8001a0a4:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a0a6:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a0a8:	58 08       	cp.w	r8,0
8001a0aa:	ef f8 0a 08 	st.weq	r7[0x20],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a0ae:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a0b2:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a0b6:	c5 4b       	rjmp	80019f5e <process_timers+0xce>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a0b8:	6c 48       	ld.w	r8,r6[0x10]
8001a0ba:	58 08       	cp.w	r8,0
8001a0bc:	c0 30       	breq	8001a0c2 <process_timers+0x232>
	  (*t->callback)( t->tag );
8001a0be:	6c 1c       	ld.w	r12,r6[0x4]
8001a0c0:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a0c2:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a0c4:	58 08       	cp.w	r8,0
8001a0c6:	ef f8 0a 09 	st.weq	r7[0x24],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a0ca:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a0ce:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a0d2:	c5 1b       	rjmp	80019f74 <process_timers+0xe4>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
	if ( t->callback != 0 ) {
8001a0d4:	6c 48       	ld.w	r8,r6[0x10]
8001a0d6:	58 08       	cp.w	r8,0
8001a0d8:	c0 30       	breq	8001a0de <process_timers+0x24e>
	  (*t->callback)( t->tag );
8001a0da:	6c 1c       	ld.w	r12,r6[0x4]
8001a0dc:	5d 18       	icall	r8
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
8001a0de:	6c 08       	ld.w	r8,r6[0x0]
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a0e0:	58 08       	cp.w	r8,0
8001a0e2:	ef f8 0a 0a 	st.weq	r7[0x28],r8
	  (*t->callback)( t->tag );
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
8001a0e6:	ed f8 10 03 	ld.wne	r8,r6[0xc]
8001a0ea:	ed f8 1a 02 	st.wne	r6[0x8],r8
8001a0ee:	c4 eb       	rjmp	80019f8a <process_timers+0xfa>
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
8001a0f0:	8f b8       	st.w	r7[0x2c],r8
8001a0f2:	c5 6b       	rjmp	80019f9e <process_timers+0x10e>

8001a0f4 <set_timer>:
8001a0f4:	eb cd 40 c0 	pushm	r6-r7,lr
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
8001a0f8:	58 09       	cp.w	r9,0
8001a0fa:	c7 e0       	breq	8001a1f6 <set_timer+0x102>
  int k;
  swTimer_t* t;

  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
8001a0fc:	d3 43       	ssrf	0x14

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a0fe:	e0 6e 1c 40 	mov	lr,7232
    if ( t == NULL ) {
8001a102:	7c 07       	ld.w	r7,lr[0x0]
8001a104:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a106:	c0 40       	breq	8001a10e <set_timer+0x1a>
8001a108:	6e 16       	ld.w	r6,r7[0x4]
8001a10a:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a10c:	c7 80       	breq	8001a1fc <set_timer+0x108>
    if ( t == NULL ) {
8001a10e:	7c 17       	ld.w	r7,lr[0x4]
8001a110:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a112:	c0 40       	breq	8001a11a <set_timer+0x26>
8001a114:	6e 16       	ld.w	r6,r7[0x4]
8001a116:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a118:	c7 80       	breq	8001a208 <set_timer+0x114>
    if ( t == NULL ) {
8001a11a:	7c 27       	ld.w	r7,lr[0x8]
8001a11c:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a11e:	c0 40       	breq	8001a126 <set_timer+0x32>
8001a120:	6e 16       	ld.w	r6,r7[0x4]
8001a122:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a124:	c7 60       	breq	8001a210 <set_timer+0x11c>
    if ( t == NULL ) {
8001a126:	7c 37       	ld.w	r7,lr[0xc]
8001a128:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a12a:	c0 40       	breq	8001a132 <set_timer+0x3e>
8001a12c:	6e 16       	ld.w	r6,r7[0x4]
8001a12e:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a130:	c7 40       	breq	8001a218 <set_timer+0x124>
    if ( t == NULL ) {
8001a132:	7c 47       	ld.w	r7,lr[0x10]
8001a134:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a136:	c0 40       	breq	8001a13e <set_timer+0x4a>
8001a138:	6e 16       	ld.w	r6,r7[0x4]
8001a13a:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a13c:	c7 20       	breq	8001a220 <set_timer+0x12c>
    if ( t == NULL ) {
8001a13e:	7c 57       	ld.w	r7,lr[0x14]
8001a140:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a142:	c0 40       	breq	8001a14a <set_timer+0x56>
8001a144:	6e 16       	ld.w	r6,r7[0x4]
8001a146:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a148:	c7 00       	breq	8001a228 <set_timer+0x134>
    if ( t == NULL ) {
8001a14a:	7c 67       	ld.w	r7,lr[0x18]
8001a14c:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a14e:	c0 40       	breq	8001a156 <set_timer+0x62>
8001a150:	6e 16       	ld.w	r6,r7[0x4]
8001a152:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a154:	c6 e0       	breq	8001a230 <set_timer+0x13c>
    if ( t == NULL ) {
8001a156:	7c 77       	ld.w	r7,lr[0x1c]
8001a158:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a15a:	c0 40       	breq	8001a162 <set_timer+0x6e>
8001a15c:	6e 16       	ld.w	r6,r7[0x4]
8001a15e:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a160:	c6 c0       	breq	8001a238 <set_timer+0x144>
    if ( t == NULL ) {
8001a162:	7c 87       	ld.w	r7,lr[0x20]
8001a164:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a166:	c0 40       	breq	8001a16e <set_timer+0x7a>
8001a168:	6e 16       	ld.w	r6,r7[0x4]
8001a16a:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a16c:	c6 a0       	breq	8001a240 <set_timer+0x14c>
    if ( t == NULL ) {
8001a16e:	7c 97       	ld.w	r7,lr[0x24]
8001a170:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a172:	c0 40       	breq	8001a17a <set_timer+0x86>
8001a174:	6e 16       	ld.w	r6,r7[0x4]
8001a176:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a178:	c6 80       	breq	8001a248 <set_timer+0x154>
    if ( t == NULL ) {
8001a17a:	7c a7       	ld.w	r7,lr[0x28]
8001a17c:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a17e:	c0 40       	breq	8001a186 <set_timer+0x92>
8001a180:	6e 16       	ld.w	r6,r7[0x4]
8001a182:	0c 3b       	cp.w	r11,r6
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
    t = timers[k];
8001a184:	c6 60       	breq	8001a250 <set_timer+0x15c>
    if ( t == NULL ) {
8001a186:	7c b7       	ld.w	r7,lr[0x2c]
8001a188:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
8001a18a:	c0 40       	breq	8001a192 <set_timer+0x9e>
8001a18c:	6e 16       	ld.w	r6,r7[0x4]
8001a18e:	0c 3b       	cp.w	r11,r6
      return t;
	//      }
    }
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
8001a190:	c6 40       	breq	8001a258 <set_timer+0x164>
  // dont add if callback appears in the list
  if ( find_timer( callback, tag ) != NULL ) {
    return false;
  }

  t->callback = callback;
8001a192:	d5 43       	csrf	0x14
  t->tag = tag;
8001a194:	99 49       	st.w	r12[0x10],r9
  t->timeout = ticks;
  t->fperiodic = fPeriodic;
8001a196:	99 1b       	st.w	r12[0x4],r11
  t->timeoutReload = ticks;
8001a198:	99 08       	st.w	r12[0x0],r8
    return false;
  }

  t->callback = callback;
  t->tag = tag;
  t->timeout = ticks;
8001a19a:	99 3a       	st.w	r12[0xc],r10
// Add timer to pointer array. Finds first empty slot.
static bool add_timer( swTimer_t* newTimer) {
  int k;
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
8001a19c:	99 2a       	st.w	r12[0x8],r10
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
8001a19e:	d3 43       	ssrf	0x14
8001a1a0:	e0 68 1c 40 	mov	r8,7232
8001a1a4:	7c 09       	ld.w	r9,lr[0x0]
8001a1a6:	58 09       	cp.w	r9,0
8001a1a8:	c5 d0       	breq	8001a262 <set_timer+0x16e>
8001a1aa:	70 19       	ld.w	r9,r8[0x4]
8001a1ac:	58 09       	cp.w	r9,0
8001a1ae:	c5 f0       	breq	8001a26c <set_timer+0x178>
8001a1b0:	70 29       	ld.w	r9,r8[0x8]
8001a1b2:	58 09       	cp.w	r9,0
8001a1b4:	c5 e0       	breq	8001a270 <set_timer+0x17c>
8001a1b6:	70 39       	ld.w	r9,r8[0xc]
8001a1b8:	58 09       	cp.w	r9,0
8001a1ba:	c5 d0       	breq	8001a274 <set_timer+0x180>
8001a1bc:	70 49       	ld.w	r9,r8[0x10]
8001a1be:	58 09       	cp.w	r9,0
8001a1c0:	c5 00       	breq	8001a260 <set_timer+0x16c>
8001a1c2:	70 59       	ld.w	r9,r8[0x14]
8001a1c4:	58 09       	cp.w	r9,0
8001a1c6:	c5 90       	breq	8001a278 <set_timer+0x184>
8001a1c8:	70 69       	ld.w	r9,r8[0x18]
8001a1ca:	58 09       	cp.w	r9,0
8001a1cc:	c5 80       	breq	8001a27c <set_timer+0x188>
8001a1ce:	70 79       	ld.w	r9,r8[0x1c]
8001a1d0:	58 09       	cp.w	r9,0
8001a1d2:	c5 70       	breq	8001a280 <set_timer+0x18c>
8001a1d4:	70 89       	ld.w	r9,r8[0x20]
8001a1d6:	58 09       	cp.w	r9,0
8001a1d8:	c5 60       	breq	8001a284 <set_timer+0x190>
8001a1da:	70 98       	ld.w	r8,r8[0x24]
8001a1dc:	58 08       	cp.w	r8,0
8001a1de:	c5 50       	breq	8001a288 <set_timer+0x194>
8001a1e0:	7c a8       	ld.w	r8,lr[0x28]
8001a1e2:	58 08       	cp.w	r8,0
8001a1e4:	c5 40       	breq	8001a28c <set_timer+0x198>
8001a1e6:	e0 68 1c 40 	mov	r8,7232
      //      Enable_interrupt_level( TIMER_INT_LEVEL );
      return true;
    }
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
8001a1ea:	70 b8       	ld.w	r8,r8[0x2c]
8001a1ec:	58 08       	cp.w	r8,0
8001a1ee:	c5 10       	breq	8001a290 <set_timer+0x19c>
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
8001a1f0:	d5 43       	csrf	0x14
8001a1f2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      continue;
    }

    if ( t->tag == tag ) {
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
8001a1f6:	12 9c       	mov	r12,r9
8001a1f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	  // tag and callback both specified and matched
	  //	  if (fReenableInterrupts)
	  //	    Enable_interrupt_level( TIMER_INT_LEVEL );
	  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
8001a1fc:	6e 47       	ld.w	r7,r7[0x10]
8001a1fe:	0e 39       	cp.w	r9,r7
8001a200:	c8 71       	brne	8001a10e <set_timer+0x1a>
      continue;
    }

    if ( t->tag == tag ) {
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
8001a202:	d5 43       	csrf	0x14
8001a204:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8001a208:	6e 47       	ld.w	r7,r7[0x10]
8001a20a:	0e 39       	cp.w	r9,r7
8001a20c:	c8 71       	brne	8001a11a <set_timer+0x26>
8001a20e:	cf ab       	rjmp	8001a202 <set_timer+0x10e>
8001a210:	6e 47       	ld.w	r7,r7[0x10]
8001a212:	0e 39       	cp.w	r9,r7
8001a214:	c8 91       	brne	8001a126 <set_timer+0x32>
8001a216:	cf 6b       	rjmp	8001a202 <set_timer+0x10e>
8001a218:	6e 47       	ld.w	r7,r7[0x10]
8001a21a:	0e 39       	cp.w	r9,r7
8001a21c:	c8 b1       	brne	8001a132 <set_timer+0x3e>
8001a21e:	cf 2b       	rjmp	8001a202 <set_timer+0x10e>
8001a220:	6e 47       	ld.w	r7,r7[0x10]
8001a222:	0e 39       	cp.w	r9,r7
8001a224:	c8 d1       	brne	8001a13e <set_timer+0x4a>
8001a226:	ce eb       	rjmp	8001a202 <set_timer+0x10e>
8001a228:	6e 47       	ld.w	r7,r7[0x10]
8001a22a:	0e 39       	cp.w	r9,r7
8001a22c:	c8 f1       	brne	8001a14a <set_timer+0x56>
8001a22e:	ce ab       	rjmp	8001a202 <set_timer+0x10e>
8001a230:	6e 47       	ld.w	r7,r7[0x10]
8001a232:	0e 39       	cp.w	r9,r7
8001a234:	c9 11       	brne	8001a156 <set_timer+0x62>
8001a236:	ce 6b       	rjmp	8001a202 <set_timer+0x10e>
8001a238:	6e 47       	ld.w	r7,r7[0x10]
8001a23a:	0e 39       	cp.w	r9,r7
8001a23c:	c9 31       	brne	8001a162 <set_timer+0x6e>
8001a23e:	ce 2b       	rjmp	8001a202 <set_timer+0x10e>
8001a240:	6e 47       	ld.w	r7,r7[0x10]
8001a242:	0e 39       	cp.w	r9,r7
8001a244:	c9 51       	brne	8001a16e <set_timer+0x7a>
8001a246:	cd eb       	rjmp	8001a202 <set_timer+0x10e>
8001a248:	6e 47       	ld.w	r7,r7[0x10]
8001a24a:	0e 39       	cp.w	r9,r7
8001a24c:	c9 71       	brne	8001a17a <set_timer+0x86>
8001a24e:	cd ab       	rjmp	8001a202 <set_timer+0x10e>
8001a250:	6e 47       	ld.w	r7,r7[0x10]
8001a252:	0e 39       	cp.w	r9,r7
8001a254:	c9 91       	brne	8001a186 <set_timer+0x92>
8001a256:	cd 6b       	rjmp	8001a202 <set_timer+0x10e>
8001a258:	6e 47       	ld.w	r7,r7[0x10]
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
8001a25a:	0e 39       	cp.w	r9,r7
      timers[k] = newTimer;
8001a25c:	c9 b1       	brne	8001a192 <set_timer+0x9e>
8001a25e:	cd 2b       	rjmp	8001a202 <set_timer+0x10e>
      cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
8001a260:	30 49       	mov	r9,4
8001a262:	fc 09 09 2c 	st.w	lr[r9<<0x2],r12
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
8001a266:	d5 43       	csrf	0x14
8001a268:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8001a26c:	30 19       	mov	r9,1
8001a26e:	cf ab       	rjmp	8001a262 <set_timer+0x16e>
8001a270:	30 29       	mov	r9,2
8001a272:	cf 8b       	rjmp	8001a262 <set_timer+0x16e>
8001a274:	30 39       	mov	r9,3
8001a276:	cf 6b       	rjmp	8001a262 <set_timer+0x16e>
8001a278:	30 59       	mov	r9,5
8001a27a:	cf 4b       	rjmp	8001a262 <set_timer+0x16e>
8001a27c:	30 69       	mov	r9,6
8001a27e:	cf 2b       	rjmp	8001a262 <set_timer+0x16e>
8001a280:	30 79       	mov	r9,7
8001a282:	cf 0b       	rjmp	8001a262 <set_timer+0x16e>
8001a284:	30 89       	mov	r9,8
8001a286:	ce eb       	rjmp	8001a262 <set_timer+0x16e>
8001a288:	30 99       	mov	r9,9
8001a28a:	ce cb       	rjmp	8001a262 <set_timer+0x16e>
8001a28c:	30 a9       	mov	r9,10
8001a28e:	ce ab       	rjmp	8001a262 <set_timer+0x16e>
8001a290:	30 b9       	mov	r9,11
8001a292:	ce 8b       	rjmp	8001a262 <set_timer+0x16e>

8001a294 <main>:
  } // got event
}

//int main(void) {
////main function
int main (void) {
8001a294:	d4 31       	pushm	r0-r7,lr
// top-level peripheral init
static void init_avr32(void) {
  volatile avr32_tc_t *tc = APP_TC;
  // clocks
  // setup clocks
  sysclk_init();
8001a296:	fe b0 dd e9 	rcall	80015e68 <sysclk_init>

  // not sure why but when need to explictly enable clock for static mem ctlr
  sysclk_enable_pbb_module(SYSCLK_SMC_REGS);
8001a29a:	30 4c       	mov	r12,4
8001a29c:	fe b0 dd 4e 	rcall	80015d38 <sysclk_enable_pbb_module>
  flashc_set_bus_freq(FCPU_HZ);
8001a2a0:	e0 6c 14 80 	mov	r12,5248
8001a2a4:	ea 1c 03 ef 	orh	r12,0x3ef
8001a2a8:	fe b0 bf 09 	rcall	800120ba <flashc_set_bus_freq>
  flashc_set_wait_state(1);
8001a2ac:	30 1c       	mov	r12,1
8001a2ae:	fe b0 be ff 	rcall	800120ac <flashc_set_wait_state>

  /// interrupts
  irq_initialize_vectors();
8001a2b2:	fe b0 c3 07 	rcall	800128c0 <INTC_init_interrupts>
  // disable all interrupts for now
  cpu_irq_disable();
8001a2b6:	d3 03       	ssrf	0x10

  // serial usb
  init_ftdi_usart();
8001a2b8:	fe b0 ee c6 	rcall	80018044 <init_ftdi_usart>
  // external sram
  smc_init(FHSB_HZ);
8001a2bc:	e0 6c 14 80 	mov	r12,5248
8001a2c0:	ea 1c 03 ef 	orh	r12,0x3ef
8001a2c4:	fe b0 be a8 	rcall	80012014 <smc_init>
  // initialize spi1: OLED, ADC, SD/MMC
  init_spi1();
8001a2c8:	fe b0 ee 4c 	rcall	80017f60 <init_spi1>
  // initialize PDCA controller
  init_local_pdca();
8001a2cc:	fe b0 ee 1c 	rcall	80017f04 <init_local_pdca>
  // initialize blackfin resources
  init_bfin_resources();
8001a2d0:	fe b0 ed e6 	rcall	80017e9c <init_bfin_resources>
  // initialize application timer
  init_tc(tc);
8001a2d4:	fe 7c 38 00 	mov	r12,-51200
8001a2d8:	fe b0 ee ca 	rcall	8001806c <init_tc>
  // initialize other GPIO
  init_gpio();
8001a2dc:	fe b0 ee e4 	rcall	800180a4 <init_gpio>
  // register interrupts
  register_interrupts();
8001a2e0:	fe b0 ef 02 	rcall	800180e4 <register_interrupts>
  // initialize the OLED screen
  init_oled();
8001a2e4:	fe b0 fa a2 	rcall	80019828 <init_oled>

  // enable interrupts
  cpu_irq_enable();
8001a2e8:	d5 03       	csrf	0x10

  // usb host controller
  init_usb_host();
8001a2ea:	fe b0 ed d5 	rcall	80017e94 <init_usb_host>
  // initialize usb classes
  init_monome();
8001a2ee:	fe b0 f0 cd 	rcall	80018488 <init_monome>
  //  init_midi();
  //  init_hid();

  print_dbg("\r\n avr32 init done ");
8001a2f2:	4e dc       	lddpc	r12,8001a4a4 <main+0x210>
8001a2f4:	fe b0 c6 54 	rcall	80012f9c <print_dbg>

  // set up avr32 hardware and peripherals
  init_avr32();

  //memory manager
  init_mem();  
8001a2f8:	fe b0 f0 a2 	rcall	8001843c <init_mem>
  print_dbg("\r\n init_mem");
8001a2fc:	4e bc       	lddpc	r12,8001a4a8 <main+0x214>
8001a2fe:	fe b0 c6 4f 	rcall	80012f9c <print_dbg>

  // intialize the FAT filesystem
  fat_init();
8001a302:	fe b0 e9 5b 	rcall	800175b8 <fat_init>
  print_dbg("\r\n init fat");
8001a306:	4e ac       	lddpc	r12,8001a4ac <main+0x218>
8001a308:	fe b0 c6 4a 	rcall	80012f9c <print_dbg>
}

// control / network / logic init
static void init_ctl(void) {
  // disable interrupts
  cpu_irq_disable();
8001a30c:	d3 03       	ssrf	0x10

  // intialize the event queue
  init_events();
8001a30e:	fe b0 e8 6f 	rcall	800173ec <init_events>
  print_dbg("\r\n init_events");
8001a312:	4e 8c       	lddpc	r12,8001a4b0 <main+0x21c>
8001a314:	fe b0 c6 44 	rcall	80012f9c <print_dbg>

  // intialize encoders
  init_encoders();
8001a318:	fe b0 e8 f2 	rcall	800174fc <init_encoders>
  print_dbg("\r\n init_encoders");
8001a31c:	4e 6c       	lddpc	r12,8001a4b4 <main+0x220>
8001a31e:	fe b0 c6 3f 	rcall	80012f9c <print_dbg>

  // send ADC config
  init_adc();
8001a322:	fe b0 e2 15 	rcall	8001674c <init_adc>
  print_dbg("\r\n init_adc");
8001a326:	4e 5c       	lddpc	r12,8001a4b8 <main+0x224>
8001a328:	fe b0 c6 3a 	rcall	80012f9c <print_dbg>

  // start timers
  init_sys_timers();
8001a32c:	fe b0 e2 88 	rcall	8001683c <init_sys_timers>
  init_app_timers();
8001a330:	e0 a0 24 40 	rcall	8001ebb0 <init_app_timers>
  print_dbg("\r\n init_timers");
8001a334:	4e 2c       	lddpc	r12,8001a4bc <main+0x228>
8001a336:	fe b0 c6 33 	rcall	80012f9c <print_dbg>

  // enable interrupts
  cpu_irq_enable();
8001a33a:	d5 03       	csrf	0x10
  fat_init();
  print_dbg("\r\n init fat");

  // setup control logic
  init_ctl();
  print_dbg("\r\n init ctl");
8001a33c:	4e 1c       	lddpc	r12,8001a4c0 <main+0x22c>
8001a33e:	fe b0 c6 2f 	rcall	80012f9c <print_dbg>

  // initialize the application
  app_init();
8001a342:	e0 a0 24 2d 	rcall	8001eb9c <app_init>
  print_dbg("\r\n init app");
8001a346:	4e 0c       	lddpc	r12,8001a4c4 <main+0x230>
8001a348:	fe b0 c6 2a 	rcall	80012f9c <print_dbg>

  // initialize flash
  firstrun = init_flash();
8001a34c:	fe b0 ea 7c 	rcall	80017844 <init_flash>
8001a350:	e0 66 1c 78 	mov	r6,7288
  print_dbg("r\n init flash, firstrun: ");
8001a354:	ac 8c       	st.b	r6[0x0],r12
8001a356:	4d dc       	lddpc	r12,8001a4c8 <main+0x234>
8001a358:	fe b0 c6 22 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(firstrun);
8001a35c:	0d 8c       	ld.ub	r12,r6[0x0]
8001a35e:	fe b0 c6 25 	rcall	80012fa8 <print_dbg_ulong>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8001a362:	30 09       	mov	r9,0
8001a364:	e0 68 03 e8 	mov	r8,1000
8001a368:	e0 6a 05 e7 	mov	r10,1511
8001a36c:	ea 1a 89 64 	orh	r10,0x8964
8001a370:	30 1b       	mov	r11,1
8001a372:	e0 a0 46 30 	rcall	80022fd2 <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001a376:	14 97       	mov	r7,r10
8001a378:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001a37c:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a380:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001a384:	14 39       	cp.w	r9,r10
8001a386:	e0 88 00 8a 	brls	8001a49a <main+0x206>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001a38a:	10 39       	cp.w	r9,r8
8001a38c:	fe 98 ff fa 	brls	8001a380 <main+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a390:	10 3a       	cp.w	r10,r8

  delay_ms(100);
  // notify 
  screen_startup();
8001a392:	cf 72       	brcc	8001a380 <main+0xec>
8001a394:	fe b0 f8 dc 	rcall	8001954c <screen_startup>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001a398:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001a39c:	f2 07 00 07 	add	r7,r9,r7
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a3a0:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001a3a4:	0e 39       	cp.w	r9,r7
8001a3a6:	e0 88 00 08 	brls	8001a3b6 <main+0x122>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001a3aa:	10 39       	cp.w	r9,r8
8001a3ac:	e0 8b 00 08 	brhi	8001a3bc <main+0x128>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a3b0:	e1 b8 00 42 	mfsr	r8,0x108
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a3b4:	cf 8b       	rjmp	8001a3a4 <main+0x110>
8001a3b6:	10 39       	cp.w	r9,r8
8001a3b8:	e0 8b 00 04 	brhi	8001a3c0 <main+0x12c>
8001a3bc:	10 37       	cp.w	r7,r8

  delay_ms(100);

  print_dbg("\r\n starting event loop.\r\n");
8001a3be:	cf 92       	brcc	8001a3b0 <main+0x11c>
8001a3c0:	4c 3c       	lddpc	r12,8001a4cc <main+0x238>
8001a3c2:	fe b0 c5 ed 	rcall	80012f9c <print_dbg>
8001a3c6:	e0 68 03 e8 	mov	r8,1000
8001a3ca:	31 c7       	mov	r7,28
8001a3cc:	30 09       	mov	r9,0
8001a3ce:	e0 6a d0 e7 	mov	r10,53479
8001a3d2:	ea 1a 27 56 	orh	r10,0x2756
8001a3d6:	30 0b       	mov	r11,0
8001a3d8:	30 c0       	mov	r0,12
8001a3da:	e0 a0 45 fc 	rcall	80022fd2 <__avr32_udiv64>
8001a3de:	e0 61 32 68 	mov	r1,12904
  /* print_dbg("\r\n handling event, type: "); */
  /* print_dbg_hex(e.eventType); */
  /* print_dbg("\r\n , data: "); */
  /* print_dbg_hex(e.eventData); */

    if(startup) {
8001a3e2:	14 92       	mov	r2,r10
8001a3e4:	e0 64 1c 70 	mov	r4,7280
// app event loop
static void check_events(void) {
  static event_t e;
  u8 launch = 0;
  //  print_dbg("\r\n checking events...");
  if( get_next_event(&e) ) {
8001a3e8:	0e 93       	mov	r3,r7
8001a3ea:	30 05       	mov	r5,0
8001a3ec:	e0 6c 1c 70 	mov	r12,7280
  /* print_dbg("\r\n handling event, type: "); */
  /* print_dbg_hex(e.eventType); */
  /* print_dbg("\r\n , data: "); */
  /* print_dbg_hex(e.eventData); */

    if(startup) {
8001a3f0:	fe b0 e8 38 	rcall	80017460 <get_next_event>
8001a3f4:	cf c0       	breq	8001a3ec <main+0x158>
      if( e.eventType == kEventSwitch0
8001a3f6:	0f 88       	ld.ub	r8,r7[0x0]
8001a3f8:	ea 08 18 00 	cp.b	r8,r5
8001a3fc:	c3 30       	breq	8001a462 <main+0x1ce>
8001a3fe:	68 08       	ld.w	r8,r4[0x0]
	  || e.eventType == kEventSwitch1
	  || e.eventType == kEventSwitch2
	  || e.eventType == kEventSwitch3
	  || e.eventType == kEventSwitch4
	  ) {
	startup = 0;
8001a400:	20 d8       	sub	r8,13
	print_dbg("\r\n key pressed, launching ");
8001a402:	58 48       	cp.w	r8,4
8001a404:	fe 9b ff f4 	brhi	8001a3ec <main+0x158>
	// return 1 if app completed firstrun tasks
	launch = app_launch(firstrun);
8001a408:	a6 85       	st.b	r3[0x0],r5
8001a40a:	4b 2c       	lddpc	r12,8001a4d0 <main+0x23c>
8001a40c:	fe b0 c5 c8 	rcall	80012f9c <print_dbg>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001a410:	0d 8c       	ld.ub	r12,r6[0x0]
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001a412:	e0 a0 22 ff 	rcall	8001ea10 <app_launch>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a416:	e1 b9 00 42 	mfsr	r9,0x108
8001a41a:	f2 02 00 0a 	add	r10,r9,r2
8001a41e:	e1 b8 00 42 	mfsr	r8,0x108
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a422:	14 39       	cp.w	r9,r10
8001a424:	e0 8b 00 14 	brhi	8001a44c <main+0x1b8>
8001a428:	12 38       	cp.w	r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a42a:	c0 83       	brcs	8001a43a <main+0x1a6>
8001a42c:	14 38       	cp.w	r8,r10
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a42e:	e0 8b 00 06 	brhi	8001a43a <main+0x1a6>
	delay_ms(10);
	if( firstrun) {
8001a432:	e1 b8 00 42 	mfsr	r8,0x108
8001a436:	12 38       	cp.w	r8,r9
8001a438:	cf a2       	brcc	8001a42c <main+0x198>
	  if(launch) {
8001a43a:	0d 88       	ld.ub	r8,r6[0x0]
8001a43c:	ea 08 18 00 	cp.b	r8,r5
	    // successfully launched on firstrun, so write magic number to flash
	    flash_write_firstrun();
8001a440:	cd 60       	breq	8001a3ec <main+0x158>
8001a442:	58 0c       	cp.w	r12,0
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001a444:	c2 80       	breq	8001a494 <main+0x200>
8001a446:	fe b0 e9 79 	rcall	80017738 <flash_write_firstrun>
8001a44a:	cd 1b       	rjmp	8001a3ec <main+0x158>
8001a44c:	10 39       	cp.w	r9,r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a44e:	e0 88 00 04 	brls	8001a456 <main+0x1c2>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001a452:	10 3a       	cp.w	r10,r8
8001a454:	cf 33       	brcs	8001a43a <main+0x1a6>
8001a456:	e1 b8 00 42 	mfsr	r8,0x108
	    flash_clear_firstrun();
	  } 
	}
      }
    } else {
      switch(e.eventType) {
8001a45a:	10 39       	cp.w	r9,r8
8001a45c:	fe 98 ff fd 	brls	8001a456 <main+0x1c2>
8001a460:	cf 9b       	rjmp	8001a452 <main+0x1be>
8001a462:	68 08       	ld.w	r8,r4[0x0]
8001a464:	58 58       	cp.w	r8,5
8001a466:	c1 40       	breq	8001a48e <main+0x1fa>
	// perform setup tasks for new ftdi device connection. 
	// won't work if called from an interrupt.
	ftdi_setup();
	break;
      default:
	(*appEventHandler)(&e);
8001a468:	e0 8b 00 09 	brhi	8001a47a <main+0x1e6>
8001a46c:	58 48       	cp.w	r8,4
8001a46e:	cb f0       	breq	8001a3ec <main+0x158>
	    flash_clear_firstrun();
	  } 
	}
      }
    } else {
      switch(e.eventType) {
8001a470:	62 08       	ld.w	r8,r1[0x0]
8001a472:	e0 6c 1c 70 	mov	r12,7280
8001a476:	5d 18       	icall	r8
	break;
	//--------------------------------------
      case kEventFtdiConnect:
	// perform setup tasks for new ftdi device connection. 
	// won't work if called from an interrupt.
	ftdi_setup();
8001a478:	cb ab       	rjmp	8001a3ec <main+0x158>
8001a47a:	58 68       	cp.w	r8,6
8001a47c:	c0 60       	breq	8001a488 <main+0x1f4>
	// poll monome serial input and spawn relevant events
	monome_read_serial();
	break;
      case kEventMonomeRefresh :
	// refresh monome device from led state buffer
	monome_grid_refresh();
8001a47e:	58 78       	cp.w	r8,7
8001a480:	cf 81       	brne	8001a470 <main+0x1dc>
8001a482:	e0 a0 03 03 	rcall	8001aa88 <ftdi_setup>
	// refresh the screen hardware
	//	screen_refresh();
	break;
      case kEventMonomePoll :
	// poll monome serial input and spawn relevant events
	monome_read_serial();
8001a486:	cb 3b       	rjmp	8001a3ec <main+0x158>
8001a488:	fe b0 f0 10 	rcall	800184a8 <monome_grid_refresh>
	    // successfully launched on firstrun, so write magic number to flash
	    flash_write_firstrun();
	    return;
	  } else {
	    // firstrun, but app launch failed, so clear magic number to try again
	    flash_clear_firstrun();
8001a48c:	cb 0b       	rjmp	8001a3ec <main+0x158>
8001a48e:	60 08       	ld.w	r8,r0[0x0]
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a490:	5d 18       	icall	r8
8001a492:	ca db       	rjmp	8001a3ec <main+0x158>
8001a494:	fe b0 e9 48 	rcall	80017724 <flash_clear_firstrun>
8001a498:	ca ab       	rjmp	8001a3ec <main+0x158>
8001a49a:	10 39       	cp.w	r9,r8
8001a49c:	fe 9b ff 7c 	brhi	8001a394 <main+0x100>
8001a4a0:	c7 8b       	rjmp	8001a390 <main+0xfc>
8001a4a2:	d7 03       	nop
8001a4a4:	80 02       	ld.sh	r2,r0[0x0]
8001a4a6:	4c 40       	lddpc	r0,8001a5b4 <uhi_hid_gamepad_install+0x20>
8001a4a8:	80 02       	ld.sh	r2,r0[0x0]
8001a4aa:	4c 54       	lddpc	r4,8001a5bc <uhi_hid_gamepad_install+0x28>
8001a4ac:	80 02       	ld.sh	r2,r0[0x0]
8001a4ae:	4c 60       	lddpc	r0,8001a5c4 <uhi_hid_gamepad_install+0x30>
8001a4b0:	80 02       	ld.sh	r2,r0[0x0]
8001a4b2:	4c 6c       	lddpc	r12,8001a5c8 <uhi_hid_gamepad_install+0x34>
8001a4b4:	80 02       	ld.sh	r2,r0[0x0]
8001a4b6:	4c 7c       	lddpc	r12,8001a5d0 <uhi_hid_gamepad_install+0x3c>
8001a4b8:	80 02       	ld.sh	r2,r0[0x0]
8001a4ba:	4c 90       	lddpc	r0,8001a5dc <uhi_hid_gamepad_install+0x48>
8001a4bc:	80 02       	ld.sh	r2,r0[0x0]
8001a4be:	4c 9c       	lddpc	r12,8001a5e0 <uhi_hid_gamepad_install+0x4c>
8001a4c0:	80 02       	ld.sh	r2,r0[0x0]
8001a4c2:	4c ac       	lddpc	r12,8001a5e8 <uhi_hid_gamepad_install+0x54>
8001a4c4:	80 02       	ld.sh	r2,r0[0x0]
8001a4c6:	4c b8       	lddpc	r8,8001a5f0 <uhi_hid_gamepad_install+0x5c>
8001a4c8:	80 02       	ld.sh	r2,r0[0x0]
8001a4ca:	4c c4       	lddpc	r4,8001a5f8 <uhi_hid_gamepad_install+0x64>
8001a4cc:	80 02       	ld.sh	r2,r0[0x0]
8001a4ce:	4c fc       	lddpc	r12,8001a608 <uhi_hid_gamepad_install+0x74>
8001a4d0:	80 02       	ld.sh	r2,r0[0x0]
8001a4d2:	4c e0       	lddpc	r0,8001a608 <uhi_hid_gamepad_install+0x74>

8001a4d4 <usb_mode_change>:
#include "usb.h"

// usb mode change callback
void usb_mode_change(bool b_host_mode) {
  // print_dbg("\r\n mode change (ignore) ");
}
8001a4d4:	5e fc       	retal	r12

8001a4d6 <usb_vbus_change>:
 
// usb Vbus change callback
void usb_vbus_change(bool b_vbus_present) {
  // print_dbg("\r\n usb vbus change, new status: ");
  // print_dbg_ulong(b_vbus_present);
}
8001a4d6:	5e fc       	retal	r12

8001a4d8 <usb_vbus_error>:

// usb vbus error callback
void usb_vbus_error(void) {
  // print_dbg("\r\n usb vbus error: ");

}
8001a4d8:	5e fc       	retal	r12

8001a4da <usb_connection>:
void usb_connection(uhc_device_t *dev, bool b_present) {
    // print_dbg("\r\n usb device connection: ");
    // print_dbg_hex(dev);
    // print_dbg(" , ");
    // print_dbg_ulong(b_present);
}
8001a4da:	5e fc       	retal	r12

8001a4dc <usb_wakeup>:

// usb wakeup callback
void usb_wakeup(void) {
    // print_dbg("\r\n usb wakeup");
}
8001a4dc:	5e fc       	retal	r12

8001a4de <usb_sof>:

// usb start-of-frame callback
void usb_sof(void) {
  //    // print_dbg("\r\n usb sof");
}
8001a4de:	5e fc       	retal	r12

8001a4e0 <usb_enum>:
  // print_dbg("\r\n usb enumerated: ");
  // print_dbg_hex(dev);
  // print_dbg(" , ");
  // print_dbg_hex(status);

}
8001a4e0:	5e fc       	retal	r12
8001a4e2:	d7 03       	nop

8001a4e4 <uhi_hid_gamepad_uninstall>:
  //uhi_hid_gamepad_dev.report_btn_prev = 0;
  uhi_hid_gamepad_start_trans_report(dev->address);
  UHI_HID_GAMEPAD_CHANGE(dev, true);
}

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
8001a4e4:	d4 01       	pushm	lr
  if (uhi_hid_gamepad_dev.dev != dev) {
8001a4e6:	e0 68 1c 7c 	mov	r8,7292
8001a4ea:	70 09       	ld.w	r9,r8[0x0]
8001a4ec:	18 39       	cp.w	r9,r12
8001a4ee:	c0 20       	breq	8001a4f2 <uhi_hid_gamepad_uninstall+0xe>
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
8001a4f0:	d8 02       	popm	pc
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
8001a4f2:	30 09       	mov	r9,0

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
8001a4f4:	70 2c       	ld.w	r12,r8[0x8]
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
8001a4f6:	91 09       	st.w	r8[0x0],r9
8001a4f8:	e0 a0 46 bc 	rcall	80023270 <free>
8001a4fc:	d8 02       	popm	pc
8001a4fe:	d7 03       	nop

8001a500 <uhi_hid_gamepad_enable>:
8001a500:	d4 01       	pushm	lr
8001a502:	e0 69 1c 7c 	mov	r9,7292
  //////////
  ////////////


void uhi_hid_gamepad_enable(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
8001a506:	72 08       	ld.w	r8,r9[0x0]
8001a508:	18 38       	cp.w	r8,r12
8001a50a:	c0 20       	breq	8001a50e <uhi_hid_gamepad_enable+0xe>
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
8001a50c:	d8 02       	popm	pc
8001a50e:	fe ca ff e2 	sub	r10,pc,-30
8001a512:	13 cb       	ld.ub	r11,r9[0x4]
8001a514:	1a da       	st.w	--sp,r10
8001a516:	30 0a       	mov	r10,0
8001a518:	1a da       	st.w	--sp,r10
8001a51a:	30 1a       	mov	r10,1
8001a51c:	f1 3c 00 12 	ld.ub	r12,r8[18]
8001a520:	13 d8       	ld.ub	r8,r9[0x5]
8001a522:	72 29       	ld.w	r9,r9[0x8]
8001a524:	fe b0 d4 e0 	rcall	80014ee4 <uhd_ep_run>
8001a528:	2f ed       	sub	sp,-8
8001a52a:	d8 02       	popm	pc

8001a52c <uhi_hid_gamepad_report_reception>:
8001a52c:	eb cd 40 e0 	pushm	r5-r7,lr
8001a530:	58 0a       	cp.w	r10,0
8001a532:	5f 18       	srne	r8

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
8001a534:	58 39       	cp.w	r9,3
8001a536:	5f 89       	srls	r9
static void uhi_hid_gamepad_report_reception(
					   usb_add_t add,
					   usb_ep_t ep,
					   uhd_trans_status_t status,
					   iram_size_t nb_transfered)
{
8001a538:	18 96       	mov	r6,r12

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
8001a53a:	f3 e8 10 08 	or	r8,r9,r8
8001a53e:	c0 30       	breq	8001a544 <uhi_hid_gamepad_report_reception+0x18>
8001a540:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
8001a544:	49 2c       	lddpc	r12,8001a58c <uhi_hid_gamepad_report_reception+0x60>
8001a546:	fe b0 c5 2b 	rcall	80012f9c <print_dbg>
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
8001a54a:	e0 67 1c 7c 	mov	r7,7292
8001a54e:	0f d8       	ld.ub	r8,r7[0x5]
8001a550:	58 08       	cp.w	r8,0
8001a552:	c0 f0       	breq	8001a570 <uhi_hid_gamepad_report_reception+0x44>
    print_dbg(" ");
8001a554:	30 05       	mov	r5,0
8001a556:	48 fc       	lddpc	r12,8001a590 <uhi_hid_gamepad_report_reception+0x64>
8001a558:	fe b0 c5 22 	rcall	80012f9c <print_dbg>
    print_dbg_hex((unsigned long int) uhi_hid_gamepad_dev.report[i]);
8001a55c:	6e 28       	ld.w	r8,r7[0x8]
8001a55e:	f0 05 07 0c 	ld.ub	r12,r8[r5]
8001a562:	fe b0 c5 45 	rcall	80012fec <print_dbg_hex>
  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
8001a566:	2f f5       	sub	r5,-1
8001a568:	0f d8       	ld.ub	r8,r7[0x5]
8001a56a:	0a 38       	cp.w	r8,r5
8001a56c:	fe 99 ff f5 	brgt	8001a556 <uhi_hid_gamepad_report_reception+0x2a>
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
8001a570:	fe c9 00 44 	sub	r9,pc,68
8001a574:	0f cb       	ld.ub	r11,r7[0x4]
8001a576:	1a d9       	st.w	--sp,r9
8001a578:	30 09       	mov	r9,0
8001a57a:	0c 9c       	mov	r12,r6
8001a57c:	1a d9       	st.w	--sp,r9
8001a57e:	30 1a       	mov	r10,1
8001a580:	6e 29       	ld.w	r9,r7[0x8]
8001a582:	fe b0 d4 b1 	rcall	80014ee4 <uhd_ep_run>
8001a586:	2f ed       	sub	sp,-8
8001a588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001a58c:	80 02       	ld.sh	r2,r0[0x0]
8001a58e:	4d 18       	lddpc	r8,8001a6d0 <ctl_req_end+0x8>
8001a590:	80 02       	ld.sh	r2,r0[0x0]
8001a592:	55 20       	stdsp	sp[0x148],r0

8001a594 <uhi_hid_gamepad_install>:
8001a594:	d4 21       	pushm	r4-r7,lr
8001a596:	e0 66 1c 7c 	mov	r6,7292
8001a59a:	18 95       	mov	r5,r12
8001a59c:	6c 08       	ld.w	r8,r6[0x0]
8001a59e:	58 08       	cp.w	r8,0
8001a5a0:	c0 30       	breq	8001a5a6 <uhi_hid_gamepad_install+0x12>
8001a5a2:	30 5c       	mov	r12,5
  usb_iface_desc_t *ptr_iface;

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
8001a5a4:	d8 22       	popm	r4-r7,pc
8001a5a6:	78 67       	ld.w	r7,r12[0x18]
8001a5a8:	0f a4       	ld.ub	r4,r7[0x2]
8001a5aa:	0f b9       	ld.ub	r9,r7[0x3]
8001a5ac:	f3 e4 10 84 	or	r4,r9,r4<<0x8
8001a5b0:	5c c4       	swap.bh	r4
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
8001a5b2:	5c 84       	casts.h	r4

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
8001a5b4:	c6 60       	breq	8001a680 <uhi_hid_gamepad_install+0xec>
8001a5b6:	10 9a       	mov	r10,r8
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8001a5b8:	c0 a8       	rjmp	8001a5cc <uhi_hid_gamepad_install+0x38>
8001a5ba:	30 59       	mov	r9,5
8001a5bc:	f2 08 18 00 	cp.b	r8,r9
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8001a5c0:	c5 60       	breq	8001a66c <uhi_hid_gamepad_install+0xd8>
8001a5c2:	0f 88       	ld.ub	r8,r7[0x0]
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001a5c4:	10 14       	sub	r4,r8
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8001a5c6:	10 07       	add	r7,r8
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
8001a5c8:	5c 84       	casts.h	r4
    switch (ptr_iface->bDescriptorType) {
8001a5ca:	c5 b0       	breq	8001a680 <uhi_hid_gamepad_install+0xec>
8001a5cc:	0f 98       	ld.ub	r8,r7[0x1]
8001a5ce:	30 49       	mov	r9,4
8001a5d0:	f2 08 18 00 	cp.b	r8,r9
    case USB_DT_INTERFACE:

      /////////////////
      ///////////////  
      //#if 1
      print_dbg("\r\n\r\n");
8001a5d4:	cf 31       	brne	8001a5ba <uhi_hid_gamepad_install+0x26>
8001a5d6:	4b 3c       	lddpc	r12,8001a6a0 <uhi_hid_gamepad_install+0x10c>
8001a5d8:	fe b0 c4 e2 	rcall	80012f9c <print_dbg>
      print_dbg("\r\n iface_desc -> bLength : ");
8001a5dc:	4b 2c       	lddpc	r12,8001a6a4 <uhi_hid_gamepad_install+0x110>
8001a5de:	fe b0 c4 df 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bLength);
8001a5e2:	0f 8c       	ld.ub	r12,r7[0x0]
8001a5e4:	fe b0 c5 04 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bDescriptorType : ");
8001a5e8:	4b 0c       	lddpc	r12,8001a6a8 <uhi_hid_gamepad_install+0x114>
8001a5ea:	fe b0 c4 d9 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bDescriptorType);
8001a5ee:	0f 9c       	ld.ub	r12,r7[0x1]
8001a5f0:	fe b0 c4 fe 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceNumber : ");
8001a5f4:	4a ec       	lddpc	r12,8001a6ac <uhi_hid_gamepad_install+0x118>
8001a5f6:	fe b0 c4 d3 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceNumber);
8001a5fa:	0f ac       	ld.ub	r12,r7[0x2]
8001a5fc:	fe b0 c4 f8 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bAlternateSetting : ");
8001a600:	4a cc       	lddpc	r12,8001a6b0 <uhi_hid_gamepad_install+0x11c>
8001a602:	fe b0 c4 cd 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bAlternateSetting);
8001a606:	0f bc       	ld.ub	r12,r7[0x3]
8001a608:	fe b0 c4 f2 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bNumEndpoints : ");
8001a60c:	4a ac       	lddpc	r12,8001a6b4 <uhi_hid_gamepad_install+0x120>
8001a60e:	fe b0 c4 c7 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bNumEndpoints);
8001a612:	0f cc       	ld.ub	r12,r7[0x4]
8001a614:	fe b0 c4 ec 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceClass : ");
8001a618:	4a 8c       	lddpc	r12,8001a6b8 <uhi_hid_gamepad_install+0x124>
8001a61a:	fe b0 c4 c1 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceClass);
8001a61e:	0f dc       	ld.ub	r12,r7[0x5]
8001a620:	fe b0 c4 e6 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceSubClass : ");
8001a624:	4a 6c       	lddpc	r12,8001a6bc <uhi_hid_gamepad_install+0x128>
8001a626:	fe b0 c4 bb 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceSubClass);
8001a62a:	0f ec       	ld.ub	r12,r7[0x6]
8001a62c:	fe b0 c4 e0 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceProtocol : ");
8001a630:	4a 4c       	lddpc	r12,8001a6c0 <uhi_hid_gamepad_install+0x12c>
8001a632:	fe b0 c4 b5 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceProtocol);
8001a636:	0f fc       	ld.ub	r12,r7[0x7]
8001a638:	fe b0 c4 da 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n iface_desc -> iInterface : ");
8001a63c:	4a 2c       	lddpc	r12,8001a6c4 <uhi_hid_gamepad_install+0x130>
8001a63e:	fe b0 c4 af 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->iInterface);
8001a642:	ef 3c 00 08 	ld.ub	r12,r7[8]
8001a646:	fe b0 c4 d3 	rcall	80012fec <print_dbg_hex>
      print_dbg("\r\n\r\n");
8001a64a:	49 6c       	lddpc	r12,8001a6a0 <uhi_hid_gamepad_install+0x10c>
8001a64c:	fe b0 c4 a8 	rcall	80012f9c <print_dbg>
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
8001a650:	0f d9       	ld.ub	r9,r7[0x5]
8001a652:	30 38       	mov	r8,3
8001a654:	f0 09 18 00 	cp.b	r9,r8
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
8001a658:	c0 30       	breq	8001a65e <uhi_hid_gamepad_install+0xca>
8001a65a:	30 0a       	mov	r10,0
      print_dbg_hex(ptr_iface->iInterface);
      print_dbg("\r\n\r\n");
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
	  && (ptr_iface->bInterfaceProtocol == HID_PROTOCOL_GENERIC) ) {
8001a65c:	cb 3b       	rjmp	8001a5c2 <uhi_hid_gamepad_install+0x2e>
8001a65e:	0f f9       	ld.ub	r9,r7[0x7]
8001a660:	30 08       	mov	r8,0
8001a662:	f0 09 18 00 	cp.b	r9,r8
8001a666:	cf a1       	brne	8001a65a <uhi_hid_gamepad_install+0xc6>
8001a668:	30 1a       	mov	r10,1
      }
      break;

    case USB_DT_ENDPOINT:
      //  Allocation of the endpoint
      if (!b_iface_supported) {
8001a66a:	ca cb       	rjmp	8001a5c2 <uhi_hid_gamepad_install+0x2e>
8001a66c:	58 0a       	cp.w	r10,0
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
8001a66e:	ca a0       	breq	8001a5c2 <uhi_hid_gamepad_install+0x2e>
8001a670:	0e 9b       	mov	r11,r7
8001a672:	eb 3c 00 12 	ld.ub	r12,r5[18]
8001a676:	fe b0 ce c9 	rcall	80014408 <uhd_ep_alloc>
8001a67a:	c0 41       	brne	8001a682 <uhi_hid_gamepad_install+0xee>
8001a67c:	30 4c       	mov	r12,4
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001a67e:	d8 22       	popm	r4-r7,pc
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
      }
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001a680:	da 2a       	popm	r4-r7,pc,r12=1
8001a682:	0f a8       	ld.ub	r8,r7[0x2]
      uhi_hid_gamepad_dev.report_size =
8001a684:	ac c8       	st.b	r6[0x4],r8
8001a686:	0f cc       	ld.ub	r12,r7[0x4]
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
8001a688:	ac dc       	st.b	r6[0x5],r12
8001a68a:	e0 a0 45 fb 	rcall	80023280 <malloc>
      if (uhi_hid_gamepad_dev.report == NULL) {
8001a68e:	8d 2c       	st.w	r6[0x8],r12
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
8001a690:	c0 60       	breq	8001a69c <uhi_hid_gamepad_install+0x108>
8001a692:	e0 68 1c 7c 	mov	r8,7292
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
8001a696:	30 0c       	mov	r12,0
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
      uhi_hid_gamepad_dev.report_size =
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
      if (uhi_hid_gamepad_dev.report == NULL) {
8001a698:	91 05       	st.w	r8[0x0],r5
8001a69a:	d8 22       	popm	r4-r7,pc
8001a69c:	30 6c       	mov	r12,6
8001a69e:	d8 22       	popm	r4-r7,pc
8001a6a0:	80 02       	ld.sh	r2,r0[0x0]
8001a6a2:	40 a0       	lddsp	r0,sp[0x28]
8001a6a4:	80 02       	ld.sh	r2,r0[0x0]
8001a6a6:	4d 2c       	lddpc	r12,8001a7ec <uhi_ftdi_install+0xb8>
8001a6a8:	80 02       	ld.sh	r2,r0[0x0]
8001a6aa:	4d 48       	lddpc	r8,8001a7f8 <uhi_ftdi_install+0xc4>
8001a6ac:	80 02       	ld.sh	r2,r0[0x0]
8001a6ae:	4d 6c       	lddpc	r12,8001a804 <uhi_ftdi_install+0xd0>
8001a6b0:	80 02       	ld.sh	r2,r0[0x0]
8001a6b2:	4d 94       	lddpc	r4,8001a814 <uhi_ftdi_install+0xe0>
8001a6b4:	80 02       	ld.sh	r2,r0[0x0]
8001a6b6:	4d bc       	lddpc	r12,8001a820 <uhi_ftdi_install+0xec>
8001a6b8:	80 02       	ld.sh	r2,r0[0x0]
8001a6ba:	4d e0       	lddpc	r0,8001a830 <ftdi_get_strings+0x4>
8001a6bc:	80 02       	ld.sh	r2,r0[0x0]
8001a6be:	4e 04       	lddpc	r4,8001a83c <ftdi_get_strings+0x10>
8001a6c0:	80 02       	ld.sh	r2,r0[0x0]
8001a6c2:	4e 2c       	lddpc	r12,8001a848 <ftdi_get_strings+0x1c>
8001a6c4:	80 02       	ld.sh	r2,r0[0x0]
8001a6c6:	4e 54       	lddpc	r4,8001a858 <ftdi_get_strings+0x2c>

8001a6c8 <ctl_req_end>:
		uhd_trans_status_t status,
		uint16_t payload_trans) {
  // last transfer ok?
  //  print_dbg("\r\n ctl request end, status: ");
  //  print_dbg_hex((u32)status);
  ctlReadBusy = 0;
8001a6c8:	30 09       	mov	r9,0
8001a6ca:	e0 68 1c 90 	mov	r8,7312
}
8001a6ce:	b0 89       	st.b	r8[0x0],r9
8001a6d0:	5e fc       	retal	r12
8001a6d2:	d7 03       	nop

8001a6d4 <uhi_ftdi_out_run>:
		    UHI_FTDI_TIMEOUT, callback);
}

// run the output endpoint (bulk)
bool uhi_ftdi_out_run(uint8_t * buf, iram_size_t buf_size,
		      uhd_callback_trans_t callback) {
8001a6d4:	d4 01       	pushm	lr
  return uhd_ep_run(uhi_ftdi_dev.dev->address,
8001a6d6:	1a da       	st.w	--sp,r10
8001a6d8:	16 98       	mov	r8,r11
8001a6da:	18 99       	mov	r9,r12
8001a6dc:	e0 6a 1c 88 	mov	r10,7304
8001a6e0:	e0 6c 4e 20 	mov	r12,20000
8001a6e4:	15 db       	ld.ub	r11,r10[0x5]
8001a6e6:	74 0a       	ld.w	r10,r10[0x0]
8001a6e8:	1a dc       	st.w	--sp,r12
8001a6ea:	f5 3c 00 12 	ld.ub	r12,r10[18]
8001a6ee:	30 1a       	mov	r10,1
8001a6f0:	fe b0 d3 fa 	rcall	80014ee4 <uhd_ep_run>
		    uhi_ftdi_dev.ep_out, true, buf, buf_size,
		    UHI_FTDI_TIMEOUT, callback);
}
8001a6f4:	2f ed       	sub	sp,-8
8001a6f6:	d8 02       	popm	pc

8001a6f8 <uhi_ftdi_in_run>:
8001a6f8:	d4 01       	pushm	lr
8001a6fa:	1a da       	st.w	--sp,r10
8001a6fc:	16 98       	mov	r8,r11
8001a6fe:	18 99       	mov	r9,r12
}

// run the input endpoint (bulk)
bool uhi_ftdi_in_run(uint8_t * buf, iram_size_t buf_size,
		     uhd_callback_trans_t callback) {
  return uhd_ep_run(uhi_ftdi_dev.dev->address,
8001a700:	e0 6a 1c 88 	mov	r10,7304
8001a704:	e0 6c 4e 20 	mov	r12,20000
8001a708:	15 cb       	ld.ub	r11,r10[0x4]
8001a70a:	74 0a       	ld.w	r10,r10[0x0]
8001a70c:	1a dc       	st.w	--sp,r12
8001a70e:	f5 3c 00 12 	ld.ub	r12,r10[18]
8001a712:	30 0a       	mov	r10,0
8001a714:	fe b0 d3 e8 	rcall	80014ee4 <uhd_ep_run>
		    uhi_ftdi_dev.ep_in, false, buf, buf_size,
		    UHI_FTDI_TIMEOUT, callback);
}
8001a718:	2f ed       	sub	sp,-8
8001a71a:	d8 02       	popm	pc

8001a71c <uhi_ftdi_uninstall>:
8001a71c:	d4 01       	pushm	lr
8001a71e:	e0 68 1c 88 	mov	r8,7304
8001a722:	70 0a       	ld.w	r10,r8[0x0]

  ftdi_change(dev, true);  
}

void uhi_ftdi_uninstall(uhc_device_t* dev) {
  if (uhi_ftdi_dev.dev != dev) {
8001a724:	18 3a       	cp.w	r10,r12
8001a726:	c0 20       	breq	8001a72a <uhi_ftdi_uninstall+0xe>
    return; // Device not enabled in this interface
  }
  uhi_ftdi_dev.dev = NULL;
8001a728:	d8 02       	popm	pc
8001a72a:	30 0b       	mov	r11,0
  Assert(uhi_ftdi_dev.report!=NULL);
  ftdi_change(dev, false);  
8001a72c:	91 0b       	st.w	r8[0x0],r11
8001a72e:	cc 5d       	rcall	8001aab8 <ftdi_change>
8001a730:	d8 02       	popm	pc
8001a732:	d7 03       	nop

8001a734 <uhi_ftdi_install>:
8001a734:	d4 31       	pushm	r0-r7,lr
8001a736:	e0 65 1c 88 	mov	r5,7304
8001a73a:	18 94       	mov	r4,r12
uhc_enum_status_t uhi_ftdi_install(uhc_device_t* dev) {
  bool b_iface_supported;
  uint16_t conf_desc_lgt, vid, pid;
  usb_iface_desc_t *ptr_iface;

  if (uhi_ftdi_dev.dev != NULL) {
8001a73c:	6a 02       	ld.w	r2,r5[0x0]
8001a73e:	58 02       	cp.w	r2,0
8001a740:	c0 30       	breq	8001a746 <uhi_ftdi_install+0x12>
8001a742:	30 5c       	mov	r12,5
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }

  // check vid/pid
  vid = le16_to_cpu(dev->dev_desc.idVendor);
8001a744:	d8 32       	popm	r0-r7,pc
8001a746:	98 48       	ld.sh	r8,r12[0x8]
8001a748:	10 9b       	mov	r11,r8
  pid = le16_to_cpu(dev->dev_desc.idProduct);
8001a74a:	5c cb       	swap.bh	r11
8001a74c:	98 58       	ld.sh	r8,r12[0xa]

  if( (vid == FTDI_VID) && (pid == FTDI_PID) ) {
8001a74e:	5c c8       	swap.bh	r8
8001a750:	e0 69 60 01 	mov	r9,24577
8001a754:	e0 6a 04 03 	mov	r10,1027
8001a758:	f2 08 19 00 	cp.h	r8,r9
8001a75c:	5f 09       	sreq	r9
8001a75e:	f4 0b 19 00 	cp.h	r11,r10
8001a762:	5f 08       	sreq	r8
8001a764:	10 69       	and	r9,r8
8001a766:	e4 09 18 00 	cp.b	r9,r2
  }

  if (b_iface_supported) {
    uhi_ftdi_dev.dev = dev;
    print_dbg("\r\n completed FTDI device install");
    return UHC_ENUM_SUCCESS;
8001a76a:	c0 21       	brne	8001a76e <uhi_ftdi_install+0x3a>
    ;; // this is an FTDI device, so continue
  } else {
    return UHC_ENUM_UNSUPPORTED;
  }

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
8001a76c:	da 3a       	popm	r0-r7,pc,r12=1
8001a76e:	78 67       	ld.w	r7,r12[0x18]
8001a770:	0f a6       	ld.ub	r6,r7[0x2]
8001a772:	0f b8       	ld.ub	r8,r7[0x3]
8001a774:	f1 e6 10 86 	or	r6,r8,r6<<0x8
8001a778:	5c c6       	swap.bh	r6
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
8001a77a:	5c 86       	casts.h	r6
    switch (ptr_iface->bDescriptorType) {
8001a77c:	cf 80       	breq	8001a76c <uhi_ftdi_install+0x38>

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
8001a77e:	30 43       	mov	r3,4
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8001a780:	3f f0       	mov	r0,-1
8001a782:	30 51       	mov	r1,5
8001a784:	c0 c8       	rjmp	8001a79c <uhi_ftdi_install+0x68>
8001a786:	e2 08 18 00 	cp.b	r8,r1
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
	break;
      }
      break;
    default:
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
8001a78a:	c1 f0       	breq	8001a7c8 <uhi_ftdi_install+0x94>
8001a78c:	4a 3c       	lddpc	r12,8001a818 <uhi_ftdi_install+0xe4>
8001a78e:	fe b0 c4 07 	rcall	80012f9c <print_dbg>
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8001a792:	0f 88       	ld.ub	r8,r7[0x0]
8001a794:	10 16       	sub	r6,r8

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
8001a796:	5c 86       	casts.h	r6
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001a798:	c3 20       	breq	8001a7fc <uhi_ftdi_install+0xc8>
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8001a79a:	10 07       	add	r7,r8
8001a79c:	0f 98       	ld.ub	r8,r7[0x1]
8001a79e:	e6 08 18 00 	cp.b	r8,r3

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
8001a7a2:	cf 21       	brne	8001a786 <uhi_ftdi_install+0x52>
8001a7a4:	0f d8       	ld.ub	r8,r7[0x5]
8001a7a6:	e0 08 18 00 	cp.b	r8,r0
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
	break;
      }
      break;
    default:
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
8001a7aa:	c0 30       	breq	8001a7b0 <uhi_ftdi_install+0x7c>
8001a7ac:	30 02       	mov	r2,0
  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
	  && (ptr_iface->bInterfaceProtocol == FTDI_PROTOCOL) ) {
8001a7ae:	cf 2b       	rjmp	8001a792 <uhi_ftdi_install+0x5e>
8001a7b0:	0f f8       	ld.ub	r8,r7[0x7]
8001a7b2:	e0 08 18 00 	cp.b	r8,r0
	print_dbg("\r\n class/protocol matches FTDI. ");
8001a7b6:	cf b1       	brne	8001a7ac <uhi_ftdi_install+0x78>
8001a7b8:	49 9c       	lddpc	r12,8001a81c <uhi_ftdi_install+0xe8>
8001a7ba:	fe b0 c3 f1 	rcall	80012f9c <print_dbg>
	b_iface_supported = true;
	uhi_ftdi_dev.ep_in = 0;
	uhi_ftdi_dev.ep_out = 0;
8001a7be:	30 09       	mov	r9,0
    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
	  && (ptr_iface->bInterfaceProtocol == FTDI_PROTOCOL) ) {
	print_dbg("\r\n class/protocol matches FTDI. ");
	b_iface_supported = true;
	uhi_ftdi_dev.ep_in = 0;
8001a7c0:	30 12       	mov	r2,1
	uhi_ftdi_dev.ep_out = 0;
8001a7c2:	aa c9       	st.b	r5[0x4],r9

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
8001a7c4:	aa d9       	st.b	r5[0x5],r9
	b_iface_supported = false;
      }
      break;

    case USB_DT_ENDPOINT:
      if (!b_iface_supported) {
8001a7c6:	ce 6b       	rjmp	8001a792 <uhi_ftdi_install+0x5e>
8001a7c8:	58 02       	cp.w	r2,0
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
8001a7ca:	ce 40       	breq	8001a792 <uhi_ftdi_install+0x5e>
8001a7cc:	0e 9b       	mov	r11,r7
8001a7ce:	e9 3c 00 12 	ld.ub	r12,r4[18]
8001a7d2:	fe b0 ce 1b 	rcall	80014408 <uhd_ep_alloc>
	print_dbg("\r\n endpoint allocation failed");
	return UHC_ENUM_HARDWARE_LIMIT;
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
8001a7d6:	c1 b0       	breq	8001a80c <uhi_ftdi_install+0xd8>
8001a7d8:	0f b8       	ld.ub	r8,r7[0x3]
8001a7da:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8001a7de:	58 28       	cp.w	r8,2
	} else {
	  uhi_ftdi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	}
	break;
      default:
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
8001a7e0:	c0 50       	breq	8001a7ea <uhi_ftdi_install+0xb6>
8001a7e2:	49 0c       	lddpc	r12,8001a820 <uhi_ftdi_install+0xec>
8001a7e4:	fe b0 c3 dc 	rcall	80012f9c <print_dbg>
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
      case USB_EP_TYPE_BULK:
	//	print_dbg("\r\n allocating bulk endpoint: ");
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
8001a7e8:	cd 5b       	rjmp	8001a792 <uhi_ftdi_install+0x5e>
8001a7ea:	0f a8       	ld.ub	r8,r7[0x2]
	  uhi_ftdi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001a7ec:	30 09       	mov	r9,0
8001a7ee:	f2 08 18 00 	cp.b	r8,r9
8001a7f2:	eb f8 5e 04 	st.blt	r5[0x4],r8
	} else {
	  uhi_ftdi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001a7f6:	eb f8 4e 05 	st.bge	r5[0x5],r8
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (b_iface_supported) {
8001a7fa:	cc cb       	rjmp	8001a792 <uhi_ftdi_install+0x5e>
8001a7fc:	58 02       	cp.w	r2,0
    uhi_ftdi_dev.dev = dev;
    print_dbg("\r\n completed FTDI device install");
8001a7fe:	cb 70       	breq	8001a76c <uhi_ftdi_install+0x38>
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (b_iface_supported) {
    uhi_ftdi_dev.dev = dev;
8001a800:	48 9c       	lddpc	r12,8001a824 <uhi_ftdi_install+0xf0>
    print_dbg("\r\n completed FTDI device install");
8001a802:	8b 04       	st.w	r5[0x0],r4
8001a804:	fe b0 c3 cc 	rcall	80012f9c <print_dbg>
    return UHC_ENUM_SUCCESS;
8001a808:	0c 9c       	mov	r12,r6
    case USB_DT_ENDPOINT:
      if (!b_iface_supported) {
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	print_dbg("\r\n endpoint allocation failed");
8001a80a:	d8 32       	popm	r0-r7,pc
8001a80c:	48 7c       	lddpc	r12,8001a828 <uhi_ftdi_install+0xf4>
8001a80e:	fe b0 c3 c7 	rcall	80012f9c <print_dbg>
	return UHC_ENUM_HARDWARE_LIMIT;
8001a812:	30 4c       	mov	r12,4
8001a814:	d8 32       	popm	r0-r7,pc
8001a816:	d7 03       	nop
8001a818:	80 02       	ld.sh	r2,r0[0x0]
8001a81a:	4e ec       	lddpc	r12,8001a9d0 <uhi_ftdi_enable+0x94>
8001a81c:	80 02       	ld.sh	r2,r0[0x0]
8001a81e:	4e 74       	lddpc	r4,8001a9b8 <uhi_ftdi_enable+0x7c>
8001a820:	80 02       	ld.sh	r2,r0[0x0]
8001a822:	4e b8       	lddpc	r8,8001a9cc <uhi_ftdi_enable+0x90>
8001a824:	80 02       	ld.sh	r2,r0[0x0]
8001a826:	4f 20       	lddpc	r0,8001a9ec <uhi_ftdi_enable+0xb0>
8001a828:	80 02       	ld.sh	r2,r0[0x0]
8001a82a:	4e 98       	lddpc	r8,8001a9cc <uhi_ftdi_enable+0x90>

8001a82c <ftdi_get_strings>:
8001a82c:	d4 31       	pushm	r0-r7,lr
8001a82e:	20 3d       	sub	sp,12
8001a830:	30 18       	mov	r8,1
8001a832:	50 0a       	stdsp	sp[0x0],r10

// read eeprom
void ftdi_get_strings(char** pManufacturer, char** pProduct, char** pSerial) {

  // get manufacturer string
  ctlReadBusy = 1;
8001a834:	e0 67 1c 90 	mov	r7,7312
8001a838:	e0 66 1c 88 	mov	r6,7304
  //  print_dbg("\r\n sending ctl request for manufacturer string, index : ");
  //  print_dbg_hex(uhi_ftdi_dev.dev->dev_desc.iManufacturer);
  if(!(send_ctl_request(
8001a83c:	ae 88       	st.b	r7[0x0],r8
8001a83e:	6c 09       	ld.w	r9,r6[0x0]
8001a840:	f3 38 00 0e 	ld.ub	r8,r9[14]
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a844:	e8 18 03 00 	orl	r8,0x300
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
8001a848:	38 0a       	mov	r10,-128
8001a84a:	ba 38       	st.h	sp[0x6],r8
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a84c:	e0 68 04 09 	mov	r8,1033
  req.bRequest = reqnum;
8001a850:	ba ca       	st.b	sp[0x4],r10
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8001a852:	ba 48       	st.h	sp[0x8],r8
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a854:	30 6a       	mov	r10,6
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8001a856:	34 08       	mov	r8,64
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a858:	ba da       	st.b	sp[0x5],r10
8001a85a:	ba 58       	st.h	sp[0xa],r8
  //  print_dbg_hex((u32)status);
  ctlReadBusy = 0;
}

// read eeprom
void ftdi_get_strings(char** pManufacturer, char** pProduct, char** pSerial) {
8001a85c:	fa c5 ff fc 	sub	r5,sp,-4
  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a860:	18 91       	mov	r1,r12
8001a862:	16 90       	mov	r0,r11
8001a864:	e0 63 32 6c 	mov	r3,12908
8001a868:	fe c4 01 a0 	sub	r4,pc,416
8001a86c:	30 08       	mov	r8,0
8001a86e:	1a d4       	st.w	--sp,r4
8001a870:	06 9a       	mov	r10,r3
8001a872:	f3 3c 00 12 	ld.ub	r12,r9[18]

  // get manufacturer string
  ctlReadBusy = 1;
  //  print_dbg("\r\n sending ctl request for manufacturer string, index : ");
  //  print_dbg_hex(uhi_ftdi_dev.dev->dev_desc.iManufacturer);
  if(!(send_ctl_request(
8001a876:	0a 9b       	mov	r11,r5
8001a878:	34 09       	mov	r9,64
8001a87a:	fe b0 d0 bd 	rcall	800149f4 <uhd_setup_request>
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 
8001a87e:	2f fd       	sub	sp,-4
8001a880:	58 0c       	cp.w	r12,0

  // get product string
  ctlReadBusy = 1;
8001a882:	c5 50       	breq	8001a92c <ftdi_get_strings+0x100>
			/* size */
			FTDI_STRING_MAX_LEN,
			/*idx*/
			FTDI_STRING_DESC_LANGID,
			/*val*/
			(USB_DT_STRING << 8) | uhi_ftdi_dev.dev->dev_desc.iProduct,
8001a884:	0f 88       	ld.ub	r8,r7[0x0]
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get product string
  ctlReadBusy = 1;
8001a886:	58 08       	cp.w	r8,0
8001a888:	cf e1       	brne	8001a884 <ftdi_get_strings+0x58>
  //  print_dbg("\r\n sending ctl request for product string, index : ");
  //  print_dbg_ulong( uhi_ftdi_dev.dev->dev_desc.iProduct);
  if(!(send_ctl_request(
8001a88a:	e0 69 1c 90 	mov	r9,7312
8001a88e:	6c 0a       	ld.w	r10,r6[0x0]
8001a890:	30 1b       	mov	r11,1
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
8001a892:	b2 8b       	st.b	r9[0x0],r11
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a894:	f5 39 00 0f 	ld.ub	r9,r10[15]
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a898:	e8 19 03 00 	orl	r9,0x300
  req.bRequest = reqnum;
8001a89c:	ba 39       	st.h	sp[0x6],r9
8001a89e:	30 69       	mov	r9,6
  req.wValue = (val);
  req.wIndex = (index);
8001a8a0:	38 0b       	mov	r11,-128
8001a8a2:	ba cb       	st.b	sp[0x4],r11
8001a8a4:	1a d4       	st.w	--sp,r4
  req.wLength = (size);
8001a8a6:	fb 69 00 09 	st.b	sp[9],r9
8001a8aa:	e0 69 04 09 	mov	r9,1033
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a8ae:	ba 69       	st.h	sp[0xc],r9
8001a8b0:	34 09       	mov	r9,64
8001a8b2:	e0 62 32 ec 	mov	r2,13036
8001a8b6:	ba 79       	st.h	sp[0xe],r9
8001a8b8:	0a 9b       	mov	r11,r5

  // get product string
  ctlReadBusy = 1;
  //  print_dbg("\r\n sending ctl request for product string, index : ");
  //  print_dbg_ulong( uhi_ftdi_dev.dev->dev_desc.iProduct);
  if(!(send_ctl_request(
8001a8ba:	f5 3c 00 12 	ld.ub	r12,r10[18]
8001a8be:	34 09       	mov	r9,64
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 
8001a8c0:	04 9a       	mov	r10,r2
8001a8c2:	fe b0 d0 99 	rcall	800149f4 <uhd_setup_request>

  // get serial string
  ctlReadBusy = 1;
8001a8c6:	2f fd       	sub	sp,-4
			/* size */
			FTDI_STRING_MAX_LEN,
			/*idx*/
			FTDI_STRING_DESC_LANGID,
			/*val*/
			(USB_DT_STRING << 8) | uhi_ftdi_dev.dev->dev_desc.iSerialNumber,
8001a8c8:	58 0c       	cp.w	r12,0
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get serial string
  ctlReadBusy = 1;
8001a8ca:	c3 10       	breq	8001a92c <ftdi_get_strings+0x100>
8001a8cc:	0f 88       	ld.ub	r8,r7[0x0]
  // print_dbg("\r\n sending ctl request for serial string : ");
  if(!(send_ctl_request(
8001a8ce:	58 08       	cp.w	r8,0
8001a8d0:	cf e1       	brne	8001a8cc <ftdi_get_strings+0xa0>
8001a8d2:	e0 69 1c 90 	mov	r9,7312
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a8d6:	6c 0a       	ld.w	r10,r6[0x0]
8001a8d8:	30 1c       	mov	r12,1
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a8da:	b2 8c       	st.b	r9[0x0],r12
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
8001a8dc:	f5 39 00 10 	ld.ub	r9,r10[16]
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a8e0:	e8 19 03 00 	orl	r9,0x300
  req.wValue = (val);
  req.wIndex = (index);
8001a8e4:	38 0c       	mov	r12,-128
8001a8e6:	ba cc       	st.b	sp[0x4],r12
8001a8e8:	1a d4       	st.w	--sp,r4
  req.wLength = (size);
8001a8ea:	ba 59       	st.h	sp[0xa],r9
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a8ec:	30 69       	mov	r9,6

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8001a8ee:	fb 69 00 09 	st.b	sp[9],r9
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a8f2:	e0 69 04 09 	mov	r9,1033
8001a8f6:	ba 69       	st.h	sp[0xc],r9
8001a8f8:	34 09       	mov	r9,64
8001a8fa:	0a 9b       	mov	r11,r5
8001a8fc:	ba 79       	st.h	sp[0xe],r9
  while(ctlReadBusy) { ;; } 

  // get serial string
  ctlReadBusy = 1;
  // print_dbg("\r\n sending ctl request for serial string : ");
  if(!(send_ctl_request(
8001a8fe:	e0 66 32 ac 	mov	r6,12972
8001a902:	f5 3c 00 12 	ld.ub	r12,r10[18]
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; }
8001a906:	34 09       	mov	r9,64
8001a908:	0c 9a       	mov	r10,r6
  //  print_dbg("\r\n requested all string descriptors.");
  *pManufacturer = manufacturer_string + FTDI_STRING_DESC_OFFSET;
8001a90a:	fe b0 d0 75 	rcall	800149f4 <uhd_setup_request>
  *pProduct = product_string + FTDI_STRING_DESC_OFFSET;
8001a90e:	2f fd       	sub	sp,-4
8001a910:	58 0c       	cp.w	r12,0
  *pSerial = serial_string + FTDI_STRING_DESC_OFFSET;
8001a912:	c0 d0       	breq	8001a92c <ftdi_get_strings+0x100>
8001a914:	0f 88       	ld.ub	r8,r7[0x0]
8001a916:	58 08       	cp.w	r8,0
  
}
8001a918:	cf e1       	brne	8001a914 <ftdi_get_strings+0xe8>
8001a91a:	2f e3       	sub	r3,-2
			(USB_DT_STRING << 8) | uhi_ftdi_dev.dev->dev_desc.iSerialNumber,
			// end-transfer callback
			&ctl_req_end )
       
       )) {
    print_dbg("\r\n control request for string descriptor failed");
8001a91c:	83 03       	st.w	r1[0x0],r3
8001a91e:	2f e2       	sub	r2,-2
8001a920:	81 02       	st.w	r0[0x0],r2
  //  print_dbg("\r\n requested all string descriptors.");
  *pManufacturer = manufacturer_string + FTDI_STRING_DESC_OFFSET;
  *pProduct = product_string + FTDI_STRING_DESC_OFFSET;
  *pSerial = serial_string + FTDI_STRING_DESC_OFFSET;
  
}
8001a922:	2f e6       	sub	r6,-2
8001a924:	40 08       	lddsp	r8,sp[0x0]
8001a926:	91 06       	st.w	r8[0x0],r6
8001a928:	2f dd       	sub	sp,-12
8001a92a:	d8 32       	popm	r0-r7,pc
8001a92c:	48 3c       	lddpc	r12,8001a938 <ftdi_get_strings+0x10c>
8001a92e:	fe b0 c3 37 	rcall	80012f9c <print_dbg>
8001a932:	2f dd       	sub	sp,-12
8001a934:	d8 32       	popm	r0-r7,pc
8001a936:	d7 03       	nop
8001a938:	80 02       	ld.sh	r2,r0[0x0]
8001a93a:	4f 44       	lddpc	r4,8001ab08 <ftdi_read+0x1c>

8001a93c <uhi_ftdi_enable>:
8001a93c:	eb cd 40 fe 	pushm	r1-r7,lr
8001a940:	20 2d       	sub	sp,8
8001a942:	e0 66 1c 88 	mov	r6,7304
8001a946:	6c 07       	ld.w	r7,r6[0x0]
8001a948:	18 37       	cp.w	r7,r12
8001a94a:	c0 40       	breq	8001a952 <uhi_ftdi_enable+0x16>
		   NULL);

  delay_ms(200);

  ftdi_change(dev, true);  
}
8001a94c:	2f ed       	sub	sp,-8
8001a94e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a952:	30 bc       	mov	r12,11
8001a954:	30 05       	mov	r5,0
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a956:	1a d5       	st.w	--sp,r5
  req.wValue = (val);
8001a958:	ba dc       	st.b	sp[0x5],r12
8001a95a:	e0 6c 00 ff 	mov	r12,255
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a95e:	fa c2 ff fc 	sub	r2,sp,-4
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a962:	ba 3c       	st.h	sp[0x6],r12
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8001a964:	34 04       	mov	r4,64
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a966:	30 03       	mov	r3,0
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8001a968:	ba c4       	st.b	sp[0x4],r4
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
8001a96a:	ba 53       	st.h	sp[0xa],r3
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a96c:	30 11       	mov	r1,1
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
8001a96e:	0a 98       	mov	r8,r5
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a970:	ba 41       	st.h	sp[0x8],r1
8001a972:	0a 99       	mov	r9,r5
8001a974:	0a 9a       	mov	r10,r5
8001a976:	04 9b       	mov	r11,r2
8001a978:	ef 3c 00 12 	ld.ub	r12,r7[18]
8001a97c:	fe b0 d0 3c 	rcall	800149f4 <uhd_setup_request>
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
8001a980:	30 4c       	mov	r12,4
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a982:	ba 41       	st.h	sp[0x8],r1
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a984:	1a d5       	st.w	--sp,r5
8001a986:	fb 6c 00 09 	st.b	sp[9],r12
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a98a:	30 8c       	mov	r12,8
8001a98c:	fb 64 00 08 	st.b	sp[8],r4
  req.bRequest = reqnum;
  req.wValue = (val);
8001a990:	ba 75       	st.h	sp[0xe],r5
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a992:	ba 5c       	st.h	sp[0xa],r12
8001a994:	6c 01       	ld.w	r1,r6[0x0]
8001a996:	0a 98       	mov	r8,r5
8001a998:	0a 99       	mov	r9,r5
8001a99a:	0a 9a       	mov	r10,r5
8001a99c:	04 9b       	mov	r11,r2
8001a99e:	e3 3c 00 12 	ld.ub	r12,r1[18]
8001a9a2:	fe b0 d0 29 	rcall	800149f4 <uhd_setup_request>
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
8001a9a6:	30 3c       	mov	r12,3
8001a9a8:	fb 64 00 08 	st.b	sp[8],r4
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a9ac:	ba 73       	st.h	sp[0xe],r3
8001a9ae:	6c 09       	ld.w	r9,r6[0x0]
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8001a9b0:	1a d5       	st.w	--sp,r5
8001a9b2:	fb 6c 00 0d 	st.b	sp[13],r12
  req.wValue = (val);
8001a9b6:	fe 7c c0 36 	mov	r12,-16330
  req.wIndex = (index);
8001a9ba:	0a 98       	mov	r8,r5
8001a9bc:	fb 53 00 10 	st.h	sp[16],r3
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a9c0:	04 9b       	mov	r11,r2
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
8001a9c2:	0a 9a       	mov	r10,r5
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8001a9c4:	ba 7c       	st.h	sp[0xe],r12
8001a9c6:	f3 3c 00 12 	ld.ub	r12,r9[18]
8001a9ca:	0a 99       	mov	r9,r5
8001a9cc:	fe b0 d0 14 	rcall	800149f4 <uhd_setup_request>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8001a9d0:	30 09       	mov	r9,0
8001a9d2:	e0 68 03 e8 	mov	r8,1000
8001a9d6:	e0 6a 07 e7 	mov	r10,2023
8001a9da:	ea 1a 12 c8 	orh	r10,0x12c8
8001a9de:	30 3b       	mov	r11,3
8001a9e0:	e0 a0 42 f9 	rcall	80022fd2 <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001a9e4:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001a9e8:	f2 0a 00 0a 	add	r10,r9,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001a9ec:	e1 b8 00 42 	mfsr	r8,0x108
8001a9f0:	2f dd       	sub	sp,-12
8001a9f2:	14 39       	cp.w	r9,r10
8001a9f4:	e0 8b 00 0f 	brhi	8001aa12 <uhi_ftdi_enable+0xd6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001a9f8:	10 39       	cp.w	r9,r8
8001a9fa:	e0 8b 00 04 	brhi	8001aa02 <uhi_ftdi_enable+0xc6>
8001a9fe:	10 3a       	cp.w	r10,r8
		   0, 49206,
		   NULL);

  delay_ms(200);

  ftdi_change(dev, true);  
8001aa00:	c0 f2       	brcc	8001aa1e <uhi_ftdi_enable+0xe2>
8001aa02:	0e 9c       	mov	r12,r7
8001aa04:	30 1b       	mov	r11,1
8001aa06:	c5 9c       	rcall	8001aab8 <ftdi_change>
}
8001aa08:	2f ed       	sub	sp,-8
8001aa0a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001aa0e:	e1 b8 00 42 	mfsr	r8,0x108
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001aa12:	10 39       	cp.w	r9,r8
8001aa14:	fe 98 ff fd 	brls	8001aa0e <uhi_ftdi_enable+0xd2>
8001aa18:	10 3a       	cp.w	r10,r8
8001aa1a:	cf a2       	brcc	8001aa0e <uhi_ftdi_enable+0xd2>
8001aa1c:	cf 3b       	rjmp	8001aa02 <uhi_ftdi_enable+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001aa1e:	e1 b8 00 42 	mfsr	r8,0x108
8001aa22:	ce bb       	rjmp	8001a9f8 <uhi_ftdi_enable+0xbc>

8001aa24 <ftdi_rx_done>:
//------- static functions

static void ftdi_rx_done(  usb_add_t add,
			   usb_ep_t ep,
			   uhd_trans_status_t stat,
			   iram_size_t nb) {
8001aa24:	d4 01       	pushm	lr
  status = stat;
8001aa26:	e0 68 1c e4 	mov	r8,7396
  rxBusy = 0;
8001aa2a:	91 0a       	st.w	r8[0x0],r10
  rxBytes = nb - FTDI_STATUS_BYTES;
8001aa2c:	e0 68 1c d4 	mov	r8,7380
static void ftdi_rx_done(  usb_add_t add,
			   usb_ep_t ep,
			   uhd_trans_status_t stat,
			   iram_size_t nb) {
  status = stat;
  rxBusy = 0;
8001aa30:	20 29       	sub	r9,2
  rxBytes = nb - FTDI_STATUS_BYTES;
8001aa32:	30 0a       	mov	r10,0
8001aa34:	b0 8a       	st.b	r8[0x0],r10
  /* print_dbg_ulong(nb); */
  /* print_dbg(" ; status bytes: 0x"); */
  /* print_dbg_hex(rxBuf[0]); */
  /* print_dbg(" 0x"); */
  /* print_dbg_hex(rxBuf[1]); */			    
  if(rxBytes) {
8001aa36:	e0 68 1c d8 	mov	r8,7384
    // check for monome events
    //    if(monome_read_serial != NULL) { 
      (*monome_read_serial)(); 
8001aa3a:	91 09       	st.w	r8[0x0],r9
8001aa3c:	58 09       	cp.w	r9,0
8001aa3e:	c0 40       	breq	8001aa46 <ftdi_rx_done+0x22>
8001aa40:	30 c8       	mov	r8,12
8001aa42:	70 08       	ld.w	r8,r8[0x0]
8001aa44:	5d 18       	icall	r8
8001aa46:	d8 02       	popm	pc

8001aa48 <ftdi_rx_buf>:
8001aa48:	e0 6c 1c 94 	mov	r12,7316
8001aa4c:	2f ec       	sub	r12,-2
8001aa4e:	5e fc       	retal	r12

8001aa50 <ftdi_rx_bytes>:
8001aa50:	e0 68 1c d8 	mov	r8,7384
}

// number of bytes from last rx trasnfer
extern volatile u8 ftdi_rx_bytes() {
  return rxBytes;
}
8001aa54:	11 bc       	ld.ub	r12,r8[0x3]
8001aa56:	5e fc       	retal	r12

8001aa58 <ftdi_rx_busy>:
8001aa58:	e0 68 1c d4 	mov	r8,7380

// busy flags
extern volatile u8 ftdi_rx_busy() {
  return rxBusy;
}
8001aa5c:	11 8c       	ld.ub	r12,r8[0x0]
8001aa5e:	5e fc       	retal	r12

8001aa60 <ftdi_tx_busy>:
8001aa60:	e0 68 1c 91 	mov	r8,7313

extern volatile u8 ftdi_tx_busy() {
  return txBusy;
}
8001aa64:	11 8c       	ld.ub	r12,r8[0x0]
8001aa66:	5e fc       	retal	r12

8001aa68 <ftdi_tx_done>:
8001aa68:	d4 01       	pushm	lr
8001aa6a:	e0 68 1c e4 	mov	r8,7396
static void ftdi_tx_done(
			       usb_add_t add,
			       usb_ep_t ep,
			       uhd_trans_status_t stat,
			       iram_size_t nb) {
  status = stat;
8001aa6e:	30 09       	mov	r9,0
  txBusy = 0;
8001aa70:	91 0a       	st.w	r8[0x0],r10
8001aa72:	e0 68 1c 91 	mov	r8,7313
  /* print_dbg("\r\n ftdi tx transfer callback. status: 0x"); */
  /* print_dbg_hex((u32)status); */
  if (status != UHD_TRANS_NOERROR) {
8001aa76:	b0 89       	st.b	r8[0x0],r9
    print_dbg("\r\n ftdi tx error");
8001aa78:	58 0a       	cp.w	r10,0
8001aa7a:	c0 40       	breq	8001aa82 <ftdi_tx_done+0x1a>
8001aa7c:	48 2c       	lddpc	r12,8001aa84 <ftdi_tx_done+0x1c>
8001aa7e:	fe b0 c2 8f 	rcall	80012f9c <print_dbg>
8001aa82:	d8 02       	popm	pc
8001aa84:	80 02       	ld.sh	r2,r0[0x0]
8001aa86:	4f 74       	lddpc	r4,8001ac60 <uhi_midi_install+0xf4>

8001aa88 <ftdi_setup>:
8001aa88:	d4 01       	pushm	lr
8001aa8a:	20 3d       	sub	sp,12
8001aa8c:	48 ac       	lddpc	r12,8001aab4 <ftdi_setup+0x2c>
8001aa8e:	fe b0 c2 87 	rcall	80012f9c <print_dbg>
  char * prodstr;
  char * serstr;
  print_dbg("\r\n FTDI setup routine");

  // get string data...
  ftdi_get_strings(&manstr, &prodstr, &serstr);  
8001aa92:	1a 9a       	mov	r10,sp
8001aa94:	fa cb ff fc 	sub	r11,sp,-4
8001aa98:	fa cc ff f8 	sub	r12,sp,-8
8001aa9c:	cc 8e       	rcall	8001a82c <ftdi_get_strings>
8001aa9e:	40 0a       	lddsp	r10,sp[0x0]
  // print the strings
  // print_unicode_string(manstr, FTDI_STRING_MAX_LEN);
  //  print_unicode_string(prodstr, FTDI_STRING_MAX_LEN);
  //  print_unicode_string(serstr, FTDI_STRING_MAX_LEN);
  //// query if this is a monome device
  check_monome_device_desc(manstr, prodstr, serstr);
8001aaa0:	40 1b       	lddsp	r11,sp[0x4]
8001aaa2:	40 2c       	lddsp	r12,sp[0x8]
8001aaa4:	fe b0 f3 84 	rcall	800191ac <check_monome_device_desc>
8001aaa8:	30 19       	mov	r9,1
  //// TODO: other protocols??

  // set connection flag
  ftdiConnect = 1;
8001aaaa:	e0 68 1c 92 	mov	r8,7314
8001aaae:	b0 89       	st.b	r8[0x0],r9
}
8001aab0:	2f dd       	sub	sp,-12
8001aab2:	d8 02       	popm	pc
8001aab4:	80 02       	ld.sh	r2,r0[0x0]
8001aab6:	4f 88       	lddpc	r8,8001ac94 <hid_mouse_move+0x1c>

8001aab8 <ftdi_change>:
8001aab8:	eb cd 40 80 	pushm	r7,lr
8001aabc:	48 bc       	lddpc	r12,8001aae8 <ftdi_change+0x30>
8001aabe:	16 97       	mov	r7,r11
8001aac0:	fe b0 c2 6e 	rcall	80012f9c <print_dbg>
8001aac4:	58 07       	cp.w	r7,0
8001aac6:	c0 b1       	brne	8001aadc <ftdi_change+0x24>
void ftdi_change(uhc_device_t* dev, u8 plug) {
  print_dbg("\r\n changed FTDI connection status");
  if(plug) { 
    e.eventType = kEventFtdiConnect; 
  } else {
    e.eventType = kEventFtdiDisconnect;
8001aac8:	e0 68 1c dc 	mov	r8,7388
8001aacc:	30 89       	mov	r9,8
  }
  // posting an event so the main loop can respond
  post_event(&e); 
8001aace:	91 09       	st.w	r8[0x0],r9
8001aad0:	e0 6c 1c dc 	mov	r12,7388
}
8001aad4:	fe b0 e4 9e 	rcall	80017410 <post_event>
// respond to connection or disconnection of ftdi device.
// may be called from an interrupt
void ftdi_change(uhc_device_t* dev, u8 plug) {
  print_dbg("\r\n changed FTDI connection status");
  if(plug) { 
    e.eventType = kEventFtdiConnect; 
8001aad8:	e3 cd 80 80 	ldm	sp++,r7,pc
8001aadc:	e0 68 1c dc 	mov	r8,7388
8001aae0:	30 79       	mov	r9,7
8001aae2:	91 09       	st.w	r8[0x0],r9
8001aae4:	cf 6b       	rjmp	8001aad0 <ftdi_change+0x18>
8001aae6:	d7 03       	nop
8001aae8:	80 02       	ld.sh	r2,r0[0x0]
8001aaea:	4f a0       	lddpc	r0,8001acd0 <hid_mouse_btn_middle+0x14>

8001aaec <ftdi_read>:
8001aaec:	d4 01       	pushm	lr
8001aaee:	30 09       	mov	r9,0
    print_dbg("\r\n error requesting ftdi output pipe");
  }
}
    
void ftdi_read(void) {
  rxBytes = 0;
8001aaf0:	e0 68 1c d8 	mov	r8,7384
  rxBusy = true;
8001aaf4:	91 09       	st.w	r8[0x0],r9
8001aaf6:	30 19       	mov	r9,1
  if (!uhi_ftdi_in_run((u8*)rxBuf,
8001aaf8:	e0 68 1c d4 	mov	r8,7380
8001aafc:	fe ca 00 d8 	sub	r10,pc,216
8001ab00:	b0 89       	st.b	r8[0x0],r9
8001ab02:	34 0b       	mov	r11,64
8001ab04:	e0 6c 1c 94 	mov	r12,7316
		       FTDI_RX_BUF_SIZE, &ftdi_rx_done)) {
    print_dbg("\r\n ftdi rx transfer error");
8001ab08:	fe b0 fd f8 	rcall	8001a6f8 <uhi_ftdi_in_run>
8001ab0c:	c0 41       	brne	8001ab14 <ftdi_read+0x28>
8001ab0e:	48 3c       	lddpc	r12,8001ab18 <ftdi_read+0x2c>
8001ab10:	fe b0 c2 46 	rcall	80012f9c <print_dbg>
8001ab14:	d8 02       	popm	pc
8001ab16:	d7 03       	nop
8001ab18:	80 02       	ld.sh	r2,r0[0x0]
8001ab1a:	4f c4       	lddpc	r4,8001ad08 <hid_mouse_btn_left+0x14>

8001ab1c <ftdi_write>:
8001ab1c:	d4 01       	pushm	lr
8001ab1e:	30 19       	mov	r9,1
8001ab20:	e0 68 1c 91 	mov	r8,7313
8001ab24:	fe ca 00 bc 	sub	r10,pc,188
8001ab28:	b0 89       	st.b	r8[0x0],r9
8001ab2a:	fe b0 fd d5 	rcall	8001a6d4 <uhi_ftdi_out_run>
//-------- extern functions
void ftdi_write(u8* data, u32 bytes) {
  txBusy = 1;
  if(!uhi_ftdi_out_run(data, bytes, &ftdi_tx_done)) {

    print_dbg("\r\n error requesting ftdi output pipe");
8001ab2e:	c0 41       	brne	8001ab36 <ftdi_write+0x1a>
8001ab30:	48 2c       	lddpc	r12,8001ab38 <ftdi_write+0x1c>
8001ab32:	fe b0 c2 35 	rcall	80012f9c <print_dbg>
8001ab36:	d8 02       	popm	pc
8001ab38:	80 02       	ld.sh	r2,r0[0x0]
8001ab3a:	4f e0       	lddpc	r0,8001ad30 <uhi_hid_mouse_enable+0x4>

8001ab3c <uhi_midi_uninstall>:
  //  UHI_MIDI_CHANGE(dev, true);
  midi_change(dev, true);  
  print_dbg("\r\n finished uhi_midi_enable");
}

void uhi_midi_uninstall(uhc_device_t* dev) {
8001ab3c:	d4 01       	pushm	lr
  if (uhi_midi_dev.dev != dev) {
8001ab3e:	32 08       	mov	r8,32
8001ab40:	70 0a       	ld.w	r10,r8[0x0]
8001ab42:	18 3a       	cp.w	r10,r12
8001ab44:	c0 20       	breq	8001ab48 <uhi_midi_uninstall+0xc>
8001ab46:	d8 02       	popm	pc
    return; // Device not enabled in this interface
  }
  uhi_midi_dev.dev = NULL;
8001ab48:	30 0b       	mov	r11,0
8001ab4a:	91 0b       	st.w	r8[0x0],r11
  Assert(uhi_midi_dev.report!=NULL);
  midi_change(dev, false);  
8001ab4c:	c9 2c       	rcall	8001ac70 <midi_change>
8001ab4e:	d8 02       	popm	pc

8001ab50 <uhi_midi_enable>:
8001ab50:	d4 01       	pushm	lr
8001ab52:	32 08       	mov	r8,32
8001ab54:	70 09       	ld.w	r9,r8[0x0]
8001ab56:	18 39       	cp.w	r9,r12
8001ab58:	c0 20       	breq	8001ab5c <uhi_midi_enable+0xc>
8001ab5a:	d8 02       	popm	pc
  ////  TODO: ??? any setup requests necessary?
  /* 		   1, 0xff,  */
  /* 		   NULL); */
  
  //  UHI_MIDI_CHANGE(dev, true);
  midi_change(dev, true);  
8001ab5c:	30 1b       	mov	r11,1
8001ab5e:	c8 9c       	rcall	8001ac70 <midi_change>
8001ab60:	48 2c       	lddpc	r12,8001ab68 <uhi_midi_enable+0x18>
  print_dbg("\r\n finished uhi_midi_enable");
8001ab62:	fe b0 c2 1d 	rcall	80012f9c <print_dbg>
8001ab66:	d8 02       	popm	pc
8001ab68:	80 02       	ld.sh	r2,r0[0x0]
8001ab6a:	50 08       	stdsp	sp[0x0],r8

8001ab6c <uhi_midi_install>:
8001ab6c:	d4 31       	pushm	r0-r7,lr
8001ab6e:	20 1d       	sub	sp,4
8001ab70:	32 05       	mov	r5,32
8001ab72:	18 92       	mov	r2,r12
8001ab74:	6a 03       	ld.w	r3,r5[0x0]
8001ab76:	58 03       	cp.w	r3,0
8001ab78:	c0 40       	breq	8001ab80 <uhi_midi_install+0x14>
8001ab7a:	30 5c       	mov	r12,5
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
    return UHC_ENUM_SUCCESS;
  }
  return UHC_ENUM_UNSUPPORTED; // No interface supported
}
8001ab7c:	2f fd       	sub	sp,-4
8001ab7e:	d8 32       	popm	r0-r7,pc

  if (uhi_midi_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
8001ab80:	78 67       	ld.w	r7,r12[0x18]
8001ab82:	0f a6       	ld.ub	r6,r7[0x2]
8001ab84:	0f b8       	ld.ub	r8,r7[0x3]
8001ab86:	f1 e6 10 86 	or	r6,r8,r6<<0x8
8001ab8a:	5c c6       	swap.bh	r6
8001ab8c:	5c 86       	casts.h	r6
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
8001ab8e:	c5 00       	breq	8001ac2e <uhi_midi_install+0xc2>
    switch (ptr_iface->bDescriptorType) {
8001ab90:	30 44       	mov	r4,4

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
8001ab92:	30 11       	mov	r1,1
	   && (ptr_iface->bInterfaceSubClass == USB_MIDI_IFACE_SUBCLASS) ) {
8001ab94:	30 30       	mov	r0,3
8001ab96:	c1 08       	rjmp	8001abb6 <uhi_midi_install+0x4a>
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8001ab98:	30 59       	mov	r9,5
8001ab9a:	f2 08 18 00 	cp.b	r8,r9
8001ab9e:	c1 f0       	breq	8001abdc <uhi_midi_install+0x70>
	;; // ignore endpoint (shouldn't get here)
	break;
      }
      break;
    default:
      print_dbg("\r\n uhi_midi_install ignoring descriptor; type: 0x");
8001aba0:	4a dc       	lddpc	r12,8001ac54 <uhi_midi_install+0xe8>
8001aba2:	fe b0 c1 fd 	rcall	80012f9c <print_dbg>
      print_dbg_hex(ptr_iface->bDescriptorType );
8001aba6:	0f 9c       	ld.ub	r12,r7[0x1]
8001aba8:	fe b0 c2 22 	rcall	80012fec <print_dbg_hex>
      break;
      
    }
      
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8001abac:	0f 88       	ld.ub	r8,r7[0x0]
8001abae:	10 16       	sub	r6,r8
8001abb0:	5c 86       	casts.h	r6

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
8001abb2:	c3 c0       	breq	8001ac2a <uhi_midi_install+0xbe>
      
    }
      
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001abb4:	10 07       	add	r7,r8
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8001abb6:	0f 98       	ld.ub	r8,r7[0x1]
8001abb8:	e8 08 18 00 	cp.b	r8,r4
8001abbc:	ce e1       	brne	8001ab98 <uhi_midi_install+0x2c>

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
8001abbe:	0f d8       	ld.ub	r8,r7[0x5]
8001abc0:	e2 08 18 00 	cp.b	r8,r1
8001abc4:	c0 30       	breq	8001abca <uhi_midi_install+0x5e>
	break;
      }
      break;
    default:
      print_dbg("\r\n uhi_midi_install ignoring descriptor; type: 0x");
      print_dbg_hex(ptr_iface->bDescriptorType );
8001abc6:	30 03       	mov	r3,0
8001abc8:	cf 2b       	rjmp	8001abac <uhi_midi_install+0x40>
      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
	   && (ptr_iface->bInterfaceSubClass == USB_MIDI_IFACE_SUBCLASS) ) {
8001abca:	0f e8       	ld.ub	r8,r7[0x6]
8001abcc:	e0 08 18 00 	cp.b	r8,r0
8001abd0:	cf b1       	brne	8001abc6 <uhi_midi_install+0x5a>

#if UHI_MIDI_PRINT_DBG
	print_dbg("\r\n class/subclass matches audio/MIDI. ");
#endif
	iface_supported = true;
	uhi_midi_dev.ep_in = 0;
8001abd2:	30 08       	mov	r8,0
	uhi_midi_dev.ep_out = 0;
8001abd4:	30 13       	mov	r3,1
8001abd6:	aa d8       	st.b	r5[0x5],r8

#if UHI_MIDI_PRINT_DBG
	print_dbg("\r\n class/subclass matches audio/MIDI. ");
#endif
	iface_supported = true;
	uhi_midi_dev.ep_in = 0;
8001abd8:	aa c8       	st.b	r5[0x4],r8

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
8001abda:	ce 9b       	rjmp	8001abac <uhi_midi_install+0x40>
	iface_supported = false;
      }
      break;

    case USB_DT_ENDPOINT:
      if (!iface_supported) {
8001abdc:	58 03       	cp.w	r3,0
8001abde:	ce 70       	breq	8001abac <uhi_midi_install+0x40>
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
8001abe0:	0e 9b       	mov	r11,r7
8001abe2:	e5 3c 00 12 	ld.ub	r12,r2[18]
8001abe6:	fe b0 cc 11 	rcall	80014408 <uhd_ep_alloc>
8001abea:	c2 c0       	breq	8001ac42 <uhi_midi_install+0xd6>
	print_dbg("\r\n endpoint allocation failed");
	return UHC_ENUM_HARDWARE_LIMIT;
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
8001abec:	0f b8       	ld.ub	r8,r7[0x3]
8001abee:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8001abf2:	58 28       	cp.w	r8,2
8001abf4:	cd c1       	brne	8001abac <uhi_midi_install+0x40>
      case USB_EP_TYPE_BULK:
       	print_dbg("\r\n allocating bulk endpoint ( ");
8001abf6:	49 9c       	lddpc	r12,8001ac58 <uhi_midi_install+0xec>
8001abf8:	fe b0 c1 d2 	rcall	80012f9c <print_dbg>
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
8001abfc:	30 08       	mov	r8,0
8001abfe:	0f a9       	ld.ub	r9,r7[0x2]
8001ac00:	f0 09 18 00 	cp.b	r9,r8
8001ac04:	c1 d5       	brlt	8001ac3e <uhi_midi_install+0xd2>
	  /* print_dbg("\r\n ( previous input : 0x"); */
	  /* print_dbg_hex((u32)uhi_midi_dev.ep_in); */
	  /* if(uhi_midi_dev.ep_in != 0) { print_dbg("\r\n reallocating midi input endpoint"); } */
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	} else {
	  print_dbg(" output )");
8001ac06:	50 08       	stdsp	sp[0x0],r8
8001ac08:	49 5c       	lddpc	r12,8001ac5c <uhi_midi_install+0xf0>
8001ac0a:	fe b0 c1 c9 	rcall	80012f9c <print_dbg>
	  print_dbg("\r\n ( previous output : 0x");
8001ac0e:	49 5c       	lddpc	r12,8001ac60 <uhi_midi_install+0xf4>
8001ac10:	fe b0 c1 c6 	rcall	80012f9c <print_dbg>
	  print_dbg_hex((u32)uhi_midi_dev.ep_out);
8001ac14:	0b dc       	ld.ub	r12,r5[0x5]
8001ac16:	fe b0 c1 eb 	rcall	80012fec <print_dbg_hex>
	  if(uhi_midi_dev.ep_out != 0) { print_dbg("\r\n reallocating midi output endpoint"); }
8001ac1a:	0b d9       	ld.ub	r9,r5[0x5]
8001ac1c:	40 08       	lddsp	r8,sp[0x0]
8001ac1e:	f0 09 18 00 	cp.b	r9,r8
8001ac22:	c1 51       	brne	8001ac4c <uhi_midi_install+0xe0>
	  uhi_midi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001ac24:	0f a8       	ld.ub	r8,r7[0x2]
8001ac26:	aa d8       	st.b	r5[0x5],r8
8001ac28:	cc 2b       	rjmp	8001abac <uhi_midi_install+0x40>
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
8001ac2a:	58 03       	cp.w	r3,0
8001ac2c:	c0 31       	brne	8001ac32 <uhi_midi_install+0xc6>
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
    return UHC_ENUM_SUCCESS;
8001ac2e:	30 1c       	mov	r12,1
8001ac30:	ca 6b       	rjmp	8001ab7c <uhi_midi_install+0x10>
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
8001ac32:	48 dc       	lddpc	r12,8001ac64 <uhi_midi_install+0xf8>
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
    uhi_midi_dev.dev = dev;
8001ac34:	8b 02       	st.w	r5[0x0],r2
    print_dbg("\r\n completed MIDI device install");
8001ac36:	fe b0 c1 b3 	rcall	80012f9c <print_dbg>
8001ac3a:	0c 9c       	mov	r12,r6
    return UHC_ENUM_SUCCESS;
8001ac3c:	ca 0b       	rjmp	8001ab7c <uhi_midi_install+0x10>
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
	  /* print_dbg(" input )"); */
	  /* print_dbg("\r\n ( previous input : 0x"); */
	  /* print_dbg_hex((u32)uhi_midi_dev.ep_in); */
	  /* if(uhi_midi_dev.ep_in != 0) { print_dbg("\r\n reallocating midi input endpoint"); } */
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001ac3e:	aa c9       	st.b	r5[0x4],r9
8001ac40:	cb 6b       	rjmp	8001abac <uhi_midi_install+0x40>
    case USB_DT_ENDPOINT:
      if (!iface_supported) {
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	print_dbg("\r\n endpoint allocation failed");
8001ac42:	48 ac       	lddpc	r12,8001ac68 <uhi_midi_install+0xfc>
8001ac44:	fe b0 c1 ac 	rcall	80012f9c <print_dbg>
8001ac48:	30 4c       	mov	r12,4
	return UHC_ENUM_HARDWARE_LIMIT;
8001ac4a:	c9 9b       	rjmp	8001ab7c <uhi_midi_install+0x10>
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	} else {
	  print_dbg(" output )");
	  print_dbg("\r\n ( previous output : 0x");
	  print_dbg_hex((u32)uhi_midi_dev.ep_out);
	  if(uhi_midi_dev.ep_out != 0) { print_dbg("\r\n reallocating midi output endpoint"); }
8001ac4c:	48 8c       	lddpc	r12,8001ac6c <uhi_midi_install+0x100>
8001ac4e:	fe b0 c1 a7 	rcall	80012f9c <print_dbg>
8001ac52:	ce 9b       	rjmp	8001ac24 <uhi_midi_install+0xb8>
8001ac54:	80 02       	ld.sh	r2,r0[0x0]
8001ac56:	50 94       	stdsp	sp[0x24],r4
8001ac58:	80 02       	ld.sh	r2,r0[0x0]
8001ac5a:	50 24       	stdsp	sp[0x8],r4
8001ac5c:	80 02       	ld.sh	r2,r0[0x0]
8001ac5e:	50 44       	stdsp	sp[0x10],r4
8001ac60:	80 02       	ld.sh	r2,r0[0x0]
8001ac62:	50 50       	stdsp	sp[0x14],r0
8001ac64:	80 02       	ld.sh	r2,r0[0x0]
8001ac66:	50 c8       	stdsp	sp[0x30],r8
8001ac68:	80 02       	ld.sh	r2,r0[0x0]
8001ac6a:	4e 98       	lddpc	r8,8001ae0c <uhi_hid_mouse_install>
8001ac6c:	80 02       	ld.sh	r2,r0[0x0]
8001ac6e:	50 6c       	stdsp	sp[0x18],r12

8001ac70 <midi_change>:
  return;
}

// MIDI device was plugged or unplugged
extern void midi_change(uhc_device_t* dev, u8 plug) {
  midiConnect = plug;
8001ac70:	e0 68 1c e8 	mov	r8,7400
}
8001ac74:	b0 8b       	st.b	r8[0x0],r11
8001ac76:	5e fc       	retal	r12

8001ac78 <hid_mouse_move>:
void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
  print_dbg_ulong(b_state);
}

void hid_mouse_move(int8_t x, int8_t y, int8_t scroll) {
8001ac78:	eb cd 40 e0 	pushm	r5-r7,lr
8001ac7c:	16 97       	mov	r7,r11
8001ac7e:	14 96       	mov	r6,r10
8001ac80:	18 95       	mov	r5,r12
  print_dbg("\r\n usb mouse move; x: ");
8001ac82:	48 cc       	lddpc	r12,8001acb0 <hid_mouse_move+0x38>
8001ac84:	fe b0 c1 8c 	rcall	80012f9c <print_dbg>
  print_dbg_hex(x);
8001ac88:	f9 d5 b0 08 	bfexts	r12,r5,0x0,0x8
8001ac8c:	fe b0 c1 b0 	rcall	80012fec <print_dbg_hex>
  print_dbg(", y: ");
8001ac90:	48 9c       	lddpc	r12,8001acb4 <hid_mouse_move+0x3c>
8001ac92:	fe b0 c1 85 	rcall	80012f9c <print_dbg>
  print_dbg_hex(y);
8001ac96:	0e 9c       	mov	r12,r7
8001ac98:	5c 6c       	casts.b	r12
8001ac9a:	fe b0 c1 a9 	rcall	80012fec <print_dbg_hex>
  print_dbg(", scroll: ");
8001ac9e:	48 7c       	lddpc	r12,8001acb8 <hid_mouse_move+0x40>
8001aca0:	fe b0 c1 7e 	rcall	80012f9c <print_dbg>
  print_dbg_hex(scroll);
8001aca4:	f9 d6 b0 08 	bfexts	r12,r6,0x0,0x8
8001aca8:	fe b0 c1 a2 	rcall	80012fec <print_dbg_hex>
}
8001acac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001acb0:	80 02       	ld.sh	r2,r0[0x0]
8001acb2:	50 ec       	stdsp	sp[0x38],r12
8001acb4:	80 02       	ld.sh	r2,r0[0x0]
8001acb6:	51 04       	stdsp	sp[0x40],r4
8001acb8:	80 02       	ld.sh	r2,r0[0x0]
8001acba:	51 0c       	stdsp	sp[0x40],r12

8001acbc <hid_mouse_btn_middle>:
8001acbc:	eb cd 40 80 	pushm	r7,lr
8001acc0:	18 97       	mov	r7,r12
8001acc2:	48 5c       	lddpc	r12,8001acd4 <hid_mouse_btn_middle+0x18>
  print_dbg("\r\n usb right mouse button: ");
  print_dbg_ulong(b_state);
}

void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
8001acc4:	fe b0 c1 6c 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(b_state);
8001acc8:	0e 9c       	mov	r12,r7
8001acca:	fe b0 c1 6f 	rcall	80012fa8 <print_dbg_ulong>
}
8001acce:	e3 cd 80 80 	ldm	sp++,r7,pc
8001acd2:	d7 03       	nop
8001acd4:	80 02       	ld.sh	r2,r0[0x0]
8001acd6:	51 18       	stdsp	sp[0x44],r8

8001acd8 <hid_mouse_btn_right>:
8001acd8:	eb cd 40 80 	pushm	r7,lr
8001acdc:	18 97       	mov	r7,r12
8001acde:	48 5c       	lddpc	r12,8001acf0 <hid_mouse_btn_right+0x18>
  
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}

void hid_mouse_btn_right(bool b_state) {
  print_dbg("\r\n usb right mouse button: ");
8001ace0:	fe b0 c1 5e 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(b_state);
8001ace4:	0e 9c       	mov	r12,r7
8001ace6:	fe b0 c1 61 	rcall	80012fa8 <print_dbg_ulong>
}
8001acea:	e3 cd 80 80 	ldm	sp++,r7,pc
8001acee:	d7 03       	nop
8001acf0:	80 02       	ld.sh	r2,r0[0x0]
8001acf2:	51 34       	stdsp	sp[0x4c],r4

8001acf4 <hid_mouse_btn_left>:
8001acf4:	eb cd 40 80 	pushm	r7,lr
8001acf8:	18 97       	mov	r7,r12
8001acfa:	48 5c       	lddpc	r12,8001ad0c <hid_mouse_btn_left+0x18>

#include "hid_mouse.h"

// mouse event callbacks
void hid_mouse_btn_left(bool b_state) {
  print_dbg("\r\n usb left mouse button: ");
8001acfc:	fe b0 c1 50 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(b_state);
8001ad00:	0e 9c       	mov	r12,r7
8001ad02:	fe b0 c1 53 	rcall	80012fa8 <print_dbg_ulong>
  
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}
8001ad06:	e3 cd 80 80 	ldm	sp++,r7,pc
8001ad0a:	d7 03       	nop
8001ad0c:	80 02       	ld.sh	r2,r0[0x0]
8001ad0e:	51 50       	stdsp	sp[0x54],r0

8001ad10 <uhi_hid_mouse_uninstall>:
	uhi_hid_mouse_start_trans_report(dev->address);
	UHI_HID_MOUSE_CHANGE(dev, true);
}

void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
8001ad10:	d4 01       	pushm	lr
	if (uhi_hid_mouse_dev.dev != dev) {
8001ad12:	e0 68 1c ec 	mov	r8,7404
8001ad16:	70 09       	ld.w	r9,r8[0x0]
8001ad18:	18 39       	cp.w	r9,r12
8001ad1a:	c0 20       	breq	8001ad1e <uhi_hid_mouse_uninstall+0xe>
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
8001ad1c:	d8 02       	popm	pc
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
8001ad1e:	30 09       	mov	r9,0
void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
8001ad20:	70 2c       	ld.w	r12,r8[0x8]
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
8001ad22:	91 09       	st.w	r8[0x0],r9
8001ad24:	e0 a0 42 a6 	rcall	80023270 <free>
8001ad28:	d8 02       	popm	pc
8001ad2a:	d7 03       	nop

8001ad2c <uhi_hid_mouse_enable>:
8001ad2c:	d4 01       	pushm	lr
8001ad2e:	e0 69 1c ec 	mov	r9,7404
	return UHC_ENUM_UNSUPPORTED; // No interface supported
}

void uhi_hid_mouse_enable(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
8001ad32:	72 08       	ld.w	r8,r9[0x0]
8001ad34:	18 38       	cp.w	r8,r12
8001ad36:	c0 20       	breq	8001ad3a <uhi_hid_mouse_enable+0xe>
		return;  // No interface to enable
	}

	// Init value
	uhi_hid_mouse_dev.report_btn_prev = 0;
8001ad38:	d8 02       	popm	pc
8001ad3a:	30 0a       	mov	r10,0
8001ad3c:	f3 6a 00 0c 	st.b	r9[12],r10
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
8001ad40:	fe ca ff e0 	sub	r10,pc,-32
8001ad44:	13 cb       	ld.ub	r11,r9[0x4]
8001ad46:	1a da       	st.w	--sp,r10
8001ad48:	30 0a       	mov	r10,0
8001ad4a:	1a da       	st.w	--sp,r10
8001ad4c:	30 1a       	mov	r10,1
8001ad4e:	f1 3c 00 12 	ld.ub	r12,r8[18]
8001ad52:	13 d8       	ld.ub	r8,r9[0x5]
8001ad54:	72 29       	ld.w	r9,r9[0x8]
8001ad56:	fe b0 d0 c7 	rcall	80014ee4 <uhd_ep_run>
8001ad5a:	2f ed       	sub	sp,-8
8001ad5c:	d8 02       	popm	pc
8001ad5e:	d7 03       	nop

8001ad60 <uhi_hid_mouse_report_reception>:
8001ad60:	d4 21       	pushm	r4-r7,lr
8001ad62:	58 0a       	cp.w	r10,0
8001ad64:	5f 18       	srne	r8
8001ad66:	58 39       	cp.w	r9,3
{
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
8001ad68:	5f 89       	srls	r9
static void uhi_hid_mouse_report_reception(
		usb_add_t add,
		usb_ep_t ep,
		uhd_trans_status_t status,
		iram_size_t nb_transfered)
{
8001ad6a:	18 96       	mov	r6,r12
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
8001ad6c:	f3 e8 10 08 	or	r8,r9,r8
8001ad70:	c2 d1       	brne	8001adca <uhi_hid_mouse_report_reception+0x6a>
		return; // HID mouse transfer aborted
	}

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
8001ad72:	e0 67 1c ec 	mov	r7,7404
	if ((state_prev & 0x01) != (state_new & 0x01)) {
8001ad76:	6e 28       	ld.w	r8,r7[0x8]
8001ad78:	ef 35 00 0c 	ld.ub	r5,r7[12]
8001ad7c:	11 84       	ld.ub	r4,r8[0x0]
8001ad7e:	e9 e5 20 05 	eor	r5,r4,r5
8001ad82:	ed b5 00 00 	bld	r5,0x0
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
8001ad86:	c3 40       	breq	8001adee <uhi_hid_mouse_report_reception+0x8e>
8001ad88:	ed b5 00 01 	bld	r5,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
8001ad8c:	c3 70       	breq	8001adfa <uhi_hid_mouse_report_reception+0x9a>
8001ad8e:	e2 15 00 04 	andl	r5,0x4,COH
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
8001ad92:	c2 41       	brne	8001adda <uhi_hid_mouse_report_reception+0x7a>
8001ad94:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
8001ad98:	6e 29       	ld.w	r9,r7[0x8]
8001ad9a:	13 9c       	ld.ub	r12,r9[0x1]
8001ad9c:	58 0c       	cp.w	r12,0
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
8001ad9e:	c1 b1       	brne	8001add4 <uhi_hid_mouse_report_reception+0x74>
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
8001ada0:	13 ab       	ld.ub	r11,r9[0x2]
8001ada2:	58 0b       	cp.w	r11,0
8001ada4:	c1 40       	breq	8001adcc <uhi_hid_mouse_report_reception+0x6c>
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
		UHI_HID_MOUSE_EVENT_MOUVE(
8001ada6:	13 ba       	ld.ub	r10,r9[0x3]
8001ada8:	5c 6a       	casts.b	r10
8001adaa:	5c 6b       	casts.b	r11
8001adac:	5c 6c       	casts.b	r12
8001adae:	c6 5f       	rcall	8001ac78 <hid_mouse_move>
8001adb0:	6e 29       	ld.w	r9,r7[0x8]
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
8001adb2:	fe c8 00 52 	sub	r8,pc,82
8001adb6:	0f cb       	ld.ub	r11,r7[0x4]
8001adb8:	1a d8       	st.w	--sp,r8
8001adba:	30 08       	mov	r8,0
8001adbc:	0c 9c       	mov	r12,r6
8001adbe:	1a d8       	st.w	--sp,r8
8001adc0:	30 1a       	mov	r10,1
8001adc2:	0f d8       	ld.ub	r8,r7[0x5]
8001adc4:	fe b0 d0 90 	rcall	80014ee4 <uhd_ep_run>
8001adc8:	2f ed       	sub	sp,-8
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
8001adca:	d8 22       	popm	r4-r7,pc
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
8001adcc:	13 ba       	ld.ub	r10,r9[0x3]
8001adce:	58 0a       	cp.w	r10,0
8001add0:	cf 10       	breq	8001adb2 <uhi_hid_mouse_report_reception+0x52>
8001add2:	ce bb       	rjmp	8001ada8 <uhi_hid_mouse_report_reception+0x48>
8001add4:	13 ba       	ld.ub	r10,r9[0x3]
8001add6:	13 ab       	ld.ub	r11,r9[0x2]
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
8001add8:	ce 8b       	rjmp	8001ada8 <uhi_hid_mouse_report_reception+0x48>
8001adda:	f9 d4 c0 41 	bfextu	r12,r4,0x2,0x1
8001adde:	c6 ff       	rcall	8001acbc <hid_mouse_btn_middle>
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
8001ade0:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
8001ade4:	6e 29       	ld.w	r9,r7[0x8]
8001ade6:	13 9c       	ld.ub	r12,r9[0x1]
8001ade8:	58 0c       	cp.w	r12,0
8001adea:	cd b0       	breq	8001ada0 <uhi_hid_mouse_report_reception+0x40>
8001adec:	cf 4b       	rjmp	8001add4 <uhi_hid_mouse_report_reception+0x74>

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
8001adee:	f9 d4 c0 01 	bfextu	r12,r4,0x0,0x1
8001adf2:	c8 1f       	rcall	8001acf4 <hid_mouse_btn_left>
8001adf4:	ed b5 00 01 	bld	r5,0x1
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
8001adf8:	cc b1       	brne	8001ad8e <uhi_hid_mouse_report_reception+0x2e>
8001adfa:	f9 d4 c0 21 	bfextu	r12,r4,0x1,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
8001adfe:	e2 15 00 04 	andl	r5,0x4,COH
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
8001ae02:	c6 bf       	rcall	8001acd8 <hid_mouse_btn_right>
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
8001ae04:	58 05       	cp.w	r5,0
8001ae06:	cc 70       	breq	8001ad94 <uhi_hid_mouse_report_reception+0x34>
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
8001ae08:	ce 9b       	rjmp	8001adda <uhi_hid_mouse_report_reception+0x7a>
8001ae0a:	d7 03       	nop

8001ae0c <uhi_hid_mouse_install>:
8001ae0c:	d4 21       	pushm	r4-r7,lr
8001ae0e:	e0 66 1c ec 	mov	r6,7404
8001ae12:	18 95       	mov	r5,r12
8001ae14:	6c 09       	ld.w	r9,r6[0x0]
8001ae16:	58 09       	cp.w	r9,0
8001ae18:	c0 30       	breq	8001ae1e <uhi_hid_mouse_install+0x12>
8001ae1a:	30 5c       	mov	r12,5
8001ae1c:	d8 22       	popm	r4-r7,pc
8001ae1e:	78 67       	ld.w	r7,r12[0x18]
8001ae20:	0f aa       	ld.ub	r10,r7[0x2]
8001ae22:	0f b8       	ld.ub	r8,r7[0x3]
8001ae24:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8001ae28:	5c c8       	swap.bh	r8
8001ae2a:	5c 88       	casts.h	r8

	if (uhi_hid_mouse_dev.dev != NULL) {
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
8001ae2c:	c2 80       	breq	8001ae7c <uhi_hid_mouse_install+0x70>
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
8001ae2e:	12 9c       	mov	r12,r9

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
8001ae30:	30 4a       	mov	r10,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
8001ae32:	30 3e       	mov	lr,3
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
8001ae34:	30 24       	mov	r4,2
8001ae36:	30 5b       	mov	r11,5
8001ae38:	c0 98       	rjmp	8001ae4a <uhi_hid_mouse_install+0x3e>
8001ae3a:	f6 09 18 00 	cp.b	r9,r11
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
8001ae3e:	c1 00       	breq	8001ae5e <uhi_hid_mouse_install+0x52>
8001ae40:	0f 89       	ld.ub	r9,r7[0x0]
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001ae42:	12 18       	sub	r8,r9
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
8001ae44:	12 07       	add	r7,r9
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
8001ae46:	5c 88       	casts.h	r8
		switch (ptr_iface->bDescriptorType) {
8001ae48:	c1 a0       	breq	8001ae7c <uhi_hid_mouse_install+0x70>
8001ae4a:	0f 99       	ld.ub	r9,r7[0x1]
8001ae4c:	f4 09 18 00 	cp.b	r9,r10

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
8001ae50:	cf 51       	brne	8001ae3a <uhi_hid_mouse_install+0x2e>
8001ae52:	0f d9       	ld.ub	r9,r7[0x5]
8001ae54:	fc 09 18 00 	cp.b	r9,lr
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
8001ae58:	c0 d0       	breq	8001ae72 <uhi_hid_mouse_install+0x66>
8001ae5a:	30 0c       	mov	r12,0
			}
			break;

		case USB_DT_ENDPOINT:
			//  Allocation of the endpoint
			if (!b_iface_supported) {
8001ae5c:	cf 2b       	rjmp	8001ae40 <uhi_hid_mouse_install+0x34>
8001ae5e:	58 0c       	cp.w	r12,0
				break;
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
8001ae60:	cf 00       	breq	8001ae40 <uhi_hid_mouse_install+0x34>
8001ae62:	0e 9b       	mov	r11,r7
8001ae64:	eb 3c 00 12 	ld.ub	r12,r5[18]
8001ae68:	fe b0 ca d0 	rcall	80014408 <uhd_ep_alloc>
8001ae6c:	c0 91       	brne	8001ae7e <uhi_hid_mouse_install+0x72>
8001ae6e:	30 4c       	mov	r12,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
8001ae70:	d8 22       	popm	r4-r7,pc
8001ae72:	0f f9       	ld.ub	r9,r7[0x7]
8001ae74:	e8 09 18 00 	cp.b	r9,r4
8001ae78:	5f 0c       	sreq	r12
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
8001ae7a:	ce 3b       	rjmp	8001ae40 <uhi_hid_mouse_install+0x34>
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
				return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
			}
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
8001ae7c:	da 2a       	popm	r4-r7,pc,r12=1
8001ae7e:	0f a8       	ld.ub	r8,r7[0x2]
			uhi_hid_mouse_dev.report_size =
8001ae80:	ac c8       	st.b	r6[0x4],r8
8001ae82:	0f cc       	ld.ub	r12,r7[0x4]
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
8001ae84:	ac dc       	st.b	r6[0x5],r12
8001ae86:	e0 a0 41 fd 	rcall	80023280 <malloc>
			if (uhi_hid_mouse_dev.report == NULL) {
8001ae8a:	8d 2c       	st.w	r6[0x8],r12
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
8001ae8c:	c0 60       	breq	8001ae98 <uhi_hid_mouse_install+0x8c>
8001ae8e:	e0 68 1c ec 	mov	r8,7404
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
8001ae92:	30 0c       	mov	r12,0
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
			uhi_hid_mouse_dev.report_size =
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
			if (uhi_hid_mouse_dev.report == NULL) {
8001ae94:	91 05       	st.w	r8[0x0],r5
8001ae96:	d8 22       	popm	r4-r7,pc
8001ae98:	30 6c       	mov	r12,6
8001ae9a:	d8 22       	popm	r4-r7,pc

8001ae9c <fatfs_lba_of_cluster>:
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8001ae9c:	78 c8       	ld.w	r8,r12[0x30]
8001ae9e:	58 08       	cp.w	r8,0
8001aea0:	c0 80       	breq	8001aeb0 <fatfs_lba_of_cluster+0x14>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8001aea2:	78 18       	ld.w	r8,r12[0x4]
8001aea4:	20 2b       	sub	r11,2
8001aea6:	19 89       	ld.ub	r9,r12[0x0]
8001aea8:	f6 09 02 4c 	mul	r12,r11,r9
8001aeac:	10 0c       	add	r12,r8
}
8001aeae:	5e fc       	retal	r12
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8001aeb0:	19 88       	ld.ub	r8,r12[0x0]
8001aeb2:	f9 19 00 28 	ld.uh	r9,r12[40]
8001aeb6:	20 2b       	sub	r11,2
8001aeb8:	a5 49       	asr	r9,0x4
8001aeba:	b1 3b       	mul	r11,r8
8001aebc:	78 18       	ld.w	r8,r12[0x4]
8001aebe:	f2 08 00 0c 	add	r12,r9,r8
8001aec2:	16 0c       	add	r12,r11
8001aec4:	5e fc       	retal	r12

8001aec6 <fatfs_sector_read>:
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8001aec6:	d4 01       	pushm	lr
8001aec8:	16 9e       	mov	lr,r11
    return fs->disk_io.read_media(lba, target, count);
8001aeca:	78 d8       	ld.w	r8,r12[0x34]
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8001aecc:	14 9b       	mov	r11,r10
    return fs->disk_io.read_media(lba, target, count);
8001aece:	1c 9c       	mov	r12,lr
8001aed0:	12 9a       	mov	r10,r9
8001aed2:	5d 18       	icall	r8
}
8001aed4:	d8 02       	popm	pc

8001aed6 <fatfs_sector_write>:
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8001aed6:	d4 01       	pushm	lr
8001aed8:	16 9e       	mov	lr,r11
    return fs->disk_io.write_media(lba, target, count);
8001aeda:	78 e8       	ld.w	r8,r12[0x38]
}
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
8001aedc:	14 9b       	mov	r11,r10
    return fs->disk_io.write_media(lba, target, count);
8001aede:	1c 9c       	mov	r12,lr
8001aee0:	12 9a       	mov	r10,r9
8001aee2:	5d 18       	icall	r8
}
8001aee4:	d8 02       	popm	pc

8001aee6 <fatfs_get_root_cluster>:
//-----------------------------------------------------------------------------
uint32 fatfs_get_root_cluster(struct fatfs *fs)
{
    // NOTE: On FAT16 this will be 0 which has a special meaning...
    return fs->rootdir_first_cluster;
}
8001aee6:	78 2c       	ld.w	r12,r12[0x8]
8001aee8:	5e fc       	retal	r12
8001aeea:	d7 03       	nop

8001aeec <fatfs_init>:

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
8001aeec:	eb cd 40 f8 	pushm	r3-r7,lr
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
8001aef0:	3f f8       	mov	r8,-1

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
8001aef2:	18 97       	mov	r7,r12
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
    fs->currentsector.dirty = 0;
8001aef4:	30 06       	mov	r6,0
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
8001aef6:	f9 48 02 44 	st.w	r12[580],r8
    fs->currentsector.dirty = 0;
8001aefa:	f9 46 02 48 	st.w	r12[584],r6

    fs->next_free_cluster = 0; // Invalid
8001aefe:	99 96       	st.w	r12[0x24],r6

    fatfs_fat_init(fs);
8001af00:	e0 a0 13 a2 	rcall	8001d644 <fatfs_fat_init>

    // Make sure we have a read function (write function is optional)
    if (!fs->disk_io.read_media)
8001af04:	6e d8       	ld.w	r8,r7[0x34]
8001af06:	58 08       	cp.w	r8,0
8001af08:	c0 31       	brne	8001af0e <fatfs_init+0x22>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8001af0a:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1

    // MBR: Sector 0 on the disk
    // NOTE: Some removeable media does not have this.

    // Load MBR (LBA 0) into the 512 byte buffer
    if (!fs->disk_io.read_media(0, fs->currentsector.sector, 1))
8001af0e:	0c 9c       	mov	r12,r6
8001af10:	30 1a       	mov	r10,1
8001af12:	ee c6 ff bc 	sub	r6,r7,-68
8001af16:	0c 9b       	mov	r11,r6
8001af18:	5d 18       	icall	r8
8001af1a:	cf 80       	breq	8001af0a <fatfs_init+0x1e>
    ///////////////////


    // Make Sure 0x55 and 0xAA are at end of sector
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
8001af1c:	ef 18 02 42 	ld.uh	r8,r7[578]
8001af20:	e0 48 55 aa 	cp.w	r8,21930
8001af24:	c0 40       	breq	8001af2c <fatfs_init+0x40>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8001af26:	3f dc       	mov	r12,-3
8001af28:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
        return FAT_INIT_INVALID_SIGNATURE;

    // Now check again using the access function to prove endian conversion function
    if (GET_16BIT_WORD(fs->currentsector.sector, SIGNATURE_POSITION) != SIGNATURE_VALUE) 
8001af2c:	ef 39 02 43 	ld.ub	r9,r7[579]
8001af30:	ef 38 02 42 	ld.ub	r8,r7[578]
8001af34:	a9 69       	lsl	r9,0x8
8001af36:	f2 08 00 08 	add	r8,r9,r8
8001af3a:	e0 48 aa 55 	cp.w	r8,43605
8001af3e:	c0 40       	breq	8001af46 <fatfs_init+0x5a>
8001af40:	3f cc       	mov	r12,-4
8001af42:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    	   
    if (sizeof(struct fat_dir_entry) != FAT_DIR_ENTRY_SIZE)
        return FAT_INIT_STRUCT_PACKING;

    // Check the partition type code
    switch(fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION])
8001af46:	ef 38 02 06 	ld.ub	r8,r7[518]
8001af4a:	30 f9       	mov	r9,15
8001af4c:	f2 08 18 00 	cp.b	r8,r9
8001af50:	e0 8b 00 0c 	brhi	8001af68 <fatfs_init+0x7c>
8001af54:	30 19       	mov	r9,1
8001af56:	f2 08 09 49 	lsl	r9,r9,r8
8001af5a:	12 9a       	mov	r10,r9
8001af5c:	e2 1a d8 60 	andl	r10,0xd860,COH
8001af60:	c0 91       	brne	8001af72 <fatfs_init+0x86>
8001af62:	ed b9 00 00 	bld	r9,0x0
8001af66:	c2 70       	breq	8001afb4 <fatfs_init+0xc8>
        break;
        case 0x00:
            valid_partition = 0;
            break;
        default:
            if (fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION] <= 0x06)
8001af68:	30 69       	mov	r9,6
8001af6a:	f2 08 18 00 	cp.b	r8,r9
8001af6e:	e0 8b 00 23 	brhi	8001afb4 <fatfs_init+0xc8>
        break;
    }

    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
8001af72:	ef 38 02 0c 	ld.ub	r8,r7[524]
8001af76:	b1 68       	lsl	r8,0x10
8001af78:	ef 3c 02 0d 	ld.ub	r12,r7[525]
8001af7c:	b9 6c       	lsl	r12,0x18
8001af7e:	10 0c       	add	r12,r8
8001af80:	ef 38 02 0a 	ld.ub	r8,r7[522]
8001af84:	10 0c       	add	r12,r8
8001af86:	ef 38 02 0b 	ld.ub	r8,r7[523]
8001af8a:	a9 68       	lsl	r8,0x8
8001af8c:	10 0c       	add	r12,r8
8001af8e:	8f 7c       	st.w	r7[0x1c],r12
    else
        fs->lba_begin = 0;

    // Load Volume 1 table into sector buffer
    // (We may already have this in the buffer if MBR less drive!)
    if (!fs->disk_io.read_media(fs->lba_begin, fs->currentsector.sector, 1))
8001af90:	0c 9b       	mov	r11,r6
8001af92:	6e d8       	ld.w	r8,r7[0x34]
8001af94:	30 1a       	mov	r10,1
8001af96:	5d 18       	icall	r8
8001af98:	cb 90       	breq	8001af0a <fatfs_init+0x1e>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
8001af9a:	ef 36 00 50 	ld.ub	r6,r7[80]
8001af9e:	ef 3a 00 4f 	ld.ub	r10,r7[79]
8001afa2:	ec 08 15 08 	lsl	r8,r6,0x8
8001afa6:	14 08       	add	r8,r10
8001afa8:	e0 48 02 00 	cp.w	r8,512
8001afac:	c0 70       	breq	8001afba <fatfs_init+0xce>
8001afae:	3f ec       	mov	r12,-2
8001afb0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
    // Else possibly MBR less disk
    else
        fs->lba_begin = 0;
8001afb4:	30 0c       	mov	r12,0
8001afb6:	8f 7c       	st.w	r7[0x1c],r12
8001afb8:	ce cb       	rjmp	8001af90 <fatfs_init+0xa4>
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
8001afba:	ef 38 00 51 	ld.ub	r8,r7[81]
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
8001afbe:	ef 39 00 55 	ld.ub	r9,r7[85]
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
8001afc2:	ae 88       	st.b	r7[0x0],r8
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
8001afc4:	ef 38 00 56 	ld.ub	r8,r7[86]
8001afc8:	a9 68       	lsl	r8,0x8
8001afca:	f2 08 00 08 	add	r8,r9,r8
8001afce:	ef 58 00 28 	st.h	r7[40],r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001afd2:	ef 39 00 5b 	ld.ub	r9,r7[91]
8001afd6:	ef 38 00 5a 	ld.ub	r8,r7[90]
8001afda:	f2 05 15 08 	lsl	r5,r9,0x8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
8001afde:	ef 3c 00 53 	ld.ub	r12,r7[83]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001afe2:	10 05       	add	r5,r8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
8001afe4:	ef 3b 00 52 	ld.ub	r11,r7[82]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
8001afe8:	ef 3e 00 54 	ld.ub	lr,r7[84]
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001afec:	c1 01       	brne	8001b00c <fatfs_init+0x120>
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
8001afee:	ef 35 00 6a 	ld.ub	r5,r7[106]
8001aff2:	b1 65       	lsl	r5,0x10
8001aff4:	ef 34 00 6b 	ld.ub	r4,r7[107]
8001aff8:	b9 64       	lsl	r4,0x18
8001affa:	0a 04       	add	r4,r5
8001affc:	ef 35 00 68 	ld.ub	r5,r7[104]
8001b000:	0a 04       	add	r4,r5
8001b002:	ef 35 00 69 	ld.ub	r5,r7[105]
8001b006:	a9 65       	lsl	r5,0x8
8001b008:	e8 05 00 05 	add	r5,r4,r5
8001b00c:	8f 85       	st.w	r7[0x20],r5
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
8001b00e:	ef 35 00 72 	ld.ub	r5,r7[114]
8001b012:	b1 65       	lsl	r5,0x10
8001b014:	ef 34 00 73 	ld.ub	r4,r7[115]
8001b018:	b9 64       	lsl	r4,0x18
8001b01a:	0a 04       	add	r4,r5
8001b01c:	ef 35 00 70 	ld.ub	r5,r7[112]
8001b020:	0a 04       	add	r4,r5
8001b022:	ef 35 00 71 	ld.ub	r5,r7[113]
8001b026:	a9 65       	lsl	r5,0x8
8001b028:	e8 05 00 05 	add	r5,r4,r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8001b02c:	ef 13 00 28 	ld.uh	r3,r7[40]
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8001b030:	ef 34 00 74 	ld.ub	r4,r7[116]
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
8001b034:	8f 25       	st.w	r7[0x8],r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8001b036:	a5 73       	lsl	r3,0x5
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8001b038:	ef 35 00 75 	ld.ub	r5,r7[117]

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8001b03c:	e6 c3 fe 01 	sub	r3,r3,-511
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8001b040:	a9 65       	lsl	r5,0x8

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8001b042:	a9 53       	asr	r3,0x9
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8001b044:	e8 05 00 05 	add	r5,r4,r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8001b048:	8f 43       	st.w	r7[0x10],r3
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8001b04a:	ef 55 00 18 	st.h	r7[24],r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
8001b04e:	6e 84       	ld.w	r4,r7[0x20]
8001b050:	f8 05 15 08 	lsl	r5,r12,0x8
8001b054:	fc 04 02 44 	mul	r4,lr,r4
8001b058:	16 05       	add	r5,r11
8001b05a:	5c 75       	castu.h	r5
8001b05c:	ea 04 00 03 	add	r3,r5,r4
8001b060:	8f 33       	st.w	r7[0xc],r3
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
8001b062:	6e 73       	ld.w	r3,r7[0x1c]
8001b064:	06 05       	add	r5,r3

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
8001b066:	ea 04 00 04 	add	r4,r5,r4
    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
8001b06a:	8f 55       	st.w	r7[0x14],r5

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
8001b06c:	8f 14       	st.w	r7[0x4],r4

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
8001b06e:	ef 35 02 42 	ld.ub	r5,r7[578]
8001b072:	ef 34 02 43 	ld.ub	r4,r7[579]
8001b076:	a9 64       	lsl	r4,0x8
8001b078:	e8 05 00 05 	add	r5,r4,r5
8001b07c:	e0 45 aa 55 	cp.w	r5,43605
8001b080:	fe 91 ff 53 	brne	8001af26 <fatfs_init+0x3a>
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001b084:	a9 69       	lsl	r9,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8001b086:	ef 33 00 56 	ld.ub	r3,r7[86]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001b08a:	f2 08 00 05 	add	r5,r9,r8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8001b08e:	ef 34 00 55 	ld.ub	r4,r7[85]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8001b092:	c0 f1       	brne	8001b0b0 <fatfs_init+0x1c4>
        FATSz = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);  
8001b094:	ef 38 00 6a 	ld.ub	r8,r7[106]
8001b098:	b1 68       	lsl	r8,0x10
8001b09a:	ef 35 00 6b 	ld.ub	r5,r7[107]
8001b09e:	b9 65       	lsl	r5,0x18
8001b0a0:	10 05       	add	r5,r8
8001b0a2:	ef 38 00 68 	ld.ub	r8,r7[104]
8001b0a6:	10 05       	add	r5,r8
8001b0a8:	ef 38 00 69 	ld.ub	r8,r7[105]
8001b0ac:	a9 68       	lsl	r8,0x8
8001b0ae:	10 05       	add	r5,r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16) != 0)
8001b0b0:	ef 39 00 58 	ld.ub	r9,r7[88]
8001b0b4:	ef 38 00 57 	ld.ub	r8,r7[87]
8001b0b8:	a9 69       	lsl	r9,0x8
8001b0ba:	10 09       	add	r9,r8
8001b0bc:	c0 f1       	brne	8001b0da <fatfs_init+0x1ee>
        total_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16);
    else
        total_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_TOTSEC32);
8001b0be:	ef 38 00 66 	ld.ub	r8,r7[102]
8001b0c2:	b1 68       	lsl	r8,0x10
8001b0c4:	ef 39 00 67 	ld.ub	r9,r7[103]
8001b0c8:	b9 69       	lsl	r9,0x18
8001b0ca:	10 09       	add	r9,r8
8001b0cc:	ef 38 00 64 	ld.ub	r8,r7[100]
8001b0d0:	10 09       	add	r9,r8
8001b0d2:	ef 38 00 65 	ld.ub	r8,r7[101]
8001b0d6:	a9 68       	lsl	r8,0x8
8001b0d8:	10 09       	add	r9,r8

    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
8001b0da:	0f 88       	ld.ub	r8,r7[0x0]
8001b0dc:	58 08       	cp.w	r8,0
8001b0de:	c0 41       	brne	8001b0e6 <fatfs_init+0x1fa>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8001b0e0:	3f bc       	mov	r12,-5
        }
    }
    else
        return FAT_INIT_WRONG_FILESYS_TYPE;    
}
8001b0e2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8001b0e6:	a9 6c       	lsl	r12,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8001b0e8:	a9 66       	lsl	r6,0x8
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8001b0ea:	a9 63       	lsl	r3,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8001b0ec:	ec 0a 00 0a 	add	r10,r6,r10
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
8001b0f0:	e6 04 00 04 	add	r4,r3,r4
8001b0f4:	ea 0e 02 4e 	mul	lr,r5,lr
8001b0f8:	f8 0b 00 0b 	add	r11,r12,r11
8001b0fc:	f4 c5 00 01 	sub	r5,r10,1
8001b100:	e8 0c 15 05 	lsl	r12,r4,0x5
8001b104:	18 05       	add	r5,r12
8001b106:	ea 0a 0c 04 	divs	r4,r5,r10
8001b10a:	e8 0a 11 00 	rsub	r10,r4,0
8001b10e:	16 1a       	sub	r10,r11
8001b110:	1c 1a       	sub	r10,lr
8001b112:	f4 09 00 09 	add	r9,r10,r9
8001b116:	f2 08 0d 08 	divu	r8,r9,r8

        if(count_of_clusters < 4085) 
8001b11a:	e0 48 0f f4 	cp.w	r8,4084
8001b11e:	fe 98 ff e1 	brls	8001b0e0 <fatfs_init+0x1f4>
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
8001b122:	e0 48 ff f4 	cp.w	r8,65524
8001b126:	f9 bc 08 00 	movls	r12,0

            // Volume is FAT16
            fs->fat_type = FAT_TYPE_16;
8001b12a:	ef fc 8a 0c 	st.wls	r7[0x30],r12
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
8001b12e:	ef fc 8a 02 	st.wls	r7[0x8],r12
            return FAT_INIT_OK;
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
8001b132:	f9 b8 0b 01 	movhi	r8,1
8001b136:	ef f8 ba 0c 	st.whi	r7[0x30],r8
8001b13a:	f9 bc 0b 00 	movhi	r12,0
            return FAT_INIT_OK;
8001b13e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8001b142:	d7 03       	nop

8001b144 <T.41>:
8001b144:	eb cd 40 f8 	pushm	r3-r7,lr
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001b148:	58 0b       	cp.w	r11,0
8001b14a:	5f 09       	sreq	r9
8001b14c:	78 c8       	ld.w	r8,r12[0x30]
}
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
8001b14e:	18 97       	mov	r7,r12
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001b150:	58 08       	cp.w	r8,0
8001b152:	5f 08       	sreq	r8
}
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
8001b154:	14 94       	mov	r4,r10
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001b156:	f3 e8 00 08 	and	r8,r9,r8
8001b15a:	c0 f0       	breq	8001b178 <T.41+0x34>
    {
        if (offset < fs->rootdir_sectors)
8001b15c:	78 48       	ld.w	r8,r12[0x10]
8001b15e:	14 38       	cp.w	r8,r10
8001b160:	e0 88 00 1d 	brls	8001b19a <T.41+0x56>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8001b164:	6e 78       	ld.w	r8,r7[0x1c]
8001b166:	78 3c       	ld.w	r12,r12[0xc]
8001b168:	10 0c       	add	r12,r8

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001b16a:	ee f8 02 44 	ld.w	r8,r7[580]

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
    {
        if (offset < fs->rootdir_sectors)
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8001b16e:	14 0c       	add	r12,r10

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001b170:	10 3c       	cp.w	r12,r8
8001b172:	c2 01       	brne	8001b1b2 <T.41+0x6e>
8001b174:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
8001b178:	19 83       	ld.ub	r3,r12[0x0]
8001b17a:	f4 03 0d 08 	divu	r8,r10,r3
8001b17e:	10 95       	mov	r5,r8
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001b180:	58 08       	cp.w	r8,0
8001b182:	c0 a0       	breq	8001b196 <T.41+0x52>
8001b184:	30 06       	mov	r6,0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8001b186:	0e 9c       	mov	r12,r7
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001b188:	2f f6       	sub	r6,-1
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8001b18a:	e0 a0 12 a7 	rcall	8001d6d8 <fatfs_find_next_cluster>
8001b18e:	18 9b       	mov	r11,r12
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001b190:	0c 35       	cp.w	r5,r6
8001b192:	fe 9b ff fa 	brhi	8001b186 <T.41+0x42>
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
8001b196:	5b fb       	cp.w	r11,-1
8001b198:	c0 31       	brne	8001b19e <T.41+0x5a>
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
    {
        fs->currentsector.address = lba;
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001b19a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8001b19e:	0e 9c       	mov	r12,r7
8001b1a0:	c7 ee       	rcall	8001ae9c <fatfs_lba_of_cluster>
8001b1a2:	a7 35       	mul	r5,r3
8001b1a4:	ee f8 02 44 	ld.w	r8,r7[580]

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001b1a8:	0a 14       	sub	r4,r5
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8001b1aa:	e8 0c 00 0c 	add	r12,r4,r12
8001b1ae:	10 3c       	cp.w	r12,r8

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001b1b0:	ce 20       	breq	8001b174 <T.41+0x30>
8001b1b2:	ef 4c 02 44 	st.w	r7[580],r12
    {
        fs->currentsector.address = lba;
8001b1b6:	ee cb ff bc 	sub	r11,r7,-68
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001b1ba:	6e d8       	ld.w	r8,r7[0x34]
8001b1bc:	30 1a       	mov	r10,1
8001b1be:	5d 18       	icall	r8
8001b1c0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8001b1c4 <fatfs_get_file_entry>:
8001b1c4:	d4 31       	pushm	r0-r7,lr
8001b1c6:	fa cd 01 28 	sub	sp,sp,296
8001b1ca:	18 97       	mov	r7,r12
8001b1cc:	50 1b       	stdsp	sp[0x4],r11
8001b1ce:	14 96       	mov	r6,r10
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
8001b1d0:	30 1b       	mov	r11,1
}
//-------------------------------------------------------------
// fatfs_get_file_entry: Find the file entry for a filename
//-------------------------------------------------------------
uint32 fatfs_get_file_entry(struct fatfs *fs, uint32 Cluster, char *name_to_find, struct fat_dir_entry *sfEntry)
{
8001b1d2:	50 39       	stdsp	sp[0xc],r9
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
8001b1d4:	fa c5 ff ee 	sub	r5,sp,-18
8001b1d8:	0a 9c       	mov	r12,r5
8001b1da:	e0 a0 0c bc 	rcall	8001cb52 <fatfs_lfn_cache_init>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b1de:	ee cb ff bc 	sub	r11,r7,-68
8001b1e2:	30 04       	mov	r4,0
8001b1e4:	50 2b       	stdsp	sp[0x8],r11
8001b1e6:	08 9a       	mov	r10,r4

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8001b1e8:	40 1b       	lddsp	r11,sp[0x4]
8001b1ea:	2f f4       	sub	r4,-1
8001b1ec:	0e 9c       	mov	r12,r7
8001b1ee:	ca bf       	rcall	8001b144 <T.41>
8001b1f0:	e0 80 00 90 	breq	8001b310 <fatfs_get_file_entry+0x14c>
8001b1f4:	40 23       	lddsp	r3,sp[0x8]
8001b1f6:	30 02       	mov	r2,0
8001b1f8:	32 01       	mov	r1,32
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
8001b1fa:	32 e0       	mov	r0,46

                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
8001b1fc:	c0 d8       	rjmp	8001b216 <fatfs_get_file_entry+0x52>
8001b1fe:	e4 cb ff bc 	sub	r11,r2,-68
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
8001b202:	0a 9c       	mov	r12,r5
8001b204:	ee 0b 00 0b 	add	r11,r7,r11
8001b208:	e0 a0 0a d8 	rcall	8001c7b8 <fatfs_lfn_cache_entry>
8001b20c:	2e 03       	sub	r3,-32
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8001b20e:	2e 02       	sub	r2,-32
8001b210:	e0 42 02 00 	cp.w	r2,512
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8001b214:	ce 90       	breq	8001b1e6 <fatfs_get_file_entry+0x22>
8001b216:	06 9c       	mov	r12,r3
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b218:	e0 a0 0b b7 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b21c:	18 9b       	mov	r11,r12
8001b21e:	cf 01       	brne	8001b1fe <fatfs_get_file_entry+0x3a>
8001b220:	50 0b       	stdsp	sp[0x0],r11
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b222:	06 9c       	mov	r12,r3
8001b224:	e0 a0 0b b8 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b228:	40 0b       	lddsp	r11,sp[0x0]
8001b22a:	c6 01       	brne	8001b2ea <fatfs_get_file_entry+0x126>
8001b22c:	06 9b       	mov	r11,r3
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists 
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) ) 
8001b22e:	0a 9c       	mov	r12,r5
8001b230:	e0 a0 0b cb 	rcall	8001c9c6 <fatfs_entry_lfn_exists>
8001b234:	18 98       	mov	r8,r12
8001b236:	c0 d0       	breq	8001b250 <fatfs_get_file_entry+0x8c>
8001b238:	0a 9c       	mov	r12,r5
                {
                    long_filename = fatfs_lfn_cache_get(&lfn);
8001b23a:	e0 a0 0b 8f 	rcall	8001c958 <fatfs_lfn_cache_get>
8001b23e:	0c 9b       	mov	r11,r6

                    // Compare names to see if they match
                    if (fatfs_compare_names(long_filename, name_to_find)) 
8001b240:	e0 a0 0f c0 	rcall	8001d1c0 <fatfs_compare_names>
8001b244:	c6 01       	brne	8001b304 <fatfs_get_file_entry+0x140>
8001b246:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8001b248:	0a 9c       	mov	r12,r5
8001b24a:	e0 a0 0c 84 	rcall	8001cb52 <fatfs_lfn_cache_init>
8001b24e:	cd fb       	rjmp	8001b20c <fatfs_get_file_entry+0x48>
8001b250:	50 08       	stdsp	sp[0x0],r8
                }                 
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b252:	06 9c       	mov	r12,r3
8001b254:	e0 a0 0b d4 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b258:	40 08       	lddsp	r8,sp[0x0]
8001b25a:	cd 90       	breq	8001b20c <fatfs_get_file_entry+0x48>
8001b25c:	30 0a       	mov	r10,0
                {
                    memset(short_filename, 0, sizeof(short_filename));
8001b25e:	30 0b       	mov	r11,0
8001b260:	fa eb 01 18 	st.d	sp[280],r10
8001b264:	54 88       	stdsp	sp[0x120],r8
8001b266:	fb 68 01 24 	st.b	sp[292],r8
8001b26a:	07 88       	ld.ub	r8,r3[0x0]

                    // Copy name to string
                    for (i=0; i<8; i++) 
                        short_filename[i] = directoryEntry->Name[i];
8001b26c:	fb 68 01 18 	st.b	sp[280],r8
8001b270:	07 99       	ld.ub	r9,r3[0x1]
8001b272:	fb 69 01 19 	st.b	sp[281],r9
8001b276:	07 a9       	ld.ub	r9,r3[0x2]
8001b278:	fb 69 01 1a 	st.b	sp[282],r9
8001b27c:	07 b9       	ld.ub	r9,r3[0x3]
8001b27e:	fb 69 01 1b 	st.b	sp[283],r9
8001b282:	07 c9       	ld.ub	r9,r3[0x4]
8001b284:	fb 69 01 1c 	st.b	sp[284],r9
8001b288:	07 d9       	ld.ub	r9,r3[0x5]
8001b28a:	fb 69 01 1d 	st.b	sp[285],r9
8001b28e:	07 e9       	ld.ub	r9,r3[0x6]
8001b290:	fb 69 01 1e 	st.b	sp[286],r9
8001b294:	07 f9       	ld.ub	r9,r3[0x7]
8001b296:	fb 69 01 1f 	st.b	sp[287],r9
8001b29a:	e7 39 00 08 	ld.ub	r9,r3[8]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8001b29e:	fb 69 01 21 	st.b	sp[289],r9
8001b2a2:	e7 39 00 09 	ld.ub	r9,r3[9]
8001b2a6:	e7 3a 00 08 	ld.ub	r10,r3[8]
                        if (directoryEntry->Name[i] != ' ')
8001b2aa:	fb 69 01 22 	st.b	sp[290],r9

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8001b2ae:	e7 39 00 09 	ld.ub	r9,r3[9]
                        if (directoryEntry->Name[i] != ' ')
8001b2b2:	e2 09 18 00 	cp.b	r9,r1
8001b2b6:	c1 e0       	breq	8001b2f2 <fatfs_get_file_entry+0x12e>
8001b2b8:	30 1b       	mov	r11,1
8001b2ba:	e7 39 00 0a 	ld.ub	r9,r3[10]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
8001b2be:	fb 69 01 23 	st.b	sp[291],r9
8001b2c2:	e7 39 00 0a 	ld.ub	r9,r3[10]
                        if (directoryEntry->Name[i] != ' ')
8001b2c6:	e2 09 18 00 	cp.b	r9,r1
8001b2ca:	c1 80       	breq	8001b2fa <fatfs_get_file_entry+0x136>
8001b2cc:	f0 00 18 00 	cp.b	r0,r8
                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
                            short_filename[8] = '.';
8001b2d0:	e2 09 17 00 	moveq	r9,r1
8001b2d4:	e0 09 17 10 	movne	r9,r0
8001b2d8:	fb 69 01 20 	st.b	sp[288],r9
8001b2dc:	0c 9b       	mov	r11,r6
                    }
                    else
                        short_filename[8] = ' ';
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
8001b2de:	fa cc fe e8 	sub	r12,sp,-280
8001b2e2:	e0 a0 0f 6f 	rcall	8001d1c0 <fatfs_compare_names>
8001b2e6:	c0 f1       	brne	8001b304 <fatfs_get_file_entry+0x140>
8001b2e8:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
8001b2ea:	0a 9c       	mov	r12,r5
8001b2ec:	e0 a0 0c 33 	rcall	8001cb52 <fatfs_lfn_cache_init>
8001b2f0:	c8 eb       	rjmp	8001b20c <fatfs_get_file_entry+0x48>
8001b2f2:	e2 0a 18 00 	cp.b	r10,r1
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
8001b2f6:	5f 1b       	srne	r11
8001b2f8:	ce 1b       	rjmp	8001b2ba <fatfs_get_file_entry+0xf6>
8001b2fa:	58 0b       	cp.w	r11,0
                            dotRequired = 1;
                    }

                    // Dot only required if extension present
                    if (dotRequired)
8001b2fc:	ce 81       	brne	8001b2cc <fatfs_get_file_entry+0x108>
8001b2fe:	fb 69 01 20 	st.b	sp[288],r9
                            short_filename[8] = '.';
                        else
                            short_filename[8] = ' ';
                    }
                    else
                        short_filename[8] = ' ';
8001b302:	ce db       	rjmp	8001b2dc <fatfs_get_file_entry+0x118>
8001b304:	06 9b       	mov	r11,r3
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
8001b306:	40 3c       	lddsp	r12,sp[0xc]
8001b308:	32 0a       	mov	r10,32
8001b30a:	e0 a0 41 db 	rcall	800236c0 <memcpy>
8001b30e:	30 1c       	mov	r12,1
8001b310:	2b 6d       	sub	sp,-296
        else
            break;
    } // End of while loop

    return 0;
}
8001b312:	d8 32       	popm	r0-r7,pc

8001b314 <fatfs_sfn_exists>:
8001b314:	d4 31       	pushm	r0-r7,lr
8001b316:	20 6d       	sub	sp,24
8001b318:	f8 c8 fe fc 	sub	r8,r12,-260
8001b31c:	50 18       	stdsp	sp[0x4],r8
8001b31e:	f8 c8 fe dc 	sub	r8,r12,-292
8001b322:	18 95       	mov	r5,r12
8001b324:	50 28       	stdsp	sp[0x8],r8
8001b326:	50 4b       	stdsp	sp[0x10],r11
8001b328:	f8 c8 fe bc 	sub	r8,r12,-324
8001b32c:	50 5a       	stdsp	sp[0x14],r10
8001b32e:	f8 c7 ff bc 	sub	r7,r12,-68
8001b332:	30 06       	mov	r6,0
8001b334:	f8 c2 ff 9c 	sub	r2,r12,-100
8001b338:	f8 c3 ff 7c 	sub	r3,r12,-132
8001b33c:	f8 c4 ff 5c 	sub	r4,r12,-164
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b340:	f8 c1 ff 3c 	sub	r1,r12,-196
8001b344:	f8 c0 ff 1c 	sub	r0,r12,-228
8001b348:	50 38       	stdsp	sp[0xc],r8
8001b34a:	0c 9a       	mov	r10,r6

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8001b34c:	40 4b       	lddsp	r11,sp[0x10]
8001b34e:	2f f6       	sub	r6,-1
8001b350:	0a 9c       	mov	r12,r5
8001b352:	cf 9e       	rcall	8001b144 <T.41>
8001b354:	c7 10       	breq	8001b436 <fatfs_sfn_exists+0x122>
8001b356:	0e 9c       	mov	r12,r7
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b358:	e0 a0 0b 17 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b35c:	e0 80 00 fd 	breq	8001b556 <fatfs_sfn_exists+0x242>
8001b360:	04 9c       	mov	r12,r2
8001b362:	e0 a0 0b 12 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b366:	e0 80 00 e5 	breq	8001b530 <fatfs_sfn_exists+0x21c>
8001b36a:	06 9c       	mov	r12,r3
8001b36c:	e0 a0 0b 0d 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b370:	e0 80 00 cd 	breq	8001b50a <fatfs_sfn_exists+0x1f6>
8001b374:	08 9c       	mov	r12,r4
8001b376:	e0 a0 0b 08 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b37a:	e0 80 00 b5 	breq	8001b4e4 <fatfs_sfn_exists+0x1d0>
8001b37e:	02 9c       	mov	r12,r1
8001b380:	e0 a0 0b 03 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b384:	e0 80 00 9d 	breq	8001b4be <fatfs_sfn_exists+0x1aa>
8001b388:	00 9c       	mov	r12,r0
8001b38a:	e0 a0 0a fe 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b38e:	e0 80 00 85 	breq	8001b498 <fatfs_sfn_exists+0x184>
8001b392:	40 1c       	lddsp	r12,sp[0x4]
8001b394:	e0 a0 0a f9 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b398:	c7 00       	breq	8001b478 <fatfs_sfn_exists+0x164>
8001b39a:	40 2c       	lddsp	r12,sp[0x8]
8001b39c:	e0 a0 0a f5 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3a0:	c5 c0       	breq	8001b458 <fatfs_sfn_exists+0x144>
8001b3a2:	40 3c       	lddsp	r12,sp[0xc]
8001b3a4:	e0 a0 0a f1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3a8:	c4 90       	breq	8001b43a <fatfs_sfn_exists+0x126>
8001b3aa:	ee c8 fe e0 	sub	r8,r7,-288
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3ae:	50 08       	stdsp	sp[0x0],r8
8001b3b0:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b3b2:	e0 a0 0a ea 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3b6:	e0 80 00 f5 	breq	8001b5a0 <fatfs_sfn_exists+0x28c>
8001b3ba:	ee c8 fe c0 	sub	r8,r7,-320
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3be:	50 08       	stdsp	sp[0x0],r8
8001b3c0:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b3c2:	e0 a0 0a e2 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3c6:	e0 80 00 db 	breq	8001b57c <fatfs_sfn_exists+0x268>
8001b3ca:	ee c8 fe a0 	sub	r8,r7,-352
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3ce:	50 08       	stdsp	sp[0x0],r8
8001b3d0:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b3d2:	e0 a0 0a da 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3d6:	e0 80 01 31 	breq	8001b638 <fatfs_sfn_exists+0x324>
8001b3da:	ee c8 fe 80 	sub	r8,r7,-384
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3de:	50 08       	stdsp	sp[0x0],r8
8001b3e0:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b3e2:	e0 a0 0a d2 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3e6:	e0 80 01 16 	breq	8001b612 <fatfs_sfn_exists+0x2fe>
8001b3ea:	ee c8 fe 60 	sub	r8,r7,-416
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3ee:	50 08       	stdsp	sp[0x0],r8
8001b3f0:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b3f2:	e0 a0 0a ca 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b3f6:	e0 80 00 fb 	breq	8001b5ec <fatfs_sfn_exists+0x2d8>
8001b3fa:	ee c8 fe 40 	sub	r8,r7,-448
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b3fe:	50 08       	stdsp	sp[0x0],r8
8001b400:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b402:	e0 a0 0a c2 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b406:	e0 80 00 e0 	breq	8001b5c6 <fatfs_sfn_exists+0x2b2>
8001b40a:	ee c8 fe 20 	sub	r8,r7,-480
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b40e:	50 08       	stdsp	sp[0x0],r8
8001b410:	10 9c       	mov	r12,r8

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b412:	e0 a0 0a ba 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b416:	c9 a1       	brne	8001b34a <fatfs_sfn_exists+0x36>
8001b418:	40 0c       	lddsp	r12,sp[0x0]
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b41a:	e0 a0 0a bd 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b41e:	c9 61       	brne	8001b34a <fatfs_sfn_exists+0x36>
8001b420:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b422:	e0 a0 0a ed 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b426:	c9 20       	breq	8001b34a <fatfs_sfn_exists+0x36>
8001b428:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b42a:	30 ba       	mov	r10,11
8001b42c:	40 5b       	lddsp	r11,sp[0x14]
8001b42e:	e0 a0 42 66 	rcall	800238fa <strncmp>
8001b432:	c8 c1       	brne	8001b34a <fatfs_sfn_exists+0x36>
8001b434:	30 1c       	mov	r12,1
8001b436:	2f ad       	sub	sp,-24
        else
            break;
    } // End of while loop

    return 0;
}
8001b438:	d8 32       	popm	r0-r7,pc
8001b43a:	40 3c       	lddsp	r12,sp[0xc]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b43c:	e0 a0 0a ac 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b440:	cb 51       	brne	8001b3aa <fatfs_sfn_exists+0x96>
8001b442:	40 3c       	lddsp	r12,sp[0xc]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b444:	e0 a0 0a dc 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b448:	cb 10       	breq	8001b3aa <fatfs_sfn_exists+0x96>
8001b44a:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b44c:	40 5b       	lddsp	r11,sp[0x14]
8001b44e:	40 3c       	lddsp	r12,sp[0xc]
8001b450:	e0 a0 42 55 	rcall	800238fa <strncmp>
8001b454:	ca b1       	brne	8001b3aa <fatfs_sfn_exists+0x96>
8001b456:	ce fb       	rjmp	8001b434 <fatfs_sfn_exists+0x120>
8001b458:	40 2c       	lddsp	r12,sp[0x8]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b45a:	e0 a0 0a 9d 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b45e:	ca 21       	brne	8001b3a2 <fatfs_sfn_exists+0x8e>
8001b460:	40 2c       	lddsp	r12,sp[0x8]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b462:	e0 a0 0a cd 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b466:	c9 e0       	breq	8001b3a2 <fatfs_sfn_exists+0x8e>
8001b468:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b46a:	40 5b       	lddsp	r11,sp[0x14]
8001b46c:	40 2c       	lddsp	r12,sp[0x8]
8001b46e:	e0 a0 42 46 	rcall	800238fa <strncmp>
8001b472:	c9 81       	brne	8001b3a2 <fatfs_sfn_exists+0x8e>
8001b474:	30 1c       	mov	r12,1
8001b476:	ce 0b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b478:	40 1c       	lddsp	r12,sp[0x4]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b47a:	e0 a0 0a 8d 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b47e:	c8 e1       	brne	8001b39a <fatfs_sfn_exists+0x86>
8001b480:	40 1c       	lddsp	r12,sp[0x4]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b482:	e0 a0 0a bd 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b486:	c8 a0       	breq	8001b39a <fatfs_sfn_exists+0x86>
8001b488:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b48a:	40 5b       	lddsp	r11,sp[0x14]
8001b48c:	40 1c       	lddsp	r12,sp[0x4]
8001b48e:	e0 a0 42 36 	rcall	800238fa <strncmp>
8001b492:	c8 41       	brne	8001b39a <fatfs_sfn_exists+0x86>
8001b494:	30 1c       	mov	r12,1
8001b496:	cd 0b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b498:	00 9c       	mov	r12,r0
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b49a:	e0 a0 0a 7d 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b49e:	fe 91 ff 7a 	brne	8001b392 <fatfs_sfn_exists+0x7e>
8001b4a2:	00 9c       	mov	r12,r0
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b4a4:	e0 a0 0a ac 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b4a8:	fe 90 ff 75 	breq	8001b392 <fatfs_sfn_exists+0x7e>
8001b4ac:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b4ae:	40 5b       	lddsp	r11,sp[0x14]
8001b4b0:	00 9c       	mov	r12,r0
8001b4b2:	e0 a0 42 24 	rcall	800238fa <strncmp>
8001b4b6:	fe 91 ff 6e 	brne	8001b392 <fatfs_sfn_exists+0x7e>
8001b4ba:	30 1c       	mov	r12,1
8001b4bc:	cb db       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b4be:	02 9c       	mov	r12,r1
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b4c0:	e0 a0 0a 6a 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b4c4:	fe 91 ff 62 	brne	8001b388 <fatfs_sfn_exists+0x74>
8001b4c8:	02 9c       	mov	r12,r1
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b4ca:	e0 a0 0a 99 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b4ce:	fe 90 ff 5d 	breq	8001b388 <fatfs_sfn_exists+0x74>
8001b4d2:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b4d4:	40 5b       	lddsp	r11,sp[0x14]
8001b4d6:	02 9c       	mov	r12,r1
8001b4d8:	e0 a0 42 11 	rcall	800238fa <strncmp>
8001b4dc:	fe 91 ff 56 	brne	8001b388 <fatfs_sfn_exists+0x74>
8001b4e0:	30 1c       	mov	r12,1
8001b4e2:	ca ab       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b4e4:	08 9c       	mov	r12,r4
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b4e6:	e0 a0 0a 57 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b4ea:	fe 91 ff 4a 	brne	8001b37e <fatfs_sfn_exists+0x6a>
8001b4ee:	08 9c       	mov	r12,r4
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b4f0:	e0 a0 0a 86 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b4f4:	fe 90 ff 45 	breq	8001b37e <fatfs_sfn_exists+0x6a>
8001b4f8:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b4fa:	40 5b       	lddsp	r11,sp[0x14]
8001b4fc:	08 9c       	mov	r12,r4
8001b4fe:	e0 a0 41 fe 	rcall	800238fa <strncmp>
8001b502:	fe 91 ff 3e 	brne	8001b37e <fatfs_sfn_exists+0x6a>
8001b506:	30 1c       	mov	r12,1
8001b508:	c9 7b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b50a:	06 9c       	mov	r12,r3
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b50c:	e0 a0 0a 44 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b510:	fe 91 ff 32 	brne	8001b374 <fatfs_sfn_exists+0x60>
8001b514:	06 9c       	mov	r12,r3
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b516:	e0 a0 0a 73 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b51a:	fe 90 ff 2d 	breq	8001b374 <fatfs_sfn_exists+0x60>
8001b51e:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b520:	40 5b       	lddsp	r11,sp[0x14]
8001b522:	06 9c       	mov	r12,r3
8001b524:	e0 a0 41 eb 	rcall	800238fa <strncmp>
8001b528:	fe 91 ff 26 	brne	8001b374 <fatfs_sfn_exists+0x60>
8001b52c:	30 1c       	mov	r12,1
8001b52e:	c8 4b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b530:	04 9c       	mov	r12,r2
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b532:	e0 a0 0a 31 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b536:	fe 91 ff 1a 	brne	8001b36a <fatfs_sfn_exists+0x56>
8001b53a:	04 9c       	mov	r12,r2
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b53c:	e0 a0 0a 60 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b540:	fe 90 ff 15 	breq	8001b36a <fatfs_sfn_exists+0x56>
8001b544:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b546:	40 5b       	lddsp	r11,sp[0x14]
8001b548:	04 9c       	mov	r12,r2
8001b54a:	e0 a0 41 d8 	rcall	800238fa <strncmp>
8001b54e:	fe 91 ff 0e 	brne	8001b36a <fatfs_sfn_exists+0x56>
8001b552:	30 1c       	mov	r12,1
8001b554:	c7 1b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b556:	0e 9c       	mov	r12,r7
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b558:	e0 a0 0a 1e 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b55c:	fe 91 ff 02 	brne	8001b360 <fatfs_sfn_exists+0x4c>
8001b560:	0e 9c       	mov	r12,r7
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b562:	e0 a0 0a 4d 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b566:	fe 90 fe fd 	breq	8001b360 <fatfs_sfn_exists+0x4c>
8001b56a:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b56c:	40 5b       	lddsp	r11,sp[0x14]
8001b56e:	0e 9c       	mov	r12,r7
8001b570:	e0 a0 41 c5 	rcall	800238fa <strncmp>
8001b574:	fe 91 fe f6 	brne	8001b360 <fatfs_sfn_exists+0x4c>
8001b578:	30 1c       	mov	r12,1
8001b57a:	c5 eb       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b57c:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b57e:	e0 a0 0a 0b 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b582:	fe 91 ff 24 	brne	8001b3ca <fatfs_sfn_exists+0xb6>
8001b586:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b588:	e0 a0 0a 3a 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b58c:	fe 90 ff 1f 	breq	8001b3ca <fatfs_sfn_exists+0xb6>
8001b590:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b592:	30 ba       	mov	r10,11
8001b594:	40 5b       	lddsp	r11,sp[0x14]
8001b596:	e0 a0 41 b2 	rcall	800238fa <strncmp>
8001b59a:	fe 91 ff 18 	brne	8001b3ca <fatfs_sfn_exists+0xb6>
8001b59e:	c4 bb       	rjmp	8001b434 <fatfs_sfn_exists+0x120>
8001b5a0:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b5a2:	e0 a0 09 f9 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b5a6:	fe 91 ff 0a 	brne	8001b3ba <fatfs_sfn_exists+0xa6>
8001b5aa:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b5ac:	e0 a0 0a 28 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b5b0:	fe 90 ff 05 	breq	8001b3ba <fatfs_sfn_exists+0xa6>
8001b5b4:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b5b6:	30 ba       	mov	r10,11
8001b5b8:	40 5b       	lddsp	r11,sp[0x14]
8001b5ba:	e0 a0 41 a0 	rcall	800238fa <strncmp>
8001b5be:	fe 91 fe fe 	brne	8001b3ba <fatfs_sfn_exists+0xa6>
8001b5c2:	30 1c       	mov	r12,1
8001b5c4:	c3 9b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b5c6:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b5c8:	e0 a0 09 e6 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b5cc:	fe 91 ff 1f 	brne	8001b40a <fatfs_sfn_exists+0xf6>
8001b5d0:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b5d2:	e0 a0 0a 15 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b5d6:	fe 90 ff 1a 	breq	8001b40a <fatfs_sfn_exists+0xf6>
8001b5da:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b5dc:	30 ba       	mov	r10,11
8001b5de:	40 5b       	lddsp	r11,sp[0x14]
8001b5e0:	e0 a0 41 8d 	rcall	800238fa <strncmp>
8001b5e4:	fe 91 ff 13 	brne	8001b40a <fatfs_sfn_exists+0xf6>
8001b5e8:	30 1c       	mov	r12,1
8001b5ea:	c2 6b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b5ec:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b5ee:	e0 a0 09 d3 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b5f2:	fe 91 ff 04 	brne	8001b3fa <fatfs_sfn_exists+0xe6>
8001b5f6:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b5f8:	e0 a0 0a 02 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b5fc:	fe 90 fe ff 	breq	8001b3fa <fatfs_sfn_exists+0xe6>
8001b600:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b602:	30 ba       	mov	r10,11
8001b604:	40 5b       	lddsp	r11,sp[0x14]
8001b606:	e0 a0 41 7a 	rcall	800238fa <strncmp>
8001b60a:	fe 91 fe f8 	brne	8001b3fa <fatfs_sfn_exists+0xe6>
8001b60e:	30 1c       	mov	r12,1
8001b610:	c1 3b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b612:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b614:	e0 a0 09 c0 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b618:	fe 91 fe e9 	brne	8001b3ea <fatfs_sfn_exists+0xd6>
8001b61c:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b61e:	e0 a0 09 ef 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b622:	fe 90 fe e4 	breq	8001b3ea <fatfs_sfn_exists+0xd6>
8001b626:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b628:	30 ba       	mov	r10,11
8001b62a:	40 5b       	lddsp	r11,sp[0x14]
8001b62c:	e0 a0 41 67 	rcall	800238fa <strncmp>
8001b630:	fe 91 fe dd 	brne	8001b3ea <fatfs_sfn_exists+0xd6>
8001b634:	30 1c       	mov	r12,1
8001b636:	c0 0b       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b638:	40 0c       	lddsp	r12,sp[0x0]
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b63a:	e0 a0 09 ad 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b63e:	fe 91 fe ce 	brne	8001b3da <fatfs_sfn_exists+0xc6>
8001b642:	40 0c       	lddsp	r12,sp[0x0]
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b644:	e0 a0 09 dc 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b648:	fe 90 fe c9 	breq	8001b3da <fatfs_sfn_exists+0xc6>
8001b64c:	40 0c       	lddsp	r12,sp[0x0]
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b64e:	30 ba       	mov	r10,11
8001b650:	40 5b       	lddsp	r11,sp[0x14]
8001b652:	e0 a0 41 54 	rcall	800238fa <strncmp>
8001b656:	fe 91 fe c2 	brne	8001b3da <fatfs_sfn_exists+0xc6>
8001b65a:	30 1c       	mov	r12,1
8001b65c:	ce da       	rjmp	8001b436 <fatfs_sfn_exists+0x122>
8001b65e:	d7 03       	nop

8001b660 <fatfs_update_file_length>:
8001b660:	d4 31       	pushm	r0-r7,lr
8001b662:	20 8d       	sub	sp,32
8001b664:	50 4b       	stdsp	sp[0x10],r11
8001b666:	50 5a       	stdsp	sp[0x14],r10
8001b668:	50 79       	stdsp	sp[0x1c],r9
8001b66a:	18 97       	mov	r7,r12
8001b66c:	78 e8       	ld.w	r8,r12[0x38]
8001b66e:	58 08       	cp.w	r8,0
8001b670:	e0 80 01 f4 	breq	8001ba58 <fatfs_update_file_length+0x3f8>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b674:	f8 ce ff 1c 	sub	lr,r12,-228
8001b678:	f8 c6 ff bc 	sub	r6,r12,-68
8001b67c:	50 0e       	stdsp	sp[0x0],lr
8001b67e:	f8 c9 fe fc 	sub	r9,r12,-260
8001b682:	f8 c8 fe dc 	sub	r8,r12,-292
8001b686:	f8 ce fe bc 	sub	lr,r12,-324
8001b68a:	30 05       	mov	r5,0
8001b68c:	50 66       	stdsp	sp[0x18],r6
8001b68e:	f8 c2 ff 9c 	sub	r2,r12,-100
8001b692:	f8 c3 ff 7c 	sub	r3,r12,-132
8001b696:	f8 c1 ff 5c 	sub	r1,r12,-164
8001b69a:	f8 c0 ff 3c 	sub	r0,r12,-196
8001b69e:	50 19       	stdsp	sp[0x4],r9
8001b6a0:	50 28       	stdsp	sp[0x8],r8
8001b6a2:	50 3e       	stdsp	sp[0xc],lr
8001b6a4:	0a 9a       	mov	r10,r5

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
8001b6a6:	40 4b       	lddsp	r11,sp[0x10]
8001b6a8:	2f f5       	sub	r5,-1
8001b6aa:	0e 9c       	mov	r12,r7
8001b6ac:	fe b0 fd 4c 	rcall	8001b144 <T.41>
8001b6b0:	e0 80 01 d4 	breq	8001ba58 <fatfs_update_file_length+0x3f8>
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b6b4:	0c 9c       	mov	r12,r6
8001b6b6:	e0 a0 09 68 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6ba:	e0 80 01 3c 	breq	8001b932 <fatfs_update_file_length+0x2d2>
8001b6be:	04 9c       	mov	r12,r2
8001b6c0:	e0 a0 09 63 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6c4:	e0 80 01 23 	breq	8001b90a <fatfs_update_file_length+0x2aa>
8001b6c8:	06 9c       	mov	r12,r3
8001b6ca:	e0 a0 09 5e 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6ce:	e0 80 01 0a 	breq	8001b8e2 <fatfs_update_file_length+0x282>
8001b6d2:	02 9c       	mov	r12,r1
8001b6d4:	e0 a0 09 59 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6d8:	e0 80 00 f1 	breq	8001b8ba <fatfs_update_file_length+0x25a>
8001b6dc:	00 9c       	mov	r12,r0
8001b6de:	e0 a0 09 54 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6e2:	e0 80 00 d7 	breq	8001b890 <fatfs_update_file_length+0x230>
8001b6e6:	40 0c       	lddsp	r12,sp[0x0]
8001b6e8:	e0 a0 09 4f 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6ec:	e0 80 00 bc 	breq	8001b864 <fatfs_update_file_length+0x204>
8001b6f0:	40 1c       	lddsp	r12,sp[0x4]
8001b6f2:	e0 a0 09 4a 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b6f6:	e0 80 00 a1 	breq	8001b838 <fatfs_update_file_length+0x1d8>
8001b6fa:	40 2c       	lddsp	r12,sp[0x8]
8001b6fc:	e0 a0 09 45 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b700:	e0 80 00 86 	breq	8001b80c <fatfs_update_file_length+0x1ac>
8001b704:	40 3c       	lddsp	r12,sp[0xc]
8001b706:	e0 a0 09 40 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b70a:	c6 e0       	breq	8001b7e6 <fatfs_update_file_length+0x186>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b70c:	ec c4 fe e0 	sub	r4,r6,-288

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b710:	08 9c       	mov	r12,r4
8001b712:	e0 a0 09 3a 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b716:	e0 80 01 35 	breq	8001b980 <fatfs_update_file_length+0x320>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b71a:	ec c4 fe c0 	sub	r4,r6,-320

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b71e:	08 9c       	mov	r12,r4
8001b720:	e0 a0 09 33 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b724:	e0 80 01 19 	breq	8001b956 <fatfs_update_file_length+0x2f6>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b728:	ec c4 fe a0 	sub	r4,r6,-352

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b72c:	08 9c       	mov	r12,r4
8001b72e:	e0 a0 09 2c 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b732:	e0 80 01 7d 	breq	8001ba2c <fatfs_update_file_length+0x3cc>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b736:	ec c4 fe 80 	sub	r4,r6,-384

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b73a:	08 9c       	mov	r12,r4
8001b73c:	e0 a0 09 25 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b740:	e0 80 01 60 	breq	8001ba00 <fatfs_update_file_length+0x3a0>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b744:	ec c4 fe 60 	sub	r4,r6,-416

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b748:	08 9c       	mov	r12,r4
8001b74a:	e0 a0 09 1e 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b74e:	e0 80 01 43 	breq	8001b9d4 <fatfs_update_file_length+0x374>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b752:	ec c4 fe 40 	sub	r4,r6,-448

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b756:	08 9c       	mov	r12,r4
8001b758:	e0 a0 09 17 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b75c:	e0 80 01 27 	breq	8001b9aa <fatfs_update_file_length+0x34a>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001b760:	ec c4 fe 20 	sub	r4,r6,-480

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
8001b764:	08 9c       	mov	r12,r4
8001b766:	e0 a0 09 10 	rcall	8001c986 <fatfs_entry_lfn_text>
8001b76a:	c9 d1       	brne	8001b6a4 <fatfs_update_file_length+0x44>
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b76c:	08 9c       	mov	r12,r4
8001b76e:	e0 a0 09 13 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b772:	c9 91       	brne	8001b6a4 <fatfs_update_file_length+0x44>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b774:	08 9c       	mov	r12,r4
8001b776:	e0 a0 09 43 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b77a:	c9 50       	breq	8001b6a4 <fatfs_update_file_length+0x44>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b77c:	30 ba       	mov	r10,11
8001b77e:	40 5b       	lddsp	r11,sp[0x14]
8001b780:	08 9c       	mov	r12,r4
8001b782:	e0 a0 40 bc 	rcall	800238fa <strncmp>
8001b786:	c8 f1       	brne	8001b6a4 <fatfs_update_file_length+0x44>
8001b788:	50 64       	stdsp	sp[0x18],r4
8001b78a:	e0 6c 01 e0 	mov	r12,480
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8001b78e:	40 79       	lddsp	r9,sp[0x1c]
8001b790:	e6 19 00 ff 	andh	r9,0xff,COH
8001b794:	40 7e       	lddsp	lr,sp[0x1c]
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8001b796:	40 6b       	lddsp	r11,sp[0x18]
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8001b798:	40 78       	lddsp	r8,sp[0x1c]
8001b79a:	1c 95       	mov	r5,lr
8001b79c:	b9 68       	lsl	r8,0x18
8001b79e:	e2 15 ff 00 	andl	r5,0xff00,COH
8001b7a2:	f1 ee 13 88 	or	r8,r8,lr>>0x18
8001b7a6:	f1 e5 10 88 	or	r8,r8,r5<<0x8
8001b7aa:	f1 e9 12 88 	or	r8,r8,r9>>0x8
8001b7ae:	f7 68 00 1f 	st.b	r11[31],r8
8001b7b2:	f0 09 16 18 	lsr	r9,r8,0x18
8001b7b6:	40 6e       	lddsp	lr,sp[0x18]
8001b7b8:	fd 69 00 1c 	st.b	lr[28],r9
8001b7bc:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
8001b7c0:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8001b7c4:	ec 0c 00 0c 	add	r12,r6,r12
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8001b7c8:	fd 68 00 1e 	st.b	lr[30],r8
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8001b7cc:	32 0a       	mov	r10,32
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8001b7ce:	fd 69 00 1d 	st.b	lr[29],r9
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8001b7d2:	e0 a0 3f 77 	rcall	800236c0 <memcpy>

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001b7d6:	0c 9b       	mov	r11,r6
8001b7d8:	ee fc 02 44 	ld.w	r12,r7[580]
8001b7dc:	6e e8       	ld.w	r8,r7[0x38]
8001b7de:	30 1a       	mov	r10,1
8001b7e0:	5d 18       	icall	r8
        else
            break;
    } // End of while loop

    return 0;
}
8001b7e2:	2f 8d       	sub	sp,-32
8001b7e4:	d8 32       	popm	r0-r7,pc
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b7e6:	40 3c       	lddsp	r12,sp[0xc]
8001b7e8:	e0 a0 08 d6 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b7ec:	c9 01       	brne	8001b70c <fatfs_update_file_length+0xac>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b7ee:	40 3c       	lddsp	r12,sp[0xc]
8001b7f0:	e0 a0 09 06 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b7f4:	c8 c0       	breq	8001b70c <fatfs_update_file_length+0xac>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b7f6:	30 ba       	mov	r10,11
8001b7f8:	40 5b       	lddsp	r11,sp[0x14]
8001b7fa:	40 3c       	lddsp	r12,sp[0xc]
8001b7fc:	e0 a0 40 7f 	rcall	800238fa <strncmp>
8001b800:	c8 61       	brne	8001b70c <fatfs_update_file_length+0xac>
8001b802:	40 39       	lddsp	r9,sp[0xc]
8001b804:	e0 6c 01 00 	mov	r12,256
8001b808:	50 69       	stdsp	sp[0x18],r9
8001b80a:	cc 2b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b80c:	40 2c       	lddsp	r12,sp[0x8]
8001b80e:	e0 a0 08 c3 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b812:	fe 91 ff 79 	brne	8001b704 <fatfs_update_file_length+0xa4>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b816:	40 2c       	lddsp	r12,sp[0x8]
8001b818:	e0 a0 08 f2 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b81c:	fe 90 ff 74 	breq	8001b704 <fatfs_update_file_length+0xa4>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b820:	30 ba       	mov	r10,11
8001b822:	40 5b       	lddsp	r11,sp[0x14]
8001b824:	40 2c       	lddsp	r12,sp[0x8]
8001b826:	e0 a0 40 6a 	rcall	800238fa <strncmp>
8001b82a:	fe 91 ff 6d 	brne	8001b704 <fatfs_update_file_length+0xa4>
8001b82e:	40 2e       	lddsp	lr,sp[0x8]
8001b830:	e0 6c 00 e0 	mov	r12,224
8001b834:	50 6e       	stdsp	sp[0x18],lr
8001b836:	ca cb       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b838:	40 1c       	lddsp	r12,sp[0x4]
8001b83a:	e0 a0 08 ad 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b83e:	fe 91 ff 5e 	brne	8001b6fa <fatfs_update_file_length+0x9a>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b842:	40 1c       	lddsp	r12,sp[0x4]
8001b844:	e0 a0 08 dc 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b848:	fe 90 ff 59 	breq	8001b6fa <fatfs_update_file_length+0x9a>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b84c:	30 ba       	mov	r10,11
8001b84e:	40 5b       	lddsp	r11,sp[0x14]
8001b850:	40 1c       	lddsp	r12,sp[0x4]
8001b852:	e0 a0 40 54 	rcall	800238fa <strncmp>
8001b856:	fe 91 ff 52 	brne	8001b6fa <fatfs_update_file_length+0x9a>
8001b85a:	40 18       	lddsp	r8,sp[0x4]
8001b85c:	e0 6c 00 c0 	mov	r12,192
8001b860:	50 68       	stdsp	sp[0x18],r8
8001b862:	c9 6b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b864:	40 0c       	lddsp	r12,sp[0x0]
8001b866:	e0 a0 08 97 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b86a:	fe 91 ff 43 	brne	8001b6f0 <fatfs_update_file_length+0x90>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b86e:	40 0c       	lddsp	r12,sp[0x0]
8001b870:	e0 a0 08 c6 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b874:	fe 90 ff 3e 	breq	8001b6f0 <fatfs_update_file_length+0x90>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b878:	30 ba       	mov	r10,11
8001b87a:	40 5b       	lddsp	r11,sp[0x14]
8001b87c:	40 0c       	lddsp	r12,sp[0x0]
8001b87e:	e0 a0 40 3e 	rcall	800238fa <strncmp>
8001b882:	fe 91 ff 37 	brne	8001b6f0 <fatfs_update_file_length+0x90>
8001b886:	40 09       	lddsp	r9,sp[0x0]
8001b888:	e0 6c 00 a0 	mov	r12,160
8001b88c:	50 69       	stdsp	sp[0x18],r9
8001b88e:	c8 0b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b890:	00 9c       	mov	r12,r0
8001b892:	e0 a0 08 81 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b896:	fe 91 ff 28 	brne	8001b6e6 <fatfs_update_file_length+0x86>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b89a:	00 9c       	mov	r12,r0
8001b89c:	e0 a0 08 b0 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b8a0:	fe 90 ff 23 	breq	8001b6e6 <fatfs_update_file_length+0x86>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b8a4:	30 ba       	mov	r10,11
8001b8a6:	40 5b       	lddsp	r11,sp[0x14]
8001b8a8:	00 9c       	mov	r12,r0
8001b8aa:	e0 a0 40 28 	rcall	800238fa <strncmp>
8001b8ae:	fe 91 ff 1c 	brne	8001b6e6 <fatfs_update_file_length+0x86>
8001b8b2:	50 60       	stdsp	sp[0x18],r0
8001b8b4:	e0 6c 00 80 	mov	r12,128
8001b8b8:	c6 bb       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b8ba:	02 9c       	mov	r12,r1
8001b8bc:	e0 a0 08 6c 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b8c0:	fe 91 ff 0e 	brne	8001b6dc <fatfs_update_file_length+0x7c>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b8c4:	02 9c       	mov	r12,r1
8001b8c6:	e0 a0 08 9b 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b8ca:	fe 90 ff 09 	breq	8001b6dc <fatfs_update_file_length+0x7c>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b8ce:	30 ba       	mov	r10,11
8001b8d0:	40 5b       	lddsp	r11,sp[0x14]
8001b8d2:	02 9c       	mov	r12,r1
8001b8d4:	e0 a0 40 13 	rcall	800238fa <strncmp>
8001b8d8:	fe 91 ff 02 	brne	8001b6dc <fatfs_update_file_length+0x7c>
8001b8dc:	50 61       	stdsp	sp[0x18],r1
8001b8de:	36 0c       	mov	r12,96
8001b8e0:	c5 7b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b8e2:	06 9c       	mov	r12,r3
8001b8e4:	e0 a0 08 58 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b8e8:	fe 91 fe f5 	brne	8001b6d2 <fatfs_update_file_length+0x72>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b8ec:	06 9c       	mov	r12,r3
8001b8ee:	e0 a0 08 87 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b8f2:	fe 90 fe f0 	breq	8001b6d2 <fatfs_update_file_length+0x72>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b8f6:	30 ba       	mov	r10,11
8001b8f8:	40 5b       	lddsp	r11,sp[0x14]
8001b8fa:	06 9c       	mov	r12,r3
8001b8fc:	e0 a0 3f ff 	rcall	800238fa <strncmp>
8001b900:	fe 91 fe e9 	brne	8001b6d2 <fatfs_update_file_length+0x72>
8001b904:	50 63       	stdsp	sp[0x18],r3
8001b906:	34 0c       	mov	r12,64
8001b908:	c4 3b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b90a:	04 9c       	mov	r12,r2
8001b90c:	e0 a0 08 44 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b910:	fe 91 fe dc 	brne	8001b6c8 <fatfs_update_file_length+0x68>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b914:	04 9c       	mov	r12,r2
8001b916:	e0 a0 08 73 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b91a:	fe 90 fe d7 	breq	8001b6c8 <fatfs_update_file_length+0x68>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b91e:	30 ba       	mov	r10,11
8001b920:	40 5b       	lddsp	r11,sp[0x14]
8001b922:	04 9c       	mov	r12,r2
8001b924:	e0 a0 3f eb 	rcall	800238fa <strncmp>
8001b928:	fe 91 fe d0 	brne	8001b6c8 <fatfs_update_file_length+0x68>
8001b92c:	50 62       	stdsp	sp[0x18],r2
8001b92e:	32 0c       	mov	r12,32
8001b930:	c2 fb       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b932:	0c 9c       	mov	r12,r6
8001b934:	e0 a0 08 30 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b938:	fe 91 fe c3 	brne	8001b6be <fatfs_update_file_length+0x5e>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b93c:	0c 9c       	mov	r12,r6
8001b93e:	e0 a0 08 5f 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b942:	fe 90 fe be 	breq	8001b6be <fatfs_update_file_length+0x5e>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b946:	30 ba       	mov	r10,11
8001b948:	40 5b       	lddsp	r11,sp[0x14]
8001b94a:	0c 9c       	mov	r12,r6
8001b94c:	e0 a0 3f d7 	rcall	800238fa <strncmp>
8001b950:	fe 91 fe b7 	brne	8001b6be <fatfs_update_file_length+0x5e>
8001b954:	c1 db       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b956:	08 9c       	mov	r12,r4
8001b958:	e0 a0 08 1e 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b95c:	fe 91 fe e6 	brne	8001b728 <fatfs_update_file_length+0xc8>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b960:	08 9c       	mov	r12,r4
8001b962:	e0 a0 08 4d 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b966:	fe 90 fe e1 	breq	8001b728 <fatfs_update_file_length+0xc8>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b96a:	30 ba       	mov	r10,11
8001b96c:	40 5b       	lddsp	r11,sp[0x14]
8001b96e:	08 9c       	mov	r12,r4
8001b970:	e0 a0 3f c5 	rcall	800238fa <strncmp>
8001b974:	fe 91 fe da 	brne	8001b728 <fatfs_update_file_length+0xc8>
8001b978:	50 64       	stdsp	sp[0x18],r4
8001b97a:	e0 6c 01 40 	mov	r12,320
8001b97e:	c0 8b       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b980:	08 9c       	mov	r12,r4
8001b982:	e0 a0 08 09 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b986:	fe 91 fe ca 	brne	8001b71a <fatfs_update_file_length+0xba>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b98a:	08 9c       	mov	r12,r4
8001b98c:	e0 a0 08 38 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b990:	fe 90 fe c5 	breq	8001b71a <fatfs_update_file_length+0xba>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b994:	30 ba       	mov	r10,11
8001b996:	40 5b       	lddsp	r11,sp[0x14]
8001b998:	08 9c       	mov	r12,r4
8001b99a:	e0 a0 3f b0 	rcall	800238fa <strncmp>
8001b99e:	fe 91 fe be 	brne	8001b71a <fatfs_update_file_length+0xba>
8001b9a2:	50 64       	stdsp	sp[0x18],r4
8001b9a4:	e0 6c 01 20 	mov	r12,288
8001b9a8:	cf 3a       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b9aa:	08 9c       	mov	r12,r4
8001b9ac:	e0 a0 07 f4 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b9b0:	fe 91 fe d8 	brne	8001b760 <fatfs_update_file_length+0x100>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b9b4:	08 9c       	mov	r12,r4
8001b9b6:	e0 a0 08 23 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b9ba:	fe 90 fe d3 	breq	8001b760 <fatfs_update_file_length+0x100>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b9be:	30 ba       	mov	r10,11
8001b9c0:	40 5b       	lddsp	r11,sp[0x14]
8001b9c2:	08 9c       	mov	r12,r4
8001b9c4:	e0 a0 3f 9b 	rcall	800238fa <strncmp>
8001b9c8:	fe 91 fe cc 	brne	8001b760 <fatfs_update_file_length+0x100>
8001b9cc:	50 64       	stdsp	sp[0x18],r4
8001b9ce:	e0 6c 01 c0 	mov	r12,448
8001b9d2:	cd ea       	rjmp	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001b9d4:	08 9c       	mov	r12,r4
8001b9d6:	e0 a0 07 df 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001b9da:	fe 91 fe bc 	brne	8001b752 <fatfs_update_file_length+0xf2>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001b9de:	08 9c       	mov	r12,r4
8001b9e0:	e0 a0 08 0e 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001b9e4:	fe 90 fe b7 	breq	8001b752 <fatfs_update_file_length+0xf2>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001b9e8:	30 ba       	mov	r10,11
8001b9ea:	40 5b       	lddsp	r11,sp[0x14]
8001b9ec:	08 9c       	mov	r12,r4
8001b9ee:	e0 a0 3f 86 	rcall	800238fa <strncmp>
8001b9f2:	fe 91 fe b0 	brne	8001b752 <fatfs_update_file_length+0xf2>
8001b9f6:	50 64       	stdsp	sp[0x18],r4
8001b9f8:	e0 6c 01 a0 	mov	r12,416
8001b9fc:	fe 9f fe c9 	bral	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001ba00:	08 9c       	mov	r12,r4
8001ba02:	e0 a0 07 c9 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001ba06:	fe 91 fe 9f 	brne	8001b744 <fatfs_update_file_length+0xe4>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001ba0a:	08 9c       	mov	r12,r4
8001ba0c:	e0 a0 07 f8 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001ba10:	fe 90 fe 9a 	breq	8001b744 <fatfs_update_file_length+0xe4>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001ba14:	30 ba       	mov	r10,11
8001ba16:	40 5b       	lddsp	r11,sp[0x14]
8001ba18:	08 9c       	mov	r12,r4
8001ba1a:	e0 a0 3f 70 	rcall	800238fa <strncmp>
8001ba1e:	fe 91 fe 93 	brne	8001b744 <fatfs_update_file_length+0xe4>
8001ba22:	50 64       	stdsp	sp[0x18],r4
8001ba24:	e0 6c 01 80 	mov	r12,384
8001ba28:	fe 9f fe b3 	bral	8001b78e <fatfs_update_file_length+0x12e>
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8001ba2c:	08 9c       	mov	r12,r4
8001ba2e:	e0 a0 07 b3 	rcall	8001c994 <fatfs_entry_lfn_invalid>
8001ba32:	fe 91 fe 82 	brne	8001b736 <fatfs_update_file_length+0xd6>
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
8001ba36:	08 9c       	mov	r12,r4
8001ba38:	e0 a0 07 e2 	rcall	8001c9fc <fatfs_entry_sfn_only>
8001ba3c:	fe 90 fe 7d 	breq	8001b736 <fatfs_update_file_length+0xd6>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8001ba40:	30 ba       	mov	r10,11
8001ba42:	40 5b       	lddsp	r11,sp[0x14]
8001ba44:	08 9c       	mov	r12,r4
8001ba46:	e0 a0 3f 5a 	rcall	800238fa <strncmp>
8001ba4a:	fe 91 fe 76 	brne	8001b736 <fatfs_update_file_length+0xd6>
8001ba4e:	50 64       	stdsp	sp[0x18],r4
8001ba50:	e0 6c 01 60 	mov	r12,352
8001ba54:	fe 9f fe 9d 	bral	8001b78e <fatfs_update_file_length+0x12e>

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001ba58:	2f 8d       	sub	sp,-32
8001ba5a:	d8 3a       	popm	r0-r7,pc,r12=0

8001ba5c <fatfs_write_sector>:
8001ba5c:	eb cd 40 e0 	pushm	r5-r7,lr
8001ba60:	20 1d       	sub	sp,4
8001ba62:	18 96       	mov	r6,r12
8001ba64:	16 98       	mov	r8,r11
8001ba66:	78 e7       	ld.w	r7,r12[0x38]
8001ba68:	58 07       	cp.w	r7,0
8001ba6a:	c2 50       	breq	8001bab4 <fatfs_write_sector+0x58>
8001ba6c:	58 0b       	cp.w	r11,0
8001ba6e:	5f 05       	sreq	r5
8001ba70:	78 ce       	ld.w	lr,r12[0x30]
8001ba72:	58 0e       	cp.w	lr,0
    // No write access?
    if (!fs->disk_io.write_media)
        return 0;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && cluster == 0)
8001ba74:	5f 0e       	sreq	lr
8001ba76:	fd e5 00 05 	and	r5,lr,r5
8001ba7a:	c1 10       	breq	8001ba9c <fatfs_write_sector+0x40>
    {
        uint32 lba;

        // In FAT16 we cannot extend the root dir!
        if (sector < fs->rootdir_sectors)
8001ba7c:	78 48       	ld.w	r8,r12[0x10]
8001ba7e:	14 38       	cp.w	r8,r10
8001ba80:	e0 88 00 1a 	brls	8001bab4 <fatfs_write_sector+0x58>
            lba = fs->lba_begin + fs->rootdir_first_sector + sector;
8001ba84:	78 3c       	ld.w	r12,r12[0xc]
8001ba86:	6c 78       	ld.w	r8,r6[0x1c]
8001ba88:	10 0c       	add	r12,r8
8001ba8a:	14 0c       	add	r12,r10
        else
            return 0;

        // User target buffer passed in
        if (target)
8001ba8c:	58 09       	cp.w	r9,0
8001ba8e:	c2 d0       	breq	8001bae8 <fatfs_write_sector+0x8c>
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8001ba90:	12 9b       	mov	r11,r9
8001ba92:	30 1a       	mov	r10,1
8001ba94:	5d 17       	icall	r7

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
        }
    }
}
8001ba96:	2f fd       	sub	sp,-4
8001ba98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    }
    // FAT16/32 Other
    else
    {
        // User target buffer passed in
        if (target)
8001ba9c:	58 09       	cp.w	r9,0
8001ba9e:	c1 90       	breq	8001bad0 <fatfs_write_sector+0x74>
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8001baa0:	58 0e       	cp.w	lr,0
8001baa2:	c0 c1       	brne	8001baba <fatfs_write_sector+0x5e>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8001baa4:	78 1b       	ld.w	r11,r12[0x4]
8001baa6:	20 28       	sub	r8,2
8001baa8:	19 8c       	ld.ub	r12,r12[0x0]
8001baaa:	f0 0c 02 4c 	mul	r12,r8,r12
8001baae:	16 0c       	add	r12,r11
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8001bab0:	14 0c       	add	r12,r10
8001bab2:	ce fb       	rjmp	8001ba90 <fatfs_write_sector+0x34>
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001bab4:	2f fd       	sub	sp,-4
8001bab6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8001baba:	19 8b       	ld.ub	r11,r12[0x0]
8001babc:	20 28       	sub	r8,2
8001babe:	f9 1c 00 28 	ld.uh	r12,r12[40]
8001bac2:	b7 38       	mul	r8,r11
8001bac4:	a5 4c       	asr	r12,0x4
8001bac6:	6c 1b       	ld.w	r11,r6[0x4]
8001bac8:	16 0c       	add	r12,r11
8001baca:	10 0c       	add	r12,r8
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
8001bacc:	14 0c       	add	r12,r10
8001bace:	ce 1b       	rjmp	8001ba90 <fatfs_write_sector+0x34>
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8001bad0:	50 0a       	stdsp	sp[0x0],r10
8001bad2:	fe b0 f9 e5 	rcall	8001ae9c <fatfs_lba_of_cluster>
8001bad6:	40 0a       	lddsp	r10,sp[0x0]

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001bad8:	ec cb ff bc 	sub	r11,r6,-68
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8001badc:	14 0c       	add	r12,r10

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001bade:	30 1a       	mov	r10,1
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
8001bae0:	ed 4c 02 44 	st.w	r6[580],r12

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001bae4:	5d 17       	icall	r7
8001bae6:	cd 8b       	rjmp	8001ba96 <fatfs_write_sector+0x3a>
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = lba;
8001bae8:	ed 4c 02 44 	st.w	r6[580],r12

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001baec:	ec cb ff bc 	sub	r11,r6,-68
8001baf0:	30 1a       	mov	r10,1
8001baf2:	5d 17       	icall	r7
8001baf4:	cd 1b       	rjmp	8001ba96 <fatfs_write_sector+0x3a>
8001baf6:	d7 03       	nop

8001baf8 <fatfs_sector_reader>:
8001baf8:	eb cd 40 fc 	pushm	r2-r7,lr
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001bafc:	58 0b       	cp.w	r11,0
8001bafe:	5f 08       	sreq	r8
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
8001bb00:	12 93       	mov	r3,r9
8001bb02:	18 97       	mov	r7,r12
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001bb04:	78 c9       	ld.w	r9,r12[0x30]
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
8001bb06:	14 96       	mov	r6,r10
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
8001bb08:	58 09       	cp.w	r9,0
8001bb0a:	5f 09       	sreq	r9
8001bb0c:	12 68       	and	r8,r9
8001bb0e:	c1 10       	breq	8001bb30 <fatfs_sector_reader+0x38>
    {
        if (offset < fs->rootdir_sectors)
8001bb10:	78 48       	ld.w	r8,r12[0x10]
8001bb12:	14 38       	cp.w	r8,r10
8001bb14:	e0 88 00 3b 	brls	8001bb8a <fatfs_sector_reader+0x92>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
8001bb18:	78 3c       	ld.w	r12,r12[0xc]
8001bb1a:	6e 78       	ld.w	r8,r7[0x1c]
8001bb1c:	10 0c       	add	r12,r8
8001bb1e:	14 0c       	add	r12,r10
        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
    }

    // User provided target array
    if (target)
8001bb20:	58 03       	cp.w	r3,0
8001bb22:	c2 70       	breq	8001bb70 <fatfs_sector_reader+0x78>
        return fs->disk_io.read_media(lba, target, 1);
8001bb24:	6e d8       	ld.w	r8,r7[0x34]
8001bb26:	06 9b       	mov	r11,r3
8001bb28:	30 1a       	mov	r10,1
8001bb2a:	5d 18       	icall	r8
8001bb2c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
8001bb30:	19 82       	ld.ub	r2,r12[0x0]
8001bb32:	f4 02 0d 08 	divu	r8,r10,r2
8001bb36:	10 94       	mov	r4,r8
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001bb38:	58 08       	cp.w	r8,0
8001bb3a:	c0 a0       	breq	8001bb4e <fatfs_sector_reader+0x56>
8001bb3c:	30 05       	mov	r5,0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8001bb3e:	0e 9c       	mov	r12,r7
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001bb40:	2f f5       	sub	r5,-1
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
8001bb42:	e0 a0 0d cb 	rcall	8001d6d8 <fatfs_find_next_cluster>
8001bb46:	18 9b       	mov	r11,r12
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
8001bb48:	0a 34       	cp.w	r4,r5
8001bb4a:	fe 9b ff fa 	brhi	8001bb3e <fatfs_sector_reader+0x46>
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
8001bb4e:	5b fb       	cp.w	r11,-1
8001bb50:	c1 d0       	breq	8001bb8a <fatfs_sector_reader+0x92>
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
8001bb52:	6e c8       	ld.w	r8,r7[0x30]
8001bb54:	58 08       	cp.w	r8,0
8001bb56:	c1 c0       	breq	8001bb8e <fatfs_sector_reader+0x96>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
8001bb58:	0f 88       	ld.ub	r8,r7[0x0]
8001bb5a:	20 2b       	sub	r11,2
8001bb5c:	b1 3b       	mul	r11,r8
8001bb5e:	6e 18       	ld.w	r8,r7[0x4]
8001bb60:	f6 08 00 08 	add	r8,r11,r8
        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
8001bb64:	a5 34       	mul	r4,r2
8001bb66:	08 16       	sub	r6,r4
8001bb68:	ec 08 00 0c 	add	r12,r6,r8
    }

    // User provided target array
    if (target)
8001bb6c:	58 03       	cp.w	r3,0
8001bb6e:	cd b1       	brne	8001bb24 <fatfs_sector_reader+0x2c>
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001bb70:	ee f8 02 44 	ld.w	r8,r7[580]
8001bb74:	18 38       	cp.w	r8,r12
8001bb76:	c1 70       	breq	8001bba4 <fatfs_sector_reader+0xac>
    {
        fs->currentsector.address = lba;
8001bb78:	ef 4c 02 44 	st.w	r7[580],r12
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001bb7c:	ee cb ff bc 	sub	r11,r7,-68
8001bb80:	6e d8       	ld.w	r8,r7[0x34]
8001bb82:	30 1a       	mov	r10,1
8001bb84:	5d 18       	icall	r8
8001bb86:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001bb8a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
8001bb8e:	ef 19 00 28 	ld.uh	r9,r7[40]
8001bb92:	a5 49       	asr	r9,0x4
8001bb94:	20 2b       	sub	r11,2
8001bb96:	6e 18       	ld.w	r8,r7[0x4]
8001bb98:	f2 08 00 08 	add	r8,r9,r8
8001bb9c:	0f 89       	ld.ub	r9,r7[0x0]
8001bb9e:	f6 09 03 48 	mac	r8,r11,r9
8001bba2:	ce 1b       	rjmp	8001bb64 <fatfs_sector_reader+0x6c>

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
8001bba4:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

8001bba8 <fatfs_cache_init>:
        file->cluster_cache_data[i] = 0; 
    }
#endif
    
    return 1;
}
8001bba8:	5e ff       	retal	1

8001bbaa <fatfs_cache_get_next_cluster>:
        return 1;
    }
#endif
    
    return 0;
}
8001bbaa:	5e fd       	retal	0

8001bbac <fatfs_cache_set_next_cluster>:
        file->cluster_cache_data[slot] = nextCluster;
    }
#endif

    return 1;
}
8001bbac:	5e ff       	retal	1
8001bbae:	d7 03       	nop

8001bbb0 <_free_file>:
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8001bbb0:	f8 f8 04 3c 	ld.w	r8,r12[1084]
8001bbb4:	58 08       	cp.w	r8,0
8001bbb6:	c1 f0       	breq	8001bbf4 <_free_file+0x44>
        list->head = node->next;
    else
        node->previous->next = node->next;
8001bbb8:	f8 f9 04 40 	ld.w	r9,r12[1088]
8001bbbc:	91 19       	st.w	r8[0x4],r9
8001bbbe:	f8 f8 04 40 	ld.w	r8,r12[1088]
8001bbc2:	f8 f9 04 3c 	ld.w	r9,r12[1084]

    if(!node->next)
8001bbc6:	58 08       	cp.w	r8,0
8001bbc8:	c1 e0       	breq	8001bc04 <_free_file+0x54>
        list->tail = node->previous;
    else
        node->next->previous = node->previous;
8001bbca:	91 09       	st.w	r8[0x0],r9
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8001bbcc:	e0 6b 29 fc 	mov	r11,10748
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8001bbd0:	f8 c9 fb c4 	sub	r9,r12,-1084
8001bbd4:	76 18       	ld.w	r8,r11[0x4]
8001bbd6:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001bbd8:	c1 a0       	breq	8001bc0c <_free_file+0x5c>
8001bbda:	f9 48 04 3c 	st.w	r12[1084],r8
    new_node->next = node->next;
8001bbde:	70 1a       	ld.w	r10,r8[0x4]
8001bbe0:	f9 4a 04 40 	st.w	r12[1088],r10
    if (!node->next)
        list->tail = new_node;
8001bbe4:	70 1a       	ld.w	r10,r8[0x4]
8001bbe6:	58 0a       	cp.w	r10,0
8001bbe8:	f7 f9 0a 01 	st.weq	r11[0x4],r9
    else
        node->next->previous = new_node;
8001bbec:	f5 f9 1a 00 	st.wne	r10[0x0],r9
    node->next = new_node;
8001bbf0:	91 19       	st.w	r8[0x4],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8001bbf2:	5e fc       	retal	r12
8001bbf4:	10 99       	mov	r9,r8
8001bbf6:	e0 6a 1c fc 	mov	r10,7420
8001bbfa:	f8 f8 04 40 	ld.w	r8,r12[1088]
    else
        node->previous->next = node->next;

    if(!node->next)
8001bbfe:	95 08       	st.w	r10[0x0],r8
        list->tail = node->previous;
8001bc00:	58 08       	cp.w	r8,0
8001bc02:	ce 41       	brne	8001bbca <_free_file+0x1a>
8001bc04:	e0 68 1c fc 	mov	r8,7420
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8001bc08:	91 19       	st.w	r8[0x4],r9
8001bc0a:	ce 1b       	rjmp	8001bbcc <_free_file+0x1c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001bc0c:	76 08       	ld.w	r8,r11[0x0]
    new_node->next = node;
8001bc0e:	58 08       	cp.w	r8,0
8001bc10:	c0 e0       	breq	8001bc2c <_free_file+0x7c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001bc12:	70 0a       	ld.w	r10,r8[0x0]
8001bc14:	f9 48 04 40 	st.w	r12[1088],r8
    new_node->next = node;
    if (!node->previous)
        list->head = new_node;
8001bc18:	f9 4a 04 3c 	st.w	r12[1084],r10
8001bc1c:	70 0a       	ld.w	r10,r8[0x0]
    else
        node->previous->next = new_node;
8001bc1e:	58 0a       	cp.w	r10,0
8001bc20:	f7 f9 0a 00 	st.weq	r11[0x0],r9
    node->previous = new_node;
8001bc24:	f5 f9 1a 01 	st.wne	r10[0x4],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8001bc28:	91 09       	st.w	r8[0x0],r9
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8001bc2a:	5e fc       	retal	r12
8001bc2c:	97 19       	st.w	r11[0x4],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001bc2e:	97 09       	st.w	r11[0x0],r9
8001bc30:	f9 48 04 40 	st.w	r12[1088],r8
8001bc34:	f9 48 04 3c 	st.w	r12[1084],r8
8001bc38:	5e fc       	retal	r12
8001bc3a:	d7 03       	nop

8001bc3c <fl_init>:
8001bc3c:	e0 68 21 70 	mov	r8,8560
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8001bc40:	30 09       	mov	r9,0
8001bc42:	f1 49 08 84 	st.w	r8[2180],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001bc46:	f1 49 04 3c 	st.w	r8[1084],r9
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8001bc4a:	e0 6a 1c fc 	mov	r10,7420
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001bc4e:	95 09       	st.w	r10[0x0],r9
8001bc50:	95 19       	st.w	r10[0x4],r9
    new_node->next = node->next;
    if (!node->next)
8001bc52:	f0 c9 fb c4 	sub	r9,r8,-1084
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001bc56:	f0 ca f7 80 	sub	r10,r8,-2176
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001bc5a:	f1 49 08 80 	st.w	r8[2176],r9
8001bc5e:	f1 4a 04 40 	st.w	r8[1088],r10
8001bc62:	e0 68 29 fc 	mov	r8,10748

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8001bc66:	91 09       	st.w	r8[0x0],r9
8001bc68:	91 1a       	st.w	r8[0x4],r10
}
8001bc6a:	30 19       	mov	r9,1
8001bc6c:	e0 68 29 f8 	mov	r8,10744
8001bc70:	91 09       	st.w	r8[0x0],r9
8001bc72:	5e fc       	retal	r12

8001bc74 <_open_directory>:
8001bc74:	eb cd 40 fe 	pushm	r1-r7,lr
8001bc78:	fa cd 01 24 	sub	sp,sp,292
//-----------------------------------------------------------------------------
// _open_directory: Cycle through path string to find the start cluster
// address of the highest subdir.
//-----------------------------------------------------------------------------
static int _open_directory(char *path, uint32 *pathCluster)
{
8001bc7c:	18 93       	mov	r3,r12
8001bc7e:	16 91       	mov	r1,r11
    char currentfolder[FATFS_MAX_LONG_FILENAME];
    struct fat_dir_entry sfEntry;
    uint32 startcluster;

    // Set starting cluster to root cluster
    startcluster = fatfs_get_root_cluster(&_fs);
8001bc80:	e0 6c 1d 08 	mov	r12,7432
8001bc84:	fe b0 f9 31 	rcall	8001aee6 <fatfs_get_root_cluster>

    // Find number of levels
    levels = fatfs_total_path_levels(path);
8001bc88:	18 95       	mov	r5,r12
8001bc8a:	06 9c       	mov	r12,r3
8001bc8c:	e0 a0 0a 6c 	rcall	8001d164 <fatfs_total_path_levels>

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8001bc90:	18 92       	mov	r2,r12
8001bc92:	c3 35       	brlt	8001bcf8 <_open_directory+0x84>
8001bc94:	30 07       	mov	r7,0
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
            return 0;

        // Find clusteraddress for folder (currentfolder) 
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
8001bc96:	1a 96       	mov	r6,sp
8001bc98:	fa c4 fe fc 	sub	r4,sp,-260
8001bc9c:	c2 18       	rjmp	8001bcde <_open_directory+0x6a>
8001bc9e:	0a 9b       	mov	r11,r5
8001bca0:	08 99       	mov	r9,r4
8001bca2:	1a 9a       	mov	r10,sp
8001bca4:	e0 6c 1d 08 	mov	r12,7432
8001bca8:	fe b0 fa 8e 	rcall	8001b1c4 <fatfs_get_file_entry>
        {
            // Check entry is folder
            if (fatfs_entry_is_dir(&sfEntry))
8001bcac:	c2 30       	breq	8001bcf2 <_open_directory+0x7e>
8001bcae:	08 9c       	mov	r12,r4
8001bcb0:	e0 a0 06 bc 	rcall	8001ca28 <fatfs_entry_is_dir>
                startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8001bcb4:	c1 f0       	breq	8001bcf2 <_open_directory+0x7e>
8001bcb6:	fb 19 01 18 	ld.uh	r9,sp[280]
8001bcba:	fb 18 01 1e 	ld.uh	r8,sp[286]
8001bcbe:	f2 05 15 08 	lsl	r5,r9,0x8
8001bcc2:	eb d5 c0 10 	bfextu	r5,r5,0x0,0x10
8001bcc6:	eb e9 12 85 	or	r5,r5,r9>>0x8
8001bcca:	f0 09 15 08 	lsl	r9,r8,0x8
8001bcce:	b1 65       	lsl	r5,0x10
8001bcd0:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001bcd4:	f3 e8 12 88 	or	r8,r9,r8>>0x8

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8001bcd8:	10 05       	add	r5,r8
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
8001bcda:	0e 32       	cp.w	r2,r7
8001bcdc:	c0 e5       	brlt	8001bcf8 <_open_directory+0x84>
8001bcde:	0e 9b       	mov	r11,r7

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8001bce0:	e0 69 01 04 	mov	r9,260
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
8001bce4:	2f f7       	sub	r7,-1
8001bce6:	1a 9a       	mov	r10,sp
8001bce8:	06 9c       	mov	r12,r3
8001bcea:	e0 a0 0b 63 	rcall	8001d3b0 <fatfs_get_substring>
        else
            return 0;
    }

    *pathCluster = startcluster;
    return 1;
8001bcee:	5b fc       	cp.w	r12,-1
8001bcf0:	cd 71       	brne	8001bc9e <_open_directory+0x2a>
8001bcf2:	2b 7d       	sub	sp,-292
        }
        else
            return 0;
    }

    *pathCluster = startcluster;
8001bcf4:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8001bcf8:	83 05       	st.w	r1[0x0],r5
8001bcfa:	2b 7d       	sub	sp,-292
8001bcfc:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1

8001bd00 <_write_sectors>:
8001bd00:	d4 31       	pushm	r0-r7,lr
8001bd02:	20 3d       	sub	sp,12
8001bd04:	3f f8       	mov	r8,-1
8001bd06:	12 90       	mov	r0,r9
8001bd08:	50 28       	stdsp	sp[0x8],r8
8001bd0a:	e0 69 1d 08 	mov	r9,7432
8001bd0e:	50 0a       	stdsp	sp[0x0],r10
8001bd10:	13 88       	ld.ub	r8,r9[0x0]
8001bd12:	f6 08 0d 06 	divu	r6,r11,r8
    uint32 lba;
    uint32 TotalWriteCount = count;

    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);
8001bd16:	18 95       	mov	r5,r12
8001bd18:	ec 08 02 42 	mul	r2,r6,r8
8001bd1c:	0c 94       	mov	r4,r6
8001bd1e:	f6 02 01 02 	sub	r2,r11,r2
    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8001bd22:	f8 f7 02 28 	ld.w	r7,r12[552]
    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);

    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
8001bd26:	e4 00 00 09 	add	r9,r2,r0
8001bd2a:	12 38       	cp.w	r8,r9
8001bd2c:	e0 01 17 20 	movhs	r1,r0
        count = _fs.sectors_per_cluster - SectorNumber;
8001bd30:	f1 d2 e3 11 	subcs	r1,r8,r2

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8001bd34:	0c 37       	cp.w	r7,r6
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001bd36:	c5 b0       	breq	8001bdec <_write_sectors+0xec>
8001bd38:	58 06       	cp.w	r6,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;
8001bd3a:	c4 e1       	brne	8001bdd6 <_write_sectors+0xd6>
8001bd3c:	6a 16       	ld.w	r6,r5[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001bd3e:	30 07       	mov	r7,0
8001bd40:	0e 34       	cp.w	r4,r7
8001bd42:	e0 88 00 58 	brls	8001bdf2 <_write_sectors+0xf2>
8001bd46:	fa c3 ff fc 	sub	r3,sp,-4

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
8001bd4a:	c0 98       	rjmp	8001bd5c <_write_sectors+0x5c>
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001bd4c:	50 26       	stdsp	sp[0x8],r6
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
8001bd4e:	2f f7       	sub	r7,-1

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
8001bd50:	40 16       	lddsp	r6,sp[0x4]
8001bd52:	5b f6       	cp.w	r6,-1
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001bd54:	c1 c0       	breq	8001bd8c <_write_sectors+0x8c>
8001bd56:	0e 34       	cp.w	r4,r7
8001bd58:	e0 88 00 2a 	brls	8001bdac <_write_sectors+0xac>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
8001bd5c:	0e 9a       	mov	r10,r7
8001bd5e:	06 99       	mov	r9,r3
8001bd60:	0a 9b       	mov	r11,r5
8001bd62:	e0 6c 1d 08 	mov	r12,7432
8001bd66:	c2 2f       	rcall	8001bbaa <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8001bd68:	cf 21       	brne	8001bd4c <_write_sectors+0x4c>
8001bd6a:	0c 9b       	mov	r11,r6
8001bd6c:	e0 6c 1d 08 	mov	r12,7432

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8001bd70:	e0 a0 0c b4 	rcall	8001d6d8 <fatfs_find_next_cluster>
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8001bd74:	0e 9a       	mov	r10,r7

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8001bd76:	18 99       	mov	r9,r12
8001bd78:	50 1c       	stdsp	sp[0x4],r12
8001bd7a:	0a 9b       	mov	r11,r5
8001bd7c:	e0 6c 1d 08 	mov	r12,7432
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001bd80:	c1 6f       	rcall	8001bbac <fatfs_cache_set_next_cluster>
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
8001bd82:	50 26       	stdsp	sp[0x8],r6

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
8001bd84:	2f f7       	sub	r7,-1
8001bd86:	40 16       	lddsp	r6,sp[0x4]
8001bd88:	5b f6       	cp.w	r6,-1
8001bd8a:	ce 61       	brne	8001bd56 <_write_sectors+0x56>

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
        {
            // Add some more cluster(s) to the last good cluster chain
            if (!fatfs_add_free_space(&_fs, &LastCluster,  (TotalWriteCount + _fs.sectors_per_cluster -1) / _fs.sectors_per_cluster))
8001bd8c:	e0 69 1d 08 	mov	r9,7432
8001bd90:	13 88       	ld.ub	r8,r9[0x0]
8001bd92:	e0 cb 00 01 	sub	r11,r0,1
8001bd96:	10 0b       	add	r11,r8
8001bd98:	f6 08 0d 0a 	divu	r10,r11,r8
8001bd9c:	fa cb ff f8 	sub	r11,sp,-8
8001bda0:	e0 6c 1d 08 	mov	r12,7432
            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
8001bda4:	e0 a0 15 38 	rcall	8001e814 <fatfs_add_free_space>

            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
8001bda8:	c1 e0       	breq	8001bde4 <_write_sectors+0xe4>
8001bdaa:	40 26       	lddsp	r6,sp[0x8]
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
    }

    // Calculate write address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + SectorNumber;
8001bdac:	eb 44 02 28 	st.w	r5[552],r4
8001bdb0:	eb 46 02 2c 	st.w	r5[556],r6

    if (fatfs_sector_write(&_fs, lba, buf, count))
8001bdb4:	0c 9b       	mov	r11,r6
8001bdb6:	e0 6c 1d 08 	mov	r12,7432
8001bdba:	fe b0 f8 71 	rcall	8001ae9c <fatfs_lba_of_cluster>
8001bdbe:	02 99       	mov	r9,r1
8001bdc0:	f8 02 00 0b 	add	r11,r12,r2
        return count;
    else
        return 0;
}
8001bdc4:	40 0a       	lddsp	r10,sp[0x0]
8001bdc6:	e0 6c 1d 08 	mov	r12,7432
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001bdca:	fe b0 f8 86 	rcall	8001aed6 <fatfs_sector_write>
8001bdce:	c0 b0       	breq	8001bde4 <_write_sectors+0xe4>
8001bdd0:	02 9c       	mov	r12,r1
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
8001bdd2:	2f dd       	sub	sp,-12
8001bdd4:	d8 32       	popm	r0-r7,pc
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001bdd6:	ee c9 ff ff 	sub	r9,r7,-1

    if (fatfs_sector_write(&_fs, lba, buf, count))
        return count;
    else
        return 0;
}
8001bdda:	0c 39       	cp.w	r9,r6
8001bddc:	cb 01       	brne	8001bd3c <_write_sectors+0x3c>
8001bdde:	f8 f6 02 2c 	ld.w	r6,r12[556]
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
8001bde2:	ca fb       	rjmp	8001bd40 <_write_sectors+0x40>
8001bde4:	30 01       	mov	r1,0
            if (Cluster == FAT32_LAST_CLUSTER)
                break;
        }

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
8001bde6:	02 9c       	mov	r12,r1
8001bde8:	2f dd       	sub	sp,-12
8001bdea:	d8 32       	popm	r0-r7,pc
8001bdec:	f8 f6 02 2c 	ld.w	r6,r12[556]
8001bdf0:	ce 2b       	rjmp	8001bdb4 <_write_sectors+0xb4>
8001bdf2:	5b f6       	cp.w	r6,-1
8001bdf4:	cd c1       	brne	8001bdac <_write_sectors+0xac>
8001bdf6:	cc eb       	rjmp	8001bd92 <_write_sectors+0x92>

8001bdf8 <_read_sectors>:
8001bdf8:	d4 31       	pushm	r0-r7,lr
8001bdfa:	20 1d       	sub	sp,4
8001bdfc:	12 92       	mov	r2,r9
8001bdfe:	e0 68 1d 08 	mov	r8,7432
8001be02:	18 96       	mov	r6,r12
8001be04:	11 88       	ld.ub	r8,r8[0x0]
8001be06:	14 90       	mov	r0,r10
    uint32 Cluster = 0;
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
8001be08:	f6 08 0d 04 	divu	r4,r11,r8
    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8001be0c:	f8 f7 02 28 	ld.w	r7,r12[552]
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    Sector = offset - (ClusterIdx * _fs.sectors_per_cluster);
8001be10:	e8 08 02 41 	mul	r1,r4,r8
8001be14:	08 95       	mov	r5,r4
8001be16:	f6 01 01 01 	sub	r1,r11,r1

    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
8001be1a:	e2 09 00 09 	add	r9,r1,r9
        count = _fs.sectors_per_cluster - Sector;
8001be1e:	12 38       	cp.w	r8,r9
8001be20:	f1 d1 e3 12 	subcs	r2,r8,r1

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8001be24:	08 37       	cp.w	r7,r4
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001be26:	c3 e0       	breq	8001bea2 <_read_sectors+0xaa>
8001be28:	58 04       	cp.w	r4,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;                    
8001be2a:	c4 41       	brne	8001beb2 <_read_sectors+0xba>
8001be2c:	6c 14       	ld.w	r4,r6[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001be2e:	30 07       	mov	r7,0
8001be30:	0e 35       	cp.w	r5,r7
8001be32:	e0 88 00 21 	brls	8001be74 <_read_sectors+0x7c>
8001be36:	1a 93       	mov	r3,sp
8001be38:	c0 68       	rjmp	8001be44 <_read_sectors+0x4c>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            Cluster = nextCluster;
8001be3a:	2f f7       	sub	r7,-1
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001be3c:	40 04       	lddsp	r4,sp[0x0]
8001be3e:	0e 35       	cp.w	r5,r7
8001be40:	e0 88 00 1a 	brls	8001be74 <_read_sectors+0x7c>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
8001be44:	0e 9a       	mov	r10,r7
8001be46:	1a 99       	mov	r9,sp
8001be48:	0c 9b       	mov	r11,r6
8001be4a:	e0 6c 1d 08 	mov	r12,7432
8001be4e:	ca ee       	rcall	8001bbaa <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8001be50:	cf 51       	brne	8001be3a <_read_sectors+0x42>
8001be52:	08 9b       	mov	r11,r4
8001be54:	e0 6c 1d 08 	mov	r12,7432

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8001be58:	e0 a0 0c 40 	rcall	8001d6d8 <fatfs_find_next_cluster>
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8001be5c:	0e 9a       	mov	r10,r7

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8001be5e:	18 99       	mov	r9,r12
8001be60:	50 0c       	stdsp	sp[0x0],r12
8001be62:	0c 9b       	mov	r11,r6
8001be64:	e0 6c 1d 08 	mov	r12,7432
            }            

            Cluster = nextCluster;
8001be68:	ca 2e       	rcall	8001bbac <fatfs_cache_set_next_cluster>
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8001be6a:	2f f7       	sub	r7,-1
8001be6c:	40 04       	lddsp	r4,sp[0x0]
8001be6e:	0e 35       	cp.w	r5,r7

            Cluster = nextCluster;
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
8001be70:	fe 9b ff ea 	brhi	8001be44 <_read_sectors+0x4c>
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
8001be74:	5b f4       	cp.w	r4,-1
8001be76:	c1 a0       	breq	8001beaa <_read_sectors+0xb2>
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
8001be78:	ed 45 02 28 	st.w	r6[552],r5
    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
        return 0;

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;
8001be7c:	ed 44 02 2c 	st.w	r6[556],r4
8001be80:	08 9b       	mov	r11,r4
8001be82:	e0 6c 1d 08 	mov	r12,7432

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
8001be86:	fe b0 f8 0b 	rcall	8001ae9c <fatfs_lba_of_cluster>
8001be8a:	04 99       	mov	r9,r2
8001be8c:	f8 01 00 0b 	add	r11,r12,r1
8001be90:	00 9a       	mov	r10,r0
8001be92:	e0 6c 1d 08 	mov	r12,7432
        return count;
    else
        return 0;
}
8001be96:	fe b0 f8 18 	rcall	8001aec6 <fatfs_sector_read>
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
8001be9a:	c0 80       	breq	8001beaa <_read_sectors+0xb2>
8001be9c:	04 9c       	mov	r12,r2
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
        }
    }

    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
8001be9e:	2f fd       	sub	sp,-4
8001bea0:	d8 32       	popm	r0-r7,pc

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
8001bea2:	f8 f4 02 2c 	ld.w	r4,r12[556]
        return count;
    else
        return 0;
}
8001bea6:	5b f4       	cp.w	r4,-1
8001bea8:	ce c1       	brne	8001be80 <_read_sectors+0x88>
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001beaa:	30 02       	mov	r2,0
8001beac:	04 9c       	mov	r12,r2
8001beae:	2f fd       	sub	sp,-4
8001beb0:	d8 32       	popm	r0-r7,pc
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
8001beb2:	ee c8 ff ff 	sub	r8,r7,-1
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8001beb6:	08 38       	cp.w	r8,r4
8001beb8:	cb a1       	brne	8001be2c <_read_sectors+0x34>
8001beba:	f8 f4 02 2c 	ld.w	r4,r12[556]
8001bebe:	cb 9b       	rjmp	8001be30 <_read_sectors+0x38>

8001bec0 <_create_file>:
8001bec0:	eb cd 40 fc 	pushm	r2-r7,lr
8001bec4:	20 bd       	sub	sp,44
8001bec6:	e0 68 1d 08 	mov	r8,7432
8001beca:	18 93       	mov	r3,r12
8001becc:	70 e8       	ld.w	r8,r8[0x38]
8001bece:	58 08       	cp.w	r8,0
    struct fat_dir_entry sfEntry;
    char shortFilename[FAT_SFN_SIZE_FULL];
    int tailNum = 0;

    // No write access?
    if (!_fs.disk_io.write_media)
8001bed0:	c0 61       	brne	8001bedc <_create_file+0x1c>

    fatfs_cache_init(&_fs, file);
    
    fatfs_fat_purge(&_fs);

    return file;
8001bed2:	30 07       	mov	r7,0
}
8001bed4:	0e 9c       	mov	r12,r7
8001bed6:	2f 5d       	sub	sp,-44
8001bed8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
{
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
8001bedc:	e0 69 29 fc 	mov	r9,10748
    if (node)
8001bee0:	72 05       	ld.w	r5,r9[0x0]
8001bee2:	58 05       	cp.w	r5,0
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8001bee4:	cf 70       	breq	8001bed2 <_create_file+0x12>
        list->head = node->next;
8001bee6:	6a 08       	ld.w	r8,r5[0x0]
8001bee8:	58 08       	cp.w	r8,0
8001beea:	f0 0a 17 00 	moveq	r10,r8
8001beee:	eb f8 00 01 	ld.weq	r8,r5[0x4]
8001bef2:	f3 f8 0a 00 	st.weq	r9[0x0],r8
    else
        node->previous->next = node->next;
8001bef6:	eb fa 10 01 	ld.wne	r10,r5[0x4]
8001befa:	f1 fa 1a 01 	st.wne	r8[0x4],r10
8001befe:	eb f8 10 01 	ld.wne	r8,r5[0x4]
8001bf02:	eb fa 10 00 	ld.wne	r10,r5[0x0]

    if(!node->next)
        list->tail = node->previous;
8001bf06:	f3 fa 0a 01 	st.weq	r9[0x4],r10
    else
        node->next->previous = node->previous;
8001bf0a:	f1 fa 1a 00 	st.wne	r8[0x0],r10
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8001bf0e:	e0 64 1c fc 	mov	r4,7420
8001bf12:	68 18       	ld.w	r8,r4[0x4]
8001bf14:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001bf16:	e0 80 00 b9 	breq	8001c088 <_create_file+0x1c8>
    new_node->next = node->next;
8001bf1a:	8b 08       	st.w	r5[0x0],r8
    if (!node->next)
8001bf1c:	70 19       	ld.w	r9,r8[0x4]
        list->tail = new_node;
8001bf1e:	8b 19       	st.w	r5[0x4],r9
8001bf20:	70 19       	ld.w	r9,r8[0x4]
8001bf22:	58 09       	cp.w	r9,0
    else
        node->next->previous = new_node;
8001bf24:	e9 f5 0a 01 	st.weq	r4[0x4],r5
    node->next = new_node;
8001bf28:	f3 f5 1a 00 	st.wne	r9[0x0],r5

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
8001bf2c:	91 15       	st.w	r8[0x4],r5
    if (!_fs.disk_io.write_media)
        return NULL;

    // Allocate a new file handle
    file = _allocate_file();
    if (!file)
8001bf2e:	ea c7 04 3c 	sub	r7,r5,1084
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
8001bf32:	cd 10       	breq	8001bed4 <_create_file+0x14>
8001bf34:	ea c6 04 28 	sub	r6,r5,1064
8001bf38:	e0 6a 01 04 	mov	r10,260
8001bf3c:	30 0b       	mov	r11,0
8001bf3e:	0c 9c       	mov	r12,r6
    memset(file->filename, '\0', sizeof(file->filename));
8001bf40:	e0 a0 3c 64 	rcall	80023808 <memset>
8001bf44:	ea c5 03 24 	sub	r5,r5,804
8001bf48:	e0 6a 01 04 	mov	r10,260
8001bf4c:	30 0b       	mov	r11,0
8001bf4e:	0a 9c       	mov	r12,r5

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)filename, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
8001bf50:	e0 a0 3c 5c 	rcall	80023808 <memset>
8001bf54:	e0 68 01 04 	mov	r8,260
8001bf58:	06 9c       	mov	r12,r3
8001bf5a:	0a 99       	mov	r9,r5
8001bf5c:	10 9a       	mov	r10,r8
8001bf5e:	0c 9b       	mov	r11,r6
8001bf60:	e0 a0 0a 80 	rcall	8001d460 <fatfs_split_path>
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
8001bf64:	5b fc       	cp.w	r12,-1
8001bf66:	c1 80       	breq	8001bf96 <_create_file+0xd6>
8001bf68:	68 04       	ld.w	r4,r4[0x0]
8001bf6a:	58 04       	cp.w	r4,0
8001bf6c:	c0 51       	brne	8001bf76 <_create_file+0xb6>
8001bf6e:	c1 88       	rjmp	8001bf9e <_create_file+0xde>
8001bf70:	68 14       	ld.w	r4,r4[0x4]
    {
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
8001bf72:	58 04       	cp.w	r4,0
8001bf74:	c1 50       	breq	8001bf9e <_create_file+0xde>

        // If not the current file 
        if (openFile != file)
8001bf76:	e8 c8 04 3c 	sub	r8,r4,1084
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
8001bf7a:	10 37       	cp.w	r7,r8
8001bf7c:	cf a0       	breq	8001bf70 <_create_file+0xb0>
8001bf7e:	0c 9b       	mov	r11,r6
8001bf80:	e8 cc 04 28 	sub	r12,r4,1064
8001bf84:	e0 a0 09 1e 	rcall	8001d1c0 <fatfs_compare_names>
8001bf88:	cf 40       	breq	8001bf70 <_create_file+0xb0>
8001bf8a:	e8 cc 03 24 	sub	r12,r4,804
8001bf8e:	0a 9b       	mov	r11,r5
8001bf90:	e0 a0 09 18 	rcall	8001d1c0 <fatfs_compare_names>
    if (tailNum == 9999)
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);

        _free_file(file);
8001bf94:	ce e0       	breq	8001bf70 <_create_file+0xb0>
8001bf96:	0e 9c       	mov	r12,r7
8001bf98:	c0 ce       	rcall	8001bbb0 <_free_file>
        return NULL;
8001bf9a:	30 07       	mov	r7,0
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0] == 0)
8001bf9c:	c9 cb       	rjmp	8001bed4 <_create_file+0x14>
8001bf9e:	ef 39 00 14 	ld.ub	r9,r7[20]
8001bfa2:	30 08       	mov	r8,0
8001bfa4:	f0 09 18 00 	cp.b	r9,r8
        file->parentcluster = fatfs_get_root_cluster(&_fs);
8001bfa8:	c6 81       	brne	8001c078 <_create_file+0x1b8>
8001bfaa:	e0 6c 1d 08 	mov	r12,7432
8001bfae:	fe b0 f7 9c 	rcall	8001aee6 <fatfs_get_root_cluster>
            return NULL;
        }
    }

    // Check if same filename exists in directory
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry) == 1)
8001bfb2:	18 9b       	mov	r11,r12
8001bfb4:	8f 0c       	st.w	r7[0x0],r12
8001bfb6:	1a 99       	mov	r9,sp
8001bfb8:	0a 9a       	mov	r10,r5
8001bfba:	e0 6c 1d 08 	mov	r12,7432
8001bfbe:	fe b0 f9 03 	rcall	8001b1c4 <fatfs_get_file_entry>
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
8001bfc2:	58 1c       	cp.w	r12,1

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
8001bfc4:	ce 90       	breq	8001bf96 <_create_file+0xd6>
8001bfc6:	30 19       	mov	r9,1
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
8001bfc8:	30 06       	mov	r6,0

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
8001bfca:	ee ca ff fc 	sub	r10,r7,-4
8001bfce:	8f 16       	st.w	r7[0x4],r6
8001bfd0:	12 9b       	mov	r11,r9
8001bfd2:	e0 6c 1d 08 	mov	r12,7432
        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
8001bfd6:	e0 a0 14 53 	rcall	8001e87c <fatfs_allocate_free_space>
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
8001bfda:	18 98       	mov	r8,r12
8001bfdc:	c6 e0       	breq	8001c0b8 <_create_file+0x1f8>
8001bfde:	0c 94       	mov	r4,r6
8001bfe0:	ee c3 fd e4 	sub	r3,r7,-540
8001bfe4:	fa c2 ff e0 	sub	r2,sp,-32
8001bfe8:	c1 28       	rjmp	8001c00c <_create_file+0x14c>
8001bfea:	08 9a       	mov	r10,r4
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);

        // Check if entry exists already or not
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
8001bfec:	04 9b       	mov	r11,r2
8001bfee:	06 9c       	mov	r12,r3
8001bff0:	e0 a0 05 cc 	rcall	8001cb88 <fatfs_lfn_generate_tail>
8001bff4:	06 9a       	mov	r10,r3
8001bff6:	6e 0b       	ld.w	r11,r7[0x0]
8001bff8:	e0 6c 1d 08 	mov	r12,7432
            break;

        tailNum++;
    }
    while (tailNum < 9999);
8001bffc:	fe b0 f9 8c 	rcall	8001b314 <fatfs_sfn_exists>
8001c000:	18 96       	mov	r6,r12
    // Generate a short filename & tail
    tailNum = 0;
    do 
    {
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);
8001c002:	c1 10       	breq	8001c024 <_create_file+0x164>
8001c004:	2f f4       	sub	r4,-1
8001c006:	e0 44 27 0f 	cp.w	r4,9999

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
8001c00a:	c5 c0       	breq	8001c0c2 <_create_file+0x202>
8001c00c:	0a 9b       	mov	r11,r5
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
8001c00e:	04 9c       	mov	r12,r2
8001c010:	e0 a0 06 1e 	rcall	8001cc4c <fatfs_lfn_create_sfn>
8001c014:	58 04       	cp.w	r4,0
8001c016:	ce a1       	brne	8001bfea <_create_file+0x12a>
8001c018:	30 ba       	mov	r10,11
        tailNum++;
    }
    while (tailNum < 9999);

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
8001c01a:	04 9b       	mov	r11,r2
8001c01c:	06 9c       	mov	r12,r3
8001c01e:	e0 a0 3b 51 	rcall	800236c0 <memcpy>
        return NULL;
    }
#endif

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
8001c022:	ce 9b       	rjmp	8001bff4 <_create_file+0x134>
8001c024:	e0 44 27 0f 	cp.w	r4,9999
8001c028:	c4 d0       	breq	8001c0c2 <_create_file+0x202>
8001c02a:	1a dc       	st.w	--sp,r12
8001c02c:	0a 9a       	mov	r10,r5
8001c02e:	1a dc       	st.w	--sp,r12
8001c030:	06 99       	mov	r9,r3
8001c032:	6e 18       	ld.w	r8,r7[0x4]
8001c034:	6e 0b       	ld.w	r11,r7[0x0]
8001c036:	e0 6c 1d 08 	mov	r12,7432
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
8001c03a:	e0 a0 0f 35 	rcall	8001dea4 <fatfs_add_file_entry>
    file->file_data_dirty = 0;
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
8001c03e:	2f ed       	sub	sp,-8
8001c040:	18 95       	mov	r5,r12
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
8001c042:	58 0c       	cp.w	r12,0
8001c044:	c3 00       	breq	8001c0a4 <_create_file+0x1e4>
    file->file_data_dirty = 0;
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
8001c046:	3f f8       	mov	r8,-1
8001c048:	0e 9b       	mov	r11,r7
    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
    file->file_data_dirty = 0;
    file->filelength_changed = 0;
8001c04a:	ef 48 02 2c 	st.w	r7[556],r8
        return NULL;
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
8001c04e:	ef 48 04 30 	st.w	r7[1072],r8
    file->file_data_address = 0xFFFFFFFF;
    file->file_data_dirty = 0;
8001c052:	ef 48 02 28 	st.w	r7[552],r8

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

    fatfs_cache_init(&_fs, file);
8001c056:	8f 46       	st.w	r7[0x10],r6
8001c058:	8f 36       	st.w	r7[0xc],r6
    
    fatfs_fat_purge(&_fs);
8001c05a:	8f 26       	st.w	r7[0x8],r6
8001c05c:	ef 46 04 34 	st.w	r7[1076],r6

    return file;
}
8001c060:	e0 6c 1d 08 	mov	r12,7432
8001c064:	fe b0 fd a2 	rcall	8001bba8 <fatfs_cache_init>
    if (file->path[0] == 0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
8001c068:	e0 6c 1d 08 	mov	r12,7432
8001c06c:	e0 a0 0b 0a 	rcall	8001d680 <fatfs_fat_purge>
8001c070:	0e 9c       	mov	r12,r7
8001c072:	2f 5d       	sub	sp,-44
        {
            _free_file(file);
            return NULL;
8001c074:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8001c078:	0c 9c       	mov	r12,r6
8001c07a:	0e 9b       	mov	r11,r7
8001c07c:	fe b0 fd fc 	rcall	8001bc74 <_open_directory>
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
    new_node->next = node;
8001c080:	18 98       	mov	r8,r12
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001c082:	c1 b0       	breq	8001c0b8 <_create_file+0x1f8>
    new_node->next = node;
    if (!node->previous)
8001c084:	6e 0b       	ld.w	r11,r7[0x0]
        list->head = new_node;
8001c086:	c9 8b       	rjmp	8001bfb6 <_create_file+0xf6>
8001c088:	68 08       	ld.w	r8,r4[0x0]
8001c08a:	58 08       	cp.w	r8,0
    else
        node->previous->next = new_node;
8001c08c:	c2 10       	breq	8001c0ce <_create_file+0x20e>
8001c08e:	70 09       	ld.w	r9,r8[0x0]
    node->previous = new_node;
8001c090:	8b 18       	st.w	r5[0x4],r8
8001c092:	8b 09       	st.w	r5[0x0],r9

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
8001c094:	70 09       	ld.w	r9,r8[0x0]
8001c096:	58 09       	cp.w	r9,0
8001c098:	e9 f5 0a 00 	st.weq	r4[0x0],r5

        _free_file(file);
8001c09c:	f3 f5 1a 01 	st.wne	r9[0x4],r5
8001c0a0:	91 05       	st.w	r8[0x0],r5
8001c0a2:	c4 6b       	rjmp	8001bf2e <_create_file+0x6e>
        return NULL;
8001c0a4:	6e 1b       	ld.w	r11,r7[0x4]
    file->startcluster = 0;

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
    {
        _free_file(file);
8001c0a6:	e0 6c 1d 08 	mov	r12,7432
8001c0aa:	e0 a0 0c f1 	rcall	8001da8c <fatfs_free_cluster_chain>
        return NULL;
8001c0ae:	0e 9c       	mov	r12,r7

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
8001c0b0:	0a 97       	mov	r7,r5
8001c0b2:	fe b0 fd 7f 	rcall	8001bbb0 <_free_file>
8001c0b6:	c0 fb       	rjmp	8001bed4 <_create_file+0x14>
8001c0b8:	0e 9c       	mov	r12,r7
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8001c0ba:	10 97       	mov	r7,r8
        list->tail = node;
8001c0bc:	fe b0 fd 7a 	rcall	8001bbb0 <_free_file>
        node->previous = 0;
8001c0c0:	c0 ab       	rjmp	8001bed4 <_create_file+0x14>
8001c0c2:	6e 1b       	ld.w	r11,r7[0x4]
8001c0c4:	e0 6c 1d 08 	mov	r12,7432
8001c0c8:	e0 a0 0c e2 	rcall	8001da8c <fatfs_free_cluster_chain>
8001c0cc:	c6 5b       	rjmp	8001bf96 <_create_file+0xd6>
8001c0ce:	89 05       	st.w	r4[0x0],r5
8001c0d0:	89 15       	st.w	r4[0x4],r5
8001c0d2:	8b 18       	st.w	r5[0x4],r8
8001c0d4:	8b 08       	st.w	r5[0x0],r8
8001c0d6:	c2 cb       	rjmp	8001bf2e <_create_file+0x6e>

8001c0d8 <fl_fflush>:
8001c0d8:	eb cd 40 c0 	pushm	r6-r7,lr
8001c0dc:	e0 69 29 f8 	mov	r9,10744
8001c0e0:	18 97       	mov	r7,r12
8001c0e2:	72 08       	ld.w	r8,r9[0x0]
8001c0e4:	58 08       	cp.w	r8,0
8001c0e6:	c1 30       	breq	8001c10c <fl_fflush+0x34>
8001c0e8:	58 07       	cp.w	r7,0
8001c0ea:	c0 f0       	breq	8001c108 <fl_fflush+0x30>
8001c0ec:	e0 66 1d 08 	mov	r6,7432
8001c0f0:	6c f8       	ld.w	r8,r6[0x3c]
8001c0f2:	58 08       	cp.w	r8,0
8001c0f4:	c0 20       	breq	8001c0f8 <fl_fflush+0x20>
8001c0f6:	5d 18       	icall	r8
8001c0f8:	ee f8 04 34 	ld.w	r8,r7[1076]
8001c0fc:	58 08       	cp.w	r8,0
8001c0fe:	c2 01       	brne	8001c13e <fl_fflush+0x66>
8001c100:	6d 08       	ld.w	r8,r6[0x40]
8001c102:	58 08       	cp.w	r8,0
8001c104:	c0 20       	breq	8001c108 <fl_fflush+0x30>
8001c106:	5d 18       	icall	r8
8001c108:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8001c10c:	e0 6a 21 70 	mov	r10,8560
8001c110:	f5 48 08 84 	st.w	r10[2180],r8
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8001c114:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8001c118:	e0 6b 1c fc 	mov	r11,7420
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c11c:	97 08       	st.w	r11[0x0],r8
8001c11e:	97 18       	st.w	r11[0x4],r8
8001c120:	f4 cc f7 80 	sub	r12,r10,-2176
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c124:	e0 68 29 fc 	mov	r8,10748
8001c128:	f5 4c 04 40 	st.w	r10[1088],r12
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c12c:	f4 cb fb c4 	sub	r11,r10,-1084

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8001c130:	f5 4b 08 80 	st.w	r10[2176],r11

        // If some write data still in buffer
        if (file->file_data_dirty)
        {
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
8001c134:	91 1c       	st.w	r8[0x4],r12
8001c136:	91 0b       	st.w	r8[0x0],r11
8001c138:	30 18       	mov	r8,1
8001c13a:	93 08       	st.w	r9[0x0],r8
8001c13c:	cd 6b       	rjmp	8001c0e8 <fl_fflush+0x10>
8001c13e:	30 19       	mov	r9,1
8001c140:	ee ca fd d0 	sub	r10,r7,-560
                file->file_data_dirty = 0;
8001c144:	ee fb 04 30 	ld.w	r11,r7[1072]
8001c148:	0e 9c       	mov	r12,r7
8001c14a:	fe b0 fd db 	rcall	8001bd00 <_write_sectors>
8001c14e:	f9 b8 01 00 	movne	r8,0
8001c152:	ef f8 1b 0d 	st.wne	r7[0x434],r8
8001c156:	cd 5b       	rjmp	8001c100 <fl_fflush+0x28>

8001c158 <T.96>:
8001c158:	eb cd 40 fe 	pushm	r1-r7,lr
8001c15c:	e0 68 29 f8 	mov	r8,10744
8001c160:	18 95       	mov	r5,r12
8001c162:	16 97       	mov	r7,r11
8001c164:	70 08       	ld.w	r8,r8[0x0]
8001c166:	58 08       	cp.w	r8,0
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (buffer==NULL || file==NULL)
8001c168:	c0 c0       	breq	8001c180 <T.96+0x28>
8001c16a:	58 07       	cp.w	r7,0
8001c16c:	5f 09       	sreq	r9
8001c16e:	58 05       	cp.w	r5,0
8001c170:	5f 08       	sreq	r8
8001c172:	f3 e8 10 08 	or	r8,r9,r8
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8001c176:	c0 80       	breq	8001c186 <T.96+0x2e>
        // Increment file pointer
        file->bytenum += copyCount;
    }    

    return bytesRead;
}
8001c178:	3f f6       	mov	r6,-1
8001c17a:	0c 9c       	mov	r12,r6
8001c17c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
    int bytesRead = 0;    

    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
8001c180:	fe b0 fd 5e 	rcall	8001bc3c <fl_init>

    if (buffer==NULL || file==NULL)
        return -1;

    // No read permissions
    if (!(file->flags & FILE_READ))
8001c184:	cf 3b       	rjmp	8001c16a <T.96+0x12>
8001c186:	ef 38 04 38 	ld.ub	r8,r7[1080]
8001c18a:	ed b8 00 00 	bld	r8,0x0
    // Nothing to be done
    if (!count)
        return 0;

    // Check if read starts past end of file
    if (file->bytenum >= file->filelength)
8001c18e:	cf 51       	brne	8001c178 <T.96+0x20>
8001c190:	6e 24       	ld.w	r4,r7[0x8]
8001c192:	6e 32       	ld.w	r2,r7[0xc]
8001c194:	04 34       	cp.w	r4,r2
        return -1;

    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
8001c196:	cf 12       	brcc	8001c178 <T.96+0x20>
8001c198:	e8 c8 ff ff 	sub	r8,r4,-1
8001c19c:	10 32       	cp.w	r2,r8
        count = file->filelength - file->bytenum;
8001c19e:	c4 d2       	brcc	8001c238 <T.96+0xe0>
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8001c1a0:	08 12       	sub	r2,r4
8001c1a2:	58 02       	cp.w	r2,0
8001c1a4:	e0 8a 00 4f 	brle	8001c242 <T.96+0xea>

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
8001c1a8:	e7 d4 c0 09 	bfextu	r3,r4,0x0,0x9
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
8001c1ac:	a9 94       	lsr	r4,0x9
8001c1ae:	ee c1 fd d0 	sub	r1,r7,-560
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
8001c1b2:	30 06       	mov	r6,0
8001c1b4:	58 03       	cp.w	r3,0
8001c1b6:	c2 a1       	brne	8001c20a <T.96+0xb2>
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
8001c1b8:	c2 38       	rjmp	8001c1fe <T.96+0xa6>
8001c1ba:	30 19       	mov	r9,1
8001c1bc:	02 9a       	mov	r10,r1
8001c1be:	08 9b       	mov	r11,r4
8001c1c0:	0e 9c       	mov	r12,r7
8001c1c2:	c1 be       	rcall	8001bdf8 <_read_sectors>
8001c1c4:	cd b0       	breq	8001c17a <T.96+0x22>
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
                file->file_data_dirty = 0;
8001c1c6:	30 08       	mov	r8,0
                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
8001c1c8:	ef 44 04 30 	st.w	r7[1072],r4
                file->file_data_dirty = 0;
8001c1cc:	ef 48 04 34 	st.w	r7[1076],r8
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
8001c1d0:	e0 68 02 00 	mov	r8,512
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
8001c1d4:	e2 03 00 0b 	add	r11,r1,r3
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
8001c1d8:	f0 03 01 03 	sub	r3,r8,r3
8001c1dc:	e4 06 01 08 	sub	r8,r2,r6

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);

            // Move onto next sector and reset copy offset
            sector++;
8001c1e0:	2f f4       	sub	r4,-1
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
8001c1e2:	e6 08 0d 43 	min	r3,r3,r8
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
8001c1e6:	ea 06 00 0c 	add	r12,r5,r6
8001c1ea:	06 9a       	mov	r10,r3
8001c1ec:	e0 a0 3a 6a 	rcall	800236c0 <memcpy>
    
        // Increase total read count 
        bytesRead += copyCount;

        // Increment file pointer
        file->bytenum += copyCount;
8001c1f0:	6e 28       	ld.w	r8,r7[0x8]
8001c1f2:	06 08       	add	r8,r3
8001c1f4:	8f 28       	st.w	r7[0x8],r8
            sector++;
            offset = 0;
        }
    
        // Increase total read count 
        bytesRead += copyCount;
8001c1f6:	06 06       	add	r6,r3

        // Increment file pointer
        file->bytenum += copyCount;
8001c1f8:	30 03       	mov	r3,0
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8001c1fa:	04 36       	cp.w	r6,r2
8001c1fc:	cb f4       	brge	8001c17a <T.96+0x22>
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
8001c1fe:	e4 06 01 09 	sub	r9,r2,r6
8001c202:	e0 49 01 ff 	cp.w	r9,511
8001c206:	e0 89 00 0d 	brgt	8001c220 <T.96+0xc8>
                break;
        }
        else
        {
            // Do we need to re-read the sector?
            if (file->file_data_address != sector)
8001c20a:	ee f8 04 30 	ld.w	r8,r7[1072]
8001c20e:	10 34       	cp.w	r4,r8
8001c210:	ce 00       	breq	8001c1d0 <T.96+0x78>
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
8001c212:	ee f8 04 34 	ld.w	r8,r7[1076]
8001c216:	58 08       	cp.w	r8,0
8001c218:	cd 10       	breq	8001c1ba <T.96+0x62>
                    fl_fflush(file);
8001c21a:	0e 9c       	mov	r12,r7
8001c21c:	c5 ef       	rcall	8001c0d8 <fl_fflush>
8001c21e:	cc eb       	rjmp	8001c1ba <T.96+0x62>
8001c220:	a9 59       	asr	r9,0x9
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
        {
            // Read as many sectors as possible into target buffer
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);        
8001c222:	ea 06 00 0a 	add	r10,r5,r6
8001c226:	08 9b       	mov	r11,r4
8001c228:	0e 9c       	mov	r12,r7
8001c22a:	fe b0 fd e7 	rcall	8001bdf8 <_read_sectors>
8001c22e:	ca 60       	breq	8001c17a <T.96+0x22>
            if (sectorsRead)
8001c230:	18 04       	add	r4,r12
            {
                // We have upto one sector to copy
                copyCount = FAT_SECTOR_SIZE * sectorsRead;

                // Move onto next sector and reset copy offset
                sector+= sectorsRead;
8001c232:	f8 03 15 09 	lsl	r3,r12,0x9
            // Read as many sectors as possible into target buffer
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);        
            if (sectorsRead)
            {
                // We have upto one sector to copy
                copyCount = FAT_SECTOR_SIZE * sectorsRead;
8001c236:	cd db       	rjmp	8001c1f0 <T.96+0x98>
8001c238:	e7 d4 c0 09 	bfextu	r3,r4,0x0,0x9

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
8001c23c:	30 12       	mov	r2,1
8001c23e:	a9 94       	lsr	r4,0x9
    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
        count = file->filelength - file->bytenum;

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
8001c240:	cb 7b       	rjmp	8001c1ae <T.96+0x56>
8001c242:	30 06       	mov	r6,0

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
8001c244:	c9 bb       	rjmp	8001c17a <T.96+0x22>
8001c246:	d7 03       	nop

8001c248 <fl_fgetc>:
8001c248:	d4 01       	pushm	lr
8001c24a:	20 1d       	sub	sp,4
8001c24c:	30 08       	mov	r8,0
8001c24e:	18 9b       	mov	r11,r12
8001c250:	fa cc ff fc 	sub	r12,sp,-4
8001c254:	18 f8       	st.b	--r12,r8
8001c256:	c8 1f       	rcall	8001c158 <T.96>
8001c258:	58 1c       	cp.w	r12,1
8001c25a:	fb fc 08 03 	ld.ubeq	r12,sp[0x3]
    int res;
    uint8 data = 0;
    
    res = fl_fread(&data, 1, 1, f);
    if (res == 1)
        return (int)data;
8001c25e:	2f fd       	sub	sp,-4
    else
        return res;
}
8001c260:	d8 02       	popm	pc
8001c262:	d7 03       	nop

8001c264 <fl_fclose>:
8001c264:	eb cd 40 c0 	pushm	r6-r7,lr
void fl_fclose(void *f)
{
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
8001c268:	e0 69 29 f8 	mov	r9,10744
8001c26c:	18 97       	mov	r7,r12
8001c26e:	72 08       	ld.w	r8,r9[0x0]
8001c270:	58 08       	cp.w	r8,0

    if (file)
8001c272:	c4 30       	breq	8001c2f8 <fl_fclose+0x94>
8001c274:	58 07       	cp.w	r7,0
    {
        FL_LOCK(&_fs);
8001c276:	c3 f0       	breq	8001c2f4 <fl_fclose+0x90>
8001c278:	e0 66 1d 08 	mov	r6,7432
8001c27c:	6c f8       	ld.w	r8,r6[0x3c]
8001c27e:	58 08       	cp.w	r8,0

        // Flush un-written data to file
        fl_fflush(f);
8001c280:	c0 20       	breq	8001c284 <fl_fclose+0x20>
8001c282:	5d 18       	icall	r8
8001c284:	0e 9c       	mov	r12,r7

        // File size changed?
        if (file->filelength_changed)
8001c286:	c2 9f       	rcall	8001c0d8 <fl_fflush>
8001c288:	6e 48       	ld.w	r8,r7[0x10]
8001c28a:	58 08       	cp.w	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
8001c28c:	c4 f1       	brne	8001c32a <fl_fclose+0xc6>
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
        file->filelength_changed = 0;
8001c28e:	30 08       	mov	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
8001c290:	8f 48       	st.w	r7[0x10],r8
        file->filelength = 0;
8001c292:	8f 28       	st.w	r7[0x8],r8
        file->startcluster = 0;
8001c294:	8f 38       	st.w	r7[0xc],r8
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
8001c296:	8f 18       	st.w	r7[0x4],r8
8001c298:	ef 48 04 34 	st.w	r7[1076],r8
        }

        file->bytenum = 0;
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
8001c29c:	3f f8       	mov	r8,-1
8001c29e:	ef 48 04 30 	st.w	r7[1072],r8
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8001c2a2:	ee f8 04 3c 	ld.w	r8,r7[1084]
8001c2a6:	58 08       	cp.w	r8,0
        list->head = node->next;
    else
        node->previous->next = node->next;
8001c2a8:	c4 c0       	breq	8001c340 <fl_fclose+0xdc>
8001c2aa:	ee f9 04 40 	ld.w	r9,r7[1088]
8001c2ae:	91 19       	st.w	r8[0x4],r9
8001c2b0:	ee f9 04 40 	ld.w	r9,r7[1088]
8001c2b4:	ee f8 04 3c 	ld.w	r8,r7[1084]

    if(!node->next)
8001c2b8:	58 09       	cp.w	r9,0
        list->tail = node->previous;
    else
        node->next->previous = node->previous;
8001c2ba:	c4 a0       	breq	8001c34e <fl_fclose+0xea>
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8001c2bc:	93 08       	st.w	r9[0x0],r8
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8001c2be:	e0 6b 29 fc 	mov	r11,10748
8001c2c2:	ee c9 fb c4 	sub	r9,r7,-1084
8001c2c6:	76 18       	ld.w	r8,r11[0x4]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c2c8:	58 08       	cp.w	r8,0
8001c2ca:	c4 60       	breq	8001c356 <fl_fclose+0xf2>
    new_node->next = node->next;
8001c2cc:	ef 48 04 3c 	st.w	r7[1084],r8
8001c2d0:	70 1a       	ld.w	r10,r8[0x4]
    if (!node->next)
8001c2d2:	ef 4a 04 40 	st.w	r7[1088],r10
        list->tail = new_node;
8001c2d6:	70 1a       	ld.w	r10,r8[0x4]
8001c2d8:	58 0a       	cp.w	r10,0
    else
        node->next->previous = new_node;
8001c2da:	f7 f9 0a 01 	st.weq	r11[0x4],r9
    node->next = new_node;
8001c2de:	f5 f9 1a 00 	st.wne	r10[0x0],r9
        file->filelength_changed = 0;

        // Free file handle
        _free_file(file);

        fatfs_fat_purge(&_fs);
8001c2e2:	91 19       	st.w	r8[0x4],r9
8001c2e4:	e0 6c 1d 08 	mov	r12,7432

        FL_UNLOCK(&_fs);
8001c2e8:	e0 a0 09 cc 	rcall	8001d680 <fatfs_fat_purge>
8001c2ec:	6d 08       	ld.w	r8,r6[0x40]
8001c2ee:	58 08       	cp.w	r8,0
8001c2f0:	c0 20       	breq	8001c2f4 <fl_fclose+0x90>

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001c2f2:	5d 18       	icall	r8
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8001c2f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001c2f8:	e0 6a 21 70 	mov	r10,8560
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8001c2fc:	f5 48 08 84 	st.w	r10[2180],r8
8001c300:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8001c304:	e0 6b 1c fc 	mov	r11,7420
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c308:	97 08       	st.w	r11[0x0],r8
8001c30a:	97 18       	st.w	r11[0x4],r8
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c30c:	f4 cc f7 80 	sub	r12,r10,-2176
8001c310:	e0 68 29 fc 	mov	r8,10748
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c314:	f5 4c 04 40 	st.w	r10[1088],r12

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8001c318:	f4 cb fb c4 	sub	r11,r10,-1084
8001c31c:	f5 4b 08 80 	st.w	r10[2176],r11
        // File size changed?
        if (file->filelength_changed)
        {
#if FATFS_INC_WRITE_SUPPORT
            // Update filesize in directory
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
8001c320:	91 1c       	st.w	r8[0x4],r12
8001c322:	91 0b       	st.w	r8[0x0],r11
8001c324:	30 18       	mov	r8,1
8001c326:	93 08       	st.w	r9[0x0],r8
8001c328:	ca 6b       	rjmp	8001c274 <fl_fclose+0x10>
8001c32a:	6e 39       	ld.w	r9,r7[0xc]
#endif
            file->filelength_changed = 0;
8001c32c:	ee ca fd e4 	sub	r10,r7,-540
8001c330:	6e 0b       	ld.w	r11,r7[0x0]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8001c332:	e0 6c 1d 08 	mov	r12,7432
8001c336:	fe b0 f9 95 	rcall	8001b660 <fatfs_update_file_length>
    else
        node->previous->next = node->next;

    if(!node->next)
8001c33a:	30 08       	mov	r8,0
8001c33c:	8f 48       	st.w	r7[0x10],r8
        list->tail = node->previous;
8001c33e:	ca 8b       	rjmp	8001c28e <fl_fclose+0x2a>
8001c340:	ee f9 04 40 	ld.w	r9,r7[1088]
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8001c344:	e0 6a 1c fc 	mov	r10,7420
8001c348:	95 09       	st.w	r10[0x0],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001c34a:	58 09       	cp.w	r9,0
    new_node->next = node;
8001c34c:	cb 81       	brne	8001c2bc <fl_fclose+0x58>
8001c34e:	e0 69 1c fc 	mov	r9,7420
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001c352:	93 18       	st.w	r9[0x4],r8
    new_node->next = node;
    if (!node->previous)
8001c354:	cb 5b       	rjmp	8001c2be <fl_fclose+0x5a>
        list->head = new_node;
8001c356:	76 08       	ld.w	r8,r11[0x0]
8001c358:	58 08       	cp.w	r8,0
8001c35a:	c0 e0       	breq	8001c376 <fl_fclose+0x112>
    else
        node->previous->next = new_node;
8001c35c:	70 0a       	ld.w	r10,r8[0x0]
8001c35e:	ef 48 04 40 	st.w	r7[1088],r8
    node->previous = new_node;
8001c362:	ef 4a 04 3c 	st.w	r7[1084],r10
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8001c366:	70 0a       	ld.w	r10,r8[0x0]
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8001c368:	58 0a       	cp.w	r10,0
8001c36a:	f7 f9 0a 00 	st.weq	r11[0x0],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001c36e:	f5 f9 1a 01 	st.wne	r10[0x4],r9
8001c372:	91 09       	st.w	r8[0x0],r9
8001c374:	cb 8b       	rjmp	8001c2e4 <fl_fclose+0x80>
8001c376:	97 19       	st.w	r11[0x4],r9
8001c378:	97 09       	st.w	r11[0x0],r9
8001c37a:	ef 48 04 40 	st.w	r7[1088],r8
8001c37e:	ef 48 04 3c 	st.w	r7[1084],r8
8001c382:	cb 1b       	rjmp	8001c2e4 <fl_fclose+0x80>

8001c384 <fl_attach_media>:
8001c384:	eb cd 40 80 	pushm	r7,lr
8001c388:	e0 6a 29 f8 	mov	r10,10744
8001c38c:	18 98       	mov	r8,r12
8001c38e:	74 09       	ld.w	r9,r10[0x0]
8001c390:	58 09       	cp.w	r9,0
8001c392:	c1 00       	breq	8001c3b2 <fl_attach_media+0x2e>
    int res;

    // If first call to library, initialise
    CHECK_FL_INIT();

    _fs.disk_io.read_media = rd;
8001c394:	e0 6c 1d 08 	mov	r12,7432
    _fs.disk_io.write_media = wr;

    // Initialise FAT parameters
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
8001c398:	99 d8       	st.w	r12[0x34],r8
8001c39a:	99 eb       	st.w	r12[0x38],r11
8001c39c:	fe b0 f5 a8 	rcall	8001aeec <fatfs_init>
	    print_dbg_hex(res);
	    print_dbg("\r\n");
        return res;
    }

    _filelib_valid = 1;
8001c3a0:	18 97       	mov	r7,r12
8001c3a2:	c2 11       	brne	8001c3e4 <fl_attach_media+0x60>
    return FAT_INIT_OK;
}
8001c3a4:	30 19       	mov	r9,1
	    print_dbg_hex(res);
	    print_dbg("\r\n");
        return res;
    }

    _filelib_valid = 1;
8001c3a6:	e0 68 1d 04 	mov	r8,7428
    return FAT_INIT_OK;
}
8001c3aa:	0e 9c       	mov	r12,r7
8001c3ac:	91 09       	st.w	r8[0x0],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
8001c3ae:	e3 cd 80 80 	ldm	sp++,r7,pc

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001c3b2:	e0 6c 21 70 	mov	r12,8560
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
8001c3b6:	f9 49 08 84 	st.w	r12[2180],r9
8001c3ba:	f9 49 04 3c 	st.w	r12[1084],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c3be:	e0 6e 1c fc 	mov	lr,7420
8001c3c2:	9d 09       	st.w	lr[0x0],r9
8001c3c4:	9d 19       	st.w	lr[0x4],r9
    new_node->next = node->next;
    if (!node->next)
8001c3c6:	f8 c7 fb c4 	sub	r7,r12,-1084
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c3ca:	e0 69 29 fc 	mov	r9,10748
8001c3ce:	f9 47 08 80 	st.w	r12[2176],r7

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8001c3d2:	f8 ce f7 80 	sub	lr,r12,-2176
8001c3d6:	f9 4e 04 40 	st.w	r12[1088],lr

    // Initialise FAT parameters
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
    {
      //        FAT_PRINTF(("FAT_FS: Error could not load FAT details (%d)!\r\n", res));
            print_dbg("FAT_FS: Error could not load FAT details!\r\n");
8001c3da:	93 1e       	st.w	r9[0x4],lr
8001c3dc:	93 07       	st.w	r9[0x0],r7
	    print_dbg("error number: ");
8001c3de:	30 19       	mov	r9,1
8001c3e0:	95 09       	st.w	r10[0x0],r9
8001c3e2:	cd 9b       	rjmp	8001c394 <fl_attach_media+0x10>
	    print_dbg_hex(res);
8001c3e4:	48 8c       	lddpc	r12,8001c404 <fl_attach_media+0x80>
8001c3e6:	fe b0 b5 db 	rcall	80012f9c <print_dbg>
	    print_dbg("\r\n");
8001c3ea:	48 8c       	lddpc	r12,8001c408 <fl_attach_media+0x84>
8001c3ec:	fe b0 b5 d8 	rcall	80012f9c <print_dbg>
        return res;
    }

    _filelib_valid = 1;
    return FAT_INIT_OK;
}
8001c3f0:	0e 9c       	mov	r12,r7
8001c3f2:	fe b0 b5 fd 	rcall	80012fec <print_dbg_hex>
8001c3f6:	48 6c       	lddpc	r12,8001c40c <fl_attach_media+0x88>
8001c3f8:	fe b0 b5 d2 	rcall	80012f9c <print_dbg>
8001c3fc:	0e 9c       	mov	r12,r7
8001c3fe:	e3 cd 80 80 	ldm	sp++,r7,pc
8001c402:	d7 03       	nop
8001c404:	80 02       	ld.sh	r2,r0[0x0]
8001c406:	52 a0       	stdsp	sp[0xa8],r0
8001c408:	80 02       	ld.sh	r2,r0[0x0]
8001c40a:	52 cc       	stdsp	sp[0xb0],r12
8001c40c:	80 02       	ld.sh	r2,r0[0x0]
8001c40e:	52 dc       	stdsp	sp[0xb4],r12

8001c410 <_open_file>:
8001c410:	eb cd 40 fe 	pushm	r1-r7,lr
8001c414:	20 8d       	sub	sp,32
8001c416:	e0 61 29 fc 	mov	r1,10748
8001c41a:	18 92       	mov	r2,r12
8001c41c:	62 06       	ld.w	r6,r1[0x0]
8001c41e:	58 06       	cp.w	r6,0
8001c420:	e0 80 00 f0 	breq	8001c600 <_open_file+0x1f0>
8001c424:	6c 08       	ld.w	r8,r6[0x0]
8001c426:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8001c428:	f0 09 17 00 	moveq	r9,r8
8001c42c:	ed f8 00 01 	ld.weq	r8,r6[0x4]
8001c430:	e3 f8 0a 00 	st.weq	r1[0x0],r8
    else
        node->previous->next = node->next;
8001c434:	ed f9 10 01 	ld.wne	r9,r6[0x4]
8001c438:	f1 f9 1a 01 	st.wne	r8[0x4],r9
8001c43c:	ed f8 10 01 	ld.wne	r8,r6[0x4]
8001c440:	ed f9 10 00 	ld.wne	r9,r6[0x0]

    if(!node->next)
        list->tail = node->previous;
8001c444:	e3 f9 0a 01 	st.weq	r1[0x4],r9
    else
        node->next->previous = node->previous;
8001c448:	f1 f9 1a 00 	st.wne	r8[0x0],r9
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8001c44c:	e0 63 1c fc 	mov	r3,7420
8001c450:	66 18       	ld.w	r8,r3[0x4]
8001c452:	58 08       	cp.w	r8,0
8001c454:	e0 80 00 db 	breq	8001c60a <_open_file+0x1fa>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c458:	8d 08       	st.w	r6[0x0],r8
    new_node->next = node->next;
8001c45a:	70 19       	ld.w	r9,r8[0x4]
8001c45c:	8d 19       	st.w	r6[0x4],r9
    if (!node->next)
8001c45e:	70 19       	ld.w	r9,r8[0x4]
        list->tail = new_node;
8001c460:	58 09       	cp.w	r9,0
8001c462:	e7 f6 0a 01 	st.weq	r3[0x4],r6
    else
        node->next->previous = new_node;
8001c466:	f3 f6 1a 00 	st.wne	r9[0x0],r6
    node->next = new_node;
8001c46a:	91 16       	st.w	r8[0x4],r6

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
8001c46c:	ec c7 04 3c 	sub	r7,r6,1084
    FL_FILE* file; 
    struct fat_dir_entry sfEntry;

    // Allocate a new file handle
    file = _allocate_file();
    if (!file)
8001c470:	c3 60       	breq	8001c4dc <_open_file+0xcc>
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
8001c472:	ec c5 04 28 	sub	r5,r6,1064
8001c476:	e0 6a 01 04 	mov	r10,260
8001c47a:	30 0b       	mov	r11,0
8001c47c:	0a 9c       	mov	r12,r5
8001c47e:	e0 a0 39 c5 	rcall	80023808 <memset>
    memset(file->filename, '\0', sizeof(file->filename));
8001c482:	ec c4 03 24 	sub	r4,r6,804
8001c486:	e0 6a 01 04 	mov	r10,260
8001c48a:	30 0b       	mov	r11,0
8001c48c:	08 9c       	mov	r12,r4
8001c48e:	e0 a0 39 bd 	rcall	80023808 <memset>

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)path, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
8001c492:	e0 68 01 04 	mov	r8,260
8001c496:	04 9c       	mov	r12,r2
8001c498:	08 99       	mov	r9,r4
8001c49a:	10 9a       	mov	r10,r8
8001c49c:	0a 9b       	mov	r11,r5
8001c49e:	e0 a0 07 e1 	rcall	8001d460 <fatfs_split_path>
8001c4a2:	5b fc       	cp.w	r12,-1
8001c4a4:	c1 80       	breq	8001c4d4 <_open_file+0xc4>
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
8001c4a6:	66 02       	ld.w	r2,r3[0x0]
8001c4a8:	58 02       	cp.w	r2,0
8001c4aa:	c0 51       	brne	8001c4b4 <_open_file+0xa4>
8001c4ac:	c1 c8       	rjmp	8001c4e4 <_open_file+0xd4>
8001c4ae:	64 12       	ld.w	r2,r2[0x4]
8001c4b0:	58 02       	cp.w	r2,0
8001c4b2:	c1 90       	breq	8001c4e4 <_open_file+0xd4>
    {
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
8001c4b4:	e4 c8 04 3c 	sub	r8,r2,1084

        // If not the current file 
        if (openFile != file)
8001c4b8:	10 37       	cp.w	r7,r8
8001c4ba:	cf a0       	breq	8001c4ae <_open_file+0x9e>
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
8001c4bc:	0a 9b       	mov	r11,r5
8001c4be:	e4 cc 04 28 	sub	r12,r2,1064
8001c4c2:	e0 a0 06 7f 	rcall	8001d1c0 <fatfs_compare_names>
8001c4c6:	cf 40       	breq	8001c4ae <_open_file+0x9e>
8001c4c8:	e4 cc 03 24 	sub	r12,r2,804
8001c4cc:	08 9b       	mov	r11,r4
8001c4ce:	e0 a0 06 79 	rcall	8001d1c0 <fatfs_compare_names>
8001c4d2:	ce e0       	breq	8001c4ae <_open_file+0x9e>
    }

    // Check if file already open
    if (_check_file_open(file))
    {
        _free_file(file);
8001c4d4:	0e 9c       	mov	r12,r7
8001c4d6:	fe b0 fb 6d 	rcall	8001bbb0 <_free_file>
8001c4da:	30 07       	mov	r7,0
            return file;
        }

    _free_file(file);
    return NULL;
}
8001c4dc:	0e 9c       	mov	r12,r7
8001c4de:	2f 8d       	sub	sp,-32
8001c4e0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
8001c4e4:	ef 39 00 14 	ld.ub	r9,r7[20]
8001c4e8:	30 08       	mov	r8,0
8001c4ea:	f0 09 18 00 	cp.b	r9,r8
8001c4ee:	c5 70       	breq	8001c59c <_open_file+0x18c>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
8001c4f0:	0a 9c       	mov	r12,r5
8001c4f2:	0e 9b       	mov	r11,r7
8001c4f4:	fe b0 fb c0 	rcall	8001bc74 <_open_directory>
8001c4f8:	18 98       	mov	r8,r12
8001c4fa:	e0 80 00 ab 	breq	8001c650 <_open_file+0x240>
        {
            _free_file(file);
            return NULL;
8001c4fe:	6e 0b       	ld.w	r11,r7[0x0]
        }
    }

    // Using dir cluster address search for filename
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry))
8001c500:	08 9a       	mov	r10,r4
8001c502:	1a 95       	mov	r5,sp
8001c504:	e0 6c 1d 08 	mov	r12,7432
8001c508:	1a 99       	mov	r9,sp
8001c50a:	fe b0 f6 5d 	rcall	8001b1c4 <fatfs_get_file_entry>
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
8001c50e:	c4 e0       	breq	8001c5aa <_open_file+0x19a>
8001c510:	1a 9c       	mov	r12,sp
8001c512:	e0 a0 02 90 	rcall	8001ca32 <fatfs_entry_is_file>
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
8001c516:	c4 a0       	breq	8001c5aa <_open_file+0x19a>
8001c518:	1a 9b       	mov	r11,sp
8001c51a:	30 ba       	mov	r10,11
8001c51c:	ee cc fd e4 	sub	r12,r7,-540
8001c520:	e0 a0 38 d0 	rcall	800236c0 <memcpy>
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
8001c524:	40 7a       	lddsp	r10,sp[0x1c]
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
8001c526:	3f f8       	mov	r8,-1
8001c528:	14 9c       	mov	r12,r10
8001c52a:	f4 06 15 18 	lsl	r6,r10,0x18
8001c52e:	e6 1c 00 ff 	andh	r12,0xff,COH
8001c532:	ed ea 13 86 	or	r6,r6,r10>>0x18
8001c536:	e2 1a ff 00 	andl	r10,0xff00,COH
8001c53a:	ed ea 10 8a 	or	r10,r6,r10<<0x8
8001c53e:	f5 ec 12 8a 	or	r10,r10,r12>>0x8
8001c542:	30 09       	mov	r9,0
            file->bytenum = 0;
8001c544:	8f 3a       	st.w	r7[0xc],r10
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8001c546:	8f 29       	st.w	r7[0x8],r9
8001c548:	fb 16 00 14 	ld.uh	r6,sp[20]
8001c54c:	fb 1a 00 1a 	ld.uh	r10,sp[26]
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
8001c550:	ef 48 02 2c 	st.w	r7[556],r8
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
8001c554:	ef 48 04 30 	st.w	r7[1072],r8
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
8001c558:	ef 48 02 28 	st.w	r7[552],r8
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
8001c55c:	ec 08 15 08 	lsl	r8,r6,0x8
8001c560:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8001c564:	f1 e6 12 86 	or	r6,r8,r6>>0x8
8001c568:	f4 08 15 08 	lsl	r8,r10,0x8
8001c56c:	b1 66       	lsl	r6,0x10
8001c56e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8001c572:	f1 ea 12 8a 	or	r10,r8,r10>>0x8
8001c576:	ec 0a 00 0a 	add	r10,r6,r10
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
            file->filelength_changed = 0;
8001c57a:	0e 9b       	mov	r11,r7
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
8001c57c:	8f 49       	st.w	r7[0x10],r9
8001c57e:	ef 49 04 34 	st.w	r7[1076],r9

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

            fatfs_cache_init(&_fs, file);
8001c582:	8f 1a       	st.w	r7[0x4],r10
8001c584:	e0 6c 1d 08 	mov	r12,7432

            fatfs_fat_purge(&_fs);
8001c588:	fe b0 fb 10 	rcall	8001bba8 <fatfs_cache_init>
8001c58c:	e0 6c 1d 08 	mov	r12,7432
            return file;
        }

    _free_file(file);
    return NULL;
}
8001c590:	e0 a0 08 78 	rcall	8001d680 <fatfs_fat_purge>
8001c594:	0e 9c       	mov	r12,r7
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
8001c596:	2f 8d       	sub	sp,-32
8001c598:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8001c59c:	e0 6c 1d 08 	mov	r12,7432
8001c5a0:	fe b0 f4 a3 	rcall	8001aee6 <fatfs_get_root_cluster>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
8001c5a4:	18 9b       	mov	r11,r12
8001c5a6:	8f 0c       	st.w	r7[0x0],r12
8001c5a8:	ca cb       	rjmp	8001c500 <_open_file+0xf0>
8001c5aa:	6c 08       	ld.w	r8,r6[0x0]
8001c5ac:	58 08       	cp.w	r8,0
8001c5ae:	f0 09 17 00 	moveq	r9,r8
    else
        node->previous->next = node->next;
8001c5b2:	ef f8 01 10 	ld.weq	r8,r7[0x440]
8001c5b6:	e7 f8 0a 00 	st.weq	r3[0x0],r8
8001c5ba:	ef f9 11 10 	ld.wne	r9,r7[0x440]
8001c5be:	f1 f9 1a 01 	st.wne	r8[0x4],r9

    if(!node->next)
        list->tail = node->previous;
8001c5c2:	ef f8 11 10 	ld.wne	r8,r7[0x440]
    else
        node->next->previous = node->previous;
8001c5c6:	ed f9 10 00 	ld.wne	r9,r6[0x0]
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
8001c5ca:	e7 f9 0a 01 	st.weq	r3[0x4],r9
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
8001c5ce:	f1 f9 1a 00 	st.wne	r8[0x0],r9
8001c5d2:	e0 6b 29 fc 	mov	r11,10748
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c5d6:	62 18       	ld.w	r8,r1[0x4]
    new_node->next = node->next;
8001c5d8:	ee c9 fb c4 	sub	r9,r7,-1084
8001c5dc:	58 08       	cp.w	r8,0
    if (!node->next)
8001c5de:	c2 40       	breq	8001c626 <_open_file+0x216>
        list->tail = new_node;
8001c5e0:	8d 08       	st.w	r6[0x0],r8
8001c5e2:	70 1a       	ld.w	r10,r8[0x4]
8001c5e4:	ef 4a 04 40 	st.w	r7[1088],r10
    else
        node->next->previous = new_node;
8001c5e8:	70 1a       	ld.w	r10,r8[0x4]
    node->next = new_node;
8001c5ea:	58 0a       	cp.w	r10,0
8001c5ec:	f7 f9 0a 01 	st.weq	r11[0x4],r9
            return file;
        }

    _free_file(file);
    return NULL;
}
8001c5f0:	f5 f9 1a 00 	st.wne	r10[0x0],r9
8001c5f4:	30 07       	mov	r7,0
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
    if (node)
8001c5f6:	91 19       	st.w	r8[0x4],r9
8001c5f8:	0e 9c       	mov	r12,r7
8001c5fa:	2f 8d       	sub	sp,-32
8001c5fc:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8001c600:	0c 97       	mov	r7,r6
8001c602:	0e 9c       	mov	r12,r7
8001c604:	2f 8d       	sub	sp,-32
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001c606:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8001c60a:	66 08       	ld.w	r8,r3[0x0]
    new_node->next = node;
    if (!node->previous)
8001c60c:	58 08       	cp.w	r8,0
        list->head = new_node;
8001c60e:	c1 c0       	breq	8001c646 <_open_file+0x236>
8001c610:	70 09       	ld.w	r9,r8[0x0]
8001c612:	8d 18       	st.w	r6[0x4],r8
    else
        node->previous->next = new_node;
8001c614:	8d 09       	st.w	r6[0x0],r9
8001c616:	70 09       	ld.w	r9,r8[0x0]
    node->previous = new_node;
8001c618:	58 09       	cp.w	r9,0
8001c61a:	e7 f6 0a 00 	st.weq	r3[0x0],r6
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8001c61e:	f3 f6 1a 01 	st.wne	r9[0x4],r6
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
8001c622:	91 06       	st.w	r8[0x0],r6
8001c624:	c2 4b       	rjmp	8001c46c <_open_file+0x5c>
    new_node->next = node;
8001c626:	76 08       	ld.w	r8,r11[0x0]
8001c628:	58 08       	cp.w	r8,0
    if (!node->previous)
8001c62a:	c1 80       	breq	8001c65a <_open_file+0x24a>
        list->head = new_node;
8001c62c:	70 0a       	ld.w	r10,r8[0x0]
8001c62e:	8d 0a       	st.w	r6[0x0],r10
8001c630:	ef 48 04 40 	st.w	r7[1088],r8
    else
        node->previous->next = new_node;
8001c634:	70 0a       	ld.w	r10,r8[0x0]
    node->previous = new_node;
8001c636:	58 0a       	cp.w	r10,0
8001c638:	f7 f9 0a 00 	st.weq	r11[0x0],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8001c63c:	f5 f9 1a 01 	st.wne	r10[0x4],r9
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8001c640:	91 09       	st.w	r8[0x0],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
8001c642:	30 07       	mov	r7,0
8001c644:	c4 cb       	rjmp	8001c4dc <_open_file+0xcc>
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
        {
            _free_file(file);
8001c646:	87 06       	st.w	r3[0x0],r6
8001c648:	87 16       	st.w	r3[0x4],r6
8001c64a:	8d 18       	st.w	r6[0x4],r8
8001c64c:	8d 08       	st.w	r6[0x0],r8
            return NULL;
8001c64e:	c0 fb       	rjmp	8001c46c <_open_file+0x5c>
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
8001c650:	0e 9c       	mov	r12,r7
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8001c652:	10 97       	mov	r7,r8
        list->tail = node;
        node->previous = 0;
8001c654:	fe b0 fa ae 	rcall	8001bbb0 <_free_file>
        node->next = 0;
8001c658:	c4 2b       	rjmp	8001c4dc <_open_file+0xcc>
8001c65a:	97 19       	st.w	r11[0x4],r9
8001c65c:	97 09       	st.w	r11[0x0],r9
8001c65e:	8d 08       	st.w	r6[0x0],r8
8001c660:	ef 48 04 40 	st.w	r7[1088],r8
8001c664:	10 97       	mov	r7,r8
8001c666:	c3 bb       	rjmp	8001c4dc <_open_file+0xcc>

8001c668 <fl_fopen>:
8001c668:	eb cd 40 fc 	pushm	r2-r7,lr
8001c66c:	20 1d       	sub	sp,4
8001c66e:	e0 69 29 f8 	mov	r9,10744
8001c672:	18 97       	mov	r7,r12
8001c674:	72 08       	ld.w	r8,r9[0x0]
8001c676:	58 08       	cp.w	r8,0
8001c678:	c0 a0       	breq	8001c68c <fl_fopen+0x24>
8001c67a:	e0 68 1d 04 	mov	r8,7428
8001c67e:	70 08       	ld.w	r8,r8[0x0]
8001c680:	58 08       	cp.w	r8,0
8001c682:	c2 21       	brne	8001c6c6 <fl_fopen+0x5e>
8001c684:	30 0c       	mov	r12,0
8001c686:	2f fd       	sub	sp,-4
8001c688:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001c68c:	e0 6a 21 70 	mov	r10,8560
8001c690:	f5 48 08 84 	st.w	r10[2180],r8
8001c694:	f5 48 04 3c 	st.w	r10[1084],r8
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
    if (!node->next)
8001c698:	e0 6c 1c fc 	mov	r12,7420
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c69c:	99 08       	st.w	r12[0x0],r8
8001c69e:	99 18       	st.w	r12[0x4],r8
8001c6a0:	f4 c6 f7 80 	sub	r6,r10,-2176
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8001c6a4:	e0 68 29 fc 	mov	r8,10748
8001c6a8:	f5 46 04 40 	st.w	r10[1088],r6
    new_node->next = node->next;
    if (!node->next)
        list->tail = new_node;
    else
        node->next->previous = new_node;
    node->next = new_node;
8001c6ac:	f4 cc fb c4 	sub	r12,r10,-1084

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8001c6b0:	f5 4c 08 80 	st.w	r10[2176],r12
    uint8 flags = 0;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (!_filelib_valid)
8001c6b4:	91 16       	st.w	r8[0x4],r6
8001c6b6:	91 0c       	st.w	r8[0x0],r12
8001c6b8:	30 18       	mov	r8,1
        return NULL;

    if (!path || !mode)
8001c6ba:	93 08       	st.w	r9[0x0],r8
8001c6bc:	e0 68 1d 04 	mov	r8,7428
8001c6c0:	70 08       	ld.w	r8,r8[0x0]
8001c6c2:	58 08       	cp.w	r8,0
8001c6c4:	ce 00       	breq	8001c684 <fl_fopen+0x1c>
8001c6c6:	58 0b       	cp.w	r11,0
    FL_UNLOCK(&_fs);
}
//-----------------------------------------------------------------------------
// fopen: Open or Create a file for reading or writing
//-----------------------------------------------------------------------------
void* fl_fopen(const char *path, const char *mode)
8001c6c8:	5f 09       	sreq	r9
8001c6ca:	58 07       	cp.w	r7,0
8001c6cc:	5f 08       	sreq	r8
8001c6ce:	f3 e8 10 08 	or	r8,r9,r8
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
    {
        switch (mode[i])
8001c6d2:	cd 91       	brne	8001c684 <fl_fopen+0x1c>
    FL_UNLOCK(&_fs);
}
//-----------------------------------------------------------------------------
// fopen: Open or Create a file for reading or writing
//-----------------------------------------------------------------------------
void* fl_fopen(const char *path, const char *mode)
8001c6d4:	16 9c       	mov	r12,r11
8001c6d6:	50 0b       	stdsp	sp[0x0],r11
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c6d8:	e0 a0 39 06 	rcall	800238e4 <strlen>
    {
        switch (mode[i])
8001c6dc:	30 06       	mov	r6,0
8001c6de:	4b 6a       	lddpc	r10,8001c7b4 <fl_fopen+0x14c>
8001c6e0:	0c 98       	mov	r8,r6
8001c6e2:	40 0b       	lddsp	r11,sp[0x0]
8001c6e4:	18 38       	cp.w	r8,r12
8001c6e6:	c1 e4       	brge	8001c722 <fl_fopen+0xba>
8001c6e8:	f6 08 07 09 	ld.ub	r9,r11[r8]
8001c6ec:	22 b9       	sub	r9,43
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
8001c6ee:	e0 49 00 4c 	cp.w	r9,76
8001c6f2:	e0 8b 00 08 	brhi	8001c702 <fl_fopen+0x9a>
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c6f6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
            break;
        case 'w':
        case 'W':
            flags |= FILE_WRITE;
            flags |= FILE_ERASE;
            flags |= FILE_CREATE;
8001c6fa:	ed b6 00 00 	bld	r6,0x0
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c6fe:	c3 81       	brne	8001c76e <fl_fopen+0x106>
8001c700:	a1 b6       	sbr	r6,0x1
    {
        switch (mode[i])
        {
        case 'r':
        case 'R':
            flags |= FILE_READ;
8001c702:	2f f8       	sub	r8,-1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c704:	cf 0b       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c706:	e8 16 00 32 	orl	r6,0x32
8001c70a:	2f f8       	sub	r8,-1
8001c70c:	ce cb       	rjmp	8001c6e4 <fl_fopen+0x7c>
            break;
        case 'a':
        case 'A':
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
8001c70e:	a1 a6       	sbr	r6,0x0
8001c710:	2f f8       	sub	r8,-1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c712:	ce 9b       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c714:	a3 b6       	sbr	r6,0x3
    // No write support!
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
8001c716:	2f f8       	sub	r8,-1
8001c718:	ce 6b       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c71a:	e8 16 00 26 	orl	r6,0x26
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);

    FL_LOCK(&_fs);
8001c71e:	2f f8       	sub	r8,-1
8001c720:	ce 2b       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c722:	e0 65 1d 08 	mov	r5,7432

    // Read
    if (flags & FILE_READ)
8001c726:	6a e8       	ld.w	r8,r5[0x38]
8001c728:	58 08       	cp.w	r8,0
8001c72a:	c3 d0       	breq	8001c7a4 <fl_fopen+0x13c>
        file = _open_file(path);

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
8001c72c:	6a f8       	ld.w	r8,r5[0x3c]
8001c72e:	58 08       	cp.w	r8,0
8001c730:	c0 20       	breq	8001c734 <fl_fopen+0xcc>
8001c732:	5d 18       	icall	r8
8001c734:	e9 d6 c0 01 	bfextu	r4,r6,0x0,0x1
        file = _create_file(path);
#endif

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
8001c738:	c2 91       	brne	8001c78a <fl_fopen+0x122>
        if ((flags & FILE_CREATE) && !file)
8001c73a:	0c 93       	mov	r3,r6
8001c73c:	e2 13 00 20 	andl	r3,0x20,COH
8001c740:	c3 51       	brne	8001c7aa <fl_fopen+0x142>
8001c742:	06 92       	mov	r2,r3
8001c744:	58 04       	cp.w	r4,0
8001c746:	c2 c1       	brne	8001c79e <fl_fopen+0x136>
8001c748:	58 03       	cp.w	r3,0
            if (flags & (FILE_WRITE | FILE_APPEND))
8001c74a:	5f 18       	srne	r8
8001c74c:	58 02       	cp.w	r2,0
8001c74e:	5f 09       	sreq	r9
8001c750:	10 69       	and	r9,r8
8001c752:	e8 09 18 00 	cp.b	r9,r4
                file = _open_file(path);

    if (file)
        file->flags = flags;

    FL_UNLOCK(&_fs);
8001c756:	c2 40       	breq	8001c79e <fl_fopen+0x136>
8001c758:	0c 98       	mov	r8,r6
8001c75a:	e2 18 00 06 	andl	r8,0x6,COH
8001c75e:	c1 d1       	brne	8001c798 <fl_fopen+0x130>
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
8001c760:	08 92       	mov	r2,r4
8001c762:	6b 08       	ld.w	r8,r5[0x40]
8001c764:	58 08       	cp.w	r8,0
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
            }
            else if (flags & FILE_APPEND)
8001c766:	c0 20       	breq	8001c76a <fl_fopen+0x102>
8001c768:	5d 18       	icall	r8
8001c76a:	04 9c       	mov	r12,r2
            {
                flags |= FILE_READ;
                flags |= FILE_WRITE;
                flags |= FILE_APPEND;
                flags |= FILE_CREATE;
8001c76c:	c8 db       	rjmp	8001c686 <fl_fopen+0x1e>
8001c76e:	ed b6 00 01 	bld	r6,0x1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c772:	c0 80       	breq	8001c782 <fl_fopen+0x11a>
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
8001c774:	ed b6 00 02 	bld	r6,0x2
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
8001c778:	cc 51       	brne	8001c702 <fl_fopen+0x9a>
8001c77a:	e8 16 00 27 	orl	r6,0x27

    FL_LOCK(&_fs);

    // Read
    if (flags & FILE_READ)
        file = _open_file(path);
8001c77e:	2f f8       	sub	r8,-1
8001c780:	cb 2b       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c782:	e8 16 00 31 	orl	r6,0x31
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);

    if (file)
        file->flags = flags;
8001c786:	2f f8       	sub	r8,-1
8001c788:	ca eb       	rjmp	8001c6e4 <fl_fopen+0x7c>
8001c78a:	0e 9c       	mov	r12,r7

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);
8001c78c:	c4 2e       	rcall	8001c410 <_open_file>
8001c78e:	18 92       	mov	r2,r12
8001c790:	cd 50       	breq	8001c73a <fl_fopen+0xd2>
8001c792:	e5 66 04 38 	st.b	r2[1080],r6

    if (file)
8001c796:	ce 6b       	rjmp	8001c762 <fl_fopen+0xfa>
8001c798:	0e 9c       	mov	r12,r7
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
8001c79a:	c3 be       	rcall	8001c410 <_open_file>
8001c79c:	18 92       	mov	r2,r12
8001c79e:	58 02       	cp.w	r2,0
        file = _open_file(path);

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
        file = _create_file(path);
8001c7a0:	cf 91       	brne	8001c792 <fl_fopen+0x12a>
8001c7a2:	ce 0b       	rjmp	8001c762 <fl_fopen+0xfa>
8001c7a4:	e2 16 00 d9 	andl	r6,0xd9,COH
8001c7a8:	cc 2b       	rjmp	8001c72c <fl_fopen+0xc4>
8001c7aa:	0e 9c       	mov	r12,r7
8001c7ac:	fe b0 fb 8a 	rcall	8001bec0 <_create_file>
8001c7b0:	18 92       	mov	r2,r12
8001c7b2:	cc 9b       	rjmp	8001c744 <fl_fopen+0xdc>
8001c7b4:	80 02       	ld.sh	r2,r0[0x0]
8001c7b6:	51 6c       	stdsp	sp[0x58],r12

8001c7b8 <fatfs_lfn_cache_entry>:
// fatfs_lfn_cache_entry - Function extracts long file name text from sector 
// at a specific offset
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
8001c7b8:	d4 01       	pushm	lr
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
8001c7ba:	31 48       	mov	r8,20
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;
8001c7bc:	17 89       	ld.ub	r9,r11[0x0]
8001c7be:	f3 d9 c0 05 	bfextu	r9,r9,0x0,0x5

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
8001c7c2:	f0 09 18 00 	cp.b	r9,r8
8001c7c6:	e0 8b 00 c8 	brhi	8001c956 <fatfs_lfn_cache_entry+0x19e>
        return ;

    // This is an error condition
    if (LFNIndex == 0)
8001c7ca:	58 09       	cp.w	r9,0
8001c7cc:	e0 80 00 c5 	breq	8001c956 <fatfs_lfn_cache_entry+0x19e>
        return ;

    if (lfn->no_of_strings == 0) 
8001c7d0:	30 08       	mov	r8,0
8001c7d2:	f9 3a 01 05 	ld.ub	r10,r12[261]
        lfn->no_of_strings = LFNIndex;
8001c7d6:	f0 0a 18 00 	cp.b	r10,r8
8001c7da:	f9 f9 0f 05 	st.beq	r12[0x105],r9

    lfn->String[LFNIndex-1][0] = entryBuffer[1];
8001c7de:	20 19       	sub	r9,1
8001c7e0:	f2 09 00 18 	add	r8,r9,r9<<0x1
8001c7e4:	17 9e       	ld.ub	lr,r11[0x1]
8001c7e6:	f2 08 00 29 	add	r9,r9,r8<<0x2
8001c7ea:	f8 09 00 08 	add	r8,r12,r9
8001c7ee:	10 9a       	mov	r10,r8
8001c7f0:	14 ce       	st.b	r10++,lr
    lfn->String[LFNIndex-1][1] = entryBuffer[3];
8001c7f2:	17 be       	ld.ub	lr,r11[0x3]
8001c7f4:	b4 8e       	st.b	r10[0x0],lr
    lfn->String[LFNIndex-1][2] = entryBuffer[5];
8001c7f6:	17 da       	ld.ub	r10,r11[0x5]
8001c7f8:	b0 aa       	st.b	r8[0x2],r10
    lfn->String[LFNIndex-1][3] = entryBuffer[7];
8001c7fa:	17 fa       	ld.ub	r10,r11[0x7]
8001c7fc:	b0 ba       	st.b	r8[0x3],r10
    lfn->String[LFNIndex-1][4] = entryBuffer[9];
8001c7fe:	f7 3a 00 09 	ld.ub	r10,r11[9]
8001c802:	b0 ca       	st.b	r8[0x4],r10
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
8001c804:	f7 3a 00 0e 	ld.ub	r10,r11[14]
8001c808:	b0 da       	st.b	r8[0x5],r10
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
8001c80a:	f7 3a 00 10 	ld.ub	r10,r11[16]
8001c80e:	b0 ea       	st.b	r8[0x6],r10
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
8001c810:	f7 3a 00 12 	ld.ub	r10,r11[18]
8001c814:	b0 fa       	st.b	r8[0x7],r10
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
8001c816:	f7 3a 00 14 	ld.ub	r10,r11[20]
8001c81a:	f1 6a 00 08 	st.b	r8[8],r10
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
8001c81e:	f7 3a 00 16 	ld.ub	r10,r11[22]
8001c822:	f1 6a 00 09 	st.b	r8[9],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
8001c826:	f7 3a 00 18 	ld.ub	r10,r11[24]
8001c82a:	f1 6a 00 0a 	st.b	r8[10],r10
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
8001c82e:	f7 3a 00 1c 	ld.ub	r10,r11[28]
8001c832:	f1 6a 00 0b 	st.b	r8[11],r10
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
8001c836:	f7 3a 00 1e 	ld.ub	r10,r11[30]

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c83a:	11 8b       	ld.ub	r11,r8[0x0]
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
8001c83c:	f1 6a 00 0c 	st.b	r8[12],r10

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c840:	3f fa       	mov	r10,-1
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c842:	f4 0b 18 00 	cp.b	r11,r10
8001c846:	f9 ba 00 20 	moveq	r10,32
8001c84a:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c84e:	f8 09 00 08 	add	r8,r12,r9
8001c852:	3f fa       	mov	r10,-1
8001c854:	2f f8       	sub	r8,-1
8001c856:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c858:	f4 0b 18 00 	cp.b	r11,r10
8001c85c:	f9 ba 00 20 	moveq	r10,32
8001c860:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c864:	f8 09 00 08 	add	r8,r12,r9
8001c868:	3f fa       	mov	r10,-1
8001c86a:	2f e8       	sub	r8,-2
8001c86c:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c86e:	f4 0b 18 00 	cp.b	r11,r10
8001c872:	f9 ba 00 20 	moveq	r10,32
8001c876:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c87a:	f8 09 00 08 	add	r8,r12,r9
8001c87e:	3f fa       	mov	r10,-1
8001c880:	2f d8       	sub	r8,-3
8001c882:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c884:	f4 0b 18 00 	cp.b	r11,r10
8001c888:	f9 ba 00 20 	moveq	r10,32
8001c88c:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c890:	f8 09 00 08 	add	r8,r12,r9
8001c894:	3f fa       	mov	r10,-1
8001c896:	2f c8       	sub	r8,-4
8001c898:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c89a:	f4 0b 18 00 	cp.b	r11,r10
8001c89e:	f9 ba 00 20 	moveq	r10,32
8001c8a2:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c8a6:	f8 09 00 08 	add	r8,r12,r9
8001c8aa:	3f fa       	mov	r10,-1
8001c8ac:	2f b8       	sub	r8,-5
8001c8ae:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c8b0:	f4 0b 18 00 	cp.b	r11,r10
8001c8b4:	f9 ba 00 20 	moveq	r10,32
8001c8b8:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c8bc:	f8 09 00 08 	add	r8,r12,r9
8001c8c0:	3f fa       	mov	r10,-1
8001c8c2:	2f a8       	sub	r8,-6
8001c8c4:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c8c6:	f4 0b 18 00 	cp.b	r11,r10
8001c8ca:	f9 ba 00 20 	moveq	r10,32
8001c8ce:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c8d2:	f8 09 00 08 	add	r8,r12,r9
8001c8d6:	3f fa       	mov	r10,-1
8001c8d8:	2f 98       	sub	r8,-7
8001c8da:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c8dc:	f4 0b 18 00 	cp.b	r11,r10
8001c8e0:	f9 ba 00 20 	moveq	r10,32
8001c8e4:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c8e8:	f8 09 00 08 	add	r8,r12,r9
8001c8ec:	3f fa       	mov	r10,-1
8001c8ee:	2f 88       	sub	r8,-8
8001c8f0:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c8f2:	f4 0b 18 00 	cp.b	r11,r10
8001c8f6:	f9 ba 00 20 	moveq	r10,32
8001c8fa:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c8fe:	f8 09 00 08 	add	r8,r12,r9
8001c902:	3f fa       	mov	r10,-1
8001c904:	2f 78       	sub	r8,-9
8001c906:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c908:	f4 0b 18 00 	cp.b	r11,r10
8001c90c:	f9 ba 00 20 	moveq	r10,32
8001c910:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c914:	f8 09 00 08 	add	r8,r12,r9
8001c918:	3f fa       	mov	r10,-1
8001c91a:	2f 68       	sub	r8,-10
8001c91c:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c91e:	f4 0b 18 00 	cp.b	r11,r10
8001c922:	f9 ba 00 20 	moveq	r10,32
8001c926:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c92a:	f8 09 00 08 	add	r8,r12,r9
8001c92e:	3f fa       	mov	r10,-1
8001c930:	2f 58       	sub	r8,-11
8001c932:	11 8b       	ld.ub	r11,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c934:	f4 0b 18 00 	cp.b	r11,r10
8001c938:	f9 ba 00 20 	moveq	r10,32
8001c93c:	f1 fa 0e 00 	st.beq	r8[0x0],r10
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
8001c940:	f8 09 00 09 	add	r9,r12,r9
8001c944:	3f f8       	mov	r8,-1
8001c946:	2f 49       	sub	r9,-12
8001c948:	13 8a       	ld.ub	r10,r9[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
8001c94a:	f0 0a 18 00 	cp.b	r10,r8
8001c94e:	f9 b8 00 20 	moveq	r8,32
8001c952:	f3 f8 0e 00 	st.beq	r9[0x0],r8
8001c956:	d8 02       	popm	pc

8001c958 <fatfs_lfn_cache_get>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
8001c958:	f9 38 01 05 	ld.ub	r8,r12[261]
8001c95c:	31 49       	mov	r9,20
8001c95e:	f2 08 18 00 	cp.b	r8,r9
8001c962:	c0 e0       	breq	8001c97e <fatfs_lfn_cache_get+0x26>
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
8001c964:	58 08       	cp.w	r8,0
8001c966:	c0 31       	brne	8001c96c <fatfs_lfn_cache_get+0x14>
        lfn->String[lfn->no_of_strings][0] = '\0';
    else
        lfn->String[0][0] = '\0';
8001c968:	b8 88       	st.b	r12[0x0],r8

    return (char*)&lfn->String[0][0];
}
8001c96a:	5e fc       	retal	r12
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
        lfn->String[lfn->no_of_strings][0] = '\0';
8001c96c:	f0 08 00 19 	add	r9,r8,r8<<0x1
8001c970:	f0 09 00 28 	add	r8,r8,r9<<0x2
8001c974:	30 09       	mov	r9,0
8001c976:	f8 08 00 08 	add	r8,r12,r8
8001c97a:	b0 89       	st.b	r8[0x0],r9
8001c97c:	5e fc       	retal	r12
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
8001c97e:	30 08       	mov	r8,0
8001c980:	f9 68 01 04 	st.b	r12[260],r8
8001c984:	5e fc       	retal	r12

8001c986 <fatfs_entry_lfn_text>:
//-----------------------------------------------------------------------------
// fatfs_entry_lfn_text: If LFN text entry found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_text(struct fat_dir_entry *entry)
{
8001c986:	f9 38 00 0b 	ld.ub	r8,r12[11]
8001c98a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8001c98e:	58 f8       	cp.w	r8,15
    if ((entry->Attr & FILE_ATTR_LFN_TEXT) == FILE_ATTR_LFN_TEXT) 
        return 1;
    else 
        return 0;
}
8001c990:	5f 0c       	sreq	r12
8001c992:	5e fc       	retal	r12

8001c994 <fatfs_entry_lfn_invalid>:
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8001c994:	3e 58       	mov	r8,-27
8001c996:	19 89       	ld.ub	r9,r12[0x0]
8001c998:	f0 09 18 00 	cp.b	r9,r8
8001c99c:	5f 0a       	sreq	r10
8001c99e:	30 08       	mov	r8,0
8001c9a0:	f0 09 18 00 	cp.b	r9,r8
8001c9a4:	5f 09       	sreq	r9
8001c9a6:	f5 e9 10 09 	or	r9,r10,r9
8001c9aa:	f0 09 18 00 	cp.b	r9,r8
8001c9ae:	c0 b1       	brne	8001c9c4 <fatfs_entry_lfn_invalid+0x30>
         (entry->Name[0]==FILE_HEADER_DELETED)||
         (entry->Attr==FILE_ATTR_VOLUME_ID) || 
8001c9b0:	f9 38 00 0b 	ld.ub	r8,r12[11]
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8001c9b4:	30 89       	mov	r9,8
8001c9b6:	f2 08 18 00 	cp.b	r8,r9
8001c9ba:	c0 50       	breq	8001c9c4 <fatfs_entry_lfn_invalid+0x30>
8001c9bc:	e2 18 00 06 	andl	r8,0x6,COH
8001c9c0:	5f 1c       	srne	r12
8001c9c2:	5e fc       	retal	r12
8001c9c4:	5e ff       	retal	1

8001c9c6 <fatfs_entry_lfn_exists>:
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8001c9c6:	f7 38 00 0b 	ld.ub	r8,r11[11]
8001c9ca:	30 f9       	mov	r9,15
8001c9cc:	f2 08 18 00 	cp.b	r8,r9
8001c9d0:	c1 50       	breq	8001c9fa <fatfs_entry_lfn_exists+0x34>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
8001c9d2:	17 89       	ld.ub	r9,r11[0x0]
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8001c9d4:	58 09       	cp.w	r9,0
8001c9d6:	c1 20       	breq	8001c9fa <fatfs_entry_lfn_exists+0x34>
8001c9d8:	3e 5a       	mov	r10,-27
8001c9da:	f4 09 18 00 	cp.b	r9,r10
8001c9de:	c0 e0       	breq	8001c9fa <fatfs_entry_lfn_exists+0x34>
8001c9e0:	30 89       	mov	r9,8
8001c9e2:	f2 08 18 00 	cp.b	r8,r9
8001c9e6:	c0 a0       	breq	8001c9fa <fatfs_entry_lfn_exists+0x34>
8001c9e8:	e2 18 00 06 	andl	r8,0x6,COH
8001c9ec:	c0 71       	brne	8001c9fa <fatfs_entry_lfn_exists+0x34>
8001c9ee:	f9 39 01 05 	ld.ub	r9,r12[261]
8001c9f2:	f0 09 18 00 	cp.b	r9,r8
8001c9f6:	5f 1c       	srne	r12
8001c9f8:	5e fc       	retal	r12
8001c9fa:	5e fd       	retal	0

8001c9fc <fatfs_entry_sfn_only>:
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8001c9fc:	f9 38 00 0b 	ld.ub	r8,r12[11]
8001ca00:	30 f9       	mov	r9,15
8001ca02:	f2 08 18 00 	cp.b	r8,r9
8001ca06:	c1 00       	breq	8001ca26 <fatfs_entry_sfn_only+0x2a>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
8001ca08:	19 89       	ld.ub	r9,r12[0x0]
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8001ca0a:	58 09       	cp.w	r9,0
8001ca0c:	c0 d0       	breq	8001ca26 <fatfs_entry_sfn_only+0x2a>
8001ca0e:	3e 5a       	mov	r10,-27
8001ca10:	f4 09 18 00 	cp.b	r9,r10
8001ca14:	c0 90       	breq	8001ca26 <fatfs_entry_sfn_only+0x2a>
8001ca16:	30 89       	mov	r9,8
8001ca18:	f2 08 18 00 	cp.b	r8,r9
8001ca1c:	c0 50       	breq	8001ca26 <fatfs_entry_sfn_only+0x2a>
8001ca1e:	e2 18 00 06 	andl	r8,0x6,COH
8001ca22:	5f 0c       	sreq	r12
8001ca24:	5e fc       	retal	r12
8001ca26:	5e fd       	retal	0

8001ca28 <fatfs_entry_is_dir>:
// TODO: FILE_ATTR_SYSHID ?!?!??!
//-----------------------------------------------------------------------------
// fatfs_entry_is_dir: Returns 1 if a directory
//-----------------------------------------------------------------------------
int fatfs_entry_is_dir(struct fat_dir_entry *entry)
{
8001ca28:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_DIR) 
        return 1;
    else 
        return 0;
}
8001ca2c:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8001ca30:	5e fc       	retal	r12

8001ca32 <fatfs_entry_is_file>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_file: Returns 1 is a file entry
//-----------------------------------------------------------------------------
int fatfs_entry_is_file(struct fat_dir_entry *entry)
{
8001ca32:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_FILE) 
        return 1;
    else 
        return 0;
}
8001ca36:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
8001ca3a:	5e fc       	retal	r12

8001ca3c <fatfs_sfn_create_entry>:
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
8001ca3c:	eb cd 40 e0 	pushm	r5-r7,lr
#endif
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
8001ca40:	f8 c7 ff fc 	sub	r7,r12,-4
8001ca44:	0e 39       	cp.w	r9,r7
8001ca46:	5f b5       	srhi	r5
8001ca48:	f2 ce ff fc 	sub	lr,r9,-4
8001ca4c:	1c 3c       	cp.w	r12,lr
8001ca4e:	5f b6       	srhi	r6
8001ca50:	eb e6 10 06 	or	r6,r5,r6
8001ca54:	f3 ec 10 05 	or	r5,r9,r12
8001ca58:	eb d5 c0 02 	bfextu	r5,r5,0x0,0x2
8001ca5c:	5f 05       	sreq	r5
8001ca5e:	eb e6 00 06 	and	r6,r5,r6
8001ca62:	c6 70       	breq	8001cb30 <fatfs_sfn_create_entry+0xf4>
{
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
8001ca64:	78 06       	ld.w	r6,r12[0x0]
8001ca66:	93 06       	st.w	r9[0x0],r6
8001ca68:	6e 07       	ld.w	r7,r7[0x0]
8001ca6a:	9d 07       	st.w	lr[0x0],r7
8001ca6c:	f9 3e 00 08 	ld.ub	lr,r12[8]
8001ca70:	f3 6e 00 08 	st.b	r9[8],lr
8001ca74:	f9 3e 00 09 	ld.ub	lr,r12[9]
8001ca78:	f3 6e 00 09 	st.b	r9[9],lr
8001ca7c:	f9 3c 00 0a 	ld.ub	r12,r12[10]
8001ca80:	f3 6c 00 0a 	st.b	r9[10],r12

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
8001ca84:	30 0c       	mov	r12,0
    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;
8001ca86:	30 0e       	mov	lr,0
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
8001ca88:	f3 6c 00 19 	st.b	r9[25],r12
    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
8001ca8c:	f3 6c 00 0d 	st.b	r9[13],r12
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
8001ca90:	f3 6c 00 0e 	st.b	r9[14],r12
8001ca94:	f3 6c 00 0f 	st.b	r9[15],r12
    entry->CrtDate[1] = 0x00;
8001ca98:	f3 6c 00 11 	st.b	r9[17],r12
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
8001ca9c:	f3 6c 00 13 	st.b	r9[19],r12
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
8001caa0:	f3 6c 00 16 	st.b	r9[22],r12
8001caa4:	f3 6c 00 17 	st.b	r9[23],r12

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
8001caa8:	32 0c       	mov	r12,32
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    

    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
8001caaa:	58 08       	cp.w	r8,0
8001caac:	f3 fc 0e 0b 	st.beq	r9[0xb],r12
    else
        entry->Attr = FILE_TYPE_DIR;
8001cab0:	f9 b8 01 10 	movne	r8,16
8001cab4:	f3 f8 1e 0b 	st.bne	r9[0xb],r8

    entry->NTRes = 0x00;
8001cab8:	f3 6e 00 0c 	st.b	r9[12],lr

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
8001cabc:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
8001cac0:	b1 8a       	lsr	r10,0x10
8001cac2:	f4 0e 16 08 	lsr	lr,r10,0x8
8001cac6:	fd ea 10 8a 	or	r10,lr,r10<<0x8
8001caca:	5c 7a       	castu.h	r10
8001cacc:	f3 6a 00 15 	st.b	r9[21],r10
8001cad0:	a9 8a       	lsr	r10,0x8
8001cad2:	f3 6a 00 14 	st.b	r9[20],r10
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
8001cad6:	f0 0a 16 08 	lsr	r10,r8,0x8
8001cada:	f5 e8 10 88 	or	r8,r10,r8<<0x8
8001cade:	5c 78       	castu.h	r8
8001cae0:	f3 68 00 1b 	st.b	r9[27],r8
8001cae4:	a9 88       	lsr	r8,0x8
8001cae6:	f3 68 00 1a 	st.b	r9[26],r8
    entry->FileSize = FAT_HTONL(size);
8001caea:	f6 08 15 18 	lsl	r8,r11,0x18
8001caee:	f1 eb 13 88 	or	r8,r8,r11>>0x18

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
8001caf2:	f3 6c 00 10 	st.b	r9[16],r12
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
8001caf6:	f3 6c 00 12 	st.b	r9[18],r12
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    
8001cafa:	f3 6c 00 18 	st.b	r9[24],r12

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
    entry->FileSize = FAT_HTONL(size);
8001cafe:	16 9c       	mov	r12,r11
8001cb00:	e2 1b ff 00 	andl	r11,0xff00,COH
8001cb04:	e6 1c 00 ff 	andh	r12,0xff,COH
8001cb08:	f1 eb 10 8b 	or	r11,r8,r11<<0x8
8001cb0c:	f7 ec 12 8b 	or	r11,r11,r12>>0x8
8001cb10:	f6 08 16 18 	lsr	r8,r11,0x18
8001cb14:	f3 6b 00 1f 	st.b	r9[31],r11
8001cb18:	f3 68 00 1c 	st.b	r9[28],r8
8001cb1c:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
8001cb20:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
8001cb24:	f3 68 00 1d 	st.b	r9[29],r8
8001cb28:	f3 6b 00 1e 	st.b	r9[30],r11
}
8001cb2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
{
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
8001cb30:	19 8e       	ld.ub	lr,r12[0x0]
8001cb32:	b2 8e       	st.b	r9[0x0],lr
8001cb34:	19 9e       	ld.ub	lr,r12[0x1]
8001cb36:	b2 9e       	st.b	r9[0x1],lr
8001cb38:	19 ae       	ld.ub	lr,r12[0x2]
8001cb3a:	b2 ae       	st.b	r9[0x2],lr
8001cb3c:	19 be       	ld.ub	lr,r12[0x3]
8001cb3e:	b2 be       	st.b	r9[0x3],lr
8001cb40:	19 ce       	ld.ub	lr,r12[0x4]
8001cb42:	b2 ce       	st.b	r9[0x4],lr
8001cb44:	19 de       	ld.ub	lr,r12[0x5]
8001cb46:	b2 de       	st.b	r9[0x5],lr
8001cb48:	19 ee       	ld.ub	lr,r12[0x6]
8001cb4a:	b2 ee       	st.b	r9[0x6],lr
8001cb4c:	19 fe       	ld.ub	lr,r12[0x7]
8001cb4e:	b2 fe       	st.b	r9[0x7],lr
8001cb50:	c8 eb       	rjmp	8001ca6c <fatfs_sfn_create_entry+0x30>

8001cb52 <fatfs_lfn_cache_init>:
//-----------------------------------------------------------------------------
void fatfs_lfn_cache_init(struct lfn_cache *lfn, int wipeTable)
{
    int i = 0;

    lfn->no_of_strings = 0;
8001cb52:	30 08       	mov	r8,0
8001cb54:	f9 68 01 05 	st.b	r12[261],r8

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
8001cb58:	58 0b       	cp.w	r11,0
8001cb5a:	5e 0c       	reteq	r12
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
            memset(lfn->String[i], 0x00, MAX_LFN_ENTRY_LENGTH);
8001cb5c:	30 0a       	mov	r10,0
8001cb5e:	14 99       	mov	r9,r10
8001cb60:	f8 0a 00 08 	add	r8,r12,r10
8001cb64:	10 c9       	st.b	r8++,r9
8001cb66:	10 c9       	st.b	r8++,r9
8001cb68:	10 c9       	st.b	r8++,r9
8001cb6a:	10 c9       	st.b	r8++,r9
8001cb6c:	10 c9       	st.b	r8++,r9
8001cb6e:	10 c9       	st.b	r8++,r9
8001cb70:	10 c9       	st.b	r8++,r9
8001cb72:	10 c9       	st.b	r8++,r9
8001cb74:	10 c9       	st.b	r8++,r9
8001cb76:	10 c9       	st.b	r8++,r9
8001cb78:	10 c9       	st.b	r8++,r9
8001cb7a:	10 c9       	st.b	r8++,r9
8001cb7c:	b0 89       	st.b	r8[0x0],r9
8001cb7e:	2f 3a       	sub	r10,-13

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
8001cb80:	e0 4a 01 04 	cp.w	r10,260
8001cb84:	ce e1       	brne	8001cb60 <fatfs_lfn_cache_init+0xe>
8001cb86:	5e fc       	retal	r12

8001cb88 <fatfs_lfn_generate_tail>:
// sfn_output = Output short filename with tail
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_generate_tail(char *sfn_output, char *sfn_input, uint32 tailNum)
{
8001cb88:	eb cd 40 fc 	pushm	r2-r7,lr
8001cb8c:	20 bd       	sub	sp,44
8001cb8e:	18 96       	mov	r6,r12
    int tail_chars;
    char tail_str[12];

    if (tailNum > 99999)
8001cb90:	e0 5a 86 9f 	cp.w	r10,99999
8001cb94:	e0 88 00 05 	brls	8001cb9e <fatfs_lfn_generate_tail+0x16>
8001cb98:	2f 5d       	sub	sp,-44
8001cb9a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
8001cb9e:	30 09       	mov	r9,0
8001cba0:	fa c7 ff e0 	sub	r7,sp,-32
8001cba4:	30 08       	mov	r8,0
8001cba6:	ee e9 00 00 	st.d	r7[0],r8
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8001cbaa:	4a 89       	lddpc	r9,8001cc48 <fatfs_lfn_generate_tail+0xc0>
8001cbac:	f3 3c 00 10 	ld.ub	r12,r9[16]
8001cbb0:	fb 6c 00 10 	st.b	sp[16],r12

    if (tailNum > 99999)
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
8001cbb4:	30 0c       	mov	r12,0
8001cbb6:	8f 2c       	st.w	r7[0x8],r12
    tail_str[0] = '~';
8001cbb8:	37 ec       	mov	r12,126
8001cbba:	fb 6c 00 20 	st.b	sp[32],r12
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8001cbbe:	f2 e4 00 00 	ld.d	r4,r9[0]
8001cbc2:	fa e5 00 00 	st.d	sp[0],r4
8001cbc6:	f2 e4 00 08 	ld.d	r4,r9[8]
8001cbca:	fa e5 00 08 	st.d	sp[8],r4
8001cbce:	fa c5 ff ec 	sub	r5,sp,-20
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
8001cbd2:	e0 64 cc cd 	mov	r4,52429
8001cbd6:	ea 14 cc cc 	orh	r4,0xcccc
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
8001cbda:	0a 99       	mov	r9,r5
8001cbdc:	c0 28       	rjmp	8001cbe0 <fatfs_lfn_generate_tail+0x58>
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
    } 
    while ((num /= 10) > 0);
8001cbde:	10 99       	mov	r9,r8
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
8001cbe0:	f4 04 06 42 	mulu.d	r2,r10,r4
8001cbe4:	e6 0c 16 03 	lsr	r12,r3,0x3
8001cbe8:	f8 0c 00 2e 	add	lr,r12,r12<<0x2
8001cbec:	12 98       	mov	r8,r9
8001cbee:	f4 0e 01 1a 	sub	r10,r10,lr<<0x1
8001cbf2:	fa ce ff d4 	sub	lr,sp,-44
8001cbf6:	fc 0a 00 0a 	add	r10,lr,r10
8001cbfa:	f5 3a ff d4 	ld.ub	r10,r10[-44]
8001cbfe:	10 ca       	st.b	r8++,r10
    } 
    while ((num /= 10) > 0);
8001cc00:	18 9a       	mov	r10,r12
8001cc02:	58 0c       	cp.w	r12,0
8001cc04:	ce d1       	brne	8001cbde <fatfs_lfn_generate_tail+0x56>
    
    *cp-- = 0;
8001cc06:	b0 8c       	st.b	r8[0x0],r12

    // Copy in forwards
    while (cp >= outbuf)
8001cc08:	0a 39       	cp.w	r9,r5
8001cc0a:	c1 c3       	brcs	8001cc42 <fatfs_lfn_generate_tail+0xba>
8001cc0c:	fa c8 ff df 	sub	r8,sp,-33
        *s++ = *cp--;
8001cc10:	13 8a       	ld.ub	r10,r9[0x0]
8001cc12:	10 ca       	st.b	r8++,r10
8001cc14:	20 19       	sub	r9,1
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
8001cc16:	0a 39       	cp.w	r9,r5
8001cc18:	cf c2       	brcc	8001cc10 <fatfs_lfn_generate_tail+0x88>
        *s++ = *cp--;

    *s = 0;
8001cc1a:	30 09       	mov	r9,0
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
8001cc1c:	30 ba       	mov	r10,11

    // Copy in forwards
    while (cp >= outbuf)
        *s++ = *cp--;

    *s = 0;
8001cc1e:	b0 89       	st.b	r8[0x0],r9
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
8001cc20:	0c 9c       	mov	r12,r6
8001cc22:	e0 a0 35 4f 	rcall	800236c0 <memcpy>
       
    // Overwrite with tail
    tail_chars = (int)strlen(tail_str);
8001cc26:	0e 9c       	mov	r12,r7
8001cc28:	e0 a0 36 5e 	rcall	800238e4 <strlen>
    memcpy(sfn_output+(FAT_SFN_SIZE_PARTIAL-tail_chars), tail_str, tail_chars);
8001cc2c:	0e 9b       	mov	r11,r7
8001cc2e:	18 9a       	mov	r10,r12
8001cc30:	f8 0c 11 08 	rsub	r12,r12,8
8001cc34:	ec 0c 00 0c 	add	r12,r6,r12
8001cc38:	e0 a0 35 44 	rcall	800236c0 <memcpy>
8001cc3c:	2f 5d       	sub	sp,-44
8001cc3e:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
8001cc42:	fa c8 ff df 	sub	r8,sp,-33
8001cc46:	ce ab       	rjmp	8001cc1a <fatfs_lfn_generate_tail+0x92>
8001cc48:	80 02       	ld.sh	r2,r0[0x0]
8001cc4a:	52 e0       	stdsp	sp[0xb8],r0

8001cc4c <fatfs_lfn_create_sfn>:
8001cc4c:	eb cd 40 fc 	pushm	r2-r7,lr
8001cc50:	20 1d       	sub	sp,4
8001cc52:	16 97       	mov	r7,r11
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
{
8001cc54:	18 94       	mov	r4,r12
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8001cc56:	16 9c       	mov	r12,r11
8001cc58:	e0 a0 36 46 	rcall	800238e4 <strlen>

    // Invalid to start with .
    if (filename[0]=='.')
8001cc5c:	32 e3       	mov	r3,46
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8001cc5e:	18 96       	mov	r6,r12

    // Invalid to start with .
    if (filename[0]=='.')
8001cc60:	0f 88       	ld.ub	r8,r7[0x0]
8001cc62:	e6 08 18 00 	cp.b	r8,r3
8001cc66:	e0 80 00 98 	breq	8001cd96 <fatfs_lfn_create_sfn+0x14a>
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
8001cc6a:	30 ba       	mov	r10,11
8001cc6c:	32 0b       	mov	r11,32
8001cc6e:	08 9c       	mov	r12,r4
8001cc70:	e0 a0 35 cc 	rcall	80023808 <memset>
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8001cc74:	0c 95       	mov	r5,r6
    // Invalid to start with .
    if (filename[0]=='.')
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    memset(ext, ' ', 3);
8001cc76:	30 3a       	mov	r10,3
8001cc78:	32 0b       	mov	r11,32
8001cc7a:	1a 9c       	mov	r12,sp
8001cc7c:	e0 a0 35 c6 	rcall	80023808 <memset>

    // Find dot seperator
    for (i = 0; i< len; i++)
8001cc80:	58 06       	cp.w	r6,0
8001cc82:	e0 8a 00 62 	brle	8001cd46 <fatfs_lfn_create_sfn+0xfa>
8001cc86:	3f f9       	mov	r9,-1
8001cc88:	30 08       	mov	r8,0
8001cc8a:	ee 08 07 0a 	ld.ub	r10,r7[r8]
8001cc8e:	e6 0a 18 00 	cp.b	r10,r3
8001cc92:	f0 09 17 00 	moveq	r9,r8
8001cc96:	2f f8       	sub	r8,-1
8001cc98:	10 36       	cp.w	r6,r8
8001cc9a:	cf 81       	brne	8001cc8a <fatfs_lfn_create_sfn+0x3e>
        if (filename[i]=='.')
            dotPos = i;
    }

    // Extract extensions
    if (dotPos!=-1)
8001cc9c:	5b f9       	cp.w	r9,-1
8001cc9e:	c2 b0       	breq	8001ccf4 <fatfs_lfn_create_sfn+0xa8>
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8001cca0:	f2 c8 ff ff 	sub	r8,r9,-1
            if (i<len)
8001cca4:	10 36       	cp.w	r6,r8
8001cca6:	e0 8a 00 0a 	brle	8001ccba <fatfs_lfn_create_sfn+0x6e>
                ext[i-(dotPos+1)] = filename[i];
8001ccaa:	fa ca ff fc 	sub	r10,sp,-4
8001ccae:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8001ccb2:	10 0a       	add	r10,r8
8001ccb4:	12 1a       	sub	r10,r9
8001ccb6:	f5 6b ff fb 	st.b	r10[-5],r11

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8001ccba:	2f f8       	sub	r8,-1
            if (i<len)
8001ccbc:	10 36       	cp.w	r6,r8
8001ccbe:	e0 8a 00 0a 	brle	8001ccd2 <fatfs_lfn_create_sfn+0x86>
                ext[i-(dotPos+1)] = filename[i];
8001ccc2:	fa ca ff fc 	sub	r10,sp,-4
8001ccc6:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8001ccca:	10 0a       	add	r10,r8
8001cccc:	12 1a       	sub	r10,r9
8001ccce:	f5 6b ff fb 	st.b	r10[-5],r11

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
8001ccd2:	2f f8       	sub	r8,-1
            if (i<len)
8001ccd4:	10 36       	cp.w	r6,r8
8001ccd6:	e0 8a 00 0b 	brle	8001ccec <fatfs_lfn_create_sfn+0xa0>
                ext[i-(dotPos+1)] = filename[i];
8001ccda:	ee 08 07 0a 	ld.ub	r10,r7[r8]
8001ccde:	fa cb ff fc 	sub	r11,sp,-4
8001cce2:	f6 08 00 08 	add	r8,r11,r8
8001cce6:	12 18       	sub	r8,r9
8001cce8:	f1 6a ff fb 	st.b	r8[-5],r10
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8001ccec:	58 09       	cp.w	r9,0
8001ccee:	e0 8a 00 2c 	brle	8001cd46 <fatfs_lfn_create_sfn+0xfa>
8001ccf2:	12 95       	mov	r5,r9
8001ccf4:	30 0a       	mov	r10,0
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8001ccf6:	32 ee       	mov	lr,46
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8001ccf8:	14 99       	mov	r9,r10
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8001ccfa:	32 03       	mov	r3,32
8001ccfc:	14 96       	mov	r6,r10
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
8001ccfe:	31 92       	mov	r2,25
8001cd00:	c0 98       	rjmp	8001cd12 <fatfs_lfn_create_sfn+0xc6>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
8001cd02:	e8 0a 0b 0c 	st.b	r4[r10],r12
8001cd06:	2f fa       	sub	r10,-1
            else
                sfn_output[pos++] = filename[i];
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
8001cd08:	58 8a       	cp.w	r10,8
8001cd0a:	c1 e0       	breq	8001cd46 <fatfs_lfn_create_sfn+0xfa>
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
8001cd0c:	2f f9       	sub	r9,-1
8001cd0e:	0a 39       	cp.w	r9,r5
8001cd10:	c1 b4       	brge	8001cd46 <fatfs_lfn_create_sfn+0xfa>
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
8001cd12:	ee 09 07 08 	ld.ub	r8,r7[r9]
8001cd16:	fc 08 18 00 	cp.b	r8,lr
8001cd1a:	5f 1c       	srne	r12
8001cd1c:	e6 08 18 00 	cp.b	r8,r3
8001cd20:	5f 1b       	srne	r11
8001cd22:	f9 eb 00 0b 	and	r11,r12,r11
8001cd26:	ec 0b 18 00 	cp.b	r11,r6
8001cd2a:	ce f0       	breq	8001cd08 <fatfs_lfn_create_sfn+0xbc>
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
                sfn_output[pos++] = filename[i] - 'a' + 'A';
8001cd2c:	f0 cc 00 20 	sub	r12,r8,32
    pos = 0; 
    for (i=0;i<len;i++)
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
8001cd30:	f0 cb 00 61 	sub	r11,r8,97
8001cd34:	e4 0b 18 00 	cp.b	r11,r2
8001cd38:	fe 98 ff e5 	brls	8001cd02 <fatfs_lfn_create_sfn+0xb6>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
            else
                sfn_output[pos++] = filename[i];
8001cd3c:	e8 0a 0b 08 	st.b	r4[r10],r8
8001cd40:	2f fa       	sub	r10,-1
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
8001cd42:	58 8a       	cp.w	r10,8
8001cd44:	ce 41       	brne	8001cd0c <fatfs_lfn_create_sfn+0xc0>
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8001cd46:	1b 88       	ld.ub	r8,sp[0x0]
8001cd48:	31 99       	mov	r9,25
8001cd4a:	f0 ca 00 61 	sub	r10,r8,97
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8001cd4e:	f2 0a 18 00 	cp.b	r10,r9
8001cd52:	f7 b8 08 20 	subls	r8,32
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8001cd56:	31 99       	mov	r9,25
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8001cd58:	e9 68 00 08 	st.b	r4[8],r8
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8001cd5c:	1b 98       	ld.ub	r8,sp[0x1]
8001cd5e:	f0 ca 00 61 	sub	r10,r8,97
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8001cd62:	f2 0a 18 00 	cp.b	r10,r9
8001cd66:	f7 b8 08 20 	subls	r8,32
8001cd6a:	e9 68 00 09 	st.b	r4[9],r8
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8001cd6e:	31 99       	mov	r9,25
8001cd70:	1b a8       	ld.ub	r8,sp[0x2]
8001cd72:	f0 ca 00 61 	sub	r10,r8,97
8001cd76:	f2 0a 18 00 	cp.b	r10,r9
8001cd7a:	e0 88 00 07 	brls	8001cd88 <fatfs_lfn_create_sfn+0x13c>
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
8001cd7e:	e9 68 00 0a 	st.b	r4[10],r8
8001cd82:	2f fd       	sub	sp,-4
8001cd84:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8001cd88:	22 08       	sub	r8,32
8001cd8a:	30 1c       	mov	r12,1
8001cd8c:	e9 68 00 0a 	st.b	r4[10],r8
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
    }

    return 1;
}
8001cd90:	2f fd       	sub	sp,-4
8001cd92:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    char ext[3];
    int pos;
    int len = (int)strlen(filename);

    // Invalid to start with .
    if (filename[0]=='.')
8001cd96:	2f fd       	sub	sp,-4
8001cd98:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

8001cd9c <fatfs_lfn_entries_required>:
8001cd9c:	d4 01       	pushm	lr
8001cd9e:	e0 a0 35 a3 	rcall	800238e4 <strlen>
8001cda2:	c0 e0       	breq	8001cdbe <fatfs_lfn_entries_required+0x22>
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
        return (length + MAX_LFN_ENTRY_LENGTH - 1) / MAX_LFN_ENTRY_LENGTH;    
8001cda4:	f8 c8 ff f4 	sub	r8,r12,-12
8001cda8:	e0 6b ec 4f 	mov	r11,60495
8001cdac:	ea 1b 4e c4 	orh	r11,0x4ec4
8001cdb0:	f0 09 14 1f 	asr	r9,r8,0x1f
8001cdb4:	f0 0b 04 4a 	muls.d	r10,r8,r11
8001cdb8:	f6 0c 14 02 	asr	r12,r11,0x2
8001cdbc:	12 1c       	sub	r12,r9
    else
        return 0;
}
8001cdbe:	d8 02       	popm	pc

8001cdc0 <fatfs_filename_to_lfn>:
8001cdc0:	eb cd 40 fe 	pushm	r1-r7,lr
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8001cdc4:	20 dd       	sub	sp,52
8001cdc6:	14 96       	mov	r6,r10
8001cdc8:	12 91       	mov	r1,r9
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8001cdca:	fe f9 03 96 	ld.w	r9,pc[918]
8001cdce:	72 ca       	ld.w	r10,r9[0x30]
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8001cdd0:	16 97       	mov	r7,r11
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8001cdd2:	50 ca       	stdsp	sp[0x30],r10
8001cdd4:	f2 ea 00 00 	ld.d	r10,r9[0]
8001cdd8:	fa eb 00 00 	st.d	sp[0],r10
8001cddc:	f2 ea 00 08 	ld.d	r10,r9[8]
8001cde0:	fa eb 00 08 	st.d	sp[8],r10
8001cde4:	f2 ea 00 10 	ld.d	r10,r9[16]
8001cde8:	fa eb 00 10 	st.d	sp[16],r10
8001cdec:	f2 ea 00 18 	ld.d	r10,r9[24]
8001cdf0:	fa eb 00 18 	st.d	sp[24],r10
8001cdf4:	f2 ea 00 20 	ld.d	r10,r9[32]
8001cdf8:	fa eb 00 20 	st.d	sp[32],r10
8001cdfc:	f2 ea 00 28 	ld.d	r10,r9[40]
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
8001ce00:	18 93       	mov	r3,r12
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
8001ce02:	fa eb 00 28 	st.d	sp[40],r10

    // 13 characters entries
    int length = (int)strlen(filename);
8001ce06:	e0 a0 35 6f 	rcall	800238e4 <strlen>
8001ce0a:	18 95       	mov	r5,r12
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
8001ce0c:	e0 80 01 60 	breq	8001d0cc <fatfs_filename_to_lfn+0x30c>
8001ce10:	f8 c8 ff f4 	sub	r8,r12,-12
8001ce14:	e0 6b ec 4f 	mov	r11,60495
8001ce18:	ea 1b 4e c4 	orh	r11,0x4ec4
8001ce1c:	f0 09 14 1f 	asr	r9,r8,0x1f
8001ce20:	f0 0b 04 4a 	muls.d	r10,r8,r11
8001ce24:	f6 02 14 02 	asr	r2,r11,0x2
8001ce28:	12 12       	sub	r2,r9
8001ce2a:	20 12       	sub	r2,1
    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
8001ce2c:	ec 06 00 14 	add	r4,r6,r6<<0x1

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
8001ce30:	32 0a       	mov	r10,32
    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
8001ce32:	ec 04 00 24 	add	r4,r6,r4<<0x2

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
8001ce36:	30 0b       	mov	r11,0
8001ce38:	0e 9c       	mov	r12,r7
8001ce3a:	e0 a0 34 e7 	rcall	80023808 <memset>

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8001ce3e:	0c 32       	cp.w	r2,r6
8001ce40:	e0 80 01 48 	breq	8001d0d0 <fatfs_filename_to_lfn+0x310>
8001ce44:	2f f6       	sub	r6,-1
8001ce46:	5c 56       	castu.b	r6

    // LFN flag
    buffer[11] = 0x0F;
8001ce48:	30 f8       	mov	r8,15

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8001ce4a:	ae 86       	st.b	r7[0x0],r6

    // LFN flag
    buffer[11] = 0x0F;

    // Checksum of short filename
    buffer[13] = sfnChk;
8001ce4c:	ef 61 00 0d 	st.b	r7[13],r1

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));

    // LFN flag
    buffer[11] = 0x0F;
8001ce50:	ef 68 00 0b 	st.b	r7[11],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ce54:	08 35       	cp.w	r5,r4
8001ce56:	e0 89 00 9e 	brgt	8001cf92 <fatfs_filename_to_lfn+0x1d2>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001ce5a:	e0 80 01 40 	breq	8001d0da <fatfs_filename_to_lfn+0x31a>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001ce5e:	40 09       	lddsp	r9,sp[0x0]
8001ce60:	3f f8       	mov	r8,-1
8001ce62:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001ce66:	ee 09 00 09 	add	r9,r7,r9
8001ce6a:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ce6c:	e8 c8 ff ff 	sub	r8,r4,-1
8001ce70:	10 35       	cp.w	r5,r8
8001ce72:	e0 8a 00 9a 	brle	8001cfa6 <fatfs_filename_to_lfn+0x1e6>
            buffer[nameIndexes[i]] = filename[start+i];
8001ce76:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001ce7a:	40 18       	lddsp	r8,sp[0x4]
8001ce7c:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ce80:	e8 c8 ff fe 	sub	r8,r4,-2
8001ce84:	10 35       	cp.w	r5,r8
8001ce86:	e0 89 00 9f 	brgt	8001cfc4 <fatfs_filename_to_lfn+0x204>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001ce8a:	10 35       	cp.w	r5,r8
8001ce8c:	e0 80 01 65 	breq	8001d156 <fatfs_filename_to_lfn+0x396>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001ce90:	40 29       	lddsp	r9,sp[0x8]
8001ce92:	3f f8       	mov	r8,-1
8001ce94:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001ce98:	ee 09 00 09 	add	r9,r7,r9
8001ce9c:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ce9e:	e8 c8 ff fd 	sub	r8,r4,-3
8001cea2:	10 35       	cp.w	r5,r8
8001cea4:	e0 8a 00 9a 	brle	8001cfd8 <fatfs_filename_to_lfn+0x218>
            buffer[nameIndexes[i]] = filename[start+i];
8001cea8:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001ceac:	40 38       	lddsp	r8,sp[0xc]
8001ceae:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ceb2:	e8 c8 ff fc 	sub	r8,r4,-4
8001ceb6:	10 35       	cp.w	r5,r8
8001ceb8:	e0 89 00 9f 	brgt	8001cff6 <fatfs_filename_to_lfn+0x236>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001cebc:	10 35       	cp.w	r5,r8
8001cebe:	e0 80 01 42 	breq	8001d142 <fatfs_filename_to_lfn+0x382>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cec2:	40 49       	lddsp	r9,sp[0x10]
8001cec4:	3f f8       	mov	r8,-1
8001cec6:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001ceca:	ee 09 00 09 	add	r9,r7,r9
8001cece:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001ced0:	e8 c8 ff fb 	sub	r8,r4,-5
8001ced4:	10 35       	cp.w	r5,r8
8001ced6:	e0 8a 00 9a 	brle	8001d00a <fatfs_filename_to_lfn+0x24a>
            buffer[nameIndexes[i]] = filename[start+i];
8001ceda:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cede:	40 58       	lddsp	r8,sp[0x14]
8001cee0:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cee4:	e8 c8 ff fa 	sub	r8,r4,-6
8001cee8:	10 35       	cp.w	r5,r8
8001ceea:	e0 89 00 9e 	brgt	8001d026 <fatfs_filename_to_lfn+0x266>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001ceee:	10 35       	cp.w	r5,r8
8001cef0:	e0 80 01 09 	breq	8001d102 <fatfs_filename_to_lfn+0x342>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cef4:	40 69       	lddsp	r9,sp[0x18]
8001cef6:	3f f8       	mov	r8,-1
8001cef8:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001cefc:	ee 09 00 09 	add	r9,r7,r9
8001cf00:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf02:	e8 c8 ff f9 	sub	r8,r4,-7
8001cf06:	10 35       	cp.w	r5,r8
8001cf08:	e0 8a 00 99 	brle	8001d03a <fatfs_filename_to_lfn+0x27a>
            buffer[nameIndexes[i]] = filename[start+i];
8001cf0c:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cf10:	40 78       	lddsp	r8,sp[0x1c]
8001cf12:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf16:	e8 c8 ff f8 	sub	r8,r4,-8
8001cf1a:	10 35       	cp.w	r5,r8
8001cf1c:	e0 89 00 9d 	brgt	8001d056 <fatfs_filename_to_lfn+0x296>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001cf20:	10 35       	cp.w	r5,r8
8001cf22:	e0 80 00 e6 	breq	8001d0ee <fatfs_filename_to_lfn+0x32e>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cf26:	40 89       	lddsp	r9,sp[0x20]
8001cf28:	3f f8       	mov	r8,-1
8001cf2a:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001cf2e:	ee 09 00 09 	add	r9,r7,r9
8001cf32:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf34:	e8 c8 ff f7 	sub	r8,r4,-9
8001cf38:	10 35       	cp.w	r5,r8
8001cf3a:	e0 8a 00 98 	brle	8001d06a <fatfs_filename_to_lfn+0x2aa>
            buffer[nameIndexes[i]] = filename[start+i];
8001cf3e:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cf42:	40 98       	lddsp	r8,sp[0x24]
8001cf44:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf48:	e8 c8 ff f6 	sub	r8,r4,-10
8001cf4c:	10 35       	cp.w	r5,r8
8001cf4e:	e0 89 00 9c 	brgt	8001d086 <fatfs_filename_to_lfn+0x2c6>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001cf52:	10 35       	cp.w	r5,r8
8001cf54:	e0 80 00 ed 	breq	8001d12e <fatfs_filename_to_lfn+0x36e>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cf58:	40 a9       	lddsp	r9,sp[0x28]
8001cf5a:	3f f8       	mov	r8,-1
8001cf5c:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001cf60:	ee 09 00 09 	add	r9,r7,r9
8001cf64:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf66:	e8 c8 ff f5 	sub	r8,r4,-11
8001cf6a:	10 35       	cp.w	r5,r8
8001cf6c:	e0 8a 00 97 	brle	8001d09a <fatfs_filename_to_lfn+0x2da>
            buffer[nameIndexes[i]] = filename[start+i];
8001cf70:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cf74:	40 b8       	lddsp	r8,sp[0x2c]
8001cf76:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf7a:	2f 44       	sub	r4,-12
8001cf7c:	08 35       	cp.w	r5,r4
8001cf7e:	e0 8a 00 9b 	brle	8001d0b4 <fatfs_filename_to_lfn+0x2f4>
            buffer[nameIndexes[i]] = filename[start+i];
8001cf82:	e6 04 07 09 	ld.ub	r9,r3[r4]
8001cf86:	40 c8       	lddsp	r8,sp[0x30]
8001cf88:	ee 08 0b 09 	st.b	r7[r8],r9
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
        }
    }
}
8001cf8c:	2f 3d       	sub	sp,-52
8001cf8e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
8001cf92:	e6 04 07 09 	ld.ub	r9,r3[r4]
8001cf96:	40 08       	lddsp	r8,sp[0x0]
8001cf98:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cf9c:	e8 c8 ff ff 	sub	r8,r4,-1
8001cfa0:	10 35       	cp.w	r5,r8
8001cfa2:	fe 99 ff 6a 	brgt	8001ce76 <fatfs_filename_to_lfn+0xb6>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001cfa6:	10 35       	cp.w	r5,r8
8001cfa8:	e0 80 00 d2 	breq	8001d14c <fatfs_filename_to_lfn+0x38c>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cfac:	40 19       	lddsp	r9,sp[0x4]
8001cfae:	3f f8       	mov	r8,-1
8001cfb0:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001cfb4:	ee 09 00 09 	add	r9,r7,r9
8001cfb8:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cfba:	e8 c8 ff fe 	sub	r8,r4,-2
8001cfbe:	10 35       	cp.w	r5,r8
8001cfc0:	fe 9a ff 65 	brle	8001ce8a <fatfs_filename_to_lfn+0xca>
            buffer[nameIndexes[i]] = filename[start+i];
8001cfc4:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cfc8:	40 28       	lddsp	r8,sp[0x8]
8001cfca:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cfce:	e8 c8 ff fd 	sub	r8,r4,-3
8001cfd2:	10 35       	cp.w	r5,r8
8001cfd4:	fe 99 ff 6a 	brgt	8001cea8 <fatfs_filename_to_lfn+0xe8>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001cfd8:	10 35       	cp.w	r5,r8
8001cfda:	e0 80 00 af 	breq	8001d138 <fatfs_filename_to_lfn+0x378>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001cfde:	40 39       	lddsp	r9,sp[0xc]
8001cfe0:	3f f8       	mov	r8,-1
8001cfe2:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001cfe6:	ee 09 00 09 	add	r9,r7,r9
8001cfea:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001cfec:	e8 c8 ff fc 	sub	r8,r4,-4
8001cff0:	10 35       	cp.w	r5,r8
8001cff2:	fe 9a ff 65 	brle	8001cebc <fatfs_filename_to_lfn+0xfc>
            buffer[nameIndexes[i]] = filename[start+i];
8001cff6:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001cffa:	40 48       	lddsp	r8,sp[0x10]
8001cffc:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d000:	e8 c8 ff fb 	sub	r8,r4,-5
8001d004:	10 35       	cp.w	r5,r8
8001d006:	fe 99 ff 6a 	brgt	8001ceda <fatfs_filename_to_lfn+0x11a>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001d00a:	10 35       	cp.w	r5,r8
8001d00c:	c7 60       	breq	8001d0f8 <fatfs_filename_to_lfn+0x338>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001d00e:	40 59       	lddsp	r9,sp[0x14]
8001d010:	3f f8       	mov	r8,-1
8001d012:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001d016:	ee 09 00 09 	add	r9,r7,r9
8001d01a:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d01c:	e8 c8 ff fa 	sub	r8,r4,-6
8001d020:	10 35       	cp.w	r5,r8
8001d022:	fe 9a ff 66 	brle	8001ceee <fatfs_filename_to_lfn+0x12e>
            buffer[nameIndexes[i]] = filename[start+i];
8001d026:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001d02a:	40 68       	lddsp	r8,sp[0x18]
8001d02c:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d030:	e8 c8 ff f9 	sub	r8,r4,-7
8001d034:	10 35       	cp.w	r5,r8
8001d036:	fe 99 ff 6b 	brgt	8001cf0c <fatfs_filename_to_lfn+0x14c>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001d03a:	10 35       	cp.w	r5,r8
8001d03c:	c5 40       	breq	8001d0e4 <fatfs_filename_to_lfn+0x324>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001d03e:	40 79       	lddsp	r9,sp[0x1c]
8001d040:	3f f8       	mov	r8,-1
8001d042:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001d046:	ee 09 00 09 	add	r9,r7,r9
8001d04a:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d04c:	e8 c8 ff f8 	sub	r8,r4,-8
8001d050:	10 35       	cp.w	r5,r8
8001d052:	fe 9a ff 67 	brle	8001cf20 <fatfs_filename_to_lfn+0x160>
            buffer[nameIndexes[i]] = filename[start+i];
8001d056:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001d05a:	40 88       	lddsp	r8,sp[0x20]
8001d05c:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d060:	e8 c8 ff f7 	sub	r8,r4,-9
8001d064:	10 35       	cp.w	r5,r8
8001d066:	fe 99 ff 6c 	brgt	8001cf3e <fatfs_filename_to_lfn+0x17e>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001d06a:	10 35       	cp.w	r5,r8
8001d06c:	c5 c0       	breq	8001d124 <fatfs_filename_to_lfn+0x364>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001d06e:	40 99       	lddsp	r9,sp[0x24]
8001d070:	3f f8       	mov	r8,-1
8001d072:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001d076:	ee 09 00 09 	add	r9,r7,r9
8001d07a:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d07c:	e8 c8 ff f6 	sub	r8,r4,-10
8001d080:	10 35       	cp.w	r5,r8
8001d082:	fe 9a ff 68 	brle	8001cf52 <fatfs_filename_to_lfn+0x192>
            buffer[nameIndexes[i]] = filename[start+i];
8001d086:	e6 08 07 09 	ld.ub	r9,r3[r8]
8001d08a:	40 a8       	lddsp	r8,sp[0x28]
8001d08c:	ee 08 0b 09 	st.b	r7[r8],r9
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d090:	e8 c8 ff f5 	sub	r8,r4,-11
8001d094:	10 35       	cp.w	r5,r8
8001d096:	fe 99 ff 6d 	brgt	8001cf70 <fatfs_filename_to_lfn+0x1b0>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001d09a:	10 35       	cp.w	r5,r8
8001d09c:	c3 80       	breq	8001d10c <fatfs_filename_to_lfn+0x34c>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001d09e:	40 b9       	lddsp	r9,sp[0x2c]
8001d0a0:	3f f8       	mov	r8,-1
8001d0a2:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001d0a6:	ee 09 00 09 	add	r9,r7,r9
8001d0aa:	b2 98       	st.b	r9[0x1],r8
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
8001d0ac:	2f 44       	sub	r4,-12
8001d0ae:	08 35       	cp.w	r5,r4
8001d0b0:	fe 99 ff 69 	brgt	8001cf82 <fatfs_filename_to_lfn+0x1c2>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
8001d0b4:	08 35       	cp.w	r5,r4
8001d0b6:	c3 00       	breq	8001d116 <fatfs_filename_to_lfn+0x356>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
8001d0b8:	40 c9       	lddsp	r9,sp[0x30]
8001d0ba:	3f f8       	mov	r8,-1
8001d0bc:	ee 09 0b 08 	st.b	r7[r9],r8
            buffer[nameIndexes[i]+1] = 0xFF;
8001d0c0:	ee 09 00 09 	add	r9,r7,r9
8001d0c4:	b2 98       	st.b	r9[0x1],r8
        }
    }
}
8001d0c6:	2f 3d       	sub	sp,-52
8001d0c8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
8001d0cc:	3f f2       	mov	r2,-1
8001d0ce:	ca fa       	rjmp	8001ce2c <fatfs_filename_to_lfn+0x6c>

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
8001d0d0:	e4 c6 ff ff 	sub	r6,r2,-1
8001d0d4:	a7 a6       	sbr	r6,0x6
8001d0d6:	5c 56       	castu.b	r6
8001d0d8:	cb 8a       	rjmp	8001ce48 <fatfs_filename_to_lfn+0x88>
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
8001d0da:	30 09       	mov	r9,0
8001d0dc:	40 08       	lddsp	r8,sp[0x0]
8001d0de:	ee 08 0b 09 	st.b	r7[r8],r9
8001d0e2:	c5 db       	rjmp	8001cf9c <fatfs_filename_to_lfn+0x1dc>
8001d0e4:	30 09       	mov	r9,0
8001d0e6:	40 78       	lddsp	r8,sp[0x1c]
8001d0e8:	ee 08 0b 09 	st.b	r7[r8],r9
8001d0ec:	c1 5b       	rjmp	8001cf16 <fatfs_filename_to_lfn+0x156>
8001d0ee:	30 09       	mov	r9,0
8001d0f0:	40 88       	lddsp	r8,sp[0x20]
8001d0f2:	ee 08 0b 09 	st.b	r7[r8],r9
8001d0f6:	cb 5b       	rjmp	8001d060 <fatfs_filename_to_lfn+0x2a0>
8001d0f8:	30 09       	mov	r9,0
8001d0fa:	40 58       	lddsp	r8,sp[0x14]
8001d0fc:	ee 08 0b 09 	st.b	r7[r8],r9
8001d100:	cf 2a       	rjmp	8001cee4 <fatfs_filename_to_lfn+0x124>
8001d102:	30 09       	mov	r9,0
8001d104:	40 68       	lddsp	r8,sp[0x18]
8001d106:	ee 08 0b 09 	st.b	r7[r8],r9
8001d10a:	c9 3b       	rjmp	8001d030 <fatfs_filename_to_lfn+0x270>
8001d10c:	30 09       	mov	r9,0
8001d10e:	40 b8       	lddsp	r8,sp[0x2c]
8001d110:	ee 08 0b 09 	st.b	r7[r8],r9
8001d114:	c3 3b       	rjmp	8001cf7a <fatfs_filename_to_lfn+0x1ba>
8001d116:	30 09       	mov	r9,0
8001d118:	40 c8       	lddsp	r8,sp[0x30]
8001d11a:	ee 08 0b 09 	st.b	r7[r8],r9
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
        }
    }
}
8001d11e:	2f 3d       	sub	sp,-52
8001d120:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
8001d124:	30 09       	mov	r9,0
8001d126:	40 98       	lddsp	r8,sp[0x24]
8001d128:	ee 08 0b 09 	st.b	r7[r8],r9
8001d12c:	c0 eb       	rjmp	8001cf48 <fatfs_filename_to_lfn+0x188>
8001d12e:	30 09       	mov	r9,0
8001d130:	40 a8       	lddsp	r8,sp[0x28]
8001d132:	ee 08 0b 09 	st.b	r7[r8],r9
8001d136:	ca db       	rjmp	8001d090 <fatfs_filename_to_lfn+0x2d0>
8001d138:	30 09       	mov	r9,0
8001d13a:	40 38       	lddsp	r8,sp[0xc]
8001d13c:	ee 08 0b 09 	st.b	r7[r8],r9
8001d140:	cb 9a       	rjmp	8001ceb2 <fatfs_filename_to_lfn+0xf2>
8001d142:	30 09       	mov	r9,0
8001d144:	40 48       	lddsp	r8,sp[0x10]
8001d146:	ee 08 0b 09 	st.b	r7[r8],r9
8001d14a:	c5 bb       	rjmp	8001d000 <fatfs_filename_to_lfn+0x240>
8001d14c:	30 09       	mov	r9,0
8001d14e:	40 18       	lddsp	r8,sp[0x4]
8001d150:	ee 08 0b 09 	st.b	r7[r8],r9
8001d154:	c9 6a       	rjmp	8001ce80 <fatfs_filename_to_lfn+0xc0>
8001d156:	30 09       	mov	r9,0
8001d158:	40 28       	lddsp	r8,sp[0x8]
8001d15a:	ee 08 0b 09 	st.b	r7[r8],r9
8001d15e:	c3 8b       	rjmp	8001cfce <fatfs_filename_to_lfn+0x20e>
8001d160:	80 02       	ld.sh	r2,r0[0x0]
8001d162:	52 f4       	stdsp	sp[0xbc],r4

8001d164 <fatfs_total_path_levels>:
int fatfs_total_path_levels(char *path)
{
    int levels = 0;
    char expectedchar;

    if (!path)
8001d164:	58 0c       	cp.w	r12,0
8001d166:	c2 b0       	breq	8001d1bc <fatfs_total_path_levels+0x58>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8001d168:	19 89       	ld.ub	r9,r12[0x0]
8001d16a:	32 f8       	mov	r8,47
8001d16c:	f0 09 18 00 	cp.b	r9,r8
8001d170:	c1 d0       	breq	8001d1aa <fatfs_total_path_levels+0x46>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d172:	19 99       	ld.ub	r9,r12[0x1]
8001d174:	33 a8       	mov	r8,58
8001d176:	f0 09 18 00 	cp.b	r9,r8
8001d17a:	c1 c1       	brne	8001d1b2 <fatfs_total_path_levels+0x4e>
    {
        expectedchar = '\\';
        path += 3;
8001d17c:	f8 c8 ff fd 	sub	r8,r12,-3
8001d180:	35 ca       	mov	r10,92
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8001d182:	11 89       	ld.ub	r9,r8[0x0]
8001d184:	58 09       	cp.w	r9,0
8001d186:	c1 c0       	breq	8001d1be <fatfs_total_path_levels+0x5a>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8001d188:	30 0c       	mov	r12,0
8001d18a:	c0 58       	rjmp	8001d194 <fatfs_total_path_levels+0x30>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
            path++;
8001d18c:	2f f8       	sub	r8,-1

    // Count levels in path string
    while (*path)
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8001d18e:	11 89       	ld.ub	r9,r8[0x0]
8001d190:	58 09       	cp.w	r9,0
8001d192:	c0 b0       	breq	8001d1a8 <fatfs_total_path_levels+0x44>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8001d194:	f2 0a 18 00 	cp.b	r10,r9
8001d198:	cf a1       	brne	8001d18c <fatfs_total_path_levels+0x28>
8001d19a:	2f f8       	sub	r8,-1
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8001d19c:	2f fc       	sub	r12,-1
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8001d19e:	11 89       	ld.ub	r9,r8[0x0]
8001d1a0:	58 09       	cp.w	r9,0
8001d1a2:	cf 91       	brne	8001d194 <fatfs_total_path_levels+0x30>
8001d1a4:	20 1c       	sub	r12,1
8001d1a6:	5e fc       	retal	r12
8001d1a8:	5e fc       	retal	r12
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8001d1aa:	f8 c8 ff ff 	sub	r8,r12,-1
8001d1ae:	32 fa       	mov	r10,47
8001d1b0:	ce 9b       	rjmp	8001d182 <fatfs_total_path_levels+0x1e>
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d1b2:	19 a9       	ld.ub	r9,r12[0x2]
8001d1b4:	35 c8       	mov	r8,92
8001d1b6:	f0 09 18 00 	cp.b	r9,r8
8001d1ba:	ce 10       	breq	8001d17c <fatfs_total_path_levels+0x18>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8001d1bc:	5e fe       	retal	-1
8001d1be:	5e fe       	retal	-1

8001d1c0 <fatfs_compare_names>:
//-----------------------------------------------------------------------------
// fatfs_compare_names: Compare two filenames (without copying or changing origonals)
// Returns 1 if match, 0 if not
//-----------------------------------------------------------------------------
int fatfs_compare_names(char* strA, char* strB)
{
8001d1c0:	d4 31       	pushm	r0-r7,lr
8001d1c2:	20 4d       	sub	sp,16
8001d1c4:	18 97       	mov	r7,r12
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8001d1c6:	19 84       	ld.ub	r4,r12[0x0]
8001d1c8:	58 04       	cp.w	r4,0
8001d1ca:	e0 80 00 e9 	breq	8001d39c <fatfs_compare_names+0x1dc>
8001d1ce:	18 99       	mov	r9,r12
8001d1d0:	08 9a       	mov	r10,r4
8001d1d2:	30 08       	mov	r8,0
8001d1d4:	3f f6       	mov	r6,-1
    {
        if (*strSrc=='.')
8001d1d6:	32 ec       	mov	r12,46
8001d1d8:	f4 0c 18 00 	cp.b	r12,r10
8001d1dc:	f0 06 17 00 	moveq	r6,r8
            dotPos = (int)(strSrc-str);

        strSrc++;
8001d1e0:	2f f9       	sub	r9,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8001d1e2:	2f f8       	sub	r8,-1
8001d1e4:	13 8a       	ld.ub	r10,r9[0x0]
8001d1e6:	58 0a       	cp.w	r10,0
8001d1e8:	cf 81       	brne	8001d1d8 <fatfs_compare_names+0x18>
8001d1ea:	17 83       	ld.ub	r3,r11[0x0]
8001d1ec:	58 03       	cp.w	r3,0
8001d1ee:	e0 80 00 d9 	breq	8001d3a0 <fatfs_compare_names+0x1e0>
8001d1f2:	06 98       	mov	r8,r3
8001d1f4:	16 9a       	mov	r10,r11
8001d1f6:	30 09       	mov	r9,0
8001d1f8:	3f f5       	mov	r5,-1
    {
        if (*strSrc=='.')
8001d1fa:	32 ec       	mov	r12,46
8001d1fc:	f0 0c 18 00 	cp.b	r12,r8
8001d200:	f2 05 17 00 	moveq	r5,r9
            dotPos = (int)(strSrc-str);

        strSrc++;
8001d204:	2f fa       	sub	r10,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8001d206:	2f f9       	sub	r9,-1
8001d208:	15 88       	ld.ub	r8,r10[0x0]
8001d20a:	58 08       	cp.w	r8,0
8001d20c:	cf 81       	brne	8001d1fc <fatfs_compare_names+0x3c>
    ext2Pos = FileString_GetExtension(strB);

    // NOTE: Extension position can be different for matching 
    // filename if trailing space are present before it!
    // Check that if one has an extension, so does the other
    if ((ext1Pos==-1) && (ext2Pos!=-1))
8001d20e:	5b f5       	cp.w	r5,-1
8001d210:	5f 1a       	srne	r10
8001d212:	5b f6       	cp.w	r6,-1
8001d214:	5f 09       	sreq	r9
8001d216:	f5 e9 00 09 	and	r9,r10,r9
8001d21a:	f0 09 18 00 	cp.b	r9,r8
8001d21e:	c1 e1       	brne	8001d25a <fatfs_compare_names+0x9a>
8001d220:	5b f5       	cp.w	r5,-1
8001d222:	5f 09       	sreq	r9
        return 0;
    if ((ext2Pos==-1) && (ext1Pos!=-1))
8001d224:	5b f6       	cp.w	r6,-1
8001d226:	5f 18       	srne	r8
8001d228:	10 69       	and	r9,r8
8001d22a:	c1 81       	brne	8001d25a <fatfs_compare_names+0x9a>
        return 0;

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
8001d22c:	58 08       	cp.w	r8,0
8001d22e:	c4 c0       	breq	8001d2c6 <fatfs_compare_names+0x106>
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
8001d230:	ea c8 ff ff 	sub	r8,r5,-1

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
8001d234:	50 0b       	stdsp	sp[0x0],r11
    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
8001d236:	f6 08 00 00 	add	r0,r11,r8

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
8001d23a:	ec c1 ff ff 	sub	r1,r6,-1
8001d23e:	50 26       	stdsp	sp[0x8],r6
8001d240:	ee 01 00 01 	add	r1,r7,r1
        ext2 = strB+ext2Pos+1;
8001d244:	50 15       	stdsp	sp[0x4],r5

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
8001d246:	02 9c       	mov	r12,r1
8001d248:	e0 a0 33 4e 	rcall	800238e4 <strlen>
8001d24c:	18 92       	mov	r2,r12
8001d24e:	00 9c       	mov	r12,r0
8001d250:	e0 a0 33 4a 	rcall	800238e4 <strlen>
8001d254:	40 0b       	lddsp	r11,sp[0x0]
8001d256:	18 32       	cp.w	r2,r12
8001d258:	c0 40       	breq	8001d260 <fatfs_compare_names+0xa0>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d25a:	30 0c       	mov	r12,0
    // Compare main part of filenames
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
        return 0;
    else
        return 1;
}
8001d25c:	2f cd       	sub	sp,-16
8001d25e:	d8 32       	popm	r0-r7,pc
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d260:	58 02       	cp.w	r2,0
8001d262:	e0 80 00 a3 	breq	8001d3a8 <fatfs_compare_names+0x1e8>
8001d266:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8001d268:	31 9c       	mov	r12,25
8001d26a:	50 34       	stdsp	sp[0xc],r4
8001d26c:	c1 68       	rjmp	8001d298 <fatfs_compare_names+0xd8>
8001d26e:	12 94       	mov	r4,r9
            a+= 32;
        if ((b>='A') && (b<='Z'))
8001d270:	f4 ce 00 41 	sub	lr,r10,65
8001d274:	f8 0e 18 00 	cp.b	lr,r12
8001d278:	e0 88 00 23 	brls	8001d2be <fatfs_compare_names+0xfe>
8001d27c:	14 9e       	mov	lr,r10
            b+= 32;

        diff = a - b;
8001d27e:	e8 0e 01 0e 	sub	lr,r4,lr

        // If different
        if (diff)
8001d282:	ce c1       	brne	8001d25a <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
8001d284:	58 09       	cp.w	r9,0
8001d286:	e0 80 00 90 	breq	8001d3a6 <fatfs_compare_names+0x1e6>
8001d28a:	58 0a       	cp.w	r10,0
8001d28c:	e0 80 00 8d 	breq	8001d3a6 <fatfs_compare_names+0x1e6>
8001d290:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d292:	10 32       	cp.w	r2,r8
8001d294:	e0 80 00 89 	breq	8001d3a6 <fatfs_compare_names+0x1e6>
    {
        a = *s1;
8001d298:	e2 08 07 09 	ld.ub	r9,r1[r8]
        b = *s2;
8001d29c:	e0 08 07 0a 	ld.ub	r10,r0[r8]

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8001d2a0:	f2 ce 00 41 	sub	lr,r9,65
8001d2a4:	f8 0e 18 00 	cp.b	lr,r12
8001d2a8:	fe 9b ff e3 	brhi	8001d26e <fatfs_compare_names+0xae>
            a+= 32;
8001d2ac:	f2 c4 ff e0 	sub	r4,r9,-32
        if ((b>='A') && (b<='Z'))
8001d2b0:	f4 ce 00 41 	sub	lr,r10,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
8001d2b4:	5c 54       	castu.b	r4
        if ((b>='A') && (b<='Z'))
8001d2b6:	f8 0e 18 00 	cp.b	lr,r12
8001d2ba:	fe 9b ff e1 	brhi	8001d27c <fatfs_compare_names+0xbc>
            b+= 32;
8001d2be:	f4 ce ff e0 	sub	lr,r10,-32
8001d2c2:	5c 5e       	castu.b	lr
8001d2c4:	cd db       	rjmp	8001d27e <fatfs_compare_names+0xbe>
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
8001d2c6:	50 0b       	stdsp	sp[0x0],r11
8001d2c8:	0e 9c       	mov	r12,r7
8001d2ca:	e0 a0 33 0d 	rcall	800238e4 <strlen>
        file2Len = (int)strlen(strB);
8001d2ce:	40 0b       	lddsp	r11,sp[0x0]
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
8001d2d0:	18 96       	mov	r6,r12
        file2Len = (int)strlen(strB);
8001d2d2:	16 9c       	mov	r12,r11
8001d2d4:	50 26       	stdsp	sp[0x8],r6
8001d2d6:	e0 a0 33 07 	rcall	800238e4 <strlen>
8001d2da:	40 0b       	lddsp	r11,sp[0x0]
8001d2dc:	50 1c       	stdsp	sp[0x4],r12
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8001d2de:	58 06       	cp.w	r6,0
8001d2e0:	c1 60       	breq	8001d30c <fatfs_compare_names+0x14c>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8001d2e2:	40 29       	lddsp	r9,sp[0x8]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d2e4:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8001d2e6:	20 19       	sub	r9,1
8001d2e8:	ee 09 00 09 	add	r9,r7,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d2ec:	13 85       	ld.ub	r5,r9[0x0]
8001d2ee:	f0 05 18 00 	cp.b	r5,r8
8001d2f2:	c0 d1       	brne	8001d30c <fatfs_compare_names+0x14c>
8001d2f4:	f2 07 01 08 	sub	r8,r9,r7
8001d2f8:	c0 68       	rjmp	8001d304 <fatfs_compare_names+0x144>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
8001d2fa:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d2fc:	13 7a       	ld.ub	r10,--r9
8001d2fe:	ea 0a 18 00 	cp.b	r10,r5
8001d302:	c0 41       	brne	8001d30a <fatfs_compare_names+0x14a>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
8001d304:	20 16       	sub	r6,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d306:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8001d308:	cf 91       	brne	8001d2fa <fatfs_compare_names+0x13a>
8001d30a:	1c 96       	mov	r6,lr
8001d30c:	58 0c       	cp.w	r12,0
8001d30e:	c1 60       	breq	8001d33a <fatfs_compare_names+0x17a>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8001d310:	40 19       	lddsp	r9,sp[0x4]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d312:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8001d314:	20 19       	sub	r9,1
8001d316:	f6 09 00 09 	add	r9,r11,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d31a:	13 85       	ld.ub	r5,r9[0x0]
8001d31c:	f0 05 18 00 	cp.b	r5,r8
8001d320:	c0 d1       	brne	8001d33a <fatfs_compare_names+0x17a>
8001d322:	f2 0b 01 08 	sub	r8,r9,r11
8001d326:	c0 68       	rjmp	8001d332 <fatfs_compare_names+0x172>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
8001d328:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d32a:	13 7a       	ld.ub	r10,--r9
8001d32c:	ea 0a 18 00 	cp.b	r10,r5
8001d330:	c0 41       	brne	8001d338 <fatfs_compare_names+0x178>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
8001d332:	20 1c       	sub	r12,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8001d334:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
8001d336:	cf 91       	brne	8001d328 <fatfs_compare_names+0x168>
8001d338:	1c 9c       	mov	r12,lr
    // Find length without trailing spaces (before ext)
    file1Len = FileString_TrimLength(strA, file1Len);
    file2Len = FileString_TrimLength(strB, file2Len);

    // Check the file lengths match
    if (file1Len!=file2Len)
8001d33a:	18 36       	cp.w	r6,r12
8001d33c:	c8 f1       	brne	8001d25a <fatfs_compare_names+0x9a>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d33e:	58 06       	cp.w	r6,0
8001d340:	c3 60       	breq	8001d3ac <fatfs_compare_names+0x1ec>
8001d342:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8001d344:	31 99       	mov	r9,25
8001d346:	c1 88       	rjmp	8001d376 <fatfs_compare_names+0x1b6>
8001d348:	08 9c       	mov	r12,r4
            a+= 32;
        if ((b>='A') && (b<='Z'))
8001d34a:	e6 ca 00 41 	sub	r10,r3,65
8001d34e:	f2 0a 18 00 	cp.b	r10,r9
8001d352:	e0 88 00 21 	brls	8001d394 <fatfs_compare_names+0x1d4>
8001d356:	06 9a       	mov	r10,r3
            b+= 32;

        diff = a - b;

        // If different
        if (diff)
8001d358:	f4 0c 18 00 	cp.b	r12,r10
8001d35c:	fe 91 ff 7f 	brne	8001d25a <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
8001d360:	58 04       	cp.w	r4,0
8001d362:	c2 50       	breq	8001d3ac <fatfs_compare_names+0x1ec>
8001d364:	58 03       	cp.w	r3,0
8001d366:	c2 30       	breq	8001d3ac <fatfs_compare_names+0x1ec>
8001d368:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d36a:	10 36       	cp.w	r6,r8
8001d36c:	c2 00       	breq	8001d3ac <fatfs_compare_names+0x1ec>
8001d36e:	ee 08 07 04 	ld.ub	r4,r7[r8]
8001d372:	f6 08 07 03 	ld.ub	r3,r11[r8]
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
8001d376:	08 9a       	mov	r10,r4
8001d378:	24 1a       	sub	r10,65
8001d37a:	f2 0a 18 00 	cp.b	r10,r9
8001d37e:	fe 9b ff e5 	brhi	8001d348 <fatfs_compare_names+0x188>
            a+= 32;
8001d382:	08 9c       	mov	r12,r4
        if ((b>='A') && (b<='Z'))
8001d384:	e6 ca 00 41 	sub	r10,r3,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
8001d388:	2e 0c       	sub	r12,-32
8001d38a:	5c 5c       	castu.b	r12
        if ((b>='A') && (b<='Z'))
8001d38c:	f2 0a 18 00 	cp.b	r10,r9
8001d390:	fe 9b ff e3 	brhi	8001d356 <fatfs_compare_names+0x196>
            b+= 32;
8001d394:	e6 ca ff e0 	sub	r10,r3,-32
8001d398:	5c 5a       	castu.b	r10
8001d39a:	cd fb       	rjmp	8001d358 <fatfs_compare_names+0x198>
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
8001d39c:	3f f6       	mov	r6,-1
8001d39e:	c2 6b       	rjmp	8001d1ea <fatfs_compare_names+0x2a>
8001d3a0:	30 19       	mov	r9,1
8001d3a2:	3f f5       	mov	r5,-1
8001d3a4:	c4 0b       	rjmp	8001d224 <fatfs_compare_names+0x64>
8001d3a6:	40 34       	lddsp	r4,sp[0xc]
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
        file2Len = (int)strlen(strB);
8001d3a8:	0a 9c       	mov	r12,r5
8001d3aa:	c9 ab       	rjmp	8001d2de <fatfs_compare_names+0x11e>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8001d3ac:	30 1c       	mov	r12,1
8001d3ae:	c5 7b       	rjmp	8001d25c <fatfs_compare_names+0x9c>

8001d3b0 <fatfs_get_substring>:
8001d3b0:	eb cd 40 f8 	pushm	r3-r7,lr
// (or file) at the specified level.
// E.g. C:\folder\file.zip : Level 0 = C:\folder, Level 1 = file.zip
// Returns: -1 = Error, 0 = Ok
//-----------------------------------------------------------------------------
int fatfs_get_substring(char *path, int levelreq, char *output, int max_len)
{
8001d3b4:	20 3d       	sub	sp,12
    int pathlen=0;
    int levels=0;
    int copypnt=0;
    char expectedchar;

    if (!path || max_len <= 0)
8001d3b6:	58 0c       	cp.w	r12,0
8001d3b8:	5f 08       	sreq	r8
8001d3ba:	58 09       	cp.w	r9,0
8001d3bc:	5f a7       	srle	r7
8001d3be:	ef e8 10 08 	or	r8,r7,r8
8001d3c2:	c4 61       	brne	8001d44e <fatfs_get_substring+0x9e>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8001d3c4:	19 8e       	ld.ub	lr,r12[0x0]
8001d3c6:	32 f8       	mov	r8,47
8001d3c8:	f0 0e 18 00 	cp.b	lr,r8
8001d3cc:	c4 40       	breq	8001d454 <fatfs_get_substring+0xa4>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d3ce:	19 9e       	ld.ub	lr,r12[0x1]
8001d3d0:	33 a8       	mov	r8,58
8001d3d2:	f0 0e 18 00 	cp.b	lr,r8
8001d3d6:	c3 71       	brne	8001d444 <fatfs_get_substring+0x94>
    {
        expectedchar = '\\';
        path += 3;
8001d3d8:	f8 c6 ff fd 	sub	r6,r12,-3
8001d3dc:	35 c7       	mov	r7,92
    }
    else
        return -1;

    // Get string length of path
    pathlen = (int)strlen (path);
8001d3de:	50 2b       	stdsp	sp[0x8],r11
8001d3e0:	50 1a       	stdsp	sp[0x4],r10
8001d3e2:	50 09       	stdsp	sp[0x0],r9
8001d3e4:	0c 9c       	mov	r12,r6
8001d3e6:	e0 a0 32 7f 	rcall	800238e4 <strlen>

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8001d3ea:	40 2b       	lddsp	r11,sp[0x8]
8001d3ec:	40 1a       	lddsp	r10,sp[0x4]
8001d3ee:	40 09       	lddsp	r9,sp[0x0]
8001d3f0:	e0 8a 00 36 	brle	8001d45c <fatfs_get_substring+0xac>
8001d3f4:	30 04       	mov	r4,0
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
8001d3f6:	20 19       	sub	r9,1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8001d3f8:	08 95       	mov	r5,r4
8001d3fa:	08 98       	mov	r8,r4
8001d3fc:	c0 48       	rjmp	8001d404 <fatfs_get_substring+0x54>
8001d3fe:	2f f8       	sub	r8,-1
8001d400:	10 3c       	cp.w	r12,r8
8001d402:	c1 70       	breq	8001d430 <fatfs_get_substring+0x80>
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;
8001d404:	ec 08 07 0e 	ld.ub	lr,r6[r8]
8001d408:	0e 93       	mov	r3,r7
8001d40a:	ee 0e 18 00 	cp.b	lr,r7
8001d40e:	f7 b5 00 ff 	subeq	r5,-1

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
8001d412:	16 35       	cp.w	r5,r11
8001d414:	cf 51       	brne	8001d3fe <fatfs_get_substring+0x4e>
8001d416:	0e 93       	mov	r3,r7
8001d418:	fc 07 18 00 	cp.b	r7,lr
8001d41c:	cf 10       	breq	8001d3fe <fatfs_get_substring+0x4e>
8001d41e:	08 39       	cp.w	r9,r4
8001d420:	fe 9a ff ef 	brle	8001d3fe <fatfs_get_substring+0x4e>
            output[copypnt++] = *path;
8001d424:	f4 04 0b 0e 	st.b	r10[r4],lr

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8001d428:	2f f8       	sub	r8,-1
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
            output[copypnt++] = *path;
8001d42a:	2f f4       	sub	r4,-1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8001d42c:	10 3c       	cp.w	r12,r8
8001d42e:	ce b1       	brne	8001d404 <fatfs_get_substring+0x54>
        // Increment through path string
        path++;
    }

    // Null Terminate
    output[copypnt] = '\0';
8001d430:	30 08       	mov	r8,0
8001d432:	f4 04 0b 08 	st.b	r10[r4],r8

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
8001d436:	15 89       	ld.ub	r9,r10[0x0]
8001d438:	f0 09 18 00 	cp.b	r9,r8
8001d43c:	c0 90       	breq	8001d44e <fatfs_get_substring+0x9e>
8001d43e:	2f dd       	sub	sp,-12
8001d440:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d444:	19 ae       	ld.ub	lr,r12[0x2]
8001d446:	35 c8       	mov	r8,92
8001d448:	f0 0e 18 00 	cp.b	lr,r8
8001d44c:	cc 60       	breq	8001d3d8 <fatfs_get_substring+0x28>

    // Null Terminate
    output[copypnt] = '\0';

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
8001d44e:	2f dd       	sub	sp,-12
8001d450:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8001d454:	f8 c6 ff ff 	sub	r6,r12,-1
8001d458:	32 f7       	mov	r7,47
8001d45a:	cc 2b       	rjmp	8001d3de <fatfs_get_substring+0x2e>

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
8001d45c:	30 04       	mov	r4,0
8001d45e:	ce 9b       	rjmp	8001d430 <fatfs_get_substring+0x80>

8001d460 <fatfs_split_path>:
8001d460:	eb cd 40 fc 	pushm	r2-r7,lr
// Returned is the path string and file Name string
// E.g. C:\folder\file.zip -> path = C:\folder  filename = file.zip
// E.g. C:\file.zip -> path = [blank]  filename = file.zip
//-----------------------------------------------------------------------------
int fatfs_split_path(char *full_path, char *path, int max_path, char *filename, int max_filename)
{
8001d464:	18 97       	mov	r7,r12
8001d466:	16 95       	mov	r5,r11
8001d468:	14 93       	mov	r3,r10
8001d46a:	12 96       	mov	r6,r9
int fatfs_total_path_levels(char *path)
{
    int levels = 0;
    char expectedchar;

    if (!path)
8001d46c:	58 0c       	cp.w	r12,0
8001d46e:	c4 60       	breq	8001d4fa <fatfs_split_path+0x9a>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
8001d470:	19 8b       	ld.ub	r11,r12[0x0]
8001d472:	32 fa       	mov	r10,47
8001d474:	f4 0b 18 00 	cp.b	r11,r10
8001d478:	c4 30       	breq	8001d4fe <fatfs_split_path+0x9e>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d47a:	19 9a       	ld.ub	r10,r12[0x1]
8001d47c:	33 a9       	mov	r9,58
8001d47e:	f2 0a 18 00 	cp.b	r10,r9
8001d482:	c3 71       	brne	8001d4f0 <fatfs_split_path+0x90>
    {
        expectedchar = '\\';
        path += 3;
8001d484:	ee ca ff fd 	sub	r10,r7,-3
8001d488:	35 cc       	mov	r12,92
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8001d48a:	15 8b       	ld.ub	r11,r10[0x0]
8001d48c:	58 0b       	cp.w	r11,0
8001d48e:	c3 60       	breq	8001d4fa <fatfs_split_path+0x9a>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8001d490:	30 04       	mov	r4,0
8001d492:	c0 58       	rjmp	8001d49c <fatfs_split_path+0x3c>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
            path++;
8001d494:	2f fa       	sub	r10,-1

    // Count levels in path string
    while (*path)
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8001d496:	15 8b       	ld.ub	r11,r10[0x0]
8001d498:	58 0b       	cp.w	r11,0
8001d49a:	c0 a0       	breq	8001d4ae <fatfs_split_path+0x4e>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
8001d49c:	f8 0b 18 00 	cp.b	r11,r12
8001d4a0:	cf a1       	brne	8001d494 <fatfs_split_path+0x34>
8001d4a2:	2f fa       	sub	r10,-1
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8001d4a4:	2f f4       	sub	r4,-1
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8001d4a6:	15 8b       	ld.ub	r11,r10[0x0]
8001d4a8:	58 0b       	cp.w	r11,0
8001d4aa:	cf 91       	brne	8001d49c <fatfs_split_path+0x3c>
8001d4ac:	c0 28       	rjmp	8001d4b0 <fatfs_split_path+0x50>
            if (*path == expectedchar) { path++; break; }
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
8001d4ae:	2f f4       	sub	r4,-1
    }
    
    // Subtract the file itself
    return levels-1;
8001d4b0:	20 14       	sub	r4,1
    int levels = fatfs_total_path_levels(full_path);
    if (levels == -1)
        return -1;

    // Get filename part of string
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
8001d4b2:	10 99       	mov	r9,r8
8001d4b4:	0c 9a       	mov	r10,r6
8001d4b6:	08 9b       	mov	r11,r4
8001d4b8:	0e 9c       	mov	r12,r7
8001d4ba:	c7 bf       	rcall	8001d3b0 <fatfs_get_substring>
8001d4bc:	18 92       	mov	r2,r12
8001d4be:	c1 e1       	brne	8001d4fa <fatfs_split_path+0x9a>
8001d4c0:	58 04       	cp.w	r4,0
        return -1;

    // If root file
    if (levels == 0)
8001d4c2:	c2 20       	breq	8001d506 <fatfs_split_path+0xa6>
8001d4c4:	0e 9c       	mov	r12,r7
        path[0] = '\0';
    else
    {
        strindex = (int)strlen(full_path) - (int)strlen(filename);
8001d4c6:	e0 a0 32 0f 	rcall	800238e4 <strlen>
8001d4ca:	18 94       	mov	r4,r12
8001d4cc:	0c 9c       	mov	r12,r6
8001d4ce:	e0 a0 32 0b 	rcall	800238e4 <strlen>
8001d4d2:	e8 0c 01 0c 	sub	r12,r4,r12
8001d4d6:	0e 9b       	mov	r11,r7
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
8001d4d8:	f8 03 0d 43 	min	r3,r12,r3
8001d4dc:	0a 9c       	mov	r12,r5
8001d4de:	06 9a       	mov	r10,r3
8001d4e0:	e0 a0 30 f0 	rcall	800236c0 <memcpy>
8001d4e4:	06 05       	add	r5,r3
        path[strindex-1] = '\0';
8001d4e6:	04 9c       	mov	r12,r2
8001d4e8:	eb 62 ff ff 	st.b	r5[-1],r2
8001d4ec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001d4f0:	19 aa       	ld.ub	r10,r12[0x2]
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8001d4f2:	35 c9       	mov	r9,92
8001d4f4:	f2 0a 18 00 	cp.b	r10,r9
8001d4f8:	cc 60       	breq	8001d484 <fatfs_split_path+0x24>
8001d4fa:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
        strindex = (int)strlen(full_path) - (int)strlen(filename);
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
        path[strindex-1] = '\0';
8001d4fe:	f8 ca ff ff 	sub	r10,r12,-1
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
8001d502:	32 fc       	mov	r12,47
8001d504:	cc 3b       	rjmp	8001d48a <fatfs_split_path+0x2a>
8001d506:	aa 84       	st.b	r5[0x0],r4
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
        return -1;

    // If root file
    if (levels == 0)
        path[0] = '\0';
8001d508:	08 9c       	mov	r12,r4
8001d50a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001d50e:	d7 03       	nop

8001d510 <fatfs_fat_writeback>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
8001d510:	eb cd 40 80 	pushm	r7,lr
8001d514:	16 97       	mov	r7,r11
    if (pcur)
8001d516:	58 0b       	cp.w	r11,0
8001d518:	c1 e0       	breq	8001d554 <fatfs_fat_writeback+0x44>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
8001d51a:	f6 f8 02 04 	ld.w	r8,r11[516]
8001d51e:	58 08       	cp.w	r8,0
8001d520:	c1 80       	breq	8001d550 <fatfs_fat_writeback+0x40>
        {
            if (fs->disk_io.write_media)
8001d522:	78 e8       	ld.w	r8,r12[0x38]
8001d524:	58 08       	cp.w	r8,0
8001d526:	c1 20       	breq	8001d54a <fatfs_fat_writeback+0x3a>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001d528:	78 8b       	ld.w	r11,r12[0x20]
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8001d52a:	ee f9 02 00 	ld.w	r9,r7[512]
8001d52e:	78 5a       	ld.w	r10,r12[0x14]
8001d530:	f2 0a 01 0a 	sub	r10,r9,r10

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001d534:	f4 cc ff ff 	sub	r12,r10,-1
8001d538:	16 3c       	cp.w	r12,r11
8001d53a:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8001d53e:	f7 da eb 1a 	subhi	r10,r11,r10

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8001d542:	12 9c       	mov	r12,r9
8001d544:	0e 9b       	mov	r11,r7
8001d546:	5d 18       	icall	r8
8001d548:	c0 60       	breq	8001d554 <fatfs_fat_writeback+0x44>
                    return 0;
            }
                
            pcur->dirty = 0;
8001d54a:	30 08       	mov	r8,0
8001d54c:	ef 48 02 04 	st.w	r7[516],r8
8001d550:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8001d554:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

8001d558 <fatfs_set_fs_info_next_free_cluster>:
} 
//-----------------------------------------------------------------------------
// fatfs_set_fs_info_next_free_cluster: Write the next free cluster to the FSINFO table
//-----------------------------------------------------------------------------
void fatfs_set_fs_info_next_free_cluster(struct fatfs *fs, uint32 newValue)
{
8001d558:	d4 21       	pushm	r4-r7,lr
8001d55a:	18 96       	mov	r6,r12
8001d55c:	16 95       	mov	r5,r11
    if (fs->fat_type == FAT_TYPE_16)
8001d55e:	78 c8       	ld.w	r8,r12[0x30]
8001d560:	58 08       	cp.w	r8,0
8001d562:	c0 21       	brne	8001d566 <fatfs_set_fs_info_next_free_cluster+0xe>
8001d564:	d8 22       	popm	r4-r7,pc
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
8001d566:	f9 14 00 18 	ld.uh	r4,r12[24]
8001d56a:	78 78       	ld.w	r8,r12[0x1c]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001d56c:	f8 f7 02 54 	ld.w	r7,r12[596]
    if (fs->fat_type == FAT_TYPE_16)
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
8001d570:	10 04       	add	r4,r8
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d572:	58 07       	cp.w	r7,0
8001d574:	c6 00       	breq	8001d634 <fatfs_set_fs_info_next_free_cluster+0xdc>
8001d576:	30 09       	mov	r9,0
8001d578:	c0 38       	rjmp	8001d57e <fatfs_set_fs_info_next_free_cluster+0x26>
8001d57a:	0e 99       	mov	r9,r7
8001d57c:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001d57e:	ee f8 02 00 	ld.w	r8,r7[512]
8001d582:	10 34       	cp.w	r4,r8
8001d584:	c0 53       	brcs	8001d58e <fatfs_set_fs_info_next_free_cluster+0x36>
8001d586:	f0 ca ff ff 	sub	r10,r8,-1
8001d58a:	14 34       	cp.w	r4,r10
8001d58c:	c4 93       	brcs	8001d61e <fatfs_set_fs_info_next_free_cluster+0xc6>
            break;

        // End of list?
        if (pcur->next == NULL)
8001d58e:	ee f8 02 0c 	ld.w	r8,r7[524]
8001d592:	58 08       	cp.w	r8,0
8001d594:	cf 31       	brne	8001d57a <fatfs_set_fs_info_next_free_cluster+0x22>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001d596:	58 09       	cp.w	r9,0
8001d598:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001d59c:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001d5a0:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d5a4:	58 08       	cp.w	r8,0
8001d5a6:	ce a1       	brne	8001d57a <fatfs_set_fs_info_next_free_cluster+0x22>
8001d5a8:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001d5ac:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001d5b0:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001d5b4:	ee f8 02 04 	ld.w	r8,r7[516]
8001d5b8:	58 08       	cp.w	r8,0
8001d5ba:	c3 f1       	brne	8001d638 <fatfs_set_fs_info_next_free_cluster+0xe0>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001d5bc:	ef 44 02 00 	st.w	r7[512],r4

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001d5c0:	08 9c       	mov	r12,r4
8001d5c2:	6c d8       	ld.w	r8,r6[0x34]
8001d5c4:	0e 94       	mov	r4,r7
8001d5c6:	30 1a       	mov	r10,1
8001d5c8:	0e 9b       	mov	r11,r7
8001d5ca:	5d 18       	icall	r8
8001d5cc:	c3 00       	breq	8001d62c <fatfs_set_fs_info_next_free_cluster+0xd4>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001d5ce:	ef 47 02 08 	st.w	r7[520],r7
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
        if (!pbuf)
            return ;

        // Change 
        FAT32_SET_32BIT_WORD(pbuf, 492, newValue);
8001d5d2:	e9 65 01 ec 	st.b	r4[492],r5
8001d5d6:	ea 09 16 08 	lsr	r9,r5,0x8
8001d5da:	ee f8 02 08 	ld.w	r8,r7[520]
8001d5de:	f1 69 01 ed 	st.b	r8[493],r9
8001d5e2:	ea 09 16 10 	lsr	r9,r5,0x10
8001d5e6:	ee f8 02 08 	ld.w	r8,r7[520]
8001d5ea:	f1 69 01 ee 	st.b	r8[494],r9
8001d5ee:	ea 09 16 18 	lsr	r9,r5,0x18
8001d5f2:	ee f8 02 08 	ld.w	r8,r7[520]
8001d5f6:	f1 69 01 ef 	st.b	r8[495],r9
8001d5fa:	30 1a       	mov	r10,1
8001d5fc:	ef 4a 02 04 	st.w	r7[516],r10
        fs->next_free_cluster = newValue;
8001d600:	8d 95       	st.w	r6[0x24],r5

        // Write back FSINFO sector to disk
        if (fs->disk_io.write_media)
8001d602:	6c e8       	ld.w	r8,r6[0x38]
8001d604:	58 08       	cp.w	r8,0
8001d606:	c0 50       	breq	8001d610 <fatfs_set_fs_info_next_free_cluster+0xb8>
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);    
8001d608:	0e 9b       	mov	r11,r7
8001d60a:	ee fc 02 00 	ld.w	r12,r7[512]
8001d60e:	5d 18       	icall	r8

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
8001d610:	3f f8       	mov	r8,-1
8001d612:	ef 48 02 00 	st.w	r7[512],r8
        pbuf->dirty = 0;
8001d616:	30 08       	mov	r8,0
8001d618:	ef 48 02 04 	st.w	r7[516],r8
8001d61c:	d8 22       	popm	r4-r7,pc
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001d61e:	10 14       	sub	r4,r8
8001d620:	a9 74       	lsl	r4,0x9
8001d622:	ee 04 00 04 	add	r4,r7,r4
8001d626:	ef 44 02 08 	st.w	r7[520],r4
8001d62a:	cd 4b       	rjmp	8001d5d2 <fatfs_set_fs_info_next_free_cluster+0x7a>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001d62c:	3f f8       	mov	r8,-1
8001d62e:	ef 48 02 00 	st.w	r7[512],r8
8001d632:	d8 22       	popm	r4-r7,pc
        if (fs->disk_io.write_media)
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);    

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
        pbuf->dirty = 0;
8001d634:	0e 98       	mov	r8,r7
8001d636:	cb bb       	rjmp	8001d5ac <fatfs_set_fs_info_next_free_cluster+0x54>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8001d638:	0e 9b       	mov	r11,r7
8001d63a:	0c 9c       	mov	r12,r6
8001d63c:	c6 af       	rcall	8001d510 <fatfs_fat_writeback>
8001d63e:	cb f1       	brne	8001d5bc <fatfs_set_fs_info_next_free_cluster+0x64>
8001d640:	c9 2b       	rjmp	8001d564 <fatfs_set_fs_info_next_free_cluster+0xc>
8001d642:	d7 03       	nop

8001d644 <fatfs_fat_init>:
8001d644:	eb cd 40 e0 	pushm	r5-r7,lr
    fs->fat_buffer_head = NULL;

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
8001d648:	3f f8       	mov	r8,-1

//-----------------------------------------------------------------------------
// fatfs_fat_init:
//-----------------------------------------------------------------------------
void fatfs_fat_init(struct fatfs *fs)
{
8001d64a:	18 97       	mov	r7,r12
    int i;

    // FAT buffer chain head
    fs->fat_buffer_head = NULL;
8001d64c:	30 06       	mov	r6,0

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
8001d64e:	f9 48 04 58 	st.w	r12[1112],r8
void fatfs_fat_init(struct fatfs *fs)
{
    int i;

    // FAT buffer chain head
    fs->fat_buffer_head = NULL;
8001d652:	f9 46 02 54 	st.w	r12[596],r6

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
8001d656:	f9 46 04 5c 	st.w	r12[1116],r6
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
8001d65a:	f8 c5 fd a8 	sub	r5,r12,-600
8001d65e:	e0 6a 02 00 	mov	r10,512
8001d662:	0c 9b       	mov	r11,r6
8001d664:	0a 9c       	mov	r12,r5
8001d666:	e0 a0 30 d1 	rcall	80023808 <memset>
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
8001d66a:	ee f8 02 54 	ld.w	r8,r7[596]
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;
8001d66e:	ef 46 04 60 	st.w	r7[1120],r6

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
        fs->fat_buffer_head = &fs->fat_buffers[i];
8001d672:	ef 45 02 54 	st.w	r7[596],r5
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
8001d676:	ef 48 04 64 	st.w	r7[1124],r8
        fs->fat_buffer_head = &fs->fat_buffers[i];
    }
}
8001d67a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001d67e:	d7 03       	nop

8001d680 <fatfs_fat_purge>:
8001d680:	eb cd 40 e0 	pushm	r5-r7,lr
}
//-----------------------------------------------------------------------------
// fatfs_fat_purge: Purge 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
int fatfs_fat_purge(struct fatfs *fs)
{
8001d684:	18 96       	mov	r6,r12
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001d686:	f8 f7 02 54 	ld.w	r7,r12[596]

    // Itterate through sector buffer list
    while (pcur)
8001d68a:	58 07       	cp.w	r7,0
8001d68c:	c2 30       	breq	8001d6d2 <fatfs_fat_purge+0x52>

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
                    return 0;
            }
                
            pcur->dirty = 0;
8001d68e:	30 05       	mov	r5,0
8001d690:	c0 58       	rjmp	8001d69a <fatfs_fat_purge+0x1a>
        // Writeback sector if changed
        if (pcur->dirty) 
            if (!fatfs_fat_writeback(fs, pcur))
                return 0;
        
        pcur = pcur->next;
8001d692:	ee f7 02 0c 	ld.w	r7,r7[524]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d696:	58 07       	cp.w	r7,0
8001d698:	c1 d0       	breq	8001d6d2 <fatfs_fat_purge+0x52>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
8001d69a:	ee f8 02 04 	ld.w	r8,r7[516]
8001d69e:	58 08       	cp.w	r8,0
8001d6a0:	cf 90       	breq	8001d692 <fatfs_fat_purge+0x12>
    if (pcur)
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8001d6a2:	6c e8       	ld.w	r8,r6[0x38]
8001d6a4:	58 08       	cp.w	r8,0
8001d6a6:	c1 00       	breq	8001d6c6 <fatfs_fat_purge+0x46>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001d6a8:	6c 89       	ld.w	r9,r6[0x20]
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8001d6aa:	ee fc 02 00 	ld.w	r12,r7[512]
8001d6ae:	6c 5b       	ld.w	r11,r6[0x14]
8001d6b0:	f8 0b 01 0b 	sub	r11,r12,r11

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8001d6b4:	f2 0b 01 0a 	sub	r10,r9,r11
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001d6b8:	2f fb       	sub	r11,-1
8001d6ba:	12 3b       	cp.w	r11,r9
8001d6bc:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8001d6c0:	0e 9b       	mov	r11,r7
8001d6c2:	5d 18       	icall	r8
8001d6c4:	c0 80       	breq	8001d6d4 <fatfs_fat_purge+0x54>
                    return 0;
            }
                
            pcur->dirty = 0;
8001d6c6:	ef 45 02 04 	st.w	r7[516],r5
        // Writeback sector if changed
        if (pcur->dirty) 
            if (!fatfs_fat_writeback(fs, pcur))
                return 0;
        
        pcur = pcur->next;
8001d6ca:	ee f7 02 0c 	ld.w	r7,r7[524]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d6ce:	58 07       	cp.w	r7,0
8001d6d0:	ce 51       	brne	8001d69a <fatfs_fat_purge+0x1a>
8001d6d2:	30 1c       	mov	r12,1
        
        pcur = pcur->next;
    }

    return 1;
}
8001d6d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d6d8 <fatfs_find_next_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_next_cluster: Return cluster number of next cluster in chain by 
// reading FAT table and traversing it. Return 0xffffffff for end of chain.
//-----------------------------------------------------------------------------
uint32 fatfs_find_next_cluster(struct fatfs *fs, uint32 current_cluster)
{
8001d6d8:	eb cd 40 f8 	pushm	r3-r7,lr
8001d6dc:	18 96       	mov	r6,r12
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8001d6de:	58 0b       	cp.w	r11,0
8001d6e0:	f6 03 17 10 	movne	r3,r11
8001d6e4:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001d6e8:	78 c8       	ld.w	r8,r12[0x30]
8001d6ea:	58 08       	cp.w	r8,0
8001d6ec:	c5 a1       	brne	8001d7a0 <fatfs_find_next_cluster+0xc8>
        fat_sector_offset = current_cluster / 256;
8001d6ee:	e6 04 16 08 	lsr	r4,r3,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d6f2:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001d6f4:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d6f8:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d6fc:	58 07       	cp.w	r7,0
8001d6fe:	c7 80       	breq	8001d7ee <fatfs_find_next_cluster+0x116>
8001d700:	30 09       	mov	r9,0
8001d702:	c0 38       	rjmp	8001d708 <fatfs_find_next_cluster+0x30>
8001d704:	0e 99       	mov	r9,r7
8001d706:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001d708:	ee f8 02 00 	ld.w	r8,r7[512]
8001d70c:	10 35       	cp.w	r5,r8
8001d70e:	c0 53       	brcs	8001d718 <fatfs_find_next_cluster+0x40>
8001d710:	f0 ca ff ff 	sub	r10,r8,-1
8001d714:	14 35       	cp.w	r5,r10
8001d716:	c4 83       	brcs	8001d7a6 <fatfs_find_next_cluster+0xce>
            break;

        // End of list?
        if (pcur->next == NULL)
8001d718:	ee f8 02 0c 	ld.w	r8,r7[524]
8001d71c:	58 08       	cp.w	r8,0
8001d71e:	cf 31       	brne	8001d704 <fatfs_find_next_cluster+0x2c>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001d720:	58 09       	cp.w	r9,0
8001d722:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001d726:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001d72a:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d72e:	58 08       	cp.w	r8,0
8001d730:	ce a1       	brne	8001d704 <fatfs_find_next_cluster+0x2c>
8001d732:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001d736:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001d73a:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001d73e:	ee f8 02 04 	ld.w	r8,r7[516]
8001d742:	58 08       	cp.w	r8,0
8001d744:	c5 71       	brne	8001d7f2 <fatfs_find_next_cluster+0x11a>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001d746:	ef 45 02 00 	st.w	r7[512],r5

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001d74a:	0a 9c       	mov	r12,r5
8001d74c:	6c d8       	ld.w	r8,r6[0x34]
8001d74e:	0e 95       	mov	r5,r7
8001d750:	30 1a       	mov	r10,1
8001d752:	0e 9b       	mov	r11,r7
8001d754:	5d 18       	icall	r8
8001d756:	c4 70       	breq	8001d7e4 <fatfs_find_next_cluster+0x10c>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001d758:	eb 47 02 08 	st.w	r5[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8001d75c:	6c c8       	ld.w	r8,r6[0x30]
8001d75e:	58 08       	cp.w	r8,0
8001d760:	c2 c0       	breq	8001d7b8 <fatfs_find_next_cluster+0xe0>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8001d762:	e8 08 15 07 	lsl	r8,r4,0x7
8001d766:	e6 08 01 08 	sub	r8,r3,r8
8001d76a:	a3 68       	lsl	r8,0x2
8001d76c:	5c 78       	castu.h	r8
8001d76e:	ea 08 07 09 	ld.ub	r9,r5[r8]
8001d772:	10 05       	add	r5,r8
8001d774:	0b 98       	ld.ub	r8,r5[0x1]
8001d776:	a9 68       	lsl	r8,0x8
8001d778:	0b bc       	ld.ub	r12,r5[0x3]
8001d77a:	0b aa       	ld.ub	r10,r5[0x2]
8001d77c:	b9 6c       	lsl	r12,0x18
8001d77e:	b1 6a       	lsl	r10,0x10
8001d780:	14 0c       	add	r12,r10
8001d782:	12 0c       	add	r12,r9
8001d784:	10 0c       	add	r12,r8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001d786:	30 88       	mov	r8,8
8001d788:	ea 18 f0 00 	orh	r8,0xf000

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8001d78c:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001d790:	f8 08 00 08 	add	r8,r12,r8
8001d794:	58 78       	cp.w	r8,7
8001d796:	e0 8b 00 25 	brhi	8001d7e0 <fatfs_find_next_cluster+0x108>
8001d79a:	3f fc       	mov	r12,-1
            return (FAT32_LAST_CLUSTER); 
    }

    // Else return next cluster
    return (nextcluster);                         
} 
8001d79c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8001d7a0:	e6 04 16 07 	lsr	r4,r3,0x7
8001d7a4:	ca 7b       	rjmp	8001d6f2 <fatfs_find_next_cluster+0x1a>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001d7a6:	10 15       	sub	r5,r8
8001d7a8:	a9 75       	lsl	r5,0x9
8001d7aa:	ee 05 00 05 	add	r5,r7,r5
8001d7ae:	ef 45 02 08 	st.w	r7[520],r5
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8001d7b2:	6c c8       	ld.w	r8,r6[0x30]
8001d7b4:	58 08       	cp.w	r8,0
8001d7b6:	cd 61       	brne	8001d762 <fatfs_find_next_cluster+0x8a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8001d7b8:	e8 08 15 08 	lsl	r8,r4,0x8
8001d7bc:	e6 08 01 08 	sub	r8,r3,r8
8001d7c0:	a1 78       	lsl	r8,0x1
8001d7c2:	5c 78       	castu.h	r8
8001d7c4:	ea 08 07 09 	ld.ub	r9,r5[r8]
8001d7c8:	ea 08 00 08 	add	r8,r5,r8
8001d7cc:	11 9c       	ld.ub	r12,r8[0x1]
8001d7ce:	a9 6c       	lsl	r12,0x8
8001d7d0:	12 0c       	add	r12,r9

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8001d7d2:	fe 79 00 08 	mov	r9,-65528
8001d7d6:	f8 09 00 08 	add	r8,r12,r9
8001d7da:	58 78       	cp.w	r8,7
8001d7dc:	fe 98 ff df 	brls	8001d79a <fatfs_find_next_cluster+0xc2>
            return (FAT32_LAST_CLUSTER); 
    }

    // Else return next cluster
    return (nextcluster);                         
} 
8001d7e0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001d7e4:	3f fc       	mov	r12,-1
8001d7e6:	ef 4c 02 00 	st.w	r7[512],r12
8001d7ea:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001d7ee:	0e 98       	mov	r8,r7
8001d7f0:	ca 3b       	rjmp	8001d736 <fatfs_find_next_cluster+0x5e>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8001d7f2:	0e 9b       	mov	r11,r7
8001d7f4:	0c 9c       	mov	r12,r6
8001d7f6:	c8 de       	rcall	8001d510 <fatfs_fat_writeback>
8001d7f8:	ca 71       	brne	8001d746 <fatfs_find_next_cluster+0x6e>
8001d7fa:	3f fc       	mov	r12,-1

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001d7fc:	cd 0b       	rjmp	8001d79c <fatfs_find_next_cluster+0xc4>
8001d7fe:	d7 03       	nop

8001d800 <fatfs_fat_set_cluster>:
8001d800:	eb cd 40 fc 	pushm	r2-r7,lr
// fatfs_fat_set_cluster: Set a cluster link in the chain. NOTE: Immediate
// write (slow).
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_set_cluster(struct fatfs *fs, uint32 cluster, uint32 next_cluster)
{
8001d804:	18 96       	mov	r6,r12
8001d806:	16 93       	mov	r3,r11
8001d808:	14 95       	mov	r5,r10
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001d80a:	78 c8       	ld.w	r8,r12[0x30]
8001d80c:	58 08       	cp.w	r8,0
8001d80e:	c4 f1       	brne	8001d8ac <fatfs_fat_set_cluster+0xac>
        fat_sector_offset = cluster / 256;
8001d810:	f6 04 16 08 	lsr	r4,r11,0x8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d814:	6c 52       	ld.w	r2,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001d816:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d81a:	e8 02 00 02 	add	r2,r4,r2
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d81e:	58 07       	cp.w	r7,0
8001d820:	c7 70       	breq	8001d90e <fatfs_fat_set_cluster+0x10e>
8001d822:	30 09       	mov	r9,0
8001d824:	c0 38       	rjmp	8001d82a <fatfs_fat_set_cluster+0x2a>
8001d826:	0e 99       	mov	r9,r7
8001d828:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001d82a:	ee f8 02 00 	ld.w	r8,r7[512]
8001d82e:	10 32       	cp.w	r2,r8
8001d830:	c0 53       	brcs	8001d83a <fatfs_fat_set_cluster+0x3a>
8001d832:	f0 ca ff ff 	sub	r10,r8,-1
8001d836:	14 32       	cp.w	r2,r10
8001d838:	c3 d3       	brcs	8001d8b2 <fatfs_fat_set_cluster+0xb2>
            break;

        // End of list?
        if (pcur->next == NULL)
8001d83a:	ee f8 02 0c 	ld.w	r8,r7[524]
8001d83e:	58 08       	cp.w	r8,0
8001d840:	cf 31       	brne	8001d826 <fatfs_fat_set_cluster+0x26>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001d842:	58 09       	cp.w	r9,0
8001d844:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001d848:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001d84c:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d850:	58 08       	cp.w	r8,0
8001d852:	ce a1       	brne	8001d826 <fatfs_fat_set_cluster+0x26>
8001d854:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001d858:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001d85c:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001d860:	ee f8 02 04 	ld.w	r8,r7[516]
8001d864:	58 08       	cp.w	r8,0
8001d866:	c5 61       	brne	8001d912 <fatfs_fat_set_cluster+0x112>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001d868:	ef 42 02 00 	st.w	r7[512],r2

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001d86c:	04 9c       	mov	r12,r2
8001d86e:	6c d8       	ld.w	r8,r6[0x34]
8001d870:	30 1a       	mov	r10,1
8001d872:	0e 9b       	mov	r11,r7
8001d874:	5d 18       	icall	r8
8001d876:	0e 99       	mov	r9,r7
8001d878:	c4 60       	breq	8001d904 <fatfs_fat_set_cluster+0x104>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001d87a:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8001d87e:	6c c8       	ld.w	r8,r6[0x30]
8001d880:	58 08       	cp.w	r8,0
8001d882:	c2 21       	brne	8001d8c6 <fatfs_fat_set_cluster+0xc6>
    {
        // Find 16 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 256)) * 2; 

        // Write Next Clusters value to Sector Buffer
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));     
8001d884:	e8 08 15 08 	lsl	r8,r4,0x8
8001d888:	e6 08 01 08 	sub	r8,r3,r8
8001d88c:	a1 78       	lsl	r8,0x1
8001d88e:	5c 78       	castu.h	r8
8001d890:	f2 08 0b 05 	st.b	r9[r8],r5
8001d894:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
8001d898:	ee f9 02 08 	ld.w	r9,r7[520]
8001d89c:	f2 08 00 08 	add	r8,r9,r8
8001d8a0:	b0 95       	st.b	r8[0x1],r5
8001d8a2:	30 1c       	mov	r12,1
8001d8a4:	ef 4c 02 04 	st.w	r7[516],r12
8001d8a8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;
8001d8ac:	f6 04 16 07 	lsr	r4,r11,0x7
8001d8b0:	cb 2b       	rjmp	8001d814 <fatfs_fat_set_cluster+0x14>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001d8b2:	e4 08 01 09 	sub	r9,r2,r8
8001d8b6:	a9 79       	lsl	r9,0x9
8001d8b8:	ee 09 00 09 	add	r9,r7,r9
8001d8bc:	ef 49 02 08 	st.w	r7[520],r9
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8001d8c0:	6c c8       	ld.w	r8,r6[0x30]
8001d8c2:	58 08       	cp.w	r8,0
8001d8c4:	ce 00       	breq	8001d884 <fatfs_fat_set_cluster+0x84>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8001d8c6:	ea 0a 16 08 	lsr	r10,r5,0x8
8001d8ca:	e8 08 15 07 	lsl	r8,r4,0x7
8001d8ce:	e6 08 01 08 	sub	r8,r3,r8
8001d8d2:	a3 68       	lsl	r8,0x2
8001d8d4:	5c 78       	castu.h	r8
8001d8d6:	f2 08 0b 05 	st.b	r9[r8],r5
8001d8da:	ee f9 02 08 	ld.w	r9,r7[520]
8001d8de:	10 09       	add	r9,r8
8001d8e0:	b2 9a       	st.b	r9[0x1],r10
8001d8e2:	ea 0a 16 10 	lsr	r10,r5,0x10
8001d8e6:	ee f9 02 08 	ld.w	r9,r7[520]
8001d8ea:	10 09       	add	r9,r8
8001d8ec:	b2 aa       	st.b	r9[0x2],r10
8001d8ee:	b9 85       	lsr	r5,0x18
8001d8f0:	ee f9 02 08 	ld.w	r9,r7[520]
8001d8f4:	f2 08 00 08 	add	r8,r9,r8
8001d8f8:	b0 b5       	st.b	r8[0x3],r5
8001d8fa:	30 1c       	mov	r12,1
8001d8fc:	ef 4c 02 04 	st.w	r7[516],r12
    }

    return 1;                     
} 
8001d900:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001d904:	3f f8       	mov	r8,-1
8001d906:	ef 48 02 00 	st.w	r7[512],r8
8001d90a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8001d90e:	0e 98       	mov	r8,r7
8001d910:	ca 4b       	rjmp	8001d858 <fatfs_fat_set_cluster+0x58>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
8001d912:	0e 9b       	mov	r11,r7
8001d914:	0c 9c       	mov	r12,r6
8001d916:	fe b0 fd fd 	rcall	8001d510 <fatfs_fat_writeback>
8001d91a:	ca 71       	brne	8001d868 <fatfs_fat_set_cluster+0x68>
8001d91c:	cf 2b       	rjmp	8001d900 <fatfs_fat_set_cluster+0x100>
8001d91e:	d7 03       	nop

8001d920 <fatfs_fat_add_cluster_to_chain>:
8001d920:	d4 31       	pushm	r0-r7,lr
8001d922:	18 96       	mov	r6,r12
// fatfs_fat_add_cluster_to_chain: Follow a chain marking and then add a new entry
// to the current tail.
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_add_cluster_to_chain(struct fatfs *fs, uint32 start_cluster, uint32 newEntry)
{
8001d924:	14 90       	mov	r0,r10
    uint32 last_cluster = FAT32_LAST_CLUSTER;
    uint32 next_cluster = start_cluster;

    if (start_cluster == FAT32_LAST_CLUSTER)
8001d926:	5b fb       	cp.w	r11,-1
8001d928:	e0 80 00 a5 	breq	8001da72 <fatfs_fat_add_cluster_to_chain+0x152>
8001d92c:	16 92       	mov	r2,r11
8001d92e:	78 c8       	ld.w	r8,r12[0x30]

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001d930:	30 81       	mov	r1,8
8001d932:	ea 11 f0 00 	orh	r1,0xf000
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8001d936:	58 02       	cp.w	r2,0
8001d938:	e4 03 17 10 	movne	r3,r2
8001d93c:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001d940:	58 08       	cp.w	r8,0
8001d942:	c5 c1       	brne	8001d9fa <fatfs_fat_add_cluster_to_chain+0xda>
        fat_sector_offset = current_cluster / 256;
8001d944:	e6 04 16 08 	lsr	r4,r3,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d948:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001d94a:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d94e:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d952:	58 07       	cp.w	r7,0
8001d954:	c5 c0       	breq	8001da0c <fatfs_fat_add_cluster_to_chain+0xec>
8001d956:	30 09       	mov	r9,0
8001d958:	c0 38       	rjmp	8001d95e <fatfs_fat_add_cluster_to_chain+0x3e>
8001d95a:	0e 99       	mov	r9,r7
8001d95c:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001d95e:	ee f8 02 00 	ld.w	r8,r7[512]
8001d962:	10 35       	cp.w	r5,r8
8001d964:	c0 63       	brcs	8001d970 <fatfs_fat_add_cluster_to_chain+0x50>
8001d966:	f0 ca ff ff 	sub	r10,r8,-1
8001d96a:	14 35       	cp.w	r5,r10
8001d96c:	e0 83 00 84 	brlo	8001da74 <fatfs_fat_add_cluster_to_chain+0x154>
            break;

        // End of list?
        if (pcur->next == NULL)
8001d970:	ee f8 02 0c 	ld.w	r8,r7[524]
8001d974:	58 08       	cp.w	r8,0
8001d976:	cf 21       	brne	8001d95a <fatfs_fat_add_cluster_to_chain+0x3a>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001d978:	58 09       	cp.w	r9,0
8001d97a:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001d97e:	ed f9 0a 95 	st.weq	r6[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001d982:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001d986:	58 08       	cp.w	r8,0
8001d988:	ce 91       	brne	8001d95a <fatfs_fat_add_cluster_to_chain+0x3a>
8001d98a:	ec f8 02 54 	ld.w	r8,r6[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001d98e:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001d992:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001d996:	ee f8 02 04 	ld.w	r8,r7[516]
8001d99a:	58 08       	cp.w	r8,0
8001d99c:	c4 11       	brne	8001da1e <fatfs_fat_add_cluster_to_chain+0xfe>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001d99e:	ef 45 02 00 	st.w	r7[512],r5

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001d9a2:	0a 9c       	mov	r12,r5
8001d9a4:	6c d8       	ld.w	r8,r6[0x34]
8001d9a6:	0e 95       	mov	r5,r7
8001d9a8:	30 1a       	mov	r10,1
8001d9aa:	0e 9b       	mov	r11,r7
8001d9ac:	5d 18       	icall	r8
8001d9ae:	c6 a0       	breq	8001da82 <fatfs_fat_add_cluster_to_chain+0x162>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001d9b0:	ef 47 02 08 	st.w	r7[520],r7
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
8001d9b4:	58 07       	cp.w	r7,0
8001d9b6:	c3 90       	breq	8001da28 <fatfs_fat_add_cluster_to_chain+0x108>
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8001d9b8:	6c c8       	ld.w	r8,r6[0x30]
8001d9ba:	58 08       	cp.w	r8,0
8001d9bc:	c3 f1       	brne	8001da3a <fatfs_fat_add_cluster_to_chain+0x11a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8001d9be:	e8 0a 15 08 	lsl	r10,r4,0x8
8001d9c2:	e6 0a 01 0a 	sub	r10,r3,r10
8001d9c6:	a1 7a       	lsl	r10,0x1
8001d9c8:	5c 7a       	castu.h	r10
8001d9ca:	ea 0a 07 0b 	ld.ub	r11,r5[r10]
8001d9ce:	ea 0a 00 0a 	add	r10,r5,r10
8001d9d2:	15 99       	ld.ub	r9,r10[0x1]
8001d9d4:	a9 69       	lsl	r9,0x8
8001d9d6:	16 09       	add	r9,r11

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8001d9d8:	fe 7b 00 08 	mov	r11,-65528
8001d9dc:	f2 0b 00 0a 	add	r10,r9,r11
8001d9e0:	58 7a       	cp.w	r10,7
8001d9e2:	e0 88 00 23 	brls	8001da28 <fatfs_fat_add_cluster_to_chain+0x108>
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
        if (!next_cluster)
8001d9e6:	58 09       	cp.w	r9,0
8001d9e8:	c4 50       	breq	8001da72 <fatfs_fat_add_cluster_to_chain+0x152>

    if (start_cluster == FAT32_LAST_CLUSTER)
        return 0;
    
    // Loop until end of chain
    while ( next_cluster != FAT32_LAST_CLUSTER )
8001d9ea:	12 92       	mov	r2,r9
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
8001d9ec:	58 02       	cp.w	r2,0
8001d9ee:	e4 03 17 10 	movne	r3,r2
8001d9f2:	f9 b3 00 02 	moveq	r3,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001d9f6:	58 08       	cp.w	r8,0
8001d9f8:	ca 60       	breq	8001d944 <fatfs_fat_add_cluster_to_chain+0x24>
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8001d9fa:	e6 04 16 07 	lsr	r4,r3,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001d9fe:	6c 55       	ld.w	r5,r6[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001da00:	ec f7 02 54 	ld.w	r7,r6[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001da04:	e8 05 00 05 	add	r5,r4,r5
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001da08:	58 07       	cp.w	r7,0
8001da0a:	ca 61       	brne	8001d956 <fatfs_fat_add_cluster_to_chain+0x36>
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);

    return 1;
8001da0c:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001da0e:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001da12:	ed 47 02 54 	st.w	r6[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001da16:	ee f8 02 04 	ld.w	r8,r7[516]
8001da1a:	58 08       	cp.w	r8,0
8001da1c:	cc 10       	breq	8001d99e <fatfs_fat_add_cluster_to_chain+0x7e>
        if (!fatfs_fat_writeback(fs, pcur))
8001da1e:	0e 9b       	mov	r11,r7
8001da20:	0c 9c       	mov	r12,r6
8001da22:	fe b0 fd 77 	rcall	8001d510 <fatfs_fat_writeback>
8001da26:	cb c1       	brne	8001d99e <fatfs_fat_add_cluster_to_chain+0x7e>
        if (!next_cluster)
            return 0;
    }

    // Add link in for new cluster
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);
8001da28:	04 9b       	mov	r11,r2
8001da2a:	00 9a       	mov	r10,r0
8001da2c:	0c 9c       	mov	r12,r6
8001da2e:	ce 9e       	rcall	8001d800 <fatfs_fat_set_cluster>
8001da30:	00 9b       	mov	r11,r0

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);
8001da32:	0c 9c       	mov	r12,r6
8001da34:	3f fa       	mov	r10,-1
8001da36:	ce 5e       	rcall	8001d800 <fatfs_fat_set_cluster>
8001da38:	da 3a       	popm	r0-r7,pc,r12=1
8001da3a:	e8 09 15 07 	lsl	r9,r4,0x7
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8001da3e:	e6 09 01 09 	sub	r9,r3,r9
8001da42:	a3 69       	lsl	r9,0x2
8001da44:	5c 79       	castu.h	r9
8001da46:	ea 09 07 0b 	ld.ub	r11,r5[r9]

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8001da4a:	12 05       	add	r5,r9
8001da4c:	0b 9a       	ld.ub	r10,r5[0x1]
8001da4e:	a9 6a       	lsl	r10,0x8
8001da50:	0b bc       	ld.ub	r12,r5[0x3]
8001da52:	0b a9       	ld.ub	r9,r5[0x2]
8001da54:	b9 6c       	lsl	r12,0x18
8001da56:	b1 69       	lsl	r9,0x10
8001da58:	f8 09 00 09 	add	r9,r12,r9
8001da5c:	16 09       	add	r9,r11
8001da5e:	14 09       	add	r9,r10
8001da60:	f3 d9 c0 1c 	bfextu	r9,r9,0x0,0x1c
8001da64:	f2 01 00 0a 	add	r10,r9,r1

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001da68:	58 7a       	cp.w	r10,7
8001da6a:	fe 98 ff df 	brls	8001da28 <fatfs_fat_add_cluster_to_chain+0x108>
8001da6e:	58 09       	cp.w	r9,0
8001da70:	cb d1       	brne	8001d9ea <fatfs_fat_add_cluster_to_chain+0xca>
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
        if (!next_cluster)
8001da72:	d8 3a       	popm	r0-r7,pc,r12=0
8001da74:	10 15       	sub	r5,r8
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);

    return 1;
8001da76:	a9 75       	lsl	r5,0x9
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001da78:	ee 05 00 05 	add	r5,r7,r5
8001da7c:	ef 45 02 08 	st.w	r7[520],r5
8001da80:	c9 cb       	rjmp	8001d9b8 <fatfs_fat_add_cluster_to_chain+0x98>
8001da82:	3f f8       	mov	r8,-1
8001da84:	ef 48 02 00 	st.w	r7[512],r8

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001da88:	cd 0b       	rjmp	8001da28 <fatfs_fat_add_cluster_to_chain+0x108>
8001da8a:	d7 03       	nop

8001da8c <fatfs_free_cluster_chain>:
8001da8c:	d4 31       	pushm	r0-r7,lr
8001da8e:	30 10       	mov	r0,1
8001da90:	16 94       	mov	r4,r11
8001da92:	18 95       	mov	r5,r12
8001da94:	30 01       	mov	r1,0
8001da96:	e8 c8 00 01 	sub	r8,r4,1
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8001da9a:	5b d8       	cp.w	r8,-3
8001da9c:	e0 8b 00 b5 	brhi	8001dc06 <fatfs_free_cluster_chain+0x17a>
    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001daa0:	6a c8       	ld.w	r8,r5[0x30]
8001daa2:	58 08       	cp.w	r8,0
8001daa4:	e0 81 00 b2 	brne	8001dc08 <fatfs_free_cluster_chain+0x17c>
        fat_sector_offset = current_cluster / 256;
8001daa8:	e8 03 16 08 	lsr	r3,r4,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001daac:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001daae:	ea f7 02 54 	ld.w	r7,r5[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dab2:	e6 06 00 06 	add	r6,r3,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001dab6:	58 07       	cp.w	r7,0
8001dab8:	e0 80 00 b2 	breq	8001dc1c <fatfs_free_cluster_chain+0x190>
8001dabc:	30 09       	mov	r9,0
8001dabe:	c0 38       	rjmp	8001dac4 <fatfs_free_cluster_chain+0x38>
8001dac0:	0e 99       	mov	r9,r7
8001dac2:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001dac4:	ee f8 02 00 	ld.w	r8,r7[512]
8001dac8:	10 36       	cp.w	r6,r8
8001daca:	c0 63       	brcs	8001dad6 <fatfs_free_cluster_chain+0x4a>
8001dacc:	f0 ca ff ff 	sub	r10,r8,-1
8001dad0:	14 36       	cp.w	r6,r10
8001dad2:	e0 83 01 2a 	brlo	8001dd26 <fatfs_free_cluster_chain+0x29a>
            break;

        // End of list?
        if (pcur->next == NULL)
8001dad6:	ee f8 02 0c 	ld.w	r8,r7[524]
8001dada:	58 08       	cp.w	r8,0
8001dadc:	cf 21       	brne	8001dac0 <fatfs_free_cluster_chain+0x34>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001dade:	58 09       	cp.w	r9,0
8001dae0:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001dae4:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001dae8:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001daec:	58 08       	cp.w	r8,0
8001daee:	ce 91       	brne	8001dac0 <fatfs_free_cluster_chain+0x34>
8001daf0:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001daf4:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001daf8:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001dafc:	ee f8 02 04 	ld.w	r8,r7[516]
8001db00:	58 08       	cp.w	r8,0
8001db02:	e0 81 00 97 	brne	8001dc30 <fatfs_free_cluster_chain+0x1a4>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001db06:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001db0a:	0c 9c       	mov	r12,r6
8001db0c:	6a d8       	ld.w	r8,r5[0x34]
8001db0e:	0e 96       	mov	r6,r7
8001db10:	30 1a       	mov	r10,1
8001db12:	0e 9b       	mov	r11,r7
8001db14:	5d 18       	icall	r8
8001db16:	e0 80 01 14 	breq	8001dd3e <fatfs_free_cluster_chain+0x2b2>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001db1a:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
8001db1e:	6a c8       	ld.w	r8,r5[0x30]
8001db20:	58 08       	cp.w	r8,0
8001db22:	e0 81 00 a1 	brne	8001dc64 <fatfs_free_cluster_chain+0x1d8>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8001db26:	e6 08 15 08 	lsl	r8,r3,0x8
8001db2a:	e8 08 01 08 	sub	r8,r4,r8
8001db2e:	a1 78       	lsl	r8,0x1
8001db30:	5c 78       	castu.h	r8
8001db32:	ec 08 07 09 	ld.ub	r9,r6[r8]
8001db36:	ec 08 00 08 	add	r8,r6,r8
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001db3a:	ea f7 02 54 	ld.w	r7,r5[596]
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8001db3e:	11 93       	ld.ub	r3,r8[0x1]
8001db40:	a9 63       	lsl	r3,0x8
8001db42:	12 03       	add	r3,r9

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
8001db44:	fe 79 00 08 	mov	r9,-65528
8001db48:	e6 09 00 08 	add	r8,r3,r9
8001db4c:	58 78       	cp.w	r8,7
8001db4e:	f9 b3 08 ff 	movls	r3,-1
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
8001db52:	e8 02 16 08 	lsr	r2,r4,0x8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001db56:	6a 56       	ld.w	r6,r5[0x14]
8001db58:	e4 06 00 06 	add	r6,r2,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001db5c:	58 07       	cp.w	r7,0
8001db5e:	e0 80 00 a9 	breq	8001dcb0 <fatfs_free_cluster_chain+0x224>
8001db62:	30 09       	mov	r9,0
8001db64:	c0 38       	rjmp	8001db6a <fatfs_free_cluster_chain+0xde>
8001db66:	0e 99       	mov	r9,r7
8001db68:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001db6a:	ee f8 02 00 	ld.w	r8,r7[512]
8001db6e:	10 36       	cp.w	r6,r8
8001db70:	c0 63       	brcs	8001db7c <fatfs_free_cluster_chain+0xf0>
8001db72:	f0 ca ff ff 	sub	r10,r8,-1
8001db76:	14 36       	cp.w	r6,r10
8001db78:	e0 83 00 d0 	brlo	8001dd18 <fatfs_free_cluster_chain+0x28c>
            break;

        // End of list?
        if (pcur->next == NULL)
8001db7c:	ee f8 02 0c 	ld.w	r8,r7[524]
8001db80:	58 08       	cp.w	r8,0
8001db82:	cf 21       	brne	8001db66 <fatfs_free_cluster_chain+0xda>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001db84:	58 09       	cp.w	r9,0
8001db86:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001db8a:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001db8e:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001db92:	58 08       	cp.w	r8,0
8001db94:	ce 91       	brne	8001db66 <fatfs_free_cluster_chain+0xda>
8001db96:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001db9a:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001db9e:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001dba2:	ee f8 02 04 	ld.w	r8,r7[516]
8001dba6:	58 08       	cp.w	r8,0
8001dba8:	e0 81 00 8e 	brne	8001dcc4 <fatfs_free_cluster_chain+0x238>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001dbac:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001dbb0:	0c 9c       	mov	r12,r6
8001dbb2:	6a d8       	ld.w	r8,r5[0x34]
8001dbb4:	0e 96       	mov	r6,r7
8001dbb6:	30 1a       	mov	r10,1
8001dbb8:	0e 9b       	mov	r11,r7
8001dbba:	5d 18       	icall	r8
8001dbbc:	e0 80 00 bc 	breq	8001dd34 <fatfs_free_cluster_chain+0x2a8>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001dbc0:	ef 47 02 08 	st.w	r7[520],r7
    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    if (!pbuf)
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
8001dbc4:	6a c8       	ld.w	r8,r5[0x30]
8001dbc6:	58 08       	cp.w	r8,0
8001dbc8:	e0 80 00 97 	breq	8001dcf6 <fatfs_free_cluster_chain+0x26a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8001dbcc:	e4 08 15 07 	lsl	r8,r2,0x7
8001dbd0:	e8 08 01 08 	sub	r8,r4,r8
8001dbd4:	a3 68       	lsl	r8,0x2
8001dbd6:	5c 78       	castu.h	r8
8001dbd8:	ec 08 0b 01 	st.b	r6[r8],r1
8001dbdc:	ee f9 02 08 	ld.w	r9,r7[520]
8001dbe0:	10 09       	add	r9,r8
8001dbe2:	b2 91       	st.b	r9[0x1],r1
8001dbe4:	ee f9 02 08 	ld.w	r9,r7[520]
8001dbe8:	10 09       	add	r9,r8
8001dbea:	b2 a1       	st.b	r9[0x2],r1
8001dbec:	ee f9 02 08 	ld.w	r9,r7[520]
8001dbf0:	f2 08 00 08 	add	r8,r9,r8
8001dbf4:	b0 b1       	st.b	r8[0x3],r1
8001dbf6:	ef 40 02 04 	st.w	r7[516],r0
8001dbfa:	06 94       	mov	r4,r3
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8001dbfc:	e8 c8 00 01 	sub	r8,r4,1
8001dc00:	5b d8       	cp.w	r8,-3
8001dc02:	fe 98 ff 4f 	brls	8001daa0 <fatfs_free_cluster_chain+0x14>
        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    }

    return 1;
} 
8001dc06:	da 3a       	popm	r0-r7,pc,r12=1

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
8001dc08:	e8 03 16 07 	lsr	r3,r4,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dc0c:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001dc0e:	ea f7 02 54 	ld.w	r7,r5[596]
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dc12:	e6 06 00 06 	add	r6,r3,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001dc16:	58 07       	cp.w	r7,0
8001dc18:	fe 91 ff 52 	brne	8001dabc <fatfs_free_cluster_chain+0x30>
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
8001dc1c:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001dc1e:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001dc22:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001dc26:	ee f8 02 04 	ld.w	r8,r7[516]
8001dc2a:	58 08       	cp.w	r8,0
8001dc2c:	fe 90 ff 6d 	breq	8001db06 <fatfs_free_cluster_chain+0x7a>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8001dc30:	58 07       	cp.w	r7,0
8001dc32:	e0 80 00 8b 	breq	8001dd48 <fatfs_free_cluster_chain+0x2bc>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8001dc36:	6a e8       	ld.w	r8,r5[0x38]
8001dc38:	58 08       	cp.w	r8,0
8001dc3a:	c1 10       	breq	8001dc5c <fatfs_free_cluster_chain+0x1d0>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8001dc3c:	ee fc 02 00 	ld.w	r12,r7[512]
8001dc40:	6a 59       	ld.w	r9,r5[0x14]
8001dc42:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001dc46:	f2 cb ff ff 	sub	r11,r9,-1
8001dc4a:	6a 8a       	ld.w	r10,r5[0x20]
8001dc4c:	14 3b       	cp.w	r11,r10
8001dc4e:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8001dc52:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8001dc56:	0e 9b       	mov	r11,r7
8001dc58:	5d 18       	icall	r8
8001dc5a:	c7 50       	breq	8001dd44 <fatfs_free_cluster_chain+0x2b8>
                    return 0;
            }
                
            pcur->dirty = 0;
8001dc5c:	30 09       	mov	r9,0
8001dc5e:	ef 49 02 04 	st.w	r7[516],r9
8001dc62:	c5 2b       	rjmp	8001db06 <fatfs_free_cluster_chain+0x7a>
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8001dc64:	e6 08 15 07 	lsl	r8,r3,0x7
8001dc68:	e8 08 01 08 	sub	r8,r4,r8
8001dc6c:	a3 68       	lsl	r8,0x2
8001dc6e:	5c 78       	castu.h	r8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8001dc70:	ec 08 07 09 	ld.ub	r9,r6[r8]
8001dc74:	10 06       	add	r6,r8
8001dc76:	0d 98       	ld.ub	r8,r6[0x1]
8001dc78:	a9 68       	lsl	r8,0x8
8001dc7a:	0d b3       	ld.ub	r3,r6[0x3]
8001dc7c:	0d aa       	ld.ub	r10,r6[0x2]
8001dc7e:	b9 63       	lsl	r3,0x18
8001dc80:	b1 6a       	lsl	r10,0x10
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001dc82:	ea f7 02 54 	ld.w	r7,r5[596]

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8001dc86:	14 03       	add	r3,r10
8001dc88:	12 03       	add	r3,r9

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001dc8a:	30 89       	mov	r9,8
8001dc8c:	ea 19 f0 00 	orh	r9,0xf000

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
8001dc90:	10 03       	add	r3,r8
8001dc92:	e7 d3 c0 1c 	bfextu	r3,r3,0x0,0x1c

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001dc96:	e6 09 00 08 	add	r8,r3,r9
8001dc9a:	58 78       	cp.w	r8,7
8001dc9c:	f9 b3 08 ff 	movls	r3,-1

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;
8001dca0:	e8 02 16 07 	lsr	r2,r4,0x7

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dca4:	6a 56       	ld.w	r6,r5[0x14]
8001dca6:	e4 06 00 06 	add	r6,r2,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001dcaa:	58 07       	cp.w	r7,0
8001dcac:	fe 91 ff 5b 	brne	8001db62 <fatfs_free_cluster_chain+0xd6>
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001dcb0:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001dcb2:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001dcb6:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001dcba:	ee f8 02 04 	ld.w	r8,r7[516]
8001dcbe:	58 08       	cp.w	r8,0
8001dcc0:	fe 90 ff 76 	breq	8001dbac <fatfs_free_cluster_chain+0x120>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8001dcc4:	58 07       	cp.w	r7,0
8001dcc6:	c9 a0       	breq	8001dbfa <fatfs_free_cluster_chain+0x16e>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8001dcc8:	6a e8       	ld.w	r8,r5[0x38]
8001dcca:	58 08       	cp.w	r8,0
8001dccc:	c1 10       	breq	8001dcee <fatfs_free_cluster_chain+0x262>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8001dcce:	ee fc 02 00 	ld.w	r12,r7[512]
8001dcd2:	6a 59       	ld.w	r9,r5[0x14]
8001dcd4:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001dcd8:	f2 cb ff ff 	sub	r11,r9,-1
8001dcdc:	6a 8a       	ld.w	r10,r5[0x20]
8001dcde:	14 3b       	cp.w	r11,r10
8001dce0:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8001dce4:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8001dce8:	0e 9b       	mov	r11,r7
8001dcea:	5d 18       	icall	r8
8001dcec:	c8 70       	breq	8001dbfa <fatfs_free_cluster_chain+0x16e>
                    return 0;
            }
                
            pcur->dirty = 0;
8001dcee:	30 08       	mov	r8,0
8001dcf0:	ef 48 02 04 	st.w	r7[516],r8
8001dcf4:	c5 cb       	rjmp	8001dbac <fatfs_free_cluster_chain+0x120>
    {
        // Find 16 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 256)) * 2; 

        // Write Next Clusters value to Sector Buffer
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));     
8001dcf6:	e4 09 15 08 	lsl	r9,r2,0x8
8001dcfa:	e8 09 01 09 	sub	r9,r4,r9
8001dcfe:	a1 79       	lsl	r9,0x1
8001dd00:	5c 79       	castu.h	r9
8001dd02:	ec 09 0b 08 	st.b	r6[r9],r8
8001dd06:	ee fa 02 08 	ld.w	r10,r7[520]
8001dd0a:	f4 09 00 09 	add	r9,r10,r9
8001dd0e:	b2 98       	st.b	r9[0x1],r8
8001dd10:	ef 40 02 04 	st.w	r7[516],r0
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8001dd14:	06 94       	mov	r4,r3
8001dd16:	c7 3b       	rjmp	8001dbfc <fatfs_free_cluster_chain+0x170>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001dd18:	10 16       	sub	r6,r8
8001dd1a:	a9 76       	lsl	r6,0x9
8001dd1c:	ee 06 00 06 	add	r6,r7,r6
8001dd20:	ef 46 02 08 	st.w	r7[520],r6
8001dd24:	c5 0b       	rjmp	8001dbc4 <fatfs_free_cluster_chain+0x138>
8001dd26:	10 16       	sub	r6,r8
8001dd28:	a9 76       	lsl	r6,0x9
8001dd2a:	ee 06 00 06 	add	r6,r7,r6
8001dd2e:	ef 46 02 08 	st.w	r7[520],r6
8001dd32:	cf 6a       	rjmp	8001db1e <fatfs_free_cluster_chain+0x92>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001dd34:	3f f9       	mov	r9,-1
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
8001dd36:	06 94       	mov	r4,r3

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001dd38:	ef 49 02 00 	st.w	r7[512],r9
8001dd3c:	c6 0b       	rjmp	8001dbfc <fatfs_free_cluster_chain+0x170>
8001dd3e:	3f f8       	mov	r8,-1
8001dd40:	ef 48 02 00 	st.w	r7[512],r8
8001dd44:	ea f7 02 54 	ld.w	r7,r5[596]
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
8001dd48:	6a c8       	ld.w	r8,r5[0x30]
8001dd4a:	58 08       	cp.w	r8,0
8001dd4c:	c0 31       	brne	8001dd52 <fatfs_free_cluster_chain+0x2c6>

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
8001dd4e:	3f f3       	mov	r3,-1
8001dd50:	c0 1b       	rjmp	8001db52 <fatfs_free_cluster_chain+0xc6>
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
8001dd52:	3f f3       	mov	r3,-1
8001dd54:	ca 6b       	rjmp	8001dca0 <fatfs_free_cluster_chain+0x214>

8001dd56 <fatfs_find_blank_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
8001dd56:	eb cd 40 fe 	pushm	r1-r7,lr

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
                    return 0;
            }
                
            pcur->dirty = 0;
8001dd5a:	30 01       	mov	r1,0
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
8001dd5c:	18 95       	mov	r5,r12
8001dd5e:	14 92       	mov	r2,r10
8001dd60:	16 93       	mov	r3,r11
8001dd62:	78 c8       	ld.w	r8,r12[0x30]
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
8001dd64:	58 08       	cp.w	r8,0
8001dd66:	c5 11       	brne	8001de08 <fatfs_find_blank_cluster+0xb2>
            fat_sector_offset = current_cluster / 256;
8001dd68:	e6 04 16 08 	lsr	r4,r3,0x8
        else
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
8001dd6c:	6a 88       	ld.w	r8,r5[0x20]
8001dd6e:	10 34       	cp.w	r4,r8
8001dd70:	c5 12       	brcc	8001de12 <fatfs_find_blank_cluster+0xbc>
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dd72:	6a 56       	ld.w	r6,r5[0x14]
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8001dd74:	ea f7 02 54 	ld.w	r7,r5[596]
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
8001dd78:	e8 06 00 06 	add	r6,r4,r6
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001dd7c:	58 07       	cp.w	r7,0
8001dd7e:	c6 d0       	breq	8001de58 <fatfs_find_blank_cluster+0x102>
8001dd80:	30 09       	mov	r9,0
8001dd82:	c0 38       	rjmp	8001dd88 <fatfs_find_blank_cluster+0x32>
8001dd84:	0e 99       	mov	r9,r7
8001dd86:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8001dd88:	ee f8 02 00 	ld.w	r8,r7[512]
8001dd8c:	10 36       	cp.w	r6,r8
8001dd8e:	c0 53       	brcs	8001dd98 <fatfs_find_blank_cluster+0x42>
8001dd90:	f0 ca ff ff 	sub	r10,r8,-1
8001dd94:	14 36       	cp.w	r6,r10
8001dd96:	c5 93       	brcs	8001de48 <fatfs_find_blank_cluster+0xf2>
            break;

        // End of list?
        if (pcur->next == NULL)
8001dd98:	ee f8 02 0c 	ld.w	r8,r7[524]
8001dd9c:	58 08       	cp.w	r8,0
8001dd9e:	cf 31       	brne	8001dd84 <fatfs_find_blank_cluster+0x2e>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
8001dda0:	58 09       	cp.w	r9,0
8001dda2:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8001dda6:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
8001ddaa:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
8001ddae:	58 08       	cp.w	r8,0
8001ddb0:	ce a1       	brne	8001dd84 <fatfs_find_blank_cluster+0x2e>
8001ddb2:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001ddb6:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001ddba:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001ddbe:	ee f8 02 04 	ld.w	r8,r7[516]
8001ddc2:	58 08       	cp.w	r8,0
8001ddc4:	c5 31       	brne	8001de6a <fatfs_find_blank_cluster+0x114>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8001ddc6:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
8001ddca:	0c 9c       	mov	r12,r6
8001ddcc:	6a d8       	ld.w	r8,r5[0x34]
8001ddce:	30 1a       	mov	r10,1
8001ddd0:	0e 9b       	mov	r11,r7
8001ddd2:	5d 18       	icall	r8
8001ddd4:	0e 99       	mov	r9,r7
8001ddd6:	c6 20       	breq	8001de9a <fatfs_find_blank_cluster+0x144>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8001ddd8:	ef 47 02 08 	st.w	r7[520],r7

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
            if (!pbuf)
8001dddc:	58 07       	cp.w	r7,0
8001ddde:	c1 a0       	breq	8001de12 <fatfs_find_blank_cluster+0xbc>
                return 0;

            if (fs->fat_type == FAT_TYPE_16)
8001dde0:	6a c8       	ld.w	r8,r5[0x30]
8001dde2:	58 08       	cp.w	r8,0
8001dde4:	c1 c1       	brne	8001de1c <fatfs_find_blank_cluster+0xc6>
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
8001dde6:	e8 0a 15 08 	lsl	r10,r4,0x8
8001ddea:	e6 0a 01 0a 	sub	r10,r3,r10
8001ddee:	a1 7a       	lsl	r10,0x1
8001ddf0:	5c 7a       	castu.h	r10
8001ddf2:	f2 0a 07 0b 	ld.ub	r11,r9[r10]
8001ddf6:	14 09       	add	r9,r10
8001ddf8:	13 99       	ld.ub	r9,r9[0x1]
8001ddfa:	a9 69       	lsl	r9,0x8
8001ddfc:	16 09       	add	r9,r11

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
8001ddfe:	58 09       	cp.w	r9,0
8001de00:	c0 b0       	breq	8001de16 <fatfs_find_blank_cluster+0xc0>
                current_cluster++;
8001de02:	2f f3       	sub	r3,-1
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
8001de04:	58 08       	cp.w	r8,0
8001de06:	cb 10       	breq	8001dd68 <fatfs_find_blank_cluster+0x12>
            fat_sector_offset = current_cluster / 256;
        else
            fat_sector_offset = current_cluster / 128;
8001de08:	e6 04 16 07 	lsr	r4,r3,0x7

        if ( fat_sector_offset < fs->fat_sectors)
8001de0c:	6a 88       	ld.w	r8,r5[0x20]
8001de0e:	10 34       	cp.w	r4,r8
8001de10:	cb 13       	brcs	8001dd72 <fatfs_find_blank_cluster+0x1c>
                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
                current_cluster++;
8001de12:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
            return 0;
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
8001de16:	85 03       	st.w	r2[0x0],r3
8001de18:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
8001de1c:	e8 0a 15 07 	lsl	r10,r4,0x7
8001de20:	e6 0a 01 0a 	sub	r10,r3,r10
8001de24:	a3 6a       	lsl	r10,0x2
8001de26:	5c 7a       	castu.h	r10
8001de28:	f2 0a 07 0b 	ld.ub	r11,r9[r10]
8001de2c:	14 09       	add	r9,r10
8001de2e:	13 9a       	ld.ub	r10,r9[0x1]
8001de30:	13 bc       	ld.ub	r12,r9[0x3]
8001de32:	a9 6a       	lsl	r10,0x8
8001de34:	b9 6c       	lsl	r12,0x18
8001de36:	13 a9       	ld.ub	r9,r9[0x2]
8001de38:	b1 69       	lsl	r9,0x10
8001de3a:	f8 09 00 09 	add	r9,r12,r9
8001de3e:	16 09       	add	r9,r11
8001de40:	14 09       	add	r9,r10

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
8001de42:	f3 d9 c0 1c 	bfextu	r9,r9,0x0,0x1c
8001de46:	cd cb       	rjmp	8001ddfe <fatfs_find_blank_cluster+0xa8>
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
8001de48:	ec 08 01 09 	sub	r9,r6,r8
8001de4c:	a9 79       	lsl	r9,0x9
8001de4e:	ee 09 00 09 	add	r9,r7,r9
8001de52:	ef 49 02 08 	st.w	r7[520],r9
8001de56:	cc 5b       	rjmp	8001dde0 <fatfs_find_blank_cluster+0x8a>
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
    return 1;
8001de58:	0e 98       	mov	r8,r7

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8001de5a:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
8001de5e:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
8001de62:	ee f8 02 04 	ld.w	r8,r7[516]
8001de66:	58 08       	cp.w	r8,0
8001de68:	ca f0       	breq	8001ddc6 <fatfs_find_blank_cluster+0x70>
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    if (pcur)
8001de6a:	58 07       	cp.w	r7,0
8001de6c:	cd 30       	breq	8001de12 <fatfs_find_blank_cluster+0xbc>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
8001de6e:	6a e8       	ld.w	r8,r5[0x38]
8001de70:	58 08       	cp.w	r8,0
8001de72:	c1 10       	breq	8001de94 <fatfs_find_blank_cluster+0x13e>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
8001de74:	ee fc 02 00 	ld.w	r12,r7[512]
8001de78:	6a 59       	ld.w	r9,r5[0x14]
8001de7a:	f8 09 01 09 	sub	r9,r12,r9

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
8001de7e:	f2 cb ff ff 	sub	r11,r9,-1
8001de82:	6a 8a       	ld.w	r10,r5[0x20]
8001de84:	14 3b       	cp.w	r11,r10
8001de86:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
8001de8a:	f5 d9 eb 1a 	subhi	r10,r10,r9

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
8001de8e:	0e 9b       	mov	r11,r7
8001de90:	5d 18       	icall	r8
8001de92:	cc 00       	breq	8001de12 <fatfs_find_blank_cluster+0xbc>
                    return 0;
            }
                
            pcur->dirty = 0;
8001de94:	ef 41 02 04 	st.w	r7[516],r1
8001de98:	c9 7b       	rjmp	8001ddc6 <fatfs_find_blank_cluster+0x70>

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8001de9a:	3f f8       	mov	r8,-1
8001de9c:	ef 48 02 00 	st.w	r7[512],r8
8001dea0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

8001dea4 <fatfs_add_file_entry>:
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
{
8001dea4:	d4 31       	pushm	r0-r7,lr
8001dea6:	fa cd 00 88 	sub	sp,sp,136
8001deaa:	50 2b       	stdsp	sp[0x8],r11
8001deac:	50 4a       	stdsp	sp[0x10],r10
8001deae:	51 49       	stdsp	sp[0x50],r9
8001deb0:	51 58       	stdsp	sp[0x54],r8
8001deb2:	fa c4 ff 54 	sub	r4,sp,-172
8001deb6:	68 19       	ld.w	r9,r4[0x4]
8001deb8:	51 79       	stdsp	sp[0x5c],r9
8001deba:	68 04       	ld.w	r4,r4[0x0]
8001debc:	51 64       	stdsp	sp[0x58],r4
8001debe:	18 93       	mov	r3,r12

    uint8 checksum;
    uint8 *pSname;

    // No write access?
    if (!fs->disk_io.write_media)
8001dec0:	78 e8       	ld.w	r8,r12[0x38]
8001dec2:	58 08       	cp.w	r8,0
8001dec4:	c0 60       	breq	8001ded0 <fatfs_add_file_entry+0x2c>
        return 0;

#if FATFS_INC_LFN_SUPPORT
    // How many LFN entries are required?
    // NOTE: We always request one LFN even if it would fit in a SFN!
    entryCount = fatfs_lfn_entries_required(filename);
8001dec6:	14 9c       	mov	r12,r10
8001dec8:	fe b0 f7 6a 	rcall	8001cd9c <fatfs_lfn_entries_required>
8001decc:	18 94       	mov	r4,r12
    if (!entryCount)
8001dece:	c0 31       	brne	8001ded4 <fatfs_add_file_entry+0x30>
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001ded0:	2d ed       	sub	sp,-136
8001ded2:	d8 3a       	popm	r0-r7,pc,r12=0
    entryCount = 0;    
#endif

    // Find space in the directory for this filename (or allocate some more)
    // NOTE: We need to find space for at least the LFN + SFN (or just the SFN if LFNs not supported).
    if (!fatfs_find_free_dir_offset(fs, dirCluster, entryCount + 1, &dirSector, &dirOffset))
8001ded4:	f8 c8 ff ff 	sub	r8,r12,-1
    int x=0;
    int possible_spaces = 0;
    int start_recorded = 0;

    // No entries required?
    if (entryCount == 0)
8001ded8:	cf c0       	breq	8001ded0 <fatfs_add_file_entry+0x2c>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001deda:	e6 c9 ff bc 	sub	r9,r3,-68
8001dede:	50 39       	stdsp	sp[0xc],r9
8001dee0:	e6 c9 ff 9c 	sub	r9,r3,-100
8001dee4:	50 59       	stdsp	sp[0x14],r9
8001dee6:	e6 c9 ff 7c 	sub	r9,r3,-132
8001deea:	50 69       	stdsp	sp[0x18],r9
8001deec:	e6 c9 ff 5c 	sub	r9,r3,-164
8001def0:	50 79       	stdsp	sp[0x1c],r9
8001def2:	e6 c9 ff 3c 	sub	r9,r3,-196
8001def6:	50 89       	stdsp	sp[0x20],r9
8001def8:	e6 c9 ff 1c 	sub	r9,r3,-228
8001defc:	50 99       	stdsp	sp[0x24],r9
8001defe:	e6 c9 fe fc 	sub	r9,r3,-260
8001df02:	50 a9       	stdsp	sp[0x28],r9
8001df04:	e6 c9 fe dc 	sub	r9,r3,-292
8001df08:	50 b9       	stdsp	sp[0x2c],r9
8001df0a:	e6 c9 fe bc 	sub	r9,r3,-324
8001df0e:	50 c9       	stdsp	sp[0x30],r9
8001df10:	e6 c9 fe 9c 	sub	r9,r3,-356
8001df14:	50 d9       	stdsp	sp[0x34],r9
8001df16:	e6 c9 fe 7c 	sub	r9,r3,-388
8001df1a:	50 e9       	stdsp	sp[0x38],r9
8001df1c:	e6 c9 fe 5c 	sub	r9,r3,-420
8001df20:	50 f9       	stdsp	sp[0x3c],r9
8001df22:	e6 c9 fe 3c 	sub	r9,r3,-452
8001df26:	51 19       	stdsp	sp[0x44],r9
8001df28:	e6 c9 fe 1c 	sub	r9,r3,-484
8001df2c:	51 09       	stdsp	sp[0x40],r9
8001df2e:	e6 c9 fd fc 	sub	r9,r3,-516
8001df32:	30 06       	mov	r6,0
8001df34:	51 29       	stdsp	sp[0x48],r9
8001df36:	0c 95       	mov	r5,r6
8001df38:	e6 c9 fd dc 	sub	r9,r3,-548
8001df3c:	0c 97       	mov	r7,r6
8001df3e:	51 39       	stdsp	sp[0x4c],r9
8001df40:	0c 90       	mov	r0,r6
8001df42:	50 16       	stdsp	sp[0x4],r6
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001df44:	3e 51       	mov	r1,-27
8001df46:	51 8c       	stdsp	sp[0x60],r12
8001df48:	10 94       	mov	r4,r8
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001df4a:	40 12       	lddsp	r2,sp[0x4]

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
8001df4c:	04 98       	mov	r8,r2
8001df4e:	2f f8       	sub	r8,-1
8001df50:	30 09       	mov	r9,0
8001df52:	50 18       	stdsp	sp[0x4],r8
8001df54:	04 9a       	mov	r10,r2
8001df56:	40 2b       	lddsp	r11,sp[0x8]
8001df58:	06 9c       	mov	r12,r3
8001df5a:	fe b0 ed cf 	rcall	8001baf8 <fatfs_sector_reader>
8001df5e:	e0 80 03 fd 	breq	8001e758 <fatfs_add_file_entry+0x8b4>

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001df62:	40 3c       	lddsp	r12,sp[0xc]
8001df64:	fe b0 f5 11 	rcall	8001c986 <fatfs_entry_lfn_text>
8001df68:	e0 81 00 fe 	brne	8001e164 <fatfs_add_file_entry+0x2c0>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001df6c:	e7 38 00 44 	ld.ub	r8,r3[68]
8001df70:	e2 08 18 00 	cp.b	r8,r1
8001df74:	e0 80 01 89 	breq	8001e286 <fatfs_add_file_entry+0x3e2>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001df78:	58 08       	cp.w	r8,0
8001df7a:	e0 80 01 86 	breq	8001e286 <fatfs_add_file_entry+0x3e2>
8001df7e:	18 97       	mov	r7,r12
8001df80:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001df82:	40 5c       	lddsp	r12,sp[0x14]
8001df84:	fe b0 f5 01 	rcall	8001c986 <fatfs_entry_lfn_text>
8001df88:	e0 81 01 00 	brne	8001e188 <fatfs_add_file_entry+0x2e4>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001df8c:	e7 38 00 64 	ld.ub	r8,r3[100]
8001df90:	e2 08 18 00 	cp.b	r8,r1
8001df94:	e0 80 03 13 	breq	8001e5ba <fatfs_add_file_entry+0x716>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001df98:	58 08       	cp.w	r8,0
8001df9a:	e0 80 03 10 	breq	8001e5ba <fatfs_add_file_entry+0x716>
8001df9e:	18 97       	mov	r7,r12
8001dfa0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001dfa2:	40 6c       	lddsp	r12,sp[0x18]
8001dfa4:	fe b0 f4 f1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001dfa8:	e0 81 00 e7 	brne	8001e176 <fatfs_add_file_entry+0x2d2>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001dfac:	e7 38 00 84 	ld.ub	r8,r3[132]
8001dfb0:	e2 08 18 00 	cp.b	r8,r1
8001dfb4:	e0 80 02 f7 	breq	8001e5a2 <fatfs_add_file_entry+0x6fe>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001dfb8:	58 08       	cp.w	r8,0
8001dfba:	e0 80 02 f4 	breq	8001e5a2 <fatfs_add_file_entry+0x6fe>
8001dfbe:	18 97       	mov	r7,r12
8001dfc0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001dfc2:	40 7c       	lddsp	r12,sp[0x1c]
8001dfc4:	fe b0 f4 e1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001dfc8:	e0 81 00 e9 	brne	8001e19a <fatfs_add_file_entry+0x2f6>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001dfcc:	e7 38 00 a4 	ld.ub	r8,r3[164]
8001dfd0:	e2 08 18 00 	cp.b	r8,r1
8001dfd4:	e0 80 03 00 	breq	8001e5d4 <fatfs_add_file_entry+0x730>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001dfd8:	58 08       	cp.w	r8,0
8001dfda:	e0 80 02 fd 	breq	8001e5d4 <fatfs_add_file_entry+0x730>
8001dfde:	18 97       	mov	r7,r12
8001dfe0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001dfe2:	40 8c       	lddsp	r12,sp[0x20]
8001dfe4:	fe b0 f4 d1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001dfe8:	e0 81 00 e2 	brne	8001e1ac <fatfs_add_file_entry+0x308>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001dfec:	e7 38 00 c4 	ld.ub	r8,r3[196]
8001dff0:	e2 08 18 00 	cp.b	r8,r1
8001dff4:	e0 80 02 fd 	breq	8001e5ee <fatfs_add_file_entry+0x74a>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001dff8:	58 08       	cp.w	r8,0
8001dffa:	e0 80 02 fa 	breq	8001e5ee <fatfs_add_file_entry+0x74a>
8001dffe:	18 97       	mov	r7,r12
8001e000:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e002:	40 9c       	lddsp	r12,sp[0x24]
8001e004:	fe b0 f4 c1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e008:	e0 81 00 db 	brne	8001e1be <fatfs_add_file_entry+0x31a>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e00c:	e7 38 00 e4 	ld.ub	r8,r3[228]
8001e010:	e2 08 18 00 	cp.b	r8,r1
8001e014:	e0 80 02 fa 	breq	8001e608 <fatfs_add_file_entry+0x764>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e018:	58 08       	cp.w	r8,0
8001e01a:	e0 80 02 f7 	breq	8001e608 <fatfs_add_file_entry+0x764>
8001e01e:	18 97       	mov	r7,r12
8001e020:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e022:	40 ac       	lddsp	r12,sp[0x28]
8001e024:	fe b0 f4 b1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e028:	e0 81 00 d4 	brne	8001e1d0 <fatfs_add_file_entry+0x32c>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e02c:	e7 38 01 04 	ld.ub	r8,r3[260]
8001e030:	e2 08 18 00 	cp.b	r8,r1
8001e034:	e0 80 02 f7 	breq	8001e622 <fatfs_add_file_entry+0x77e>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e038:	58 08       	cp.w	r8,0
8001e03a:	e0 80 02 f4 	breq	8001e622 <fatfs_add_file_entry+0x77e>
8001e03e:	18 97       	mov	r7,r12
8001e040:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e042:	40 bc       	lddsp	r12,sp[0x2c]
8001e044:	fe b0 f4 a1 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e048:	e0 81 00 cd 	brne	8001e1e2 <fatfs_add_file_entry+0x33e>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e04c:	e7 38 01 24 	ld.ub	r8,r3[292]
8001e050:	e2 08 18 00 	cp.b	r8,r1
8001e054:	e0 80 02 f4 	breq	8001e63c <fatfs_add_file_entry+0x798>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e058:	58 08       	cp.w	r8,0
8001e05a:	e0 80 02 f1 	breq	8001e63c <fatfs_add_file_entry+0x798>
8001e05e:	18 97       	mov	r7,r12
8001e060:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e062:	40 cc       	lddsp	r12,sp[0x30]
8001e064:	fe b0 f4 91 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e068:	e0 81 00 c6 	brne	8001e1f4 <fatfs_add_file_entry+0x350>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e06c:	e7 38 01 44 	ld.ub	r8,r3[324]
8001e070:	e2 08 18 00 	cp.b	r8,r1
8001e074:	e0 80 02 f1 	breq	8001e656 <fatfs_add_file_entry+0x7b2>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e078:	58 08       	cp.w	r8,0
8001e07a:	e0 80 02 ee 	breq	8001e656 <fatfs_add_file_entry+0x7b2>
8001e07e:	18 97       	mov	r7,r12
8001e080:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e082:	40 dc       	lddsp	r12,sp[0x34]
8001e084:	fe b0 f4 81 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e088:	e0 81 00 c8 	brne	8001e218 <fatfs_add_file_entry+0x374>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e08c:	e7 38 01 64 	ld.ub	r8,r3[356]
8001e090:	e2 08 18 00 	cp.b	r8,r1
8001e094:	e0 80 02 ee 	breq	8001e670 <fatfs_add_file_entry+0x7cc>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e098:	58 08       	cp.w	r8,0
8001e09a:	e0 80 02 eb 	breq	8001e670 <fatfs_add_file_entry+0x7cc>
8001e09e:	18 97       	mov	r7,r12
8001e0a0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e0a2:	40 ec       	lddsp	r12,sp[0x38]
8001e0a4:	fe b0 f4 71 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e0a8:	e0 81 00 af 	brne	8001e206 <fatfs_add_file_entry+0x362>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e0ac:	e7 38 01 84 	ld.ub	r8,r3[388]
8001e0b0:	e2 08 18 00 	cp.b	r8,r1
8001e0b4:	e0 80 02 eb 	breq	8001e68a <fatfs_add_file_entry+0x7e6>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e0b8:	58 08       	cp.w	r8,0
8001e0ba:	e0 80 02 e8 	breq	8001e68a <fatfs_add_file_entry+0x7e6>
8001e0be:	18 97       	mov	r7,r12
8001e0c0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e0c2:	40 fc       	lddsp	r12,sp[0x3c]
8001e0c4:	fe b0 f4 61 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e0c8:	e0 81 00 ba 	brne	8001e23c <fatfs_add_file_entry+0x398>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e0cc:	e7 38 01 a4 	ld.ub	r8,r3[420]
8001e0d0:	e2 08 18 00 	cp.b	r8,r1
8001e0d4:	e0 80 02 e8 	breq	8001e6a4 <fatfs_add_file_entry+0x800>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e0d8:	58 08       	cp.w	r8,0
8001e0da:	e0 80 02 e5 	breq	8001e6a4 <fatfs_add_file_entry+0x800>
8001e0de:	18 97       	mov	r7,r12
8001e0e0:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e0e2:	41 1c       	lddsp	r12,sp[0x44]
8001e0e4:	fe b0 f4 51 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e0e8:	e0 81 00 a1 	brne	8001e22a <fatfs_add_file_entry+0x386>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e0ec:	e7 38 01 c4 	ld.ub	r8,r3[452]
8001e0f0:	e2 08 18 00 	cp.b	r8,r1
8001e0f4:	e0 80 02 e5 	breq	8001e6be <fatfs_add_file_entry+0x81a>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e0f8:	58 08       	cp.w	r8,0
8001e0fa:	e0 80 02 e2 	breq	8001e6be <fatfs_add_file_entry+0x81a>
8001e0fe:	18 97       	mov	r7,r12
8001e100:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e102:	41 0c       	lddsp	r12,sp[0x40]
8001e104:	fe b0 f4 41 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e108:	e0 81 00 ac 	brne	8001e260 <fatfs_add_file_entry+0x3bc>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e10c:	e7 38 01 e4 	ld.ub	r8,r3[484]
8001e110:	e2 08 18 00 	cp.b	r8,r1
8001e114:	e0 80 02 e2 	breq	8001e6d8 <fatfs_add_file_entry+0x834>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e118:	58 08       	cp.w	r8,0
8001e11a:	e0 80 02 df 	breq	8001e6d8 <fatfs_add_file_entry+0x834>
8001e11e:	18 97       	mov	r7,r12
8001e120:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e122:	41 2c       	lddsp	r12,sp[0x48]
8001e124:	fe b0 f4 31 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e128:	e0 81 00 93 	brne	8001e24e <fatfs_add_file_entry+0x3aa>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e12c:	e7 38 02 04 	ld.ub	r8,r3[516]
8001e130:	e2 08 18 00 	cp.b	r8,r1
8001e134:	e0 80 02 df 	breq	8001e6f2 <fatfs_add_file_entry+0x84e>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e138:	58 08       	cp.w	r8,0
8001e13a:	e0 80 02 dc 	breq	8001e6f2 <fatfs_add_file_entry+0x84e>
8001e13e:	18 97       	mov	r7,r12
8001e140:	18 90       	mov	r0,r12

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
8001e142:	41 3c       	lddsp	r12,sp[0x4c]
8001e144:	fe b0 f4 21 	rcall	8001c986 <fatfs_entry_lfn_text>
8001e148:	e0 81 00 95 	brne	8001e272 <fatfs_add_file_entry+0x3ce>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
8001e14c:	e7 38 02 24 	ld.ub	r8,r3[548]
8001e150:	e2 08 18 00 	cp.b	r8,r1
8001e154:	e0 80 02 dc 	breq	8001e70c <fatfs_add_file_entry+0x868>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
8001e158:	58 08       	cp.w	r8,0
8001e15a:	e0 80 02 d9 	breq	8001e70c <fatfs_add_file_entry+0x868>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
8001e15e:	18 97       	mov	r7,r12
8001e160:	18 90       	mov	r0,r12
8001e162:	cf 4a       	rjmp	8001df4a <fatfs_add_file_entry+0xa6>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e164:	58 00       	cp.w	r0,0
8001e166:	e4 05 17 00 	moveq	r5,r2
8001e16a:	e0 06 17 00 	moveq	r6,r0
8001e16e:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e172:	2f f0       	sub	r0,-1
8001e174:	c0 7b       	rjmp	8001df82 <fatfs_add_file_entry+0xde>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e176:	58 00       	cp.w	r0,0
8001e178:	e4 05 17 00 	moveq	r5,r2
8001e17c:	f9 b6 00 02 	moveq	r6,2
8001e180:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e184:	2f f0       	sub	r0,-1
8001e186:	c1 eb       	rjmp	8001dfc2 <fatfs_add_file_entry+0x11e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e188:	58 00       	cp.w	r0,0
8001e18a:	f9 b6 00 01 	moveq	r6,1
8001e18e:	e4 05 17 00 	moveq	r5,r2
8001e192:	ec 07 17 00 	moveq	r7,r6
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e196:	2f f0       	sub	r0,-1
8001e198:	c0 5b       	rjmp	8001dfa2 <fatfs_add_file_entry+0xfe>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e19a:	58 00       	cp.w	r0,0
8001e19c:	e4 05 17 00 	moveq	r5,r2
8001e1a0:	f9 b6 00 03 	moveq	r6,3
8001e1a4:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e1a8:	2f f0       	sub	r0,-1
8001e1aa:	c1 cb       	rjmp	8001dfe2 <fatfs_add_file_entry+0x13e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e1ac:	58 00       	cp.w	r0,0
8001e1ae:	e4 05 17 00 	moveq	r5,r2
8001e1b2:	f9 b6 00 04 	moveq	r6,4
8001e1b6:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e1ba:	2f f0       	sub	r0,-1
8001e1bc:	c2 3b       	rjmp	8001e002 <fatfs_add_file_entry+0x15e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e1be:	58 00       	cp.w	r0,0
8001e1c0:	e4 05 17 00 	moveq	r5,r2
8001e1c4:	f9 b6 00 05 	moveq	r6,5
8001e1c8:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e1cc:	2f f0       	sub	r0,-1
8001e1ce:	c2 ab       	rjmp	8001e022 <fatfs_add_file_entry+0x17e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e1d0:	58 00       	cp.w	r0,0
8001e1d2:	e4 05 17 00 	moveq	r5,r2
8001e1d6:	f9 b6 00 06 	moveq	r6,6
8001e1da:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e1de:	2f f0       	sub	r0,-1
8001e1e0:	c3 1b       	rjmp	8001e042 <fatfs_add_file_entry+0x19e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e1e2:	58 00       	cp.w	r0,0
8001e1e4:	e4 05 17 00 	moveq	r5,r2
8001e1e8:	f9 b6 00 07 	moveq	r6,7
8001e1ec:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e1f0:	2f f0       	sub	r0,-1
8001e1f2:	c3 8b       	rjmp	8001e062 <fatfs_add_file_entry+0x1be>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e1f4:	58 00       	cp.w	r0,0
8001e1f6:	e4 05 17 00 	moveq	r5,r2
8001e1fa:	f9 b6 00 08 	moveq	r6,8
8001e1fe:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e202:	2f f0       	sub	r0,-1
8001e204:	c3 fb       	rjmp	8001e082 <fatfs_add_file_entry+0x1de>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e206:	58 00       	cp.w	r0,0
8001e208:	e4 05 17 00 	moveq	r5,r2
8001e20c:	f9 b6 00 0a 	moveq	r6,10
8001e210:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e214:	2f f0       	sub	r0,-1
8001e216:	c5 6b       	rjmp	8001e0c2 <fatfs_add_file_entry+0x21e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e218:	58 00       	cp.w	r0,0
8001e21a:	e4 05 17 00 	moveq	r5,r2
8001e21e:	f9 b6 00 09 	moveq	r6,9
8001e222:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e226:	2f f0       	sub	r0,-1
8001e228:	c3 db       	rjmp	8001e0a2 <fatfs_add_file_entry+0x1fe>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e22a:	58 00       	cp.w	r0,0
8001e22c:	e4 05 17 00 	moveq	r5,r2
8001e230:	f9 b6 00 0c 	moveq	r6,12
8001e234:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e238:	2f f0       	sub	r0,-1
8001e23a:	c6 4b       	rjmp	8001e102 <fatfs_add_file_entry+0x25e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e23c:	58 00       	cp.w	r0,0
8001e23e:	e4 05 17 00 	moveq	r5,r2
8001e242:	f9 b6 00 0b 	moveq	r6,11
8001e246:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e24a:	2f f0       	sub	r0,-1
8001e24c:	c4 bb       	rjmp	8001e0e2 <fatfs_add_file_entry+0x23e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e24e:	58 00       	cp.w	r0,0
8001e250:	e4 05 17 00 	moveq	r5,r2
8001e254:	f9 b6 00 0e 	moveq	r6,14
8001e258:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e25c:	2f f0       	sub	r0,-1
8001e25e:	c7 2b       	rjmp	8001e142 <fatfs_add_file_entry+0x29e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e260:	58 00       	cp.w	r0,0
8001e262:	e4 05 17 00 	moveq	r5,r2
8001e266:	f9 b6 00 0d 	moveq	r6,13
8001e26a:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e26e:	2f f0       	sub	r0,-1
8001e270:	c5 9b       	rjmp	8001e122 <fatfs_add_file_entry+0x27e>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
8001e272:	58 00       	cp.w	r0,0
8001e274:	e4 05 17 00 	moveq	r5,r2
8001e278:	f9 b6 00 0f 	moveq	r6,15
8001e27c:	f9 b7 00 01 	moveq	r7,1
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
8001e280:	2f f0       	sub	r0,-1
8001e282:	fe 9f fe 64 	bral	8001df4a <fatfs_add_file_entry+0xa6>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e286:	58 00       	cp.w	r0,0
8001e288:	e4 05 17 00 	moveq	r5,r2
8001e28c:	e0 06 17 00 	moveq	r6,r0
8001e290:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e294:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e296:	00 34       	cp.w	r4,r0
8001e298:	fe 99 fe 75 	brgt	8001df82 <fatfs_add_file_entry+0xde>
8001e29c:	41 84       	lddsp	r4,sp[0x60]
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8001e29e:	41 49       	lddsp	r9,sp[0x50]
8001e2a0:	13 3a       	ld.ub	r10,r9++
8001e2a2:	13 3c       	ld.ub	r12,r9++
8001e2a4:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e2a8:	f8 0b 00 0b 	add	r11,r12,r11
8001e2ac:	e0 68 00 80 	mov	r8,128
8001e2b0:	13 3c       	ld.ub	r12,r9++
8001e2b2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e2b6:	f0 0a 17 10 	movne	r10,r8
8001e2ba:	f6 0a 00 0a 	add	r10,r11,r10
8001e2be:	5c 5a       	castu.b	r10
8001e2c0:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e2c4:	f8 0b 00 0b 	add	r11,r12,r11
8001e2c8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e2cc:	13 3c       	ld.ub	r12,r9++
8001e2ce:	f0 0a 17 10 	movne	r10,r8
8001e2d2:	f6 0a 00 0a 	add	r10,r11,r10
8001e2d6:	5c 5a       	castu.b	r10
8001e2d8:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e2dc:	f8 0b 00 0b 	add	r11,r12,r11
8001e2e0:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e2e4:	13 3c       	ld.ub	r12,r9++
8001e2e6:	f0 0a 17 10 	movne	r10,r8
8001e2ea:	f6 0a 00 0a 	add	r10,r11,r10
8001e2ee:	5c 5a       	castu.b	r10
8001e2f0:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e2f4:	f8 0b 00 0b 	add	r11,r12,r11
8001e2f8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e2fc:	13 3c       	ld.ub	r12,r9++
8001e2fe:	f0 0a 17 10 	movne	r10,r8
8001e302:	f6 0a 00 0a 	add	r10,r11,r10
8001e306:	5c 5a       	castu.b	r10
8001e308:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e30c:	f8 0b 00 0b 	add	r11,r12,r11
8001e310:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e314:	13 3c       	ld.ub	r12,r9++
8001e316:	f0 0a 17 10 	movne	r10,r8
8001e31a:	f6 0a 00 0a 	add	r10,r11,r10
8001e31e:	5c 5a       	castu.b	r10
8001e320:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e324:	f8 0b 00 0b 	add	r11,r12,r11
8001e328:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e32c:	13 3c       	ld.ub	r12,r9++
8001e32e:	f0 0a 17 10 	movne	r10,r8
8001e332:	f6 0a 00 0a 	add	r10,r11,r10
8001e336:	5c 5a       	castu.b	r10
8001e338:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e33c:	f8 0b 00 0b 	add	r11,r12,r11
8001e340:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e344:	13 3c       	ld.ub	r12,r9++
8001e346:	f0 0a 17 10 	movne	r10,r8
8001e34a:	f6 0a 00 0a 	add	r10,r11,r10
8001e34e:	5c 5a       	castu.b	r10
8001e350:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e354:	f8 0b 00 0b 	add	r11,r12,r11
8001e358:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e35c:	13 3c       	ld.ub	r12,r9++
8001e35e:	f0 0a 17 10 	movne	r10,r8
8001e362:	f6 0a 00 0a 	add	r10,r11,r10
8001e366:	5c 5a       	castu.b	r10
8001e368:	f4 0b 16 01 	lsr	r11,r10,0x1
8001e36c:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8001e370:	f0 0a 17 10 	movne	r10,r8
8001e374:	f8 0b 00 0b 	add	r11,r12,r11
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e378:	0a 92       	mov	r2,r5
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8001e37a:	13 8c       	ld.ub	r12,r9[0x0]
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e37c:	30 01       	mov	r1,0
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8001e37e:	f6 0a 00 09 	add	r9,r11,r10
8001e382:	50 15       	stdsp	sp[0x4],r5
8001e384:	5c 59       	castu.b	r9
8001e386:	0c 95       	mov	r5,r6
8001e388:	f2 0a 16 01 	lsr	r10,r9,0x1
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8001e38c:	30 10       	mov	r0,1
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
8001e38e:	f8 0a 00 0a 	add	r10,r12,r10
8001e392:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8001e396:	40 46       	lddsp	r6,sp[0x10]
8001e398:	f0 09 17 10 	movne	r9,r8
8001e39c:	f4 09 00 09 	add	r9,r10,r9
8001e3a0:	ef d9 c0 08 	bfextu	r7,r9,0x0,0x8

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
8001e3a4:	30 09       	mov	r9,0
8001e3a6:	04 9a       	mov	r10,r2
8001e3a8:	40 2b       	lddsp	r11,sp[0x8]
8001e3aa:	06 9c       	mov	r12,r3
8001e3ac:	fe b0 eb a6 	rcall	8001baf8 <fatfs_sector_reader>
8001e3b0:	fe 90 fd 90 	breq	8001ded0 <fatfs_add_file_entry+0x2c>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
8001e3b4:	58 01       	cp.w	r1,0
8001e3b6:	c4 b1       	brne	8001e44c <fatfs_add_file_entry+0x5a8>
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8001e3b8:	40 19       	lddsp	r9,sp[0x4]
8001e3ba:	12 32       	cp.w	r2,r9
8001e3bc:	c0 30       	breq	8001e3c2 <fatfs_add_file_entry+0x51e>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8001e3be:	2f f2       	sub	r2,-1
8001e3c0:	cf 2b       	rjmp	8001e3a4 <fatfs_add_file_entry+0x500>
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
8001e3c2:	58 05       	cp.w	r5,0
8001e3c4:	c4 40       	breq	8001e44c <fatfs_add_file_entry+0x5a8>
8001e3c6:	e0 05 18 00 	cp.b	r5,r0
8001e3ca:	c4 b0       	breq	8001e460 <fatfs_add_file_entry+0x5bc>
8001e3cc:	30 28       	mov	r8,2
8001e3ce:	f0 05 18 00 	cp.b	r5,r8
8001e3d2:	c5 10       	breq	8001e474 <fatfs_add_file_entry+0x5d0>
8001e3d4:	30 39       	mov	r9,3
8001e3d6:	f2 05 18 00 	cp.b	r5,r9
8001e3da:	c5 70       	breq	8001e488 <fatfs_add_file_entry+0x5e4>
8001e3dc:	30 48       	mov	r8,4
8001e3de:	f0 05 18 00 	cp.b	r5,r8
8001e3e2:	c5 d0       	breq	8001e49c <fatfs_add_file_entry+0x5f8>
8001e3e4:	30 59       	mov	r9,5
8001e3e6:	f2 05 18 00 	cp.b	r5,r9
8001e3ea:	c6 30       	breq	8001e4b0 <fatfs_add_file_entry+0x60c>
8001e3ec:	30 68       	mov	r8,6
8001e3ee:	f0 05 18 00 	cp.b	r5,r8
8001e3f2:	c6 90       	breq	8001e4c4 <fatfs_add_file_entry+0x620>
8001e3f4:	30 79       	mov	r9,7
8001e3f6:	f2 05 18 00 	cp.b	r5,r9
8001e3fa:	c6 f0       	breq	8001e4d8 <fatfs_add_file_entry+0x634>
8001e3fc:	30 88       	mov	r8,8
8001e3fe:	f0 05 18 00 	cp.b	r5,r8
8001e402:	c7 50       	breq	8001e4ec <fatfs_add_file_entry+0x648>
8001e404:	30 98       	mov	r8,9
8001e406:	f0 05 18 00 	cp.b	r5,r8
8001e40a:	c7 b0       	breq	8001e500 <fatfs_add_file_entry+0x65c>
8001e40c:	30 a8       	mov	r8,10
8001e40e:	f0 05 18 00 	cp.b	r5,r8
8001e412:	e0 80 00 81 	breq	8001e514 <fatfs_add_file_entry+0x670>
8001e416:	30 b8       	mov	r8,11
8001e418:	f0 05 18 00 	cp.b	r5,r8
8001e41c:	e0 80 00 86 	breq	8001e528 <fatfs_add_file_entry+0x684>
8001e420:	30 c8       	mov	r8,12
8001e422:	f0 05 18 00 	cp.b	r5,r8
8001e426:	e0 80 00 8b 	breq	8001e53c <fatfs_add_file_entry+0x698>
8001e42a:	30 d8       	mov	r8,13
8001e42c:	f0 05 18 00 	cp.b	r5,r8
8001e430:	e0 80 00 90 	breq	8001e550 <fatfs_add_file_entry+0x6ac>
8001e434:	30 e8       	mov	r8,14
8001e436:	f0 05 18 00 	cp.b	r5,r8
8001e43a:	e0 80 00 95 	breq	8001e564 <fatfs_add_file_entry+0x6c0>
8001e43e:	30 f8       	mov	r8,15
8001e440:	f0 05 18 00 	cp.b	r5,r8
8001e444:	e0 80 00 9a 	breq	8001e578 <fatfs_add_file_entry+0x6d4>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8001e448:	2f f2       	sub	r2,-1
8001e44a:	ca db       	rjmp	8001e3a4 <fatfs_add_file_entry+0x500>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e44c:	58 04       	cp.w	r4,0
8001e44e:	e0 80 01 6e 	breq	8001e72a <fatfs_add_file_entry+0x886>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e452:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e454:	0e 99       	mov	r9,r7
8001e456:	08 9a       	mov	r10,r4
8001e458:	40 3b       	lddsp	r11,sp[0xc]
8001e45a:	0c 9c       	mov	r12,r6
8001e45c:	fe b0 f4 b2 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e460:	58 04       	cp.w	r4,0
8001e462:	e0 80 01 b0 	breq	8001e7c2 <fatfs_add_file_entry+0x91e>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e466:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e468:	0e 99       	mov	r9,r7
8001e46a:	08 9a       	mov	r10,r4
8001e46c:	40 5b       	lddsp	r11,sp[0x14]
8001e46e:	0c 9c       	mov	r12,r6
8001e470:	fe b0 f4 a8 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e474:	58 04       	cp.w	r4,0
8001e476:	e0 80 01 a4 	breq	8001e7be <fatfs_add_file_entry+0x91a>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e47a:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e47c:	0e 99       	mov	r9,r7
8001e47e:	08 9a       	mov	r10,r4
8001e480:	40 6b       	lddsp	r11,sp[0x18]
8001e482:	0c 9c       	mov	r12,r6
8001e484:	fe b0 f4 9e 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e488:	58 04       	cp.w	r4,0
8001e48a:	e0 80 01 9e 	breq	8001e7c6 <fatfs_add_file_entry+0x922>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e48e:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e490:	0e 99       	mov	r9,r7
8001e492:	08 9a       	mov	r10,r4
8001e494:	40 7b       	lddsp	r11,sp[0x1c]
8001e496:	0c 9c       	mov	r12,r6
8001e498:	fe b0 f4 94 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e49c:	58 04       	cp.w	r4,0
8001e49e:	e0 80 01 8d 	breq	8001e7b8 <fatfs_add_file_entry+0x914>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e4a2:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e4a4:	0e 99       	mov	r9,r7
8001e4a6:	08 9a       	mov	r10,r4
8001e4a8:	40 8b       	lddsp	r11,sp[0x20]
8001e4aa:	0c 9c       	mov	r12,r6
8001e4ac:	fe b0 f4 8a 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e4b0:	58 04       	cp.w	r4,0
8001e4b2:	e0 80 01 9e 	breq	8001e7ee <fatfs_add_file_entry+0x94a>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e4b6:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e4b8:	0e 99       	mov	r9,r7
8001e4ba:	08 9a       	mov	r10,r4
8001e4bc:	40 9b       	lddsp	r11,sp[0x24]
8001e4be:	0c 9c       	mov	r12,r6
8001e4c0:	fe b0 f4 80 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e4c4:	58 04       	cp.w	r4,0
8001e4c6:	e0 80 01 91 	breq	8001e7e8 <fatfs_add_file_entry+0x944>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e4ca:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e4cc:	0e 99       	mov	r9,r7
8001e4ce:	08 9a       	mov	r10,r4
8001e4d0:	40 ab       	lddsp	r11,sp[0x28]
8001e4d2:	0c 9c       	mov	r12,r6
8001e4d4:	fe b0 f4 76 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e4d8:	58 04       	cp.w	r4,0
8001e4da:	e0 80 01 84 	breq	8001e7e2 <fatfs_add_file_entry+0x93e>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e4de:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e4e0:	0e 99       	mov	r9,r7
8001e4e2:	08 9a       	mov	r10,r4
8001e4e4:	40 bb       	lddsp	r11,sp[0x2c]
8001e4e6:	0c 9c       	mov	r12,r6
8001e4e8:	fe b0 f4 6c 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e4ec:	58 04       	cp.w	r4,0
8001e4ee:	e0 80 01 77 	breq	8001e7dc <fatfs_add_file_entry+0x938>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e4f2:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e4f4:	0e 99       	mov	r9,r7
8001e4f6:	08 9a       	mov	r10,r4
8001e4f8:	40 cb       	lddsp	r11,sp[0x30]
8001e4fa:	0c 9c       	mov	r12,r6
8001e4fc:	fe b0 f4 62 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e500:	58 04       	cp.w	r4,0
8001e502:	e0 80 01 6a 	breq	8001e7d6 <fatfs_add_file_entry+0x932>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e506:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e508:	0e 99       	mov	r9,r7
8001e50a:	08 9a       	mov	r10,r4
8001e50c:	40 db       	lddsp	r11,sp[0x34]
8001e50e:	0c 9c       	mov	r12,r6
8001e510:	fe b0 f4 58 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e514:	58 04       	cp.w	r4,0
8001e516:	e0 80 01 5d 	breq	8001e7d0 <fatfs_add_file_entry+0x92c>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e51a:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e51c:	0e 99       	mov	r9,r7
8001e51e:	08 9a       	mov	r10,r4
8001e520:	40 eb       	lddsp	r11,sp[0x38]
8001e522:	0c 9c       	mov	r12,r6
8001e524:	fe b0 f4 4e 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e528:	58 04       	cp.w	r4,0
8001e52a:	e0 80 01 50 	breq	8001e7ca <fatfs_add_file_entry+0x926>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e52e:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e530:	0e 99       	mov	r9,r7
8001e532:	08 9a       	mov	r10,r4
8001e534:	40 fb       	lddsp	r11,sp[0x3c]
8001e536:	0c 9c       	mov	r12,r6
8001e538:	fe b0 f4 44 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e53c:	58 04       	cp.w	r4,0
8001e53e:	e0 80 01 5b 	breq	8001e7f4 <fatfs_add_file_entry+0x950>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e542:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e544:	0e 99       	mov	r9,r7
8001e546:	08 9a       	mov	r10,r4
8001e548:	41 1b       	lddsp	r11,sp[0x44]
8001e54a:	0c 9c       	mov	r12,r6
8001e54c:	fe b0 f4 3a 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e550:	58 04       	cp.w	r4,0
8001e552:	e0 80 01 57 	breq	8001e800 <fatfs_add_file_entry+0x95c>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e556:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e558:	0e 99       	mov	r9,r7
8001e55a:	08 9a       	mov	r10,r4
8001e55c:	41 0b       	lddsp	r11,sp[0x40]
8001e55e:	0c 9c       	mov	r12,r6
8001e560:	fe b0 f4 30 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e564:	58 04       	cp.w	r4,0
8001e566:	e0 80 01 4a 	breq	8001e7fa <fatfs_add_file_entry+0x956>
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e56a:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e56c:	0e 99       	mov	r9,r7
8001e56e:	08 9a       	mov	r10,r4
8001e570:	41 2b       	lddsp	r11,sp[0x48]
8001e572:	0c 9c       	mov	r12,r6
8001e574:	fe b0 f4 26 	rcall	8001cdc0 <fatfs_filename_to_lfn>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e578:	58 04       	cp.w	r4,0
8001e57a:	e0 80 00 d6 	breq	8001e726 <fatfs_add_file_entry+0x882>
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e57e:	41 3b       	lddsp	r11,sp[0x4c]
8001e580:	0c 9c       	mov	r12,r6
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
8001e582:	20 14       	sub	r4,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
8001e584:	0e 99       	mov	r9,r7
8001e586:	08 9a       	mov	r10,r4
8001e588:	fe b0 f4 1c 	rcall	8001cdc0 <fatfs_filename_to_lfn>
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
8001e58c:	30 1a       	mov	r10,1
8001e58e:	66 e8       	ld.w	r8,r3[0x38]
8001e590:	40 3b       	lddsp	r11,sp[0xc]
8001e592:	e6 fc 02 44 	ld.w	r12,r3[580]
8001e596:	5d 18       	icall	r8
8001e598:	fe 90 fc 9c 	breq	8001ded0 <fatfs_add_file_entry+0x2c>
                if (!fatfs_write_sector(fs, newCluster, i, 0))
                    return 0;
            }

            // If non of the name fitted on previous sectors
            if (!start_recorded) 
8001e59c:	30 11       	mov	r1,1
8001e59e:	2f f2       	sub	r2,-1
8001e5a0:	c0 2b       	rjmp	8001e3a4 <fatfs_add_file_entry+0x500>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e5a2:	58 00       	cp.w	r0,0
8001e5a4:	e4 05 17 00 	moveq	r5,r2
8001e5a8:	f9 b6 00 02 	moveq	r6,2
8001e5ac:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e5b0:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e5b2:	00 34       	cp.w	r4,r0
8001e5b4:	fe 99 fd 07 	brgt	8001dfc2 <fatfs_add_file_entry+0x11e>
8001e5b8:	c7 2a       	rjmp	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e5ba:	58 00       	cp.w	r0,0
8001e5bc:	f9 b6 00 01 	moveq	r6,1
8001e5c0:	e4 05 17 00 	moveq	r5,r2
8001e5c4:	ec 07 17 00 	moveq	r7,r6
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e5c8:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e5ca:	00 34       	cp.w	r4,r0
8001e5cc:	fe 99 fc eb 	brgt	8001dfa2 <fatfs_add_file_entry+0xfe>
8001e5d0:	fe 9f fe 66 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e5d4:	58 00       	cp.w	r0,0
8001e5d6:	e4 05 17 00 	moveq	r5,r2
8001e5da:	f9 b6 00 03 	moveq	r6,3
8001e5de:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e5e2:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e5e4:	00 34       	cp.w	r4,r0
8001e5e6:	fe 99 fc fe 	brgt	8001dfe2 <fatfs_add_file_entry+0x13e>
8001e5ea:	fe 9f fe 59 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e5ee:	58 00       	cp.w	r0,0
8001e5f0:	e4 05 17 00 	moveq	r5,r2
8001e5f4:	f9 b6 00 04 	moveq	r6,4
8001e5f8:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e5fc:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e5fe:	00 34       	cp.w	r4,r0
8001e600:	fe 99 fd 01 	brgt	8001e002 <fatfs_add_file_entry+0x15e>
8001e604:	fe 9f fe 4c 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e608:	58 00       	cp.w	r0,0
8001e60a:	e4 05 17 00 	moveq	r5,r2
8001e60e:	f9 b6 00 05 	moveq	r6,5
8001e612:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e616:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e618:	00 34       	cp.w	r4,r0
8001e61a:	fe 99 fd 04 	brgt	8001e022 <fatfs_add_file_entry+0x17e>
8001e61e:	fe 9f fe 3f 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e622:	58 00       	cp.w	r0,0
8001e624:	e4 05 17 00 	moveq	r5,r2
8001e628:	f9 b6 00 06 	moveq	r6,6
8001e62c:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e630:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e632:	00 34       	cp.w	r4,r0
8001e634:	fe 99 fd 07 	brgt	8001e042 <fatfs_add_file_entry+0x19e>
8001e638:	fe 9f fe 32 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e63c:	58 00       	cp.w	r0,0
8001e63e:	e4 05 17 00 	moveq	r5,r2
8001e642:	f9 b6 00 07 	moveq	r6,7
8001e646:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e64a:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e64c:	00 34       	cp.w	r4,r0
8001e64e:	fe 99 fd 0a 	brgt	8001e062 <fatfs_add_file_entry+0x1be>
8001e652:	fe 9f fe 25 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e656:	58 00       	cp.w	r0,0
8001e658:	e4 05 17 00 	moveq	r5,r2
8001e65c:	f9 b6 00 08 	moveq	r6,8
8001e660:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e664:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e666:	00 34       	cp.w	r4,r0
8001e668:	fe 99 fd 0d 	brgt	8001e082 <fatfs_add_file_entry+0x1de>
8001e66c:	fe 9f fe 18 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e670:	58 00       	cp.w	r0,0
8001e672:	e4 05 17 00 	moveq	r5,r2
8001e676:	f9 b6 00 09 	moveq	r6,9
8001e67a:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e67e:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e680:	00 34       	cp.w	r4,r0
8001e682:	fe 99 fd 10 	brgt	8001e0a2 <fatfs_add_file_entry+0x1fe>
8001e686:	fe 9f fe 0b 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e68a:	58 00       	cp.w	r0,0
8001e68c:	e4 05 17 00 	moveq	r5,r2
8001e690:	f9 b6 00 0a 	moveq	r6,10
8001e694:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e698:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e69a:	00 34       	cp.w	r4,r0
8001e69c:	fe 99 fd 13 	brgt	8001e0c2 <fatfs_add_file_entry+0x21e>
8001e6a0:	fe 9f fd fe 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e6a4:	58 00       	cp.w	r0,0
8001e6a6:	e4 05 17 00 	moveq	r5,r2
8001e6aa:	f9 b6 00 0b 	moveq	r6,11
8001e6ae:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e6b2:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e6b4:	00 34       	cp.w	r4,r0
8001e6b6:	fe 99 fd 16 	brgt	8001e0e2 <fatfs_add_file_entry+0x23e>
8001e6ba:	fe 9f fd f1 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e6be:	58 00       	cp.w	r0,0
8001e6c0:	e4 05 17 00 	moveq	r5,r2
8001e6c4:	f9 b6 00 0c 	moveq	r6,12
8001e6c8:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e6cc:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e6ce:	00 34       	cp.w	r4,r0
8001e6d0:	fe 99 fd 19 	brgt	8001e102 <fatfs_add_file_entry+0x25e>
8001e6d4:	fe 9f fd e4 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e6d8:	58 00       	cp.w	r0,0
8001e6da:	e4 05 17 00 	moveq	r5,r2
8001e6de:	f9 b6 00 0d 	moveq	r6,13
8001e6e2:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e6e6:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e6e8:	00 34       	cp.w	r4,r0
8001e6ea:	fe 99 fd 1c 	brgt	8001e122 <fatfs_add_file_entry+0x27e>
8001e6ee:	fe 9f fd d7 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e6f2:	58 00       	cp.w	r0,0
8001e6f4:	e4 05 17 00 	moveq	r5,r2
8001e6f8:	f9 b6 00 0e 	moveq	r6,14
8001e6fc:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e700:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e702:	00 34       	cp.w	r4,r0
8001e704:	fe 99 fd 1f 	brgt	8001e142 <fatfs_add_file_entry+0x29e>
8001e708:	fe 9f fd ca 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
                    {
                        // First entry?
                        if (possible_spaces == 0)
8001e70c:	58 00       	cp.w	r0,0
8001e70e:	e4 05 17 00 	moveq	r5,r2
8001e712:	f9 b6 00 0f 	moveq	r6,15
8001e716:	f9 b7 00 01 	moveq	r7,1
                            *pSector = x-1;
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        possible_spaces++;
8001e71a:	2f f0       	sub	r0,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
8001e71c:	00 34       	cp.w	r4,r0
8001e71e:	fe 99 fc 16 	brgt	8001df4a <fatfs_add_file_entry+0xa6>
8001e722:	fe 9f fd bd 	bral	8001e29c <fatfs_add_file_entry+0x3f8>
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
8001e726:	e0 64 01 e0 	mov	r4,480
                if (foundEnd)
                {                
                    if (entryCount==0)
                    {
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
8001e72a:	fa c7 ff 9c 	sub	r7,sp,-100
8001e72e:	41 78       	lddsp	r8,sp[0x5c]
8001e730:	41 5a       	lddsp	r10,sp[0x54]
8001e732:	41 6b       	lddsp	r11,sp[0x58]
8001e734:	41 4c       	lddsp	r12,sp[0x50]
8001e736:	0e 99       	mov	r9,r7
8001e738:	fe b0 f1 82 	rcall	8001ca3c <fatfs_sfn_create_entry>
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));
8001e73c:	0e 9b       	mov	r11,r7
8001e73e:	40 3c       	lddsp	r12,sp[0xc]
8001e740:	32 0a       	mov	r10,32
8001e742:	08 0c       	add	r12,r4
8001e744:	e0 a0 27 be 	rcall	800236c0 <memcpy>

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001e748:	40 3b       	lddsp	r11,sp[0xc]
8001e74a:	e6 fc 02 44 	ld.w	r12,r3[580]
8001e74e:	66 e8       	ld.w	r8,r3[0x38]
8001e750:	30 1a       	mov	r10,1
8001e752:	5d 18       	icall	r8
        else
            return 0;
    } // End of while loop

    return 0;
}
8001e754:	2d ed       	sub	sp,-136
8001e756:	d8 32       	popm	r0-r7,pc
8001e758:	18 98       	mov	r8,r12
        else
        {
            uint32 newCluster;

            // Get a new cluster for directory
            if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &newCluster))
8001e75a:	66 2b       	ld.w	r11,r3[0x8]
8001e75c:	41 84       	lddsp	r4,sp[0x60]
8001e75e:	fa ca ff 7c 	sub	r10,sp,-132
8001e762:	06 9c       	mov	r12,r3
8001e764:	50 08       	stdsp	sp[0x0],r8
8001e766:	fe b0 fa f8 	rcall	8001dd56 <fatfs_find_blank_cluster>
8001e76a:	fe 90 fb b3 	breq	8001ded0 <fatfs_add_file_entry+0x2c>
                return 0;

            // Add cluster to end of directory tree
            if (!fatfs_fat_add_cluster_to_chain(fs, dirCluster, newCluster))
8001e76e:	42 1a       	lddsp	r10,sp[0x84]
8001e770:	40 2b       	lddsp	r11,sp[0x8]
8001e772:	06 9c       	mov	r12,r3
8001e774:	fe b0 f8 d6 	rcall	8001d920 <fatfs_fat_add_cluster_to_chain>
8001e778:	40 08       	lddsp	r8,sp[0x0]
8001e77a:	fe 90 fb ab 	breq	8001ded0 <fatfs_add_file_entry+0x2c>
                return 0;

            // Erase new directory cluster
            memset(fs->currentsector.sector, 0x00, FAT_SECTOR_SIZE);
8001e77e:	e0 6a 02 00 	mov	r10,512
8001e782:	10 9b       	mov	r11,r8
8001e784:	40 3c       	lddsp	r12,sp[0xc]
8001e786:	e0 a0 28 41 	rcall	80023808 <memset>
            for (i=0;i<fs->sectors_per_cluster;i++)
8001e78a:	07 8a       	ld.ub	r10,r3[0x0]
8001e78c:	40 08       	lddsp	r8,sp[0x0]
8001e78e:	f0 0a 18 00 	cp.b	r10,r8
8001e792:	c3 a0       	breq	8001e806 <fatfs_add_file_entry+0x962>
8001e794:	10 91       	mov	r1,r8
8001e796:	c0 88       	rjmp	8001e7a6 <fatfs_add_file_entry+0x902>
8001e798:	2f f1       	sub	r1,-1
8001e79a:	07 88       	ld.ub	r8,r3[0x0]
8001e79c:	5c 51       	castu.b	r1
8001e79e:	e2 08 18 00 	cp.b	r8,r1
8001e7a2:	e0 88 00 32 	brls	8001e806 <fatfs_add_file_entry+0x962>
            {
                if (!fatfs_write_sector(fs, newCluster, i, 0))
8001e7a6:	02 9a       	mov	r10,r1
8001e7a8:	30 09       	mov	r9,0
8001e7aa:	42 1b       	lddsp	r11,sp[0x84]
8001e7ac:	06 9c       	mov	r12,r3
8001e7ae:	fe b0 e9 57 	rcall	8001ba5c <fatfs_write_sector>
8001e7b2:	cf 31       	brne	8001e798 <fatfs_add_file_entry+0x8f4>
8001e7b4:	fe 9f fb 8e 	bral	8001ded0 <fatfs_add_file_entry+0x2c>
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
8001e7b8:	e0 64 00 80 	mov	r4,128
8001e7bc:	cb 7b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7be:	34 04       	mov	r4,64
8001e7c0:	cb 5b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7c2:	32 04       	mov	r4,32
8001e7c4:	cb 3b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7c6:	36 04       	mov	r4,96
8001e7c8:	cb 1b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7ca:	e0 64 01 60 	mov	r4,352
8001e7ce:	ca eb       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7d0:	e0 64 01 40 	mov	r4,320
8001e7d4:	ca bb       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7d6:	e0 64 01 20 	mov	r4,288
8001e7da:	ca 8b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7dc:	e0 64 01 00 	mov	r4,256
8001e7e0:	ca 5b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7e2:	e0 64 00 e0 	mov	r4,224
8001e7e6:	ca 2b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7e8:	e0 64 00 c0 	mov	r4,192
8001e7ec:	c9 fb       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7ee:	e0 64 00 a0 	mov	r4,160
8001e7f2:	c9 cb       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7f4:	e0 64 01 80 	mov	r4,384
8001e7f8:	c9 9b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e7fa:	e0 64 01 c0 	mov	r4,448
8001e7fe:	c9 6b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
8001e800:	e0 64 01 a0 	mov	r4,416
8001e804:	c9 3b       	rjmp	8001e72a <fatfs_add_file_entry+0x886>
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8001e806:	58 07       	cp.w	r7,0
8001e808:	e4 05 17 00 	moveq	r5,r2
8001e80c:	ee 06 17 00 	moveq	r6,r7
8001e810:	fe 9f fd 47 	bral	8001e29e <fatfs_add_file_entry+0x3fa>

8001e814 <fatfs_add_free_space>:
8001e814:	eb cd 40 fc 	pushm	r2-r7,lr
8001e818:	20 1d       	sub	sp,4
8001e81a:	16 92       	mov	r2,r11
8001e81c:	14 94       	mov	r4,r10
8001e81e:	18 97       	mov	r7,r12
8001e820:	76 05       	ld.w	r5,r11[0x0]
8001e822:	78 98       	ld.w	r8,r12[0x24]
8001e824:	5b f8       	cp.w	r8,-1
8001e826:	c0 40       	breq	8001e82e <fatfs_add_free_space+0x1a>
8001e828:	3f fb       	mov	r11,-1
8001e82a:	fe b0 f6 97 	rcall	8001d558 <fatfs_set_fs_info_next_free_cluster>
8001e82e:	58 04       	cp.w	r4,0
8001e830:	c2 20       	breq	8001e874 <fatfs_add_free_space+0x60>
8001e832:	30 06       	mov	r6,0
8001e834:	1a 93       	mov	r3,sp
8001e836:	c1 18       	rjmp	8001e858 <fatfs_add_free_space+0x44>
8001e838:	40 0a       	lddsp	r10,sp[0x0]
8001e83a:	fe b0 f7 e3 	rcall	8001d800 <fatfs_fat_set_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
            
            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8001e83e:	3f fa       	mov	r10,-1
8001e840:	40 0b       	lddsp	r11,sp[0x0]
8001e842:	0e 9c       	mov	r12,r7
8001e844:	fe b0 f7 de 	rcall	8001d800 <fatfs_fat_set_cluster>

            // Adjust argument reference
            start = nextcluster;
8001e848:	40 05       	lddsp	r5,sp[0x0]
            if (i == 0)
                *startCluster = nextcluster;
8001e84a:	58 06       	cp.w	r6,0
8001e84c:	e5 f5 0a 00 	st.weq	r2[0x0],r5

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8001e850:	2f f6       	sub	r6,-1
8001e852:	0c 34       	cp.w	r4,r6
8001e854:	e0 88 00 10 	brls	8001e874 <fatfs_add_free_space+0x60>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e858:	6e 2b       	ld.w	r11,r7[0x8]
8001e85a:	1a 9a       	mov	r10,sp
8001e85c:	0e 9c       	mov	r12,r7
8001e85e:	fe b0 fa 7c 	rcall	8001dd56 <fatfs_find_blank_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8001e862:	0a 9b       	mov	r11,r5
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e864:	18 98       	mov	r8,r12
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8001e866:	0e 9c       	mov	r12,r7
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e868:	58 08       	cp.w	r8,0
8001e86a:	ce 71       	brne	8001e838 <fatfs_add_free_space+0x24>
8001e86c:	10 9c       	mov	r12,r8
        else
            return 0;
    }

    return 1;
}
8001e86e:	2f fd       	sub	sp,-4
8001e870:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8001e874:	2f fd       	sub	sp,-4
8001e876:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8001e87a:	d7 03       	nop

8001e87c <fatfs_allocate_free_space>:
8001e87c:	eb cd 40 f8 	pushm	r3-r7,lr
8001e880:	20 3d       	sub	sp,12
8001e882:	16 97       	mov	r7,r11
8001e884:	14 96       	mov	r6,r10
8001e886:	18 95       	mov	r5,r12
{
    uint32 clusterSize;
    uint32 clusterCount;
    uint32 nextcluster;

    if (size==0)
8001e888:	58 09       	cp.w	r9,0
8001e88a:	c3 c0       	breq	8001e902 <fatfs_allocate_free_space+0x86>
        return 0;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
8001e88c:	78 98       	ld.w	r8,r12[0x24]
8001e88e:	5b f8       	cp.w	r8,-1
8001e890:	c0 60       	breq	8001e89c <fatfs_allocate_free_space+0x20>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 
8001e892:	50 09       	stdsp	sp[0x0],r9
8001e894:	3f fb       	mov	r11,-1
8001e896:	fe b0 f6 61 	rcall	8001d558 <fatfs_set_fs_info_next_free_cluster>
8001e89a:	40 09       	lddsp	r9,sp[0x0]

    // Work out size and clusters
    clusterSize = fs->sectors_per_cluster * FAT_SECTOR_SIZE;
8001e89c:	0b 88       	ld.ub	r8,r5[0x0]
8001e89e:	a9 78       	lsl	r8,0x9
    clusterCount = (size / clusterSize);
8001e8a0:	f2 08 0d 0a 	divu	r10,r9,r8
8001e8a4:	14 94       	mov	r4,r10

    // If any left over
    if (size-(clusterSize*clusterCount))
8001e8a6:	f4 08 02 48 	mul	r8,r10,r8
        clusterCount++;
8001e8aa:	12 38       	cp.w	r8,r9
8001e8ac:	f7 b4 01 ff 	subne	r4,-1

    // Allocated first link in the chain if a new file
    if (newFile)
8001e8b0:	58 07       	cp.w	r7,0
8001e8b2:	c2 f1       	brne	8001e910 <fatfs_allocate_free_space+0x94>
            return 1;
        }
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;
8001e8b4:	6c 06       	ld.w	r6,r6[0x0]
8001e8b6:	50 26       	stdsp	sp[0x8],r6
    uint32 i;
    uint32 nextcluster;
    uint32 start = *startCluster;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
8001e8b8:	6a 98       	ld.w	r8,r5[0x24]
8001e8ba:	5b f8       	cp.w	r8,-1
8001e8bc:	c0 50       	breq	8001e8c6 <fatfs_allocate_free_space+0x4a>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 
8001e8be:	3f fb       	mov	r11,-1
8001e8c0:	0a 9c       	mov	r12,r5
8001e8c2:	fe b0 f6 4b 	rcall	8001d558 <fatfs_set_fs_info_next_free_cluster>

    for (i=0;i<clusters;i++)
8001e8c6:	58 04       	cp.w	r4,0
8001e8c8:	c2 10       	breq	8001e90a <fatfs_allocate_free_space+0x8e>
8001e8ca:	30 07       	mov	r7,0
8001e8cc:	fa c3 ff fc 	sub	r3,sp,-4
8001e8d0:	c1 28       	rjmp	8001e8f4 <fatfs_allocate_free_space+0x78>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8001e8d2:	40 1a       	lddsp	r10,sp[0x4]
8001e8d4:	0a 9c       	mov	r12,r5
8001e8d6:	fe b0 f7 95 	rcall	8001d800 <fatfs_fat_set_cluster>
            
            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8001e8da:	3f fa       	mov	r10,-1
8001e8dc:	40 1b       	lddsp	r11,sp[0x4]
8001e8de:	0a 9c       	mov	r12,r5
8001e8e0:	fe b0 f7 90 	rcall	8001d800 <fatfs_fat_set_cluster>

            // Adjust argument reference
            start = nextcluster;
8001e8e4:	40 16       	lddsp	r6,sp[0x4]
            if (i == 0)
                *startCluster = nextcluster;
8001e8e6:	58 07       	cp.w	r7,0
8001e8e8:	fb f6 0a 02 	st.weq	sp[0x8],r6

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8001e8ec:	2f f7       	sub	r7,-1
8001e8ee:	0e 34       	cp.w	r4,r7
8001e8f0:	e0 88 00 0d 	brls	8001e90a <fatfs_allocate_free_space+0x8e>
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e8f4:	6a 2b       	ld.w	r11,r5[0x8]
8001e8f6:	06 9a       	mov	r10,r3
8001e8f8:	0a 9c       	mov	r12,r5
8001e8fa:	fe b0 fa 2e 	rcall	8001dd56 <fatfs_find_blank_cluster>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
8001e8fe:	0c 9b       	mov	r11,r6
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e900:	ce 91       	brne	8001e8d2 <fatfs_allocate_free_space+0x56>

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8001e902:	30 0c       	mov	r12,0

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
            return 0;

    return 1;
}
8001e904:	2f dd       	sub	sp,-12
8001e906:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
8001e90a:	2f dd       	sub	sp,-12
8001e90c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
        clusterCount++;

    // Allocated first link in the chain if a new file
    if (newFile)
    {
        if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
8001e910:	fa ca ff f8 	sub	r10,sp,-8
8001e914:	6a 2b       	ld.w	r11,r5[0x8]
8001e916:	0a 9c       	mov	r12,r5
8001e918:	fe b0 fa 1f 	rcall	8001dd56 <fatfs_find_blank_cluster>
8001e91c:	cf 30       	breq	8001e902 <fatfs_allocate_free_space+0x86>
            return 0;

        // If this is all that is needed then all done
        if (clusterCount==1)
8001e91e:	58 14       	cp.w	r4,1
8001e920:	c0 30       	breq	8001e926 <fatfs_allocate_free_space+0xaa>
8001e922:	40 26       	lddsp	r6,sp[0x8]
8001e924:	cc ab       	rjmp	8001e8b8 <fatfs_allocate_free_space+0x3c>
        {
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
8001e926:	0a 9c       	mov	r12,r5
8001e928:	3f fa       	mov	r10,-1
8001e92a:	40 2b       	lddsp	r11,sp[0x8]
8001e92c:	fe b0 f7 6a 	rcall	8001d800 <fatfs_fat_set_cluster>
            *startCluster = nextcluster;
8001e930:	40 28       	lddsp	r8,sp[0x8]
8001e932:	08 9c       	mov	r12,r4
8001e934:	8d 08       	st.w	r6[0x0],r8
            return 1;
8001e936:	ce 7b       	rjmp	8001e904 <fatfs_allocate_free_space+0x88>

8001e938 <itoa_whole_lj>:
  if(sign) { *buf = '-'; }
}


// format whole part, left justified, no length argument (!)
int itoa_whole_lj(int val, char* buf) {
8001e938:	eb cd 40 fc 	pushm	r2-r7,lr
  static char* p;
  char tmp;
  int i;
  int len = 0;
  
  if(val == 0) {
8001e93c:	58 0c       	cp.w	r12,0
8001e93e:	c4 d0       	breq	8001e9d8 <itoa_whole_lj+0xa0>
    *buf = '0';
    return 1;
  }

  sign = BIT_SIGN(val);
8001e940:	18 94       	mov	r4,r12
8001e942:	e0 69 2a 0c 	mov	r9,10764
8001e946:	e6 14 80 00 	andh	r4,0x8000,COH
8001e94a:	93 04       	st.w	r9[0x0],r4
  p = buf;
8001e94c:	18 98       	mov	r8,r12

  if ( sign ) {
8001e94e:	e0 62 2a 10 	mov	r2,10768
    p++;
    len++;
    val = BIT_INVERT(val) + 1; // FIXME: this will wrap at 0xffffffff
  }

  u = (unsigned int)val;
8001e952:	58 04       	cp.w	r4,0
8001e954:	c3 51       	brne	8001e9be <itoa_whole_lj+0x86>
8001e956:	e0 63 2a 04 	mov	r3,10756

  while (u > 0) {
    a = u % 10;
8001e95a:	16 9e       	mov	lr,r11
8001e95c:	87 0c       	st.w	r3[0x0],r12
8001e95e:	08 9c       	mov	r12,r4
8001e960:	e0 65 cc cd 	mov	r5,52429
8001e964:	ea 15 cc cc 	orh	r5,0xcccc
8001e968:	f0 05 06 46 	mulu.d	r6,r8,r5
8001e96c:	0e 99       	mov	r9,r7
8001e96e:	a3 99       	lsr	r9,0x3
8001e970:	12 9a       	mov	r10,r9
8001e972:	f2 09 00 29 	add	r9,r9,r9<<0x2
    u /= 10;
    *p = '0' + a;
8001e976:	f0 09 01 19 	sub	r9,r8,r9<<0x1
    p++;
    len++;
8001e97a:	f2 c8 ff d0 	sub	r8,r9,-48
    val = BIT_INVERT(val) + 1; // FIXME: this will wrap at 0xffffffff
  }

  u = (unsigned int)val;

  while (u > 0) {
8001e97e:	1c c8       	st.b	lr++,r8
8001e980:	2f fc       	sub	r12,-1
8001e982:	14 98       	mov	r8,r10
8001e984:	58 0a       	cp.w	r10,0
8001e986:	cf 11       	brne	8001e968 <itoa_whole_lj+0x30>
8001e988:	e0 68 2a 08 	mov	r8,10760
  /* print_dbg(" ; buf: "); */
  /* print_dbg(buf); */
  
  //// FIXME
  /// ugh, swap digits
  if(sign) {
8001e98c:	87 0a       	st.w	r3[0x0],r10
      tmp = buf[i];
      buf[i] = buf[len - i];
      buf[len - i + 1] = tmp;
    }
  } else {
    for (i=0; i<(len >>1); i++) {
8001e98e:	85 0e       	st.w	r2[0x0],lr
8001e990:	91 09       	st.w	r8[0x0],r9
8001e992:	58 04       	cp.w	r4,0
8001e994:	c2 71       	brne	8001e9e2 <itoa_whole_lj+0xaa>
8001e996:	f8 07 14 01 	asr	r7,r12,0x1
  /* print_dbg(buf); */
  
  //// FIXME
  /// ugh, swap digits
  if(sign) {
    for (i=1; i<len; i++) {
8001e99a:	58 07       	cp.w	r7,0
8001e99c:	e0 8a 00 37 	brle	8001ea0a <itoa_whole_lj+0xd2>
8001e9a0:	f8 c8 00 01 	sub	r8,r12,1
    }
  } else {
    for (i=0; i<(len >>1); i++) {
      //      print_dbg("\r\n digit: ");
      //      print_dbg_ulong(i);
      tmp = *(buf + i);
8001e9a4:	08 99       	mov	r9,r4
      //      print_dbg(" ; tmp: ");
      //      print_dbg_char(tmp);
      //      print_dbg(" , swap with : ");
      //      print_dbg_char( *(buf + len - i - 1) );

      *(buf + i) = *(buf + len - i - 1);
8001e9a6:	f6 08 00 08 	add	r8,r11,r8
      tmp = buf[i];
      buf[i] = buf[len - i];
      buf[len - i + 1] = tmp;
    }
  } else {
    for (i=0; i<(len >>1); i++) {
8001e9aa:	11 8e       	ld.ub	lr,r8[0x0]
8001e9ac:	17 8a       	ld.ub	r10,r11[0x0]
8001e9ae:	16 ce       	st.b	r11++,lr
8001e9b0:	b0 8a       	st.b	r8[0x0],r10
  }
  //  print_dbg(" ; buf (swap): ");
  //  print_dbg(buf);

  return len;
}
8001e9b2:	2f f9       	sub	r9,-1
8001e9b4:	20 18       	sub	r8,1

  sign = BIT_SIGN(val);
  p = buf;

  if ( sign ) {
    *p = '-';
8001e9b6:	0e 39       	cp.w	r9,r7
8001e9b8:	cf 91       	brne	8001e9aa <itoa_whole_lj+0x72>
8001e9ba:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    p++;
8001e9be:	16 9e       	mov	lr,r11
    len++;
    val = BIT_INVERT(val) + 1; // FIXME: this will wrap at 0xffffffff
  }

  u = (unsigned int)val;
8001e9c0:	32 d9       	mov	r9,45
  sign = BIT_SIGN(val);
  p = buf;

  if ( sign ) {
    *p = '-';
    p++;
8001e9c2:	1c c9       	st.b	lr++,r9
    len++;
    val = BIT_INVERT(val) + 1; // FIXME: this will wrap at 0xffffffff
  }

  u = (unsigned int)val;
8001e9c4:	f8 08 11 01 	rsub	r8,r12,1

  while (u > 0) {
8001e9c8:	e0 63 2a 04 	mov	r3,10756
8001e9cc:	85 0e       	st.w	r2[0x0],lr
  char tmp;
  int i;
  int len = 0;
  
  if(val == 0) {
    *buf = '0';
8001e9ce:	87 08       	st.w	r3[0x0],r8
8001e9d0:	58 08       	cp.w	r8,0
8001e9d2:	c1 a0       	breq	8001ea06 <itoa_whole_lj+0xce>
    return 1;
8001e9d4:	30 1c       	mov	r12,1
8001e9d6:	cc 5b       	rjmp	8001e960 <itoa_whole_lj+0x28>
  /* print_dbg(buf); */
  
  //// FIXME
  /// ugh, swap digits
  if(sign) {
    for (i=1; i<len; i++) {
8001e9d8:	33 08       	mov	r8,48
8001e9da:	30 1c       	mov	r12,1
8001e9dc:	b6 88       	st.b	r11[0x0],r8
8001e9de:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001e9e2:	58 1c       	cp.w	r12,1
8001e9e4:	fe 9a ff eb 	brle	8001e9ba <itoa_whole_lj+0x82>
      tmp = buf[i];
      buf[i] = buf[len - i];
8001e9e8:	f6 0c 00 08 	add	r8,r11,r12
8001e9ec:	30 19       	mov	r9,1
      buf[len - i + 1] = tmp;
8001e9ee:	2f fb       	sub	r11,-1
  /* print_dbg(buf); */
  
  //// FIXME
  /// ugh, swap digits
  if(sign) {
    for (i=1; i<len; i++) {
8001e9f0:	17 8a       	ld.ub	r10,r11[0x0]
8001e9f2:	f1 3e ff ff 	ld.ub	lr,r8[-1]
8001e9f6:	16 ce       	st.b	r11++,lr
8001e9f8:	b0 8a       	st.b	r8[0x0],r10
8001e9fa:	2f f9       	sub	r9,-1
      tmp = buf[i];
      buf[i] = buf[len - i];
      buf[len - i + 1] = tmp;
    }
  } else {
    for (i=0; i<(len >>1); i++) {
8001e9fc:	20 18       	sub	r8,1
8001e9fe:	18 39       	cp.w	r9,r12
8001ea00:	cf 81       	brne	8001e9f0 <itoa_whole_lj+0xb8>
8001ea02:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001ea06:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8001ea0a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8001ea0e:	d7 03       	nop

8001ea10 <app_launch>:
  render_init();
}

// this is called from the event queue to start the app 
// return >0 if there is an error doing firstrun init
u8 app_launch(u8 firstrun) {
8001ea10:	eb cd 40 80 	pushm	r7,lr
8001ea14:	20 1d       	sub	sp,4
8001ea16:	18 97       	mov	r7,r12
  u32 waitForCard;

  print_dbg("\r\n app launch");
8001ea18:	fe cc 96 f0 	sub	r12,pc,-26896
8001ea1c:	fe b0 a2 c0 	rcall	80012f9c <print_dbg>
  print_dbg("\r\n firstrun: ");
8001ea20:	fe cc 96 e8 	sub	r12,pc,-26904
  print_dbg_ulong(firstrun);
8001ea24:	fe b0 a2 bc 	rcall	80012f9c <print_dbg>
8001ea28:	0e 9c       	mov	r12,r7

  if(firstrun) {
8001ea2a:	fe b0 a2 bf 	rcall	80012fa8 <print_dbg_ulong>
8001ea2e:	58 07       	cp.w	r7,0
    // it is the first run.
    // need to copy audio module binary from sdcard to internal flash.
    render_status("first run. waiting for SDcard...");
8001ea30:	e0 80 00 93 	breq	8001eb56 <app_launch+0x146>
8001ea34:	fe cc 96 ec 	sub	r12,pc,-26900
    render_update();
8001ea38:	e0 a0 09 92 	rcall	8001fd5c <render_status>
  
    print_dbg("\r\n SD check... ");
8001ea3c:	e0 a0 07 90 	rcall	8001f95c <render_update>
    while (!sd_mmc_spi_mem_check()) {
8001ea40:	fe cc 96 d4 	sub	r12,pc,-26924
8001ea44:	fe b0 a2 ac 	rcall	80012f9c <print_dbg>
      waitForCard++;
    }
    print_dbg("\r\nfound SD card. ");
8001ea48:	fe b0 ab 16 	rcall	80014074 <sd_mmc_spi_mem_check>

    render_status("found sdcard.. reading DSP...");
8001ea4c:	cf e0       	breq	8001ea48 <app_launch+0x38>
8001ea4e:	fe cc 96 d2 	sub	r12,pc,-26926
    render_update();
8001ea52:	fe b0 a2 a5 	rcall	80012f9c <print_dbg>

    // search for our dsp and load it
    // return success (0 == fail)
    if( files_search_dsp() ) {
8001ea56:	fe cc 96 c6 	sub	r12,pc,-26938
8001ea5a:	e0 a0 09 81 	rcall	8001fd5c <render_status>
    render_update();
    // reboot DSP from RAM
    bfin_load_buf();
  }

  render_status("waiting for bfin init...      ");
8001ea5e:	e0 a0 07 7f 	rcall	8001f95c <render_update>
8001ea62:	cc 5c       	rcall	8001ebec <files_search_dsp>
  render_update();
8001ea64:	e0 80 00 94 	breq	8001eb8c <app_launch+0x17c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001ea68:	fe cc 96 84 	sub	r12,pc,-27004
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001ea6c:	e0 a0 09 78 	rcall	8001fd5c <render_status>
8001ea70:	e0 a0 07 76 	rcall	8001f95c <render_update>
8001ea74:	e1 b7 00 42 	mfsr	r7,0x108
8001ea78:	e0 68 03 e8 	mov	r8,1000
8001ea7c:	30 09       	mov	r9,0
8001ea7e:	e0 6a 17 e7 	mov	r10,6119
8001ea82:	ea 1a 5d e8 	orh	r10,0x5de8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001ea86:	30 fb       	mov	r11,15
8001ea88:	e0 a0 22 a5 	rcall	80022fd2 <__avr32_udiv64>
8001ea8c:	ee 0a 00 0a 	add	r10,r7,r10
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001ea90:	e1 b8 00 42 	mfsr	r8,0x108
8001ea94:	14 37       	cp.w	r7,r10
8001ea96:	e0 8b 00 4a 	brhi	8001eb2a <app_launch+0x11a>

  // this is retarded, we need the GPIO for bfin to signal when init done
  delay_ms(1000);

  // report parameters
  render_status("reporting bfin params...       ");
8001ea9a:	10 37       	cp.w	r7,r8
8001ea9c:	e0 8b 00 04 	brhi	8001eaa4 <app_launch+0x94>
  render_update();
8001eaa0:	10 3a       	cp.w	r10,r8
  if( ctl_report_params() ) {
8001eaa2:	c5 42       	brcc	8001eb4a <app_launch+0x13a>
8001eaa4:	fe cc 96 40 	sub	r12,pc,-27072
8001eaa8:	e0 a0 09 5a 	rcall	8001fd5c <render_status>
    render_status("param report failed!           ");
    render_update();
    return 0;
  }

  render_status("setting initial parameters...  ");
8001eaac:	e0 a0 07 58 	rcall	8001f95c <render_update>
  render_update();
8001eab0:	e0 a0 03 84 	rcall	8001f1b8 <ctl_report_params>

  ctl_init_params();
8001eab4:	18 97       	mov	r7,r12
8001eab6:	c6 10       	breq	8001eb78 <app_launch+0x168>

  render_status("initializing input scalers...");
8001eab8:	fe cc 96 94 	sub	r12,pc,-26988
8001eabc:	e0 a0 09 50 	rcall	8001fd5c <render_status>
  render_update();
8001eac0:	e0 a0 07 4e 	rcall	8001f95c <render_update>
  
  inputs_init();
8001eac4:	e0 a0 02 b0 	rcall	8001f024 <ctl_init_params>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001eac8:	fe cc 96 84 	sub	r12,pc,-27004
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001eacc:	e0 a0 09 48 	rcall	8001fd5c <render_status>
8001ead0:	e0 a0 07 46 	rcall	8001f95c <render_update>
8001ead4:	e0 a0 04 0e 	rcall	8001f2f0 <inputs_init>
8001ead8:	e1 b7 00 42 	mfsr	r7,0x108
8001eadc:	e0 68 03 e8 	mov	r8,1000
8001eae0:	30 09       	mov	r9,0
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001eae2:	e0 6a 9d e7 	mov	r10,40423
8001eae6:	ea 1a 4e ad 	orh	r10,0x4ead
8001eaea:	30 0b       	mov	r11,0
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001eaec:	e0 a0 22 73 	rcall	80022fd2 <__avr32_udiv64>
8001eaf0:	ee 0a 00 0a 	add	r10,r7,r10
8001eaf4:	e1 b8 00 42 	mfsr	r8,0x108

  delay_ms(20);

  // enable audio
  render_status("run                       ");
8001eaf8:	14 37       	cp.w	r7,r10
8001eafa:	e0 8b 00 20 	brhi	8001eb3a <app_launch+0x12a>
  render_update();
8001eafe:	10 37       	cp.w	r7,r8

  bfin_enable();
8001eb00:	e0 8b 00 04 	brhi	8001eb08 <app_launch+0xf8>

  render_startup();
8001eb04:	10 3a       	cp.w	r10,r8
8001eb06:	c2 52       	brcc	8001eb50 <app_launch+0x140>
  render_update();
8001eb08:	fe cc 96 84 	sub	r12,pc,-27004
8001eb0c:	e0 a0 09 28 	rcall	8001fd5c <render_status>
8001eb10:	e0 a0 07 26 	rcall	8001f95c <render_update>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001eb14:	fe b0 be e8 	rcall	800168e4 <bfin_enable>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001eb18:	e0 a0 08 ca 	rcall	8001fcac <render_startup>
8001eb1c:	e0 a0 07 20 	rcall	8001f95c <render_update>
8001eb20:	2f fd       	sub	sp,-4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001eb22:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001eb26:	e1 b8 00 42 	mfsr	r8,0x108
8001eb2a:	10 37       	cp.w	r7,r8
8001eb2c:	fe 98 ff fd 	brls	8001eb26 <app_launch+0x116>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001eb30:	10 3a       	cp.w	r10,r8
8001eb32:	cb 93       	brcs	8001eaa4 <app_launch+0x94>
8001eb34:	cf 9b       	rjmp	8001eb26 <app_launch+0x116>
8001eb36:	e1 b8 00 42 	mfsr	r8,0x108
8001eb3a:	10 37       	cp.w	r7,r8
8001eb3c:	fe 98 ff fd 	brls	8001eb36 <app_launch+0x126>
8001eb40:	10 3a       	cp.w	r10,r8

  } else {

    // firstrun pattern was set, so there should be a blackfin executable in flash.
    // read from flash to RAM
    render_status("loading flash to RAM...");
8001eb42:	ce 33       	brcs	8001eb08 <app_launch+0xf8>
8001eb44:	e1 b8 00 42 	mfsr	r8,0x108
    render_update();
8001eb48:	cf 9b       	rjmp	8001eb3a <app_launch+0x12a>
8001eb4a:	e1 b8 00 42 	mfsr	r8,0x108
    flash_read_ldr();
8001eb4e:	ca 6b       	rjmp	8001ea9a <app_launch+0x8a>
    
    render_status( "booting DSP from flash...");
8001eb50:	e1 b8 00 42 	mfsr	r8,0x108
8001eb54:	cd 5b       	rjmp	8001eafe <app_launch+0xee>
    render_update();
8001eb56:	fe cc 97 a6 	sub	r12,pc,-26714
    // reboot DSP from RAM
    bfin_load_buf();
8001eb5a:	e0 a0 09 01 	rcall	8001fd5c <render_status>
8001eb5e:	e0 a0 06 ff 	rcall	8001f95c <render_update>
  render_status("reporting bfin params...       ");
  render_update();
  if( ctl_report_params() ) {
    ;;
  } else {
    render_status("param report failed!           ");
8001eb62:	fe b0 c6 55 	rcall	8001780c <flash_read_ldr>
    render_update();
8001eb66:	fe cc 97 9e 	sub	r12,pc,-26722
8001eb6a:	e0 a0 08 f9 	rcall	8001fd5c <render_status>

  render_startup();
  render_update();
  
  return 1;
}
8001eb6e:	e0 a0 06 f7 	rcall	8001f95c <render_update>
    // search for our dsp and load it
    // return success (0 == fail)
    if( files_search_dsp() ) {
      ;;
    } else {
      screen_clear();
8001eb72:	fe b0 c2 fd 	rcall	8001716c <bfin_load_buf>
8001eb76:	c7 9b       	rjmp	8001ea68 <app_launch+0x58>
8001eb78:	fe cc 97 74 	sub	r12,pc,-26764

  render_startup();
  render_update();
  
  return 1;
}
8001eb7c:	e0 a0 08 f0 	rcall	8001fd5c <render_status>
8001eb80:	e0 a0 06 ee 	rcall	8001f95c <render_update>
8001eb84:	0e 9c       	mov	r12,r7
8001eb86:	2f fd       	sub	sp,-4
8001eb88:	e3 cd 80 80 	ldm	sp++,r7,pc
8001eb8c:	50 0c       	stdsp	sp[0x0],r12
8001eb8e:	fe b0 d4 b7 	rcall	800194fc <screen_clear>
8001eb92:	40 0c       	lddsp	r12,sp[0x0]
8001eb94:	2f fd       	sub	sp,-4
8001eb96:	e3 cd 80 80 	ldm	sp++,r7,pc
8001eb9a:	d7 03       	nop

8001eb9c <app_init>:
8001eb9c:	d4 01       	pushm	lr
8001eb9e:	fe c9 fe e2 	sub	r9,pc,-286
8001eba2:	e0 68 32 68 	mov	r8,12904
8001eba6:	91 09       	st.w	r8[0x0],r9
8001eba8:	e0 a0 07 5a 	rcall	8001fa5c <render_init>
8001ebac:	d8 02       	popm	pc
8001ebae:	d7 03       	nop

8001ebb0 <init_app_timers>:
/*   } */
/* } */


//====== external
void init_app_timers(void) {
8001ebb0:	d4 01       	pushm	lr
  set_timer(&screenTimer,        eScreenTimerTag,        20,  &screen_timer_callback,  1);
8001ebb2:	30 18       	mov	r8,1
8001ebb4:	fe c9 ff d0 	sub	r9,pc,-48
8001ebb8:	31 4a       	mov	r10,20
8001ebba:	30 2b       	mov	r11,2
8001ebbc:	e0 6c 2a 14 	mov	r12,10772
  //  set_timer(&adcTimer,           eAdcTimerTag,           5,   &adc_timer_callback,     1);
  //  set_timer(&monomePollTimer,    eMonomePollTimerTag,    20,  &monome_poll_timer_callback,    1);
  //  set_timer(&monomeRefreshTimer, eMonomeRefreshTimerTag, 20,  &monome_refresh_timer_callback, 1);
  //  set_timer(&midiPollTimer,      eMidiPollTimerTag,      5,  &midi_poll_timer_callback, 1);
  set_timer(&metroTimer,        eMetroTimerTag,        100,  &metro_timer_callback,  1);
8001ebc0:	fe b0 da 9a 	rcall	8001a0f4 <set_timer>
8001ebc4:	30 18       	mov	r8,1
8001ebc6:	fe c9 ff ee 	sub	r9,pc,-18
8001ebca:	36 4a       	mov	r10,100
8001ebcc:	30 3b       	mov	r11,3

}
8001ebce:	e0 6c 2a 28 	mov	r12,10792
8001ebd2:	fe b0 da 91 	rcall	8001a0f4 <set_timer>
8001ebd6:	d8 02       	popm	pc

8001ebd8 <metro_timer_callback>:
8001ebd8:	d4 01       	pushm	lr
8001ebda:	fe cc 97 3a 	sub	r12,pc,-26822
8001ebde:	fe b0 a1 df 	rcall	80012f9c <print_dbg>
8001ebe2:	d8 02       	popm	pc

8001ebe4 <screen_timer_callback>:
}

// metronome timer callback
static void metro_timer_callback(int tag) {
  print_dbg(">");
}
8001ebe4:	d4 01       	pushm	lr
8001ebe6:	e0 a0 06 bb 	rcall	8001f95c <render_update>
8001ebea:	d8 02       	popm	pc

8001ebec <files_search_dsp>:
    n++;
    dst++;
  }
}

u8 files_search_dsp(void) {
8001ebec:	eb cd 40 f8 	pushm	r3-r7,lr
  void* fp;
  //  FL_DIR dirstat;
  u32 size;
  // open file pointer
  print_dbg("\r\n opening dsp file at path: ");
8001ebf0:	fe cc 97 4c 	sub	r12,pc,-26804
8001ebf4:	fe b0 a1 d4 	rcall	80012f9c <print_dbg>
  print_dbg(LPPR_LDR_PATH);
8001ebf8:	fe cc 97 34 	sub	r12,pc,-26828

  // we don't want to be handling UI interrupts while working with the filesystem
  app_pause();
8001ebfc:	fe b0 a1 d0 	rcall	80012f9c <print_dbg>

  fp = fl_fopen(LPPR_LDR_PATH, "r");
8001ec00:	fe b0 bd f2 	rcall	800167e4 <app_pause>
8001ec04:	fe cb 9c 28 	sub	r11,pc,-25560
8001ec08:	fe cc 97 44 	sub	r12,pc,-26812
  if( fp != NULL) {
    size = ((FL_FILE*)(fp))->filelength;
8001ec0c:	fe b0 ed 2e 	rcall	8001c668 <fl_fopen>
    print_dbg("\r\n opened file, size: ");
8001ec10:	18 95       	mov	r5,r12
8001ec12:	c4 c0       	breq	8001ecaa <files_search_dsp+0xbe>
    print_dbg_ulong(size);
8001ec14:	78 34       	ld.w	r4,r12[0xc]
8001ec16:	fe cc 97 3a 	sub	r12,pc,-26822
    print_dbg(" ; pointer: ");
8001ec1a:	fe b0 a1 c1 	rcall	80012f9c <print_dbg>
8001ec1e:	08 9c       	mov	r12,r4
    print_dbg_hex((u32)fp);
8001ec20:	fe b0 a1 c4 	rcall	80012fa8 <print_dbg_ulong>
8001ec24:	fe cc 97 30 	sub	r12,pc,-26832

    render_status("loading sdcard -> RAM...     ");
8001ec28:	fe b0 a1 ba 	rcall	80012f9c <print_dbg>
    render_update();
8001ec2c:	0a 9c       	mov	r12,r5
8001ec2e:	fe b0 a1 df 	rcall	80012fec <print_dbg_hex>

    // read .ldr data to RAM buffer
    //    fl_fread((void*)bfinLdrData, 1, size, fp);
    fake_fread((void*)bfinLdrData, size, fp);
8001ec32:	fe cc 97 2e 	sub	r12,pc,-26834

// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
8001ec36:	e0 a0 08 93 	rcall	8001fd5c <render_status>
    n++;
    dst++;
  }
}

u8 files_search_dsp(void) {
8001ec3a:	e0 a0 06 91 	rcall	8001f95c <render_update>
// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
    *dst = fl_fgetc(fp);
8001ec3e:	e0 68 31 54 	mov	r8,12628
8001ec42:	70 03       	ld.w	r3,r8[0x0]
8001ec44:	58 04       	cp.w	r4,0
    /* print_dbg_ulong(n); */
    /* print_dbg(","); */
    /* print_dbg_hex( ((u32)dst) & 0xff ); */
    /* print_dbg(" \r\n"); */
    n++;
8001ec46:	c0 c0       	breq	8001ec5e <files_search_dsp+0x72>

// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
8001ec48:	30 07       	mov	r7,0
8001ec4a:	e6 07 00 06 	add	r6,r3,r7

    // read .ldr data to RAM buffer
    //    fl_fread((void*)bfinLdrData, 1, size, fp);
    fake_fread((void*)bfinLdrData, size, fp);

    fl_fclose(fp);
8001ec4e:	0a 9c       	mov	r12,r5
8001ec50:	fe b0 ea fc 	rcall	8001c248 <fl_fgetc>

    print_dbg("\r\n finished reading .ldr file to RAM");
8001ec54:	ac 8c       	st.b	r6[0x0],r12
8001ec56:	2f f7       	sub	r7,-1
8001ec58:	0e 34       	cp.w	r4,r7
    bfinLdrSize = size;
8001ec5a:	fe 9b ff f8 	brhi	8001ec4a <files_search_dsp+0x5e>
8001ec5e:	0a 9c       	mov	r12,r5


    render_status("writing RAM -> flash...     ");
8001ec60:	fe b0 eb 02 	rcall	8001c264 <fl_fclose>
    render_update();
8001ec64:	fe cc 97 40 	sub	r12,pc,-26816

    // write buf to flash
    flash_write_ldr();
8001ec68:	fe b0 a1 9a 	rcall	80012f9c <print_dbg>
    print_dbg("\r\n finished writing .ldr file to flash");
8001ec6c:	e0 68 0b 98 	mov	r8,2968
8001ec70:	fe cc 97 24 	sub	r12,pc,-26844
    // reboot the DSP from RAM
    print_dbg("\r\n booting DSP from RAM");
8001ec74:	91 04       	st.w	r8[0x0],r4
8001ec76:	e0 a0 08 73 	rcall	8001fd5c <render_status>


    render_status("booting DSP from RAM...     ");
8001ec7a:	e0 a0 06 71 	rcall	8001f95c <render_update>
    render_update();
8001ec7e:	fe b0 c5 6b 	rcall	80017754 <flash_write_ldr>

    bfin_load_buf();
8001ec82:	fe cc 97 16 	sub	r12,pc,-26858
    app_resume();
8001ec86:	fe b0 a1 8b 	rcall	80012f9c <print_dbg>
8001ec8a:	fe cc 96 f6 	sub	r12,pc,-26890

    return 1; // ok
  } else {
    print_dbg("\r\n encountered an error opening .ldr file.");
8001ec8e:	fe b0 a1 87 	rcall	80012f9c <print_dbg>
8001ec92:	fe cc 96 e6 	sub	r12,pc,-26906

    app_resume();
8001ec96:	e0 a0 08 63 	rcall	8001fd5c <render_status>
    return 0; // error opening
  }
}
8001ec9a:	e0 a0 06 61 	rcall	8001f95c <render_update>
8001ec9e:	fe b0 c2 67 	rcall	8001716c <bfin_load_buf>
8001eca2:	fe b0 bd 9d 	rcall	800167dc <app_resume>
8001eca6:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
8001ecaa:	fe cc 96 de 	sub	r12,pc,-26914
8001ecae:	fe b0 a1 77 	rcall	80012f9c <print_dbg>
8001ecb2:	fe b0 bd 95 	rcall	800167dc <app_resume>
8001ecb6:	0a 9c       	mov	r12,r5
8001ecb8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8001ecbc <flry_handler>:

//---------------------------------------
//---- external funcs

// handle key presses
extern void flry_handler(event_t* ev) {
8001ecbc:	eb cd 40 f8 	pushm	r3-r7,lr
8001ecc0:	18 97       	mov	r7,r12
  u8 touchedThis = 0;
  // clear the main region if this is a new touch
  print_dbg("\r\n \r\n check type: ");
8001ecc2:	fe cc 96 ca 	sub	r12,pc,-26934
8001ecc6:	fe b0 a1 6b 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(ev->eventType);
8001ecca:	6e 0c       	ld.w	r12,r7[0x0]
8001eccc:	fe b0 a1 6e 	rcall	80012fa8 <print_dbg_ulong>
  if(touched != ev->eventType) {
8001ecd0:	32 86       	mov	r6,40
8001ecd2:	6e 09       	ld.w	r9,r7[0x0]
8001ecd4:	6c 08       	ld.w	r8,r6[0x0]
8001ecd6:	10 39       	cp.w	r9,r8
    print_dbg("\r\n new touch");
8001ecd8:	c2 70       	breq	8001ed26 <flry_handler+0x6a>
8001ecda:	fe cc 96 ce 	sub	r12,pc,-26930
    touchedThis = 1;
    touched = ev->eventType;
8001ecde:	fe b0 a1 5f 	rcall	80012f9c <print_dbg>
8001ece2:	6e 08       	ld.w	r8,r7[0x0]
  }
  switch (ev->eventType) {
8001ece4:	8d 08       	st.w	r6[0x0],r8
8001ece6:	30 19       	mov	r9,1
8001ece8:	58 f8       	cp.w	r8,15
8001ecea:	c2 10       	breq	8001ed2c <flry_handler+0x70>
8001ecec:	58 f8       	cp.w	r8,15
8001ecee:	e0 88 00 16 	brls	8001ed1a <flry_handler+0x5e>
8001ecf2:	59 38       	cp.w	r8,19
8001ecf4:	c6 20       	breq	8001edb8 <flry_handler+0xfc>
8001ecf6:	59 48       	cp.w	r8,20
8001ecf8:	c2 80       	breq	8001ed48 <flry_handler+0x8c>
    } 
    render_sw_on(2, ev->eventData > 0);
    break;

  case kEventSwitch3:
    if(ev->eventData > 0) {
8001ecfa:	59 08       	cp.w	r8,16
8001ecfc:	c1 31       	brne	8001ed22 <flry_handler+0x66>
8001ecfe:	6e 18       	ld.w	r8,r7[0x4]
8001ed00:	58 08       	cp.w	r8,0
      if(touchedThis) {
	//	render_new_param_touch();
      }
      // record loop on line 2
      ctl_loop_playback(1);
8001ed02:	e0 8a 00 05 	brle	8001ed0c <flry_handler+0x50>
8001ed06:	30 1c       	mov	r12,1
8001ed08:	ca cc       	rcall	8001ee60 <ctl_loop_playback>
    }
    render_sw_on(3, ev->eventData > 0);
8001ed0a:	6e 18       	ld.w	r8,r7[0x4]
8001ed0c:	58 08       	cp.w	r8,0
8001ed0e:	5f 9b       	srgt	r11
8001ed10:	30 3c       	mov	r12,3
8001ed12:	e0 a0 06 23 	rcall	8001f958 <render_sw_on>
    break;
8001ed16:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
  if(touched != ev->eventType) {
    print_dbg("\r\n new touch");
    touchedThis = 1;
    touched = ev->eventType;
  }
  switch (ev->eventType) {
8001ed1a:	58 d8       	cp.w	r8,13
8001ed1c:	c5 60       	breq	8001edc8 <flry_handler+0x10c>
8001ed1e:	58 e8       	cp.w	r8,14
8001ed20:	c1 b0       	breq	8001ed56 <flry_handler+0x9a>
8001ed22:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8001ed26:	30 09       	mov	r9,0
8001ed28:	58 f8       	cp.w	r8,15
    }
    render_sw_on(1, ev->eventData > 0);
    break;

  case kEventSwitch2:
    if(ev->eventData > 0) {
8001ed2a:	ce 11       	brne	8001ecec <flry_handler+0x30>
8001ed2c:	6e 18       	ld.w	r8,r7[0x4]
8001ed2e:	58 08       	cp.w	r8,0
8001ed30:	e0 8a 00 05 	brle	8001ed3a <flry_handler+0x7e>
      if(touchedThis) {
	//	render_new_param_touch();
      }
      // record loop on line 1
      ctl_loop_record(1);
8001ed34:	30 1c       	mov	r12,1
8001ed36:	c1 7d       	rcall	8001ef64 <ctl_loop_record>
8001ed38:	6e 18       	ld.w	r8,r7[0x4]
    } 
    render_sw_on(2, ev->eventData > 0);
8001ed3a:	58 08       	cp.w	r8,0
8001ed3c:	5f 9b       	srgt	r11
8001ed3e:	30 2c       	mov	r12,2
8001ed40:	e0 a0 06 0c 	rcall	8001f958 <render_sw_on>
    break;
8001ed44:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
      ctl_loop_record(1);
    } 
    break;
    
  case kEventSwitch7:
    if(ev->eventData > 0) {
8001ed48:	6e 18       	ld.w	r8,r7[0x4]
8001ed4a:	58 08       	cp.w	r8,0
8001ed4c:	fe 9a ff eb 	brle	8001ed22 <flry_handler+0x66>
      ctl_loop_playback(1);
8001ed50:	30 1c       	mov	r12,1
8001ed52:	c8 7c       	rcall	8001ee60 <ctl_loop_playback>
8001ed54:	ce 7b       	rjmp	8001ed22 <flry_handler+0x66>
8001ed56:	6e 14       	ld.w	r4,r7[0x4]
    render_sw_on(0, ev->eventData > 0);
    break;

  case kEventSwitch1:
    // tap delaytime 2
    if(ev->eventData > 0) {
8001ed58:	58 04       	cp.w	r4,0
8001ed5a:	e0 8a 00 28 	brle	8001edaa <flry_handler+0xee>
8001ed5e:	58 09       	cp.w	r9,0
      if(touchedThis) {
8001ed60:	c7 61       	brne	8001ee4c <flry_handler+0x190>
8001ed62:	5c 54       	castu.b	r4
	render_touched_delaytime(1);
      }	
      sw_tap_delay(1, ev->eventData);
8001ed64:	e0 65 2a 3c 	mov	r5,10812
//--------- static funcs

// process timing on key press and return interval
static u32 sw_time(u8 num, u8 val) {
  u32 ret;
  if( swTicks[num][val] > tcTicks) {
8001ed68:	2f e4       	sub	r4,-2
8001ed6a:	e0 66 0b a0 	mov	r6,2976
8001ed6e:	ea 04 03 23 	ld.w	r3,r5[r4<<0x2]
8001ed72:	ec ea 00 00 	ld.d	r10,r6[0]
8001ed76:	06 98       	mov	r8,r3
8001ed78:	30 09       	mov	r9,0
8001ed7a:	14 38       	cp.w	r8,r10
8001ed7c:	f6 09 13 00 	cpc	r9,r11
8001ed80:	e0 8b 00 54 	brhi	8001ee28 <flry_handler+0x16c>
    // overflow
    ret = tcTicks + (0xffffffff - swTicks[num][val] );
    print_dbg("\r\n overflow in sw timer");
  } else {
    ret = tcTicks - swTicks[num][val];
8001ed84:	ec e8 00 00 	ld.d	r8,r6[0]
8001ed88:	fe cc 97 54 	sub	r12,pc,-26796
    print_dbg("\r\n sw_time: "); 
8001ed8c:	f0 03 01 03 	sub	r3,r8,r3
    print_dbg_ulong(ret);
8001ed90:	fe b0 a1 06 	rcall	80012f9c <print_dbg>
8001ed94:	06 9c       	mov	r12,r3
  }
  swTicks[num][val] = tcTicks;
8001ed96:	fe b0 a1 09 	rcall	80012fa8 <print_dbg_ulong>
  return ret;
}

// set delay time from switch tap
static void sw_tap_delay(u8 idx, u8 val) {
  ctl_set_delay_ms(idx,  sw_time(idx, val) );
8001ed9a:	ec e8 00 00 	ld.d	r8,r6[0]
  } else {
    ret = tcTicks - swTicks[num][val];
    print_dbg("\r\n sw_time: "); 
    print_dbg_ulong(ret);
  }
  swTicks[num][val] = tcTicks;
8001ed9e:	06 9b       	mov	r11,r3
  return ret;
}

// set delay time from switch tap
static void sw_tap_delay(u8 idx, u8 val) {
  ctl_set_delay_ms(idx,  sw_time(idx, val) );
8001eda0:	ea 04 09 28 	st.w	r5[r4<<0x2],r8
8001eda4:	30 1c       	mov	r12,1
8001eda6:	c9 bd       	rcall	8001f0dc <ctl_set_delay_ms>
      if(touchedThis) {
	render_touched_delaytime(1);
      }	
      sw_tap_delay(1, ev->eventData);
    }
    render_sw_on(1, ev->eventData > 0);
8001eda8:	6e 14       	ld.w	r4,r7[0x4]
8001edaa:	58 04       	cp.w	r4,0
8001edac:	5f 9b       	srgt	r11
8001edae:	30 1c       	mov	r12,1
8001edb0:	e0 a0 05 d4 	rcall	8001f958 <render_sw_on>
    break;
8001edb4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    }
    render_sw_on(3, ev->eventData > 0);
    break;
    
  case kEventSwitch6:
    if(ev->eventData > 0) {
8001edb8:	6e 18       	ld.w	r8,r7[0x4]
8001edba:	58 08       	cp.w	r8,0
8001edbc:	fe 9a ff b3 	brle	8001ed22 <flry_handler+0x66>
      ctl_loop_record(1);
8001edc0:	30 1c       	mov	r12,1
8001edc2:	cd 1c       	rcall	8001ef64 <ctl_loop_record>
8001edc4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    touched = ev->eventType;
  }
  switch (ev->eventType) {
  case kEventSwitch0:
    /// tap delaytime 1
    if(ev->eventData > 0) {
8001edc8:	6e 14       	ld.w	r4,r7[0x4]
8001edca:	58 04       	cp.w	r4,0
8001edcc:	e0 8a 00 27 	brle	8001ee1a <flry_handler+0x15e>
      if(touchedThis) {
8001edd0:	58 09       	cp.w	r9,0
8001edd2:	c4 21       	brne	8001ee56 <flry_handler+0x19a>
	render_touched_delaytime(0);
      }
      sw_tap_delay(0, ev->eventData);
8001edd4:	5c 54       	castu.b	r4
//--------- static funcs

// process timing on key press and return interval
static u32 sw_time(u8 num, u8 val) {
  u32 ret;
  if( swTicks[num][val] > tcTicks) {
8001edd6:	e0 65 2a 3c 	mov	r5,10812
8001edda:	e0 66 0b a0 	mov	r6,2976
8001edde:	ea 04 03 23 	ld.w	r3,r5[r4<<0x2]
8001ede2:	ec ea 00 00 	ld.d	r10,r6[0]
8001ede6:	06 98       	mov	r8,r3
8001ede8:	30 09       	mov	r9,0
8001edea:	14 38       	cp.w	r8,r10
8001edec:	f6 09 13 00 	cpc	r9,r11
    // overflow
    ret = tcTicks + (0xffffffff - swTicks[num][val] );
    print_dbg("\r\n overflow in sw timer");
  } else {
    ret = tcTicks - swTicks[num][val];
8001edf0:	e0 8b 00 25 	brhi	8001ee3a <flry_handler+0x17e>
    print_dbg("\r\n sw_time: "); 
8001edf4:	ec e8 00 00 	ld.d	r8,r6[0]
  if( swTicks[num][val] > tcTicks) {
    // overflow
    ret = tcTicks + (0xffffffff - swTicks[num][val] );
    print_dbg("\r\n overflow in sw timer");
  } else {
    ret = tcTicks - swTicks[num][val];
8001edf8:	fe cc 97 c4 	sub	r12,pc,-26684
    print_dbg("\r\n sw_time: "); 
8001edfc:	f0 03 01 03 	sub	r3,r8,r3
    print_dbg_ulong(ret);
8001ee00:	fe b0 a0 ce 	rcall	80012f9c <print_dbg>
  }
  swTicks[num][val] = tcTicks;
8001ee04:	06 9c       	mov	r12,r3
8001ee06:	fe b0 a0 d1 	rcall	80012fa8 <print_dbg_ulong>
8001ee0a:	ec e8 00 00 	ld.d	r8,r6[0]
  return ret;
}

// set delay time from switch tap
static void sw_tap_delay(u8 idx, u8 val) {
  ctl_set_delay_ms(idx,  sw_time(idx, val) );
8001ee0e:	06 9b       	mov	r11,r3
8001ee10:	ea 04 09 28 	st.w	r5[r4<<0x2],r8
8001ee14:	30 0c       	mov	r12,0
      if(touchedThis) {
	render_touched_delaytime(0);
      }
      sw_tap_delay(0, ev->eventData);
    }
    render_sw_on(0, ev->eventData > 0);
8001ee16:	c6 3d       	rcall	8001f0dc <ctl_set_delay_ms>
8001ee18:	6e 14       	ld.w	r4,r7[0x4]
8001ee1a:	58 04       	cp.w	r4,0
8001ee1c:	5f 9b       	srgt	r11
8001ee1e:	30 0c       	mov	r12,0
    break;
8001ee20:	e0 a0 05 9c 	rcall	8001f958 <render_sw_on>
// process timing on key press and return interval
static u32 sw_time(u8 num, u8 val) {
  u32 ret;
  if( swTicks[num][val] > tcTicks) {
    // overflow
    ret = tcTicks + (0xffffffff - swTicks[num][val] );
8001ee24:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8001ee28:	ec e8 00 00 	ld.d	r8,r6[0]
8001ee2c:	5c d3       	com	r3
    print_dbg("\r\n overflow in sw timer");
8001ee2e:	fe cc 98 12 	sub	r12,pc,-26606
8001ee32:	10 03       	add	r3,r8
// process timing on key press and return interval
static u32 sw_time(u8 num, u8 val) {
  u32 ret;
  if( swTicks[num][val] > tcTicks) {
    // overflow
    ret = tcTicks + (0xffffffff - swTicks[num][val] );
8001ee34:	fe b0 a0 b4 	rcall	80012f9c <print_dbg>
8001ee38:	cb 1b       	rjmp	8001ed9a <flry_handler+0xde>
    print_dbg("\r\n overflow in sw timer");
8001ee3a:	ec e8 00 00 	ld.d	r8,r6[0]
8001ee3e:	5c d3       	com	r3
8001ee40:	fe cc 98 24 	sub	r12,pc,-26588

  case kEventSwitch1:
    // tap delaytime 2
    if(ev->eventData > 0) {
      if(touchedThis) {
	render_touched_delaytime(1);
8001ee44:	10 03       	add	r3,r8
8001ee46:	fe b0 a0 ab 	rcall	80012f9c <print_dbg>
8001ee4a:	ce 0b       	rjmp	8001ee0a <flry_handler+0x14e>
8001ee4c:	30 1c       	mov	r12,1
  switch (ev->eventType) {
  case kEventSwitch0:
    /// tap delaytime 1
    if(ev->eventData > 0) {
      if(touchedThis) {
	render_touched_delaytime(0);
8001ee4e:	e0 a0 07 e7 	rcall	8001fe1c <render_touched_delaytime>
8001ee52:	6e 14       	ld.w	r4,r7[0x4]
8001ee54:	c8 7b       	rjmp	8001ed62 <flry_handler+0xa6>
8001ee56:	30 0c       	mov	r12,0
8001ee58:	e0 a0 07 e2 	rcall	8001fe1c <render_touched_delaytime>
8001ee5c:	6e 14       	ld.w	r4,r7[0x4]
8001ee5e:	cb bb       	rjmp	8001edd4 <flry_handler+0x118>

8001ee60 <ctl_loop_playback>:
    loopRec1 = 1;
  }
}

// stop recording loop / start playback on given delayline
void ctl_loop_playback(u8 idx) {
8001ee60:	eb cd 40 ec 	pushm	r2-r3,r5-r7,lr
  u32 samps;
  u32 ms;
  print_dbg("\r\n\r\n ctl_loop_playback:");
8001ee64:	fe cc 98 20 	sub	r12,pc,-26592
8001ee68:	fe b0 a0 9a 	rcall	80012f9c <print_dbg>

  if(loopRec1) {
8001ee6c:	30 09       	mov	r9,0
8001ee6e:	e0 67 2a 80 	mov	r7,10880
8001ee72:	0f 88       	ld.ub	r8,r7[0x0]
8001ee74:	f2 08 18 00 	cp.b	r8,r9
    // recording
    if(loopPlay1) {
8001ee78:	c1 70       	breq	8001eea6 <ctl_loop_playback+0x46>
8001ee7a:	e0 66 2a 81 	mov	r6,10881
8001ee7e:	0d 88       	ld.ub	r8,r6[0x0]

      // already playing
      print_dbg("\r\n (existing loop)");
8001ee80:	f2 08 18 00 	cp.b	r8,r9
8001ee84:	c1 90       	breq	8001eeb6 <ctl_loop_playback+0x56>
      print_dbg("\r\n write disable");
8001ee86:	fe cc 98 2a 	sub	r12,pc,-26582
8001ee8a:	fe b0 a0 89 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_write1, 0);
8001ee8e:	fe cc 98 1e 	sub	r12,pc,-26594
8001ee92:	fe b0 a0 85 	rcall	80012f9c <print_dbg>

      // set loop-playing flag
      loopPlay1 = 1;
    }
    // unset loop-recording
    loopRec1 = 0;  
8001ee96:	30 0b       	mov	r11,0
8001ee98:	30 cc       	mov	r12,12
8001ee9a:	fe b0 c2 4d 	rcall	80017334 <ctl_param_change>
  } else {
    // not recording
    if (loopPlay1) {
8001ee9e:	30 08       	mov	r8,0
8001eea0:	ae 88       	st.b	r7[0x0],r8
8001eea2:	e3 cd 80 ec 	ldm	sp++,r2-r3,r5-r7,pc
8001eea6:	e0 69 2a 81 	mov	r9,10881
      print_dbg("\r\n write disable");
      ctl_param_change(eParam_write1, 0);
    } else {

      // not playing
      print_dbg("\r\n (new loop)"); 
8001eeaa:	13 89       	ld.ub	r9,r9[0x0]
8001eeac:	f0 09 18 00 	cp.b	r9,r8
      if (ms_loop1 > tcTicks) { // overflow
8001eeb0:	c4 b1       	brne	8001ef46 <ctl_loop_playback+0xe6>
8001eeb2:	e3 cd 80 ec 	ldm	sp++,r2-r3,r5-r7,pc
8001eeb6:	fe cc 98 32 	sub	r12,pc,-26574
8001eeba:	fe b0 a0 71 	rcall	80012f9c <print_dbg>
8001eebe:	e0 68 2a 7c 	mov	r8,10876
8001eec2:	e0 6a 0b a0 	mov	r10,2976
8001eec6:	70 05       	ld.w	r5,r8[0x0]
	ms = tcTicks + (0xffffffff - ms_loop1);
      } else {
	ms = tcTicks - ms_loop1;
8001eec8:	f4 e2 00 00 	ld.d	r2,r10[0]
8001eecc:	0a 98       	mov	r8,r5
8001eece:	30 09       	mov	r9,0
      }
      samps = MS_TO_SAMPS(ms) - 1;

      print_dbg("\r\n write disable");
8001eed0:	04 38       	cp.w	r8,r2
8001eed2:	e6 09 13 00 	cpc	r9,r3
      ctl_param_change(eParam_write1, 0);
8001eed6:	e0 8b 00 42 	brhi	8001ef5a <ctl_loop_playback+0xfa>
8001eeda:	f4 e8 00 00 	ld.d	r8,r10[0]
      print_dbg("\r\n reset write head");
8001eede:	f0 05 01 05 	sub	r5,r8,r5
8001eee2:	fe cc 98 72 	sub	r12,pc,-26510
      ctl_param_change(eParam_pos_write1, 1);
8001eee6:	fe b0 a0 5b 	rcall	80012f9c <print_dbg>
8001eeea:	30 0b       	mov	r11,0
      print_dbg("\r\n reset read head");
8001eeec:	30 cc       	mov	r12,12
8001eeee:	fe b0 c2 23 	rcall	80017334 <ctl_param_change>
      ctl_param_change(eParam_pos_read1, 0);
8001eef2:	fe cc 98 5e 	sub	r12,pc,-26530
8001eef6:	fe b0 a0 53 	rcall	80012f9c <print_dbg>
      print_dbg("\r\n set loop time");
8001eefa:	30 1b       	mov	r11,1
8001eefc:	30 ec       	mov	r12,14
8001eefe:	fe b0 c2 1b 	rcall	80017334 <ctl_param_change>
      ctl_param_change(eParam_loop1, samps);
8001ef02:	fe cc 98 5a 	sub	r12,pc,-26534
8001ef06:	fe b0 a0 4b 	rcall	80012f9c <print_dbg>
8001ef0a:	30 0b       	mov	r11,0
8001ef0c:	30 fc       	mov	r12,15
8001ef0e:	fe b0 c2 13 	rcall	80017334 <ctl_param_change>
      print_dbg("\r\n start read head");
8001ef12:	fe cc 98 56 	sub	r12,pc,-26538
      ctl_param_change(eParam_run_read1, 1);
8001ef16:	fe b0 a0 43 	rcall	80012f9c <print_dbg>
8001ef1a:	ea 05 00 15 	add	r5,r5,r5<<0x1

      // set loop-playing flag
      loopPlay1 = 1;
8001ef1e:	30 ac       	mov	r12,10
8001ef20:	ea 0b 15 04 	lsl	r11,r5,0x4
    }
    // unset loop-recording
    loopRec1 = 0;  
8001ef24:	20 1b       	sub	r11,1
8001ef26:	fe b0 c2 07 	rcall	80017334 <ctl_param_change>
  } else {
    // not recording
    if (loopPlay1) {
      // but a loop is playing
      // reset the loop 
	print_dbg("\r\n reset read head");
8001ef2a:	fe cc 98 5a 	sub	r12,pc,-26534
8001ef2e:	fe b0 a0 37 	rcall	80012f9c <print_dbg>
	ctl_param_change(eParam_pos_read1, 0);
8001ef32:	30 1b       	mov	r11,1
8001ef34:	31 0c       	mov	r12,16
8001ef36:	fe b0 c1 ff 	rcall	80017334 <ctl_param_change>
8001ef3a:	30 18       	mov	r8,1
    } else {

      // not playing
      print_dbg("\r\n (new loop)"); 
      if (ms_loop1 > tcTicks) { // overflow
	ms = tcTicks + (0xffffffff - ms_loop1);
8001ef3c:	ac 88       	st.b	r6[0x0],r8
8001ef3e:	30 08       	mov	r8,0
8001ef40:	ae 88       	st.b	r7[0x0],r8
8001ef42:	e3 cd 80 ec 	ldm	sp++,r2-r3,r5-r7,pc
8001ef46:	fe cc 98 9e 	sub	r12,pc,-26466
8001ef4a:	fe b0 a0 29 	rcall	80012f9c <print_dbg>
8001ef4e:	30 0b       	mov	r11,0
8001ef50:	30 fc       	mov	r12,15
8001ef52:	fe b0 c1 f1 	rcall	80017334 <ctl_param_change>
8001ef56:	e3 cd 80 ec 	ldm	sp++,r2-r3,r5-r7,pc
8001ef5a:	f4 e8 00 00 	ld.d	r8,r10[0]
8001ef5e:	5c d5       	com	r5
8001ef60:	10 05       	add	r5,r8
8001ef62:	cc 0b       	rjmp	8001eee2 <ctl_loop_playback+0x82>

8001ef64 <ctl_loop_record>:
8001ef64:	eb cd 40 80 	pushm	r7,lr
8001ef68:	fe cc 98 84 	sub	r12,pc,-26492
8001ef6c:	fe b0 a0 18 	rcall	80012f9c <print_dbg>
8001ef70:	30 09       	mov	r9,0
8001ef72:	e0 67 2a 80 	mov	r7,10880
8001ef76:	0f 88       	ld.ub	r8,r7[0x0]
8001ef78:	f2 08 18 00 	cp.b	r8,r9
8001ef7c:	c3 41       	brne	8001efe4 <ctl_loop_record+0x80>
8001ef7e:	e0 69 2a 81 	mov	r9,10881

// start recording loop on given delayline
void ctl_loop_record(u8 idx) {
  print_dbg("\r\n\r\n ctl_loop_record:");
  if(!loopRec1) {
    if(loopPlay1) {
8001ef82:	13 89       	ld.ub	r9,r9[0x0]
      ctl_param_change(eParam_pre1, fix16_one);
      // can reset loop length
      // by recording, cancelling loop, playing
      ms_loop1 = tcTicks; 
    } else {
      print_dbg("\r\n (new loop)");
8001ef84:	f0 09 18 00 	cp.b	r9,r8
8001ef88:	c3 01       	brne	8001efe8 <ctl_loop_record+0x84>
      ms_loop1 = tcTicks;
8001ef8a:	fe cc 99 06 	sub	r12,pc,-26362
8001ef8e:	fe b0 a0 07 	rcall	80012f9c <print_dbg>
      print_dbg("\r\n stop read head movement");
8001ef92:	e0 68 0b a0 	mov	r8,2976
8001ef96:	f0 ea 00 00 	ld.d	r10,r8[0]
      ctl_param_change(eParam_run_read1, 0);
8001ef9a:	e0 68 2a 7c 	mov	r8,10876
8001ef9e:	fe cc 98 7e 	sub	r12,pc,-26498
      print_dbg("\r\n reset write head");
8001efa2:	91 0a       	st.w	r8[0x0],r10
8001efa4:	fe b0 9f fc 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_pos_write1, 0);
8001efa8:	30 0b       	mov	r11,0
8001efaa:	31 0c       	mov	r12,16
8001efac:	fe b0 c1 c4 	rcall	80017334 <ctl_param_change>
      print_dbg("\r\n write enable");
8001efb0:	fe cc 99 1c 	sub	r12,pc,-26340
8001efb4:	fe b0 9f f4 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_write1, 1);
8001efb8:	30 0b       	mov	r11,0
8001efba:	30 ec       	mov	r12,14
8001efbc:	fe b0 c1 bc 	rcall	80017334 <ctl_param_change>
      print_dbg("\r\n start write head movement");
8001efc0:	fe cc 98 84 	sub	r12,pc,-26492
      ctl_param_change(eParam_run_write1, 1);
8001efc4:	fe b0 9f ec 	rcall	80012f9c <print_dbg>
8001efc8:	30 1b       	mov	r11,1
8001efca:	30 cc       	mov	r12,12
    }
    loopRec1 = 1;
8001efcc:	fe b0 c1 b4 	rcall	80017334 <ctl_param_change>
8001efd0:	fe cc 98 84 	sub	r12,pc,-26492
// start recording loop on given delayline
void ctl_loop_record(u8 idx) {
  print_dbg("\r\n\r\n ctl_loop_record:");
  if(!loopRec1) {
    if(loopPlay1) {
      print_dbg("\r\n (existing loop)");
8001efd4:	fe b0 9f e4 	rcall	80012f9c <print_dbg>
8001efd8:	30 1b       	mov	r11,1
      print_dbg("\r\n start writing ");
8001efda:	31 1c       	mov	r12,17
8001efdc:	fe b0 c1 ac 	rcall	80017334 <ctl_param_change>
      ctl_param_change(eParam_write1, 1);
8001efe0:	30 18       	mov	r8,1
8001efe2:	ae 88       	st.b	r7[0x0],r8
8001efe4:	e3 cd 80 80 	ldm	sp++,r7,pc
      print_dbg("\r\n full overdub");
8001efe8:	fe cc 99 8c 	sub	r12,pc,-26228
8001efec:	fe b0 9f d8 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_pre1, fix16_one);
8001eff0:	fe cc 98 f4 	sub	r12,pc,-26380
8001eff4:	fe b0 9f d4 	rcall	80012f9c <print_dbg>
      // can reset loop length
      // by recording, cancelling loop, playing
      ms_loop1 = tcTicks; 
8001eff8:	30 1b       	mov	r11,1
8001effa:	30 cc       	mov	r12,12
8001effc:	fe b0 c1 9c 	rcall	80017334 <ctl_param_change>
8001f000:	fe cc 98 f0 	sub	r12,pc,-26384
8001f004:	fe b0 9f cc 	rcall	80012f9c <print_dbg>
8001f008:	e0 7b 00 00 	mov	r11,65536
8001f00c:	30 dc       	mov	r12,13
8001f00e:	fe b0 c1 93 	rcall	80017334 <ctl_param_change>
8001f012:	e0 68 0b a0 	mov	r8,2976
8001f016:	f0 ea 00 00 	ld.d	r10,r8[0]
8001f01a:	e0 68 2a 7c 	mov	r8,10876
8001f01e:	91 0a       	st.w	r8[0x0],r10
8001f020:	ce 0b       	rjmp	8001efe0 <ctl_loop_record+0x7c>
8001f022:	d7 03       	nop

8001f024 <ctl_init_params>:
8001f024:	d4 01       	pushm	lr
8001f026:	30 0b       	mov	r11,0
8001f028:	31 8c       	mov	r12,24
8001f02a:	fe b0 c1 85 	rcall	80017334 <ctl_param_change>
8001f02e:	30 0b       	mov	r11,0
8001f030:	31 fc       	mov	r12,31
8001f032:	fe b0 c1 81 	rcall	80017334 <ctl_param_change>
8001f036:	e0 6b ff ff 	mov	r11,65535
8001f03a:	ea 1b 3f ff 	orh	r11,0x3fff
8001f03e:	33 4c       	mov	r12,52
void ctl_init_params(void) {
  // no filters
  ctl_param_change(eParam_mix0, 0);
  ctl_param_change(eParam_mix1, 0);
  // half dry
  ctl_param_change(eParam_adc0_dac0, fr32_from_float(0.5) );
8001f040:	fe b0 c1 7a 	rcall	80017334 <ctl_param_change>
  // half wet
  ctl_param_change(eParam_del0_dac0, fr32_from_float(0.5) );
8001f044:	e0 6b ff ff 	mov	r11,65535
8001f048:	ea 1b 3f ff 	orh	r11,0x3fff
8001f04c:	32 cc       	mov	r12,44
8001f04e:	fe b0 c1 73 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_del1_dac0, fr32_from_float(0.5) );
8001f052:	e0 6b ff ff 	mov	r11,65535
8001f056:	ea 1b 3f ff 	orh	r11,0x3fff
8001f05a:	33 0c       	mov	r12,48
8001f05c:	fe b0 c1 6c 	rcall	80017334 <ctl_param_change>
  // adc0 -> del0
  ctl_param_change(eParam_adc0_del0, fr32_from_float(0.99));
8001f060:	e0 6b 51 ff 	mov	r11,20991
8001f064:	ea 1b 7e b8 	orh	r11,0x7eb8
8001f068:	32 0c       	mov	r12,32
8001f06a:	fe b0 c1 65 	rcall	80017334 <ctl_param_change>
  // adc0 -> del1
  ctl_param_change(eParam_adc0_del1, fr32_from_float(0.99));
8001f06e:	e0 6b 51 ff 	mov	r11,20991
8001f072:	ea 1b 7e b8 	orh	r11,0x7eb8
8001f076:	32 1c       	mov	r12,33
8001f078:	fe b0 c1 5e 	rcall	80017334 <ctl_param_change>
  // del0 -> del1
  ctl_param_change(eParam_del0_del1, fr32_from_float(0.99));				    
8001f07c:	e0 6b 51 ff 	mov	r11,20991
8001f080:	ea 1b 7e b8 	orh	r11,0x7eb8
8001f084:	32 9c       	mov	r12,41
8001f086:	fe b0 c1 57 	rcall	80017334 <ctl_param_change>
  // slight feedback on del0 
  ctl_param_change(eParam_del0_del0, fix16_one >> 2);
8001f08a:	e0 6b 40 00 	mov	r11,16384
8001f08e:	32 8c       	mov	r12,40
8001f090:	fe b0 c1 52 	rcall	80017334 <ctl_param_change>
  // set write flags
  ctl_param_change(eParam_write0, 1);
8001f094:	30 1b       	mov	r11,1
8001f096:	30 3c       	mov	r12,3
8001f098:	fe b0 c1 4e 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_write1, 1);		   
8001f09c:	30 1b       	mov	r11,1
8001f09e:	30 cc       	mov	r12,12
8001f0a0:	fe b0 c1 4a 	rcall	80017334 <ctl_param_change>
  // set run flags
  ctl_param_change(eParam_run_write0, 1);
8001f0a4:	30 1b       	mov	r11,1
8001f0a6:	30 8c       	mov	r12,8
8001f0a8:	fe b0 c1 46 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_run_write1, 1);		   
8001f0ac:	30 1b       	mov	r11,1
8001f0ae:	31 1c       	mov	r12,17
8001f0b0:	fe b0 c1 42 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_run_read0, 1);
8001f0b4:	30 1b       	mov	r11,1
8001f0b6:	30 7c       	mov	r12,7
8001f0b8:	fe b0 c1 3e 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_run_read1, 1);		   
8001f0bc:	30 1b       	mov	r11,1
8001f0be:	31 0c       	mov	r12,16
8001f0c0:	fe b0 c1 3a 	rcall	80017334 <ctl_param_change>
  // set delay time
  ctl_param_change(eParam_delay0, 250 * 48 );
8001f0c4:	e0 6b 2e e0 	mov	r11,12000
8001f0c8:	30 0c       	mov	r12,0
8001f0ca:	fe b0 c1 35 	rcall	80017334 <ctl_param_change>
  ctl_param_change(eParam_delay1, 500 * 48 );
8001f0ce:	e0 6b 5d c0 	mov	r11,24000
8001f0d2:	30 9c       	mov	r12,9
8001f0d4:	fe b0 c1 30 	rcall	80017334 <ctl_param_change>
}
8001f0d8:	d8 02       	popm	pc
8001f0da:	d7 03       	nop

8001f0dc <ctl_set_delay_ms>:
8001f0dc:	d4 21       	pushm	r4-r7,lr
8001f0de:	f6 0b 00 16 	add	r6,r11,r11<<0x1


// set delay time in ms
void  ctl_set_delay_ms(u8 idx, u32 ms)  {
8001f0e2:	18 95       	mov	r5,r12
8001f0e4:	16 97       	mov	r7,r11
  u32 samps =  MS_TO_SAMPS(ms);
  print_dbg("\r\n\r\n ctl_set_delay_ms:");
8001f0e6:	fe cc 99 7a 	sub	r12,pc,-26246
8001f0ea:	fe b0 9f 59 	rcall	80012f9c <print_dbg>
  while(samps > PARAM_BUFFER_MAX) {
8001f0ee:	a5 66       	lsl	r6,0x4
8001f0f0:	e0 69 f1 ff 	mov	r9,61951
8001f0f4:	ea 19 00 2b 	orh	r9,0x2b
8001f0f8:	12 36       	cp.w	r6,r9
8001f0fa:	e0 88 00 0e 	brls	8001f116 <ctl_set_delay_ms+0x3a>
    samps -= PARAM_BUFFER_MAX;
8001f0fe:	e0 68 0e 01 	mov	r8,3585
8001f102:	ea 18 ff d4 	orh	r8,0xffd4

// set delay time in ms
void  ctl_set_delay_ms(u8 idx, u32 ms)  {
  u32 samps =  MS_TO_SAMPS(ms);
  print_dbg("\r\n\r\n ctl_set_delay_ms:");
  while(samps > PARAM_BUFFER_MAX) {
8001f106:	10 06       	add	r6,r8
8001f108:	e0 69 f1 ff 	mov	r9,61951
8001f10c:	ea 19 00 2b 	orh	r9,0x2b
8001f110:	12 36       	cp.w	r6,r9
8001f112:	fe 9b ff fa 	brhi	8001f106 <ctl_set_delay_ms+0x2a>
    samps -= PARAM_BUFFER_MAX;
  }
  // bleh
  switch(idx) {
8001f116:	30 04       	mov	r4,0
8001f118:	e8 05 18 00 	cp.b	r5,r4
8001f11c:	c0 60       	breq	8001f128 <ctl_set_delay_ms+0x4c>
8001f11e:	30 18       	mov	r8,1
8001f120:	f0 05 18 00 	cp.b	r5,r8
8001f124:	c0 c0       	breq	8001f13c <ctl_set_delay_ms+0x60>
  case 0:
    ctl_param_change(eParam_delay0, samps);
8001f126:	d8 22       	popm	r4-r7,pc
8001f128:	0c 9b       	mov	r11,r6
8001f12a:	30 0c       	mov	r12,0
8001f12c:	fe b0 c1 04 	rcall	80017334 <ctl_param_change>
    render_delay_time(0, ms, samps);
8001f130:	0c 9a       	mov	r10,r6
8001f132:	0e 9b       	mov	r11,r7
8001f134:	30 0c       	mov	r12,0
8001f136:	e0 a0 06 35 	rcall	8001fda0 <render_delay_time>
    break;
  case 1:    
    if(loopPlay1) {
8001f13a:	d8 22       	popm	r4-r7,pc
8001f13c:	e0 65 2a 81 	mov	r5,10881
8001f140:	0b 88       	ld.ub	r8,r5[0x0]
8001f142:	e8 08 18 00 	cp.b	r8,r4
      ctl_param_change(eParam_run_write1, 1);
      print_dbg("\r\n no overdub");
      ctl_param_change(eParam_pre1, 0);
      loopPlay1 = 0;
    }
    print_dbg("\r\n sync write/read heads");
8001f146:	c0 f1       	brne	8001f164 <ctl_set_delay_ms+0x88>
8001f148:	fe cc 99 74 	sub	r12,pc,-26252
    ctl_param_change(eParam_delay1, samps);    
8001f14c:	fe b0 9f 28 	rcall	80012f9c <print_dbg>
8001f150:	0c 9b       	mov	r11,r6
    render_delay_time(1, ms, samps);
8001f152:	30 9c       	mov	r12,9
8001f154:	fe b0 c0 f0 	rcall	80017334 <ctl_param_change>
8001f158:	0c 9a       	mov	r10,r6
8001f15a:	0e 9b       	mov	r11,r7
8001f15c:	30 1c       	mov	r12,1
    ctl_param_change(eParam_delay0, samps);
    render_delay_time(0, ms, samps);
    break;
  case 1:    
    if(loopPlay1) {
      print_dbg("\r\n (switching from loop to delay mode");
8001f15e:	e0 a0 06 21 	rcall	8001fda0 <render_delay_time>
8001f162:	d8 22       	popm	r4-r7,pc
      print_dbg("\r\n set loop time to max");
8001f164:	fe cc 99 e0 	sub	r12,pc,-26144
8001f168:	fe b0 9f 1a 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_loop1, PARAM_BUFFER_MAX);
8001f16c:	fe cc 99 c0 	sub	r12,pc,-26176
8001f170:	fe b0 9f 16 	rcall	80012f9c <print_dbg>
8001f174:	e0 6b f1 ff 	mov	r11,61951
      print_dbg("\r\n write enable");
8001f178:	ea 1b 00 2b 	orh	r11,0x2b
8001f17c:	30 ac       	mov	r12,10
      ctl_param_change(eParam_write1, 1);
8001f17e:	fe b0 c0 db 	rcall	80017334 <ctl_param_change>
8001f182:	fe cc 9a 46 	sub	r12,pc,-26042
      print_dbg("\r\n start write head movement");
8001f186:	fe b0 9f 0b 	rcall	80012f9c <print_dbg>
8001f18a:	30 1b       	mov	r11,1
      ctl_param_change(eParam_run_write1, 1);
8001f18c:	30 cc       	mov	r12,12
8001f18e:	fe b0 c0 d3 	rcall	80017334 <ctl_param_change>
8001f192:	fe cc 9a 46 	sub	r12,pc,-26042
      print_dbg("\r\n no overdub");
8001f196:	fe b0 9f 03 	rcall	80012f9c <print_dbg>
      ctl_param_change(eParam_pre1, 0);
8001f19a:	30 1b       	mov	r11,1
8001f19c:	31 1c       	mov	r12,17
8001f19e:	fe b0 c0 cb 	rcall	80017334 <ctl_param_change>
      loopPlay1 = 0;
8001f1a2:	fe cc 99 de 	sub	r12,pc,-26146
8001f1a6:	fe b0 9e fb 	rcall	80012f9c <print_dbg>
8001f1aa:	30 0b       	mov	r11,0
8001f1ac:	30 dc       	mov	r12,13
8001f1ae:	fe b0 c0 c3 	rcall	80017334 <ctl_param_change>
8001f1b2:	aa 84       	st.b	r5[0x0],r4
8001f1b4:	cc ab       	rjmp	8001f148 <ctl_set_delay_ms+0x6c>
8001f1b6:	d7 03       	nop

8001f1b8 <ctl_report_params>:
8001f1b8:	eb cd 40 c0 	pushm	r6-r7,lr
8001f1bc:	21 ad       	sub	sp,104
8001f1be:	fa cc ff 9c 	sub	r12,sp,-100
8001f1c2:	fe b0 bf 25 	rcall	8001700c <bfin_get_num_params>
8001f1c6:	fe cc 99 d6 	sub	r12,pc,-26154
8001f1ca:	fe b0 9e e9 	rcall	80012f9c <print_dbg>
8001f1ce:	41 9c       	lddsp	r12,sp[0x64]
8001f1d0:	fe b0 9e ec 	rcall	80012fa8 <print_dbg_ulong>
 
  bfin_get_num_params(&numParams);
  print_dbg("\r\nnumparams: ");
  print_dbg_ulong(numParams);

  if(numParams == 255) {
8001f1d4:	41 97       	lddsp	r7,sp[0x64]
8001f1d6:	e0 47 00 ff 	cp.w	r7,255
8001f1da:	e0 80 00 85 	breq	8001f2e4 <ctl_report_params+0x12c>
    print_dbg("\r\n report_params fail (too many)");
    return 0;
  }

  if(numParams > 0) {
8001f1de:	58 07       	cp.w	r7,0
8001f1e0:	c7 a0       	breq	8001f2d4 <ctl_report_params+0x11c>
8001f1e2:	fa c6 ff bd 	sub	r6,sp,-67
    for(i=0; i<numParams; i++) {
      bfin_get_param_desc(i, &pdesc);
8001f1e6:	30 07       	mov	r7,0
8001f1e8:	0c 9b       	mov	r11,r6
8001f1ea:	0e 9c       	mov	r12,r7
8001f1ec:	fe b0 bb c4 	rcall	80016974 <bfin_get_param_desc>
      
      print_dbg("\r\n got pdesc : ");
8001f1f0:	fe cc 99 cc 	sub	r12,pc,-26164
      print_dbg((const char* )pdesc.label);
8001f1f4:	fe b0 9e d4 	rcall	80012f9c <print_dbg>
8001f1f8:	0c 9c       	mov	r12,r6
    print_dbg("\r\n report_params fail (too many)");
    return 0;
  }

  if(numParams > 0) {
    for(i=0; i<numParams; i++) {
8001f1fa:	fe b0 9e d1 	rcall	80012f9c <print_dbg>
8001f1fe:	41 98       	lddsp	r8,sp[0x64]
8001f200:	2f f7       	sub	r7,-1
8001f202:	5c 57       	castu.b	r7
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001f204:	10 37       	cp.w	r7,r8
8001f206:	cf 13       	brcs	8001f1e8 <ctl_report_params+0x30>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001f208:	e1 b7 00 42 	mfsr	r7,0x108
8001f20c:	e0 68 03 e8 	mov	r8,1000
8001f210:	30 09       	mov	r9,0
8001f212:	e0 6a 05 e7 	mov	r10,1511
8001f216:	ea 1a 89 64 	orh	r10,0x8964
8001f21a:	30 1b       	mov	r11,1
8001f21c:	e0 a0 1e db 	rcall	80022fd2 <__avr32_udiv64>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001f220:	ee 0a 00 0a 	add	r10,r7,r10
8001f224:	e1 b8 00 42 	mfsr	r8,0x108
8001f228:	14 37       	cp.w	r7,r10
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001f22a:	e0 8b 00 3a 	brhi	8001f29e <ctl_report_params+0xe6>
8001f22e:	0e 38       	cp.w	r8,r7
8001f230:	c0 43       	brcs	8001f238 <ctl_report_params+0x80>
8001f232:	14 38       	cp.w	r8,r10
    return 0;
  }
  
  delay_ms(100);

  print_dbg("\r\n checking module label ");
8001f234:	e0 88 00 43 	brls	8001f2ba <ctl_report_params+0x102>
8001f238:	fe cc 99 b4 	sub	r12,pc,-26188
  // check module label
  bfin_get_module_name(buf);
8001f23c:	fe b0 9e b0 	rcall	80012f9c <print_dbg>
8001f240:	1a 9c       	mov	r12,sp
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001f242:	1a 97       	mov	r7,sp
8001f244:	fe b0 bb 62 	rcall	80016908 <bfin_get_module_name>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001f248:	e1 b6 00 42 	mfsr	r6,0x108
8001f24c:	e0 68 03 e8 	mov	r8,1000
8001f250:	30 09       	mov	r9,0
8001f252:	e0 6a d0 e7 	mov	r10,53479
8001f256:	ea 1a 27 56 	orh	r10,0x2756
8001f25a:	30 0b       	mov	r11,0
8001f25c:	e0 a0 1e bb 	rcall	80022fd2 <__avr32_udiv64>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001f260:	ec 0a 00 0a 	add	r10,r6,r10
8001f264:	e1 b8 00 42 	mfsr	r8,0x108
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001f268:	14 36       	cp.w	r6,r10
8001f26a:	e0 8b 00 22 	brhi	8001f2ae <ctl_report_params+0xf6>
8001f26e:	10 36       	cp.w	r6,r8
8001f270:	e0 8b 00 04 	brhi	8001f278 <ctl_report_params+0xc0>

  delay_ms(10);

  print_dbg("\r\n bfin module name: ");
8001f274:	10 3a       	cp.w	r10,r8
8001f276:	c2 52       	brcc	8001f2c0 <ctl_report_params+0x108>
  print_dbg((const char*)buf);
8001f278:	fe cc 99 d8 	sub	r12,pc,-26152
8001f27c:	fe b0 9e 90 	rcall	80012f9c <print_dbg>
  if(strcmp((const char*)buf, "aleph-lines")) {
8001f280:	1a 9c       	mov	r12,sp
8001f282:	fe b0 9e 8d 	rcall	80012f9c <print_dbg>
8001f286:	1a 9c       	mov	r12,sp
8001f288:	fe cb 99 d0 	sub	r11,pc,-26160
    print_dbg( "\r\n report_params fail (module name mismatch)" );
    return 0;
  } else {
    return 1;
  }
}
8001f28c:	e0 a0 22 d8 	rcall	8002383c <strcmp>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001f290:	c1 b1       	brne	8001f2c6 <ctl_report_params+0x10e>
8001f292:	30 1c       	mov	r12,1
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001f294:	2e 6d       	sub	sp,-104
8001f296:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001f29a:	e1 b8 00 42 	mfsr	r8,0x108
8001f29e:	10 37       	cp.w	r7,r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001f2a0:	fe 98 ff fd 	brls	8001f29a <ctl_report_params+0xe2>
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001f2a4:	10 3a       	cp.w	r10,r8
8001f2a6:	cc 93       	brcs	8001f238 <ctl_report_params+0x80>
8001f2a8:	cf 9b       	rjmp	8001f29a <ctl_report_params+0xe2>
8001f2aa:	e1 b8 00 42 	mfsr	r8,0x108
8001f2ae:	10 36       	cp.w	r6,r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001f2b0:	fe 98 ff fd 	brls	8001f2aa <ctl_report_params+0xf2>
8001f2b4:	10 3a       	cp.w	r10,r8
8001f2b6:	ce 13       	brcs	8001f278 <ctl_report_params+0xc0>
8001f2b8:	cf 9b       	rjmp	8001f2aa <ctl_report_params+0xf2>
8001f2ba:	e1 b8 00 42 	mfsr	r8,0x108
  delay_ms(10);

  print_dbg("\r\n bfin module name: ");
  print_dbg((const char*)buf);
  if(strcmp((const char*)buf, "aleph-lines")) {
    print_dbg( "\r\n report_params fail (module name mismatch)" );
8001f2be:	cb 8b       	rjmp	8001f22e <ctl_report_params+0x76>
8001f2c0:	e1 b8 00 42 	mfsr	r8,0x108
8001f2c4:	cd 5b       	rjmp	8001f26e <ctl_report_params+0xb6>
8001f2c6:	fe cc 9a 72 	sub	r12,pc,-25998
      
      print_dbg("\r\n got pdesc : ");
      print_dbg((const char* )pdesc.label);
    }
  } else {
    print_dbg("\r\n report_params fail (none)");
8001f2ca:	fe b0 9e 69 	rcall	80012f9c <print_dbg>
8001f2ce:	2e 6d       	sub	sp,-104
    print_dbg( "\r\n report_params fail (module name mismatch)" );
    return 0;
  } else {
    return 1;
  }
}
8001f2d0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8001f2d4:	fe cc 9a a0 	sub	r12,pc,-25952
  bfin_get_num_params(&numParams);
  print_dbg("\r\nnumparams: ");
  print_dbg_ulong(numParams);

  if(numParams == 255) {
    print_dbg("\r\n report_params fail (too many)");
8001f2d8:	fe b0 9e 62 	rcall	80012f9c <print_dbg>
8001f2dc:	0e 9c       	mov	r12,r7
    return 0;
8001f2de:	2e 6d       	sub	sp,-104
8001f2e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001f2e4:	fe cc 9a e4 	sub	r12,pc,-25884
8001f2e8:	fe b0 9e 5a 	rcall	80012f9c <print_dbg>
8001f2ec:	30 0c       	mov	r12,0
8001f2ee:	cd 3b       	rjmp	8001f294 <ctl_report_params+0xdc>

8001f2f0 <inputs_init>:
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f2f0:	d4 31       	pushm	r0-r7,lr
8001f2f2:	20 3d       	sub	sp,12
  // allocate memory
  tabAmp = (table*)alloc_mem(sizeof(table));
8001f2f4:	e0 6c 20 00 	mov	r12,8192
8001f2f8:	fe b0 c8 76 	rcall	800183e4 <alloc_mem>
8001f2fc:	e0 64 33 30 	mov	r4,13104
8001f300:	89 0c       	st.w	r4[0x0],r12
  tabDb = (table*)alloc_mem(sizeof(table));
8001f302:	e0 6c 20 00 	mov	r12,8192
8001f306:	fe b0 c8 6f 	rcall	800183e4 <alloc_mem>
8001f30a:	e0 61 33 3c 	mov	r1,13116
8001f30e:	83 0c       	st.w	r1[0x0],r12
  tabHz = (table*)alloc_mem(sizeof(table));
8001f310:	e0 6c 20 00 	mov	r12,8192
8001f314:	fe b0 c8 68 	rcall	800183e4 <alloc_mem>
8001f318:	e0 69 33 38 	mov	r9,13112
  tabFreq = (table*)alloc_mem(sizeof(table));
8001f31c:	30 07       	mov	r7,0
// maybe in aleph/audio
extern void inputs_init(void) {
  // allocate memory
  tabAmp = (table*)alloc_mem(sizeof(table));
  tabDb = (table*)alloc_mem(sizeof(table));
  tabHz = (table*)alloc_mem(sizeof(table));
8001f31e:	93 0c       	st.w	r9[0x0],r12
  tabFreq = (table*)alloc_mem(sizeof(table));
8001f320:	e0 6c 20 00 	mov	r12,8192
8001f324:	fe b0 c8 60 	rcall	800183e4 <alloc_mem>
8001f328:	e0 68 33 2c 	mov	r8,13100
8001f32c:	30 15       	mov	r5,1
8001f32e:	30 02       	mov	r2,0
8001f330:	30 03       	mov	r3,0
8001f332:	91 0c       	st.w	r8[0x0],r12
8001f334:	0e 96       	mov	r6,r7
8001f336:	c1 78       	rjmp	8001f364 <inputs_init+0x74>
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
    /// linear ramp in [0, breakDb]
    if (i == 0) {
      // zero the bottom
      tabAmp->data[i] = 0;
8001f338:	68 08       	ld.w	r8,r4[0x0]
8001f33a:	91 06       	st.w	r8[0x0],r6
      // fix16 lacks '-inf' ...
      tabDb->data[i] = fix16_min;
8001f33c:	fc 19 80 00 	movh	r9,0x8000
8001f340:	62 08       	ld.w	r8,r1[0x0]
    /* print_dbg(", db (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" ( "); */
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
8001f342:	04 9a       	mov	r10,r2
8001f344:	06 9b       	mov	r11,r3
    /// linear ramp in [0, breakDb]
    if (i == 0) {
      // zero the bottom
      tabAmp->data[i] = 0;
      // fix16 lacks '-inf' ...
      tabDb->data[i] = fix16_min;
8001f346:	91 09       	st.w	r8[0x0],r9
    /* print_dbg(", db (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" ( "); */
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
8001f348:	e0 68 10 04 	mov	r8,4100
8001f34c:	ea 18 00 40 	orh	r8,0x40
8001f350:	e0 69 04 01 	mov	r9,1025
8001f354:	ea 19 3f 50 	orh	r9,0x3f50
extern void inputs_init(void) {
  // allocate memory
  tabAmp = (table*)alloc_mem(sizeof(table));
  tabDb = (table*)alloc_mem(sizeof(table));
  tabHz = (table*)alloc_mem(sizeof(table));
  tabFreq = (table*)alloc_mem(sizeof(table));
8001f358:	2f f6       	sub	r6,-1
    /* print_dbg(", db (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" ( "); */
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
8001f35a:	e0 a0 18 49 	rcall	800223ec <__avr32_f64_add>
extern void inputs_init(void) {
  // allocate memory
  tabAmp = (table*)alloc_mem(sizeof(table));
  tabDb = (table*)alloc_mem(sizeof(table));
  tabHz = (table*)alloc_mem(sizeof(table));
  tabFreq = (table*)alloc_mem(sizeof(table));
8001f35e:	2f f5       	sub	r5,-1
    /* print_dbg(", db (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" ( "); */
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
8001f360:	14 92       	mov	r2,r10
8001f362:	16 93       	mov	r3,r11
    const double log10 = log(10.0);
  // fill amp/db tables
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
    /// linear ramp in [0, breakDb]
    if (i == 0) {
8001f364:	58 06       	cp.w	r6,0
8001f366:	ce 90       	breq	8001f338 <inputs_init+0x48>
      // zero the bottom
      tabAmp->data[i] = 0;
      // fix16 lacks '-inf' ...
      tabDb->data[i] = fix16_min;
    } else if(f <= ampBreak) {
8001f368:	04 98       	mov	r8,r2
8001f36a:	06 99       	mov	r9,r3
8001f36c:	e0 6a 99 9a 	mov	r10,39322
8001f370:	ea 1a 99 99 	orh	r10,0x9999
8001f374:	e0 6b 99 99 	mov	r11,39321
8001f378:	ea 1b 3f b9 	orh	r11,0x3fb9
8001f37c:	e0 a0 19 58 	rcall	8002262c <__avr32_f64_cmp_ge>
8001f380:	c4 30       	breq	8001f406 <inputs_init+0x116>
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * f);
8001f382:	e0 69 ff ff 	mov	r9,65535
8001f386:	ea 19 41 df 	orh	r9,0x41df
8001f38a:	fc 18 ff c0 	movh	r8,0xffc0
8001f38e:	04 9a       	mov	r10,r2
8001f390:	06 9b       	mov	r11,r3
8001f392:	e0 a0 16 73 	rcall	80022078 <__avr32_f64_mul>
8001f396:	e0 a0 18 b1 	rcall	800224f8 <__avr32_f64_to_s32>
8001f39a:	68 08       	ld.w	r8,r4[0x0]
      tabDb->data[i] = fix16_from_float((float)(log(f) / log10 * 20.0));
8001f39c:	04 9a       	mov	r10,r2
      // zero the bottom
      tabAmp->data[i] = 0;
      // fix16 lacks '-inf' ...
      tabDb->data[i] = fix16_min;
    } else if(f <= ampBreak) {
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * f);
8001f39e:	f0 06 09 2c 	st.w	r8[r6<<0x2],r12
      tabDb->data[i] = fix16_from_float((float)(log(f) / log10 * 20.0));
8001f3a2:	06 9b       	mov	r11,r3
8001f3a4:	62 07       	ld.w	r7,r1[0x0]
8001f3a6:	e0 a0 07 ad 	rcall	80020300 <log>
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f3aa:	e0 68 55 16 	mov	r8,21782
8001f3ae:	ea 18 bb b5 	orh	r8,0xbbb5
8001f3b2:	e0 69 6b b1 	mov	r9,27569
8001f3b6:	ea 19 40 02 	orh	r9,0x4002
8001f3ba:	e0 a0 19 e1 	rcall	8002277c <__avr32_f64_div>
8001f3be:	30 08       	mov	r8,0
8001f3c0:	fc 19 40 34 	movh	r9,0x4034
8001f3c4:	e0 a0 16 5a 	rcall	80022078 <__avr32_f64_mul>
8001f3c8:	e0 a0 1d c0 	rcall	80022f48 <__avr32_f64_to_f32>
8001f3cc:	fc 1b 47 80 	movh	r11,0x4780
8001f3d0:	e0 a0 1c d2 	rcall	80022d74 <__avr32_f32_mul>
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f3d4:	30 0b       	mov	r11,0
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f3d6:	18 90       	mov	r0,r12
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f3d8:	e0 a0 19 9e 	rcall	80022714 <__avr32_f32_cmp_ge>
8001f3dc:	fc 19 bf 00 	movh	r9,0xbf00
8001f3e0:	fc 1b 3f 00 	movh	r11,0x3f00
8001f3e4:	58 0c       	cp.w	r12,0
8001f3e6:	f2 0b 17 00 	moveq	r11,r9
8001f3ea:	00 9c       	mov	r12,r0
8001f3ec:	e0 a0 1c 6e 	rcall	80022cc8 <__avr32_f32_add>
8001f3f0:	e0 a0 1d 6d 	rcall	80022eca <__avr32_f32_to_s32>
8001f3f4:	ee 06 09 2c 	st.w	r7[r6<<0x2],r12
  // 1 / (1 - ampBreak)
    const double recip_inv_ampBreak = 1.0 / 0.9;  
    const double log10 = log(10.0);
  // fill amp/db tables
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
8001f3f8:	e0 45 03 ff 	cp.w	r5,1023
8001f3fc:	e0 8b 00 75 	brhi	8001f4e6 <inputs_init+0x1f6>
    /* print_dbg(", db (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" ( "); */
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
8001f400:	04 9a       	mov	r10,r2
8001f402:	06 9b       	mov	r11,r3
8001f404:	ca 2b       	rjmp	8001f348 <inputs_init+0x58>
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * f);
      tabDb->data[i] = fix16_from_float((float)(log(f) / log10 * 20.0));
    } else {
      //// audio taper in (breakDb, 1]
      // map db linearly to input
      fy = (1.0 - (f - ampBreak) * recip_inv_ampBreak) * dbBreak;
8001f406:	e0 68 99 9a 	mov	r8,39322
8001f40a:	ea 18 99 99 	orh	r8,0x9999
8001f40e:	e0 69 99 99 	mov	r9,39321
8001f412:	ea 19 3f b9 	orh	r9,0x3fb9
8001f416:	04 9a       	mov	r10,r2
8001f418:	06 9b       	mov	r11,r3
8001f41a:	e0 a0 17 1b 	rcall	80022250 <__avr32_f64_sub>
8001f41e:	e0 68 1c 72 	mov	r8,7282
8001f422:	ea 18 71 c7 	orh	r8,0x71c7
8001f426:	e0 69 c7 1c 	mov	r9,50972
8001f42a:	ea 19 bf f1 	orh	r9,0xbff1
8001f42e:	e0 a0 16 25 	rcall	80022078 <__avr32_f64_mul>
8001f432:	30 08       	mov	r8,0
8001f434:	fc 19 3f f0 	movh	r9,0x3ff0
8001f438:	e0 a0 17 da 	rcall	800223ec <__avr32_f64_add>
8001f43c:	30 08       	mov	r8,0
8001f43e:	fc 19 c0 34 	movh	r9,0xc034
8001f442:	e0 a0 16 1b 	rcall	80022078 <__avr32_f64_mul>
      // convert to amplitude
      fx = powf(10.0, fy * 0.05);
8001f446:	e0 68 99 9a 	mov	r8,39322
8001f44a:	ea 18 99 99 	orh	r8,0x9999
8001f44e:	e0 69 99 99 	mov	r9,39321
8001f452:	ea 19 3f a9 	orh	r9,0x3fa9
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * f);
      tabDb->data[i] = fix16_from_float((float)(log(f) / log10 * 20.0));
    } else {
      //// audio taper in (breakDb, 1]
      // map db linearly to input
      fy = (1.0 - (f - ampBreak) * recip_inv_ampBreak) * dbBreak;
8001f456:	fa eb 00 04 	st.d	sp[4],r10
      // convert to amplitude
      fx = powf(10.0, fy * 0.05);
8001f45a:	e0 a0 16 0f 	rcall	80022078 <__avr32_f64_mul>
8001f45e:	e0 a0 1d 75 	rcall	80022f48 <__avr32_f64_to_f32>
8001f462:	18 9b       	mov	r11,r12
8001f464:	fc 1c 41 20 	movh	r12,0x4120
8001f468:	e0 a0 05 ea 	rcall	8002003c <powf>
      // amp in fract32
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * fx);
8001f46c:	e0 a0 1d 3e 	rcall	80022ee8 <__avr32_f32_to_f64>
8001f470:	fc 18 ff c0 	movh	r8,0xffc0
8001f474:	e0 69 ff ff 	mov	r9,65535
8001f478:	ea 19 41 df 	orh	r9,0x41df
8001f47c:	68 07       	ld.w	r7,r4[0x0]
8001f47e:	e0 a0 15 fd 	rcall	80022078 <__avr32_f64_mul>
8001f482:	e0 a0 18 3b 	rcall	800224f8 <__avr32_f64_to_s32>
8001f486:	ee 06 09 2c 	st.w	r7[r6<<0x2],r12
      // check underflow
      if(tabAmp->data[i] < 0) { tabAmp->data[i] = 0; }
8001f48a:	68 08       	ld.w	r8,r4[0x0]
8001f48c:	f0 06 03 29 	ld.w	r9,r8[r6<<0x2]
8001f490:	58 09       	cp.w	r9,0
8001f492:	e0 85 01 7d 	brlt	8001f78c <inputs_init+0x49c>
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f496:	fa ea 00 04 	ld.d	r10,sp[4]
8001f49a:	e0 a0 1d 57 	rcall	80022f48 <__avr32_f64_to_f32>
8001f49e:	fc 1b 47 80 	movh	r11,0x4780
8001f4a2:	e0 a0 1c 69 	rcall	80022d74 <__avr32_f32_mul>
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f4a6:	30 0b       	mov	r11,0
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f4a8:	18 97       	mov	r7,r12
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f4aa:	e0 a0 19 35 	rcall	80022714 <__avr32_f32_cmp_ge>
      // clamp to 0db
      tabDb->data[i] = fix16_from_float((float)fy); 
8001f4ae:	fc 18 bf 00 	movh	r8,0xbf00
8001f4b2:	fc 1b 3f 00 	movh	r11,0x3f00
8001f4b6:	58 0c       	cp.w	r12,0
8001f4b8:	f0 0b 17 00 	moveq	r11,r8
8001f4bc:	0e 9c       	mov	r12,r7
8001f4be:	62 07       	ld.w	r7,r1[0x0]
8001f4c0:	e0 a0 1c 04 	rcall	80022cc8 <__avr32_f32_add>
8001f4c4:	e0 a0 1d 03 	rcall	80022eca <__avr32_f32_to_s32>
8001f4c8:	ee 06 09 2c 	st.w	r7[r6<<0x2],r12
      if(tabDb->data[i] > 0) { tabDb->data[i] = 0; }
8001f4cc:	62 08       	ld.w	r8,r1[0x0]
8001f4ce:	f0 06 03 29 	ld.w	r9,r8[r6<<0x2]
8001f4d2:	58 09       	cp.w	r9,0
8001f4d4:	fe 9a ff 92 	brle	8001f3f8 <inputs_init+0x108>
8001f4d8:	30 09       	mov	r9,0
8001f4da:	f0 06 09 29 	st.w	r8[r6<<0x2],r9
  // 1 / (1 - ampBreak)
    const double recip_inv_ampBreak = 1.0 / 0.9;  
    const double log10 = log(10.0);
  // fill amp/db tables
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
8001f4de:	e0 45 03 ff 	cp.w	r5,1023
8001f4e2:	fe 98 ff 8f 	brls	8001f400 <inputs_init+0x110>
    /* print_dbg_hex(tabDb->data[i]); */
    /* print_dbg(" )"); */
    f += finc;
  }
  // calculate deltas
  table_calc_deltas(tabAmp);
8001f4e6:	68 03       	ld.w	r3,r4[0x0]
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f4e8:	30 06       	mov	r6,0
8001f4ea:	06 97       	mov	r7,r3
8001f4ec:	0f 05       	ld.w	r5,r7++
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f4ee:	6e 04       	ld.w	r4,r7[0x0]
    tab->delta[i] = (s32)f;
8001f4f0:	e8 05 01 0c 	sub	r12,r4,r5
8001f4f4:	e0 a0 18 19 	rcall	80022526 <__avr32_s32_to_f64>
8001f4f8:	30 08       	mov	r8,0
8001f4fa:	e0 69 80 00 	mov	r9,32768
8001f4fe:	ea 19 40 4f 	orh	r9,0x404f
8001f502:	e0 a0 19 3d 	rcall	8002277c <__avr32_f64_div>
8001f506:	e0 a0 17 f9 	rcall	800224f8 <__avr32_f64_to_s32>
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f50a:	6e 15       	ld.w	r5,r7[0x4]
    tab->delta[i] = (s32)f;
8001f50c:	ef 4c 0f fc 	st.w	r7[4092],r12
8001f510:	ea 04 01 0c 	sub	r12,r5,r4
8001f514:	e0 a0 18 09 	rcall	80022526 <__avr32_s32_to_f64>
8001f518:	30 08       	mov	r8,0
8001f51a:	e0 69 80 00 	mov	r9,32768
8001f51e:	ea 19 40 4f 	orh	r9,0x404f
8001f522:	e0 a0 19 2d 	rcall	8002277c <__avr32_f64_div>
8001f526:	e0 a0 17 e9 	rcall	800224f8 <__avr32_f64_to_s32>
8001f52a:	ef 4c 10 00 	st.w	r7[4096],r12
8001f52e:	2f e6       	sub	r6,-2
8001f530:	2f 87       	sub	r7,-8
8001f532:	e0 46 03 fe 	cp.w	r6,1022
8001f536:	cd c1       	brne	8001f4ee <inputs_init+0x1fe>
8001f538:	e6 f8 0f f8 	ld.w	r8,r3[4088]
8001f53c:	e6 fc 0f fc 	ld.w	r12,r3[4092]
8001f540:	10 1c       	sub	r12,r8
8001f542:	e0 a0 17 f2 	rcall	80022526 <__avr32_s32_to_f64>
8001f546:	30 08       	mov	r8,0
8001f548:	e0 69 80 00 	mov	r9,32768
8001f54c:	ea 19 40 4f 	orh	r9,0x404f
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f550:	30 06       	mov	r6,0
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
    tab->delta[i] = (s32)f;
8001f552:	e0 a0 19 15 	rcall	8002277c <__avr32_f64_div>
8001f556:	e0 a0 17 d1 	rcall	800224f8 <__avr32_f64_to_s32>
    /* print_dbg(" = 0x"); */
    /* print_dbg_hex((u32)sdif); */
    /* print_dbg(" ; delta: 0x"); */
    /* print_dbg_hex( tab->delta[i] ); */
  }
  tab->delta[TABLE_MAX] = tab->delta[TABLE_MAX - 1];
8001f55a:	e7 4c 1f fc 	st.w	r3[8188],r12
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
    tab->delta[i] = (s32)f;
8001f55e:	e7 4c 1f f8 	st.w	r3[8184],r12
    /* print_dbg(" )"); */
    f += finc;
  }
  // calculate deltas
  table_calc_deltas(tabAmp);
  table_calc_deltas(tabDb);
8001f562:	62 03       	ld.w	r3,r1[0x0]
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f564:	06 97       	mov	r7,r3
8001f566:	0f 05       	ld.w	r5,r7++
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f568:	6e 04       	ld.w	r4,r7[0x0]
    tab->delta[i] = (s32)f;
8001f56a:	e8 05 01 0c 	sub	r12,r4,r5
8001f56e:	e0 a0 17 dc 	rcall	80022526 <__avr32_s32_to_f64>
8001f572:	30 08       	mov	r8,0
8001f574:	e0 69 80 00 	mov	r9,32768
8001f578:	ea 19 40 4f 	orh	r9,0x404f
8001f57c:	e0 a0 19 00 	rcall	8002277c <__avr32_f64_div>
8001f580:	e0 a0 17 bc 	rcall	800224f8 <__avr32_f64_to_s32>
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f584:	6e 15       	ld.w	r5,r7[0x4]
    tab->delta[i] = (s32)f;
8001f586:	ef 4c 0f fc 	st.w	r7[4092],r12
8001f58a:	ea 04 01 0c 	sub	r12,r5,r4
8001f58e:	e0 a0 17 cc 	rcall	80022526 <__avr32_s32_to_f64>
8001f592:	30 08       	mov	r8,0
8001f594:	e0 69 80 00 	mov	r9,32768
8001f598:	ea 19 40 4f 	orh	r9,0x404f
8001f59c:	e0 a0 18 f0 	rcall	8002277c <__avr32_f64_div>
8001f5a0:	e0 a0 17 ac 	rcall	800224f8 <__avr32_f64_to_s32>
8001f5a4:	ef 4c 10 00 	st.w	r7[4096],r12
8001f5a8:	2f e6       	sub	r6,-2
8001f5aa:	2f 87       	sub	r7,-8
8001f5ac:	e0 46 03 fe 	cp.w	r6,1022
8001f5b0:	cd c1       	brne	8001f568 <inputs_init+0x278>
8001f5b2:	e6 f8 0f f8 	ld.w	r8,r3[4088]
8001f5b6:	e6 fc 0f fc 	ld.w	r12,r3[4092]
8001f5ba:	10 1c       	sub	r12,r8
8001f5bc:	e0 a0 17 b5 	rcall	80022526 <__avr32_s32_to_f64>
8001f5c0:	30 08       	mov	r8,0
8001f5c2:	e0 69 80 00 	mov	r9,32768
8001f5c6:	ea 19 40 4f 	orh	r9,0x404f
8001f5ca:	e0 a0 18 d9 	rcall	8002277c <__avr32_f64_div>
8001f5ce:	e0 a0 17 95 	rcall	800224f8 <__avr32_f64_to_s32>
  double fn;
  s32 itmp;
  // 2 ** (1/12)
  const double tempered = 1.0594630943593;

  noteMin_fix = (u32)noteMin << 16;
8001f5d2:	fc 19 00 13 	movh	r9,0x13
    /* print_dbg(" = 0x"); */
    /* print_dbg_hex((u32)sdif); */
    /* print_dbg(" ; delta: 0x"); */
    /* print_dbg_hex( tab->delta[i] ); */
  }
  tab->delta[TABLE_MAX] = tab->delta[TABLE_MAX - 1];
8001f5d6:	e7 4c 1f fc 	st.w	r3[8188],r12
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
    tab->delta[i] = (s32)f;
8001f5da:	e7 4c 1f f8 	st.w	r3[8184],r12
  double fn;
  s32 itmp;
  // 2 ** (1/12)
  const double tempered = 1.0594630943593;

  noteMin_fix = (u32)noteMin << 16;
8001f5de:	e0 68 2a 84 	mov	r8,10884
8001f5e2:	91 09       	st.w	r8[0x0],r9
  noteMax_fix = (u32)noteMax << 16;
8001f5e4:	fc 19 00 74 	movh	r9,0x74
8001f5e8:	e0 68 2a 8c 	mov	r8,10892
  noteSpan_fix = noteMax_fix - noteMin_fix;  
8001f5ec:	30 07       	mov	r7,0
  s32 itmp;
  // 2 ** (1/12)
  const double tempered = 1.0594630943593;

  noteMin_fix = (u32)noteMin << 16;
  noteMax_fix = (u32)noteMax << 16;
8001f5ee:	91 09       	st.w	r8[0x0],r9
  noteSpan_fix = noteMax_fix - noteMin_fix;  
8001f5f0:	30 02       	mov	r2,0
8001f5f2:	fc 19 00 61 	movh	r9,0x61
8001f5f6:	e0 68 2a 88 	mov	r8,10888
8001f5fa:	30 03       	mov	r3,0
8001f5fc:	91 09       	st.w	r8[0x0],r9
  for(i=0; i<TABLE_SIZE; i++) {
    // note numbers (difference)s
    fn = f * ((double)noteMax - (double)noteMin) - 69.0 + noteMin;
    itmp = (s32)fn;
    // octave multiplier
    fy = powf(2.0, (double)(itmp / 12));
8001f5fe:	e0 66 aa ab 	mov	r6,43691
8001f602:	ea 16 2a aa 	orh	r6,0x2aaa
8001f606:	c1 e8       	rjmp	8001f642 <inputs_init+0x352>
    tabHz->data[i] = fix16_from_float(fz);     
    // svf coefficient
    // HACK : assume samplerate == 48000 ...
    fx = (double)((double)fz / (double)48000.0);
    // stability limit:
    if(fx > 0.25) { fx = 0.25; }
8001f608:	e0 6c ff ff 	mov	r12,65535
8001f60c:	ea 1c 7f ff 	orh	r12,0x7fff
    fy = (double)sinf(M_PI * fx) * 2.0;
    // store as fract32
    tabFreq->data[i] = (s32)(fy * (double)(FR32_MAX));
8001f610:	e0 69 33 2c 	mov	r9,13100
8001f614:	72 08       	ld.w	r8,r9[0x0]
8001f616:	f0 07 09 2c 	st.w	r8[r7<<0x2],r12
    /* print_dbg_ulong((s32)fn + 69); */
    /* print_dbg(", hz (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" coeff : 0x"); */
    /* print_dbg_hex(tabFreq->data[i]); */
    f += finc;
8001f61a:	04 9a       	mov	r10,r2
  noteMax_fix = (u32)noteMax << 16;
  noteSpan_fix = noteMax_fix - noteMin_fix;  

  // fill hz / coeff tables 
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
8001f61c:	2f f7       	sub	r7,-1
    /* print_dbg_ulong((s32)fn + 69); */
    /* print_dbg(", hz (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" coeff : 0x"); */
    /* print_dbg_hex(tabFreq->data[i]); */
    f += finc;
8001f61e:	06 9b       	mov	r11,r3
    fx = (double)((double)fz / (double)48000.0);
    // stability limit:
    if(fx > 0.25) { fx = 0.25; }
    fy = (double)sinf(M_PI * fx) * 2.0;
    // store as fract32
    tabFreq->data[i] = (s32)(fy * (double)(FR32_MAX));
8001f620:	12 98       	mov	r8,r9
  noteMax_fix = (u32)noteMax << 16;
  noteSpan_fix = noteMax_fix - noteMin_fix;  

  // fill hz / coeff tables 
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
8001f622:	e0 47 04 00 	cp.w	r7,1024
8001f626:	e0 80 00 b8 	breq	8001f796 <inputs_init+0x4a6>
    /* print_dbg_ulong((s32)fn + 69); */
    /* print_dbg(", hz (fix16) : "); */
    /* print_dbg(strbuf); */
    /* print_dbg(" coeff : 0x"); */
    /* print_dbg_hex(tabFreq->data[i]); */
    f += finc;
8001f62a:	e0 68 10 04 	mov	r8,4100
8001f62e:	ea 18 00 40 	orh	r8,0x40
8001f632:	e0 69 04 01 	mov	r9,1025
8001f636:	ea 19 3f 50 	orh	r9,0x3f50
8001f63a:	e0 a0 16 d9 	rcall	800223ec <__avr32_f64_add>
8001f63e:	14 92       	mov	r2,r10
8001f640:	16 93       	mov	r3,r11

  // fill hz / coeff tables 
  f = 0.0;
  for(i=0; i<TABLE_SIZE; i++) {
    // note numbers (difference)s
    fn = f * ((double)noteMax - (double)noteMin) - 69.0 + noteMin;
8001f642:	30 08       	mov	r8,0
8001f644:	e0 69 40 00 	mov	r9,16384
8001f648:	ea 19 40 58 	orh	r9,0x4058
8001f64c:	04 9a       	mov	r10,r2
8001f64e:	06 9b       	mov	r11,r3
8001f650:	e0 a0 15 14 	rcall	80022078 <__avr32_f64_mul>
8001f654:	30 08       	mov	r8,0
8001f656:	e0 69 40 00 	mov	r9,16384
8001f65a:	ea 19 40 51 	orh	r9,0x4051
8001f65e:	e0 a0 15 f9 	rcall	80022250 <__avr32_f64_sub>
8001f662:	fc 19 40 33 	movh	r9,0x4033
8001f666:	30 08       	mov	r8,0
8001f668:	e0 a0 16 c2 	rcall	800223ec <__avr32_f64_add>
8001f66c:	14 94       	mov	r4,r10
8001f66e:	16 95       	mov	r5,r11
    itmp = (s32)fn;
    // octave multiplier
    fy = powf(2.0, (double)(itmp / 12));
8001f670:	e0 a0 17 44 	rcall	800224f8 <__avr32_f64_to_s32>
8001f674:	f8 08 14 1f 	asr	r8,r12,0x1f
8001f678:	f8 06 04 4a 	muls.d	r10,r12,r6
8001f67c:	f6 0c 14 01 	asr	r12,r11,0x1
8001f680:	10 1c       	sub	r12,r8
8001f682:	e0 a0 17 52 	rcall	80022526 <__avr32_s32_to_f64>
8001f686:	e0 a0 1c 61 	rcall	80022f48 <__avr32_f64_to_f32>
8001f68a:	18 9b       	mov	r11,r12
8001f68c:	fc 1c 40 00 	movh	r12,0x4000
8001f690:	e0 a0 04 d6 	rcall	8002003c <powf>
8001f694:	e0 a0 1c 2a 	rcall	80022ee8 <__avr32_f32_to_f64>
    // center frequency
    fy *= 440.0;
    // tempered ratio
    fz = fy * powf(tempered, fmod(fn, 12.0));
8001f698:	30 08       	mov	r8,0
8001f69a:	fc 19 40 28 	movh	r9,0x4028
  for(i=0; i<TABLE_SIZE; i++) {
    // note numbers (difference)s
    fn = f * ((double)noteMax - (double)noteMin) - 69.0 + noteMin;
    itmp = (s32)fn;
    // octave multiplier
    fy = powf(2.0, (double)(itmp / 12));
8001f69e:	16 91       	mov	r1,r11
8001f6a0:	14 90       	mov	r0,r10
    // center frequency
    fy *= 440.0;
    // tempered ratio
    fz = fy * powf(tempered, fmod(fn, 12.0));
8001f6a2:	0a 9b       	mov	r11,r5
8001f6a4:	08 9a       	mov	r10,r4
8001f6a6:	e0 a0 04 7b 	rcall	8001ff9c <fmod>
8001f6aa:	e0 a0 1c 4f 	rcall	80022f48 <__avr32_f64_to_f32>
8001f6ae:	18 9b       	mov	r11,r12
8001f6b0:	e0 6c 9c 7d 	mov	r12,40061
8001f6b4:	ea 1c 3f 87 	orh	r12,0x3f87
8001f6b8:	e0 a0 04 c2 	rcall	8002003c <powf>
8001f6bc:	30 08       	mov	r8,0
8001f6be:	e0 69 80 00 	mov	r9,32768
8001f6c2:	ea 19 40 7b 	orh	r9,0x407b
8001f6c6:	02 9b       	mov	r11,r1
8001f6c8:	50 0c       	stdsp	sp[0x0],r12
8001f6ca:	00 9a       	mov	r10,r0
8001f6cc:	e0 a0 14 d6 	rcall	80022078 <__avr32_f64_mul>
8001f6d0:	40 0c       	lddsp	r12,sp[0x0]
8001f6d2:	14 94       	mov	r4,r10
8001f6d4:	16 95       	mov	r5,r11
8001f6d6:	e0 a0 1c 09 	rcall	80022ee8 <__avr32_f32_to_f64>
8001f6da:	14 98       	mov	r8,r10
8001f6dc:	16 99       	mov	r9,r11
8001f6de:	08 9a       	mov	r10,r4
8001f6e0:	0a 9b       	mov	r11,r5
8001f6e2:	e0 a0 14 cb 	rcall	80022078 <__avr32_f64_mul>
8001f6e6:	14 94       	mov	r4,r10
8001f6e8:	16 95       	mov	r5,r11
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f6ea:	e0 a0 1c 2f 	rcall	80022f48 <__avr32_f64_to_f32>
8001f6ee:	fc 1b 47 80 	movh	r11,0x4780
8001f6f2:	e0 a0 1b 41 	rcall	80022d74 <__avr32_f32_mul>
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f6f6:	30 0b       	mov	r11,0
#endif
}

static inline fix16_t fix16_from_float(float a)
{
    float temp = a * fix16_one;
8001f6f8:	18 91       	mov	r1,r12
#ifndef FIXMATH_NO_ROUNDING
    temp += (temp >= 0) ? 0.5f : -0.5f;
8001f6fa:	e0 a0 18 0d 	rcall	80022714 <__avr32_f32_cmp_ge>
    // store hz
    tabHz->data[i] = fix16_from_float(fz);     
8001f6fe:	fc 19 bf 00 	movh	r9,0xbf00
8001f702:	fc 1b 3f 00 	movh	r11,0x3f00
8001f706:	58 0c       	cp.w	r12,0
8001f708:	f2 0b 17 00 	moveq	r11,r9
8001f70c:	02 9c       	mov	r12,r1
8001f70e:	e0 a0 1a dd 	rcall	80022cc8 <__avr32_f32_add>
8001f712:	e0 a0 1b dc 	rcall	80022eca <__avr32_f32_to_s32>
8001f716:	e0 69 33 38 	mov	r9,13112
8001f71a:	72 08       	ld.w	r8,r9[0x0]
    // svf coefficient
    // HACK : assume samplerate == 48000 ...
    fx = (double)((double)fz / (double)48000.0);
8001f71c:	08 9a       	mov	r10,r4
    // center frequency
    fy *= 440.0;
    // tempered ratio
    fz = fy * powf(tempered, fmod(fn, 12.0));
    // store hz
    tabHz->data[i] = fix16_from_float(fz);     
8001f71e:	f0 07 09 2c 	st.w	r8[r7<<0x2],r12
    // svf coefficient
    // HACK : assume samplerate == 48000 ...
    fx = (double)((double)fz / (double)48000.0);
8001f722:	0a 9b       	mov	r11,r5
8001f724:	30 08       	mov	r8,0
8001f726:	e0 69 70 00 	mov	r9,28672
8001f72a:	ea 19 40 e7 	orh	r9,0x40e7
8001f72e:	e0 a0 18 27 	rcall	8002277c <__avr32_f64_div>
8001f732:	16 95       	mov	r5,r11
    // stability limit:
    if(fx > 0.25) { fx = 0.25; }
8001f734:	14 98       	mov	r8,r10
    fz = fy * powf(tempered, fmod(fn, 12.0));
    // store hz
    tabHz->data[i] = fix16_from_float(fz);     
    // svf coefficient
    // HACK : assume samplerate == 48000 ...
    fx = (double)((double)fz / (double)48000.0);
8001f736:	14 94       	mov	r4,r10
    // stability limit:
    if(fx > 0.25) { fx = 0.25; }
8001f738:	0a 99       	mov	r9,r5
8001f73a:	30 0a       	mov	r10,0
8001f73c:	fc 1b 3f d0 	movh	r11,0x3fd0
8001f740:	e0 a0 17 aa 	rcall	80022694 <__avr32_f64_cmp_lt>
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f744:	08 9a       	mov	r10,r4
8001f746:	0a 9b       	mov	r11,r5
8001f748:	e0 68 2d 18 	mov	r8,11544
8001f74c:	ea 18 54 44 	orh	r8,0x5444
8001f750:	e0 69 21 fb 	mov	r9,8699
8001f754:	ea 19 40 09 	orh	r9,0x4009
    tabHz->data[i] = fix16_from_float(fz);     
    // svf coefficient
    // HACK : assume samplerate == 48000 ...
    fx = (double)((double)fz / (double)48000.0);
    // stability limit:
    if(fx > 0.25) { fx = 0.25; }
8001f758:	58 0c       	cp.w	r12,0
8001f75a:	fe 91 ff 57 	brne	8001f608 <inputs_init+0x318>
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f75e:	e0 a0 14 8d 	rcall	80022078 <__avr32_f64_mul>
8001f762:	e0 a0 1b f3 	rcall	80022f48 <__avr32_f64_to_f32>
8001f766:	e0 a0 03 df 	rcall	8001ff24 <sinf>
8001f76a:	e0 a0 1b bf 	rcall	80022ee8 <__avr32_f32_to_f64>
8001f76e:	14 98       	mov	r8,r10
8001f770:	16 99       	mov	r9,r11
8001f772:	e0 a0 16 3d 	rcall	800223ec <__avr32_f64_add>
8001f776:	fc 18 ff c0 	movh	r8,0xffc0
8001f77a:	e0 69 ff ff 	mov	r9,65535
8001f77e:	ea 19 41 df 	orh	r9,0x41df
8001f782:	e0 a0 14 7b 	rcall	80022078 <__avr32_f64_mul>
8001f786:	e0 a0 16 b9 	rcall	800224f8 <__avr32_f64_to_s32>
8001f78a:	c4 3b       	rjmp	8001f610 <inputs_init+0x320>
      // convert to amplitude
      fx = powf(10.0, fy * 0.05);
      // amp in fract32
      tabAmp->data[i] = (s32)((double)(FR32_MAX) * fx);
      // check underflow
      if(tabAmp->data[i] < 0) { tabAmp->data[i] = 0; }
8001f78c:	30 09       	mov	r9,0
8001f78e:	f0 06 09 29 	st.w	r8[r6<<0x2],r9
8001f792:	fe 9f fe 82 	bral	8001f496 <inputs_init+0x1a6>
    /* print_dbg(" coeff : 0x"); */
    /* print_dbg_hex(tabFreq->data[i]); */
    f += finc;
  }   
  /// hack the endpoints of freq table
  tabFreq->data[0] = tabFreq->data[1] + (tabFreq->data[1] - tabFreq->data[2]);
8001f796:	72 09       	ld.w	r9,r9[0x0]
8001f798:	72 1b       	ld.w	r11,r9[0x4]
8001f79a:	72 2a       	ld.w	r10,r9[0x8]
8001f79c:	a1 7b       	lsl	r11,0x1
8001f79e:	f6 0a 01 0a 	sub	r10,r11,r10
8001f7a2:	93 0a       	st.w	r9[0x0],r10
  tabFreq->data[TABLE_SIZE - 1] = tabFreq->data[TABLE_SIZE - 2]
    + (tabFreq->data[TABLE_SIZE - 2] - tabFreq->data[TABLE_SIZE - 3]);
8001f7a4:	70 08       	ld.w	r8,r8[0x0]
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f7a6:	30 06       	mov	r6,0
    f += finc;
  }   
  /// hack the endpoints of freq table
  tabFreq->data[0] = tabFreq->data[1] + (tabFreq->data[1] - tabFreq->data[2]);
  tabFreq->data[TABLE_SIZE - 1] = tabFreq->data[TABLE_SIZE - 2]
    + (tabFreq->data[TABLE_SIZE - 2] - tabFreq->data[TABLE_SIZE - 3]);
8001f7a8:	f0 fa 0f f8 	ld.w	r10,r8[4088]
    /* print_dbg_hex(tabFreq->data[i]); */
    f += finc;
  }   
  /// hack the endpoints of freq table
  tabFreq->data[0] = tabFreq->data[1] + (tabFreq->data[1] - tabFreq->data[2]);
  tabFreq->data[TABLE_SIZE - 1] = tabFreq->data[TABLE_SIZE - 2]
8001f7ac:	f0 f9 0f f4 	ld.w	r9,r8[4084]
8001f7b0:	a1 7a       	lsl	r10,0x1
8001f7b2:	f4 09 01 09 	sub	r9,r10,r9
8001f7b6:	f1 49 0f fc 	st.w	r8[4092],r9
    + (tabFreq->data[TABLE_SIZE - 2] - tabFreq->data[TABLE_SIZE - 3]);
  /// calculate deltas 
  table_calc_deltas(tabHz);
8001f7ba:	e0 68 33 38 	mov	r8,13112
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f7be:	70 03       	ld.w	r3,r8[0x0]
8001f7c0:	06 97       	mov	r7,r3
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f7c2:	0f 05       	ld.w	r5,r7++
    tab->delta[i] = (s32)f;
8001f7c4:	6e 04       	ld.w	r4,r7[0x0]
8001f7c6:	e8 05 01 0c 	sub	r12,r4,r5
8001f7ca:	e0 a0 16 ae 	rcall	80022526 <__avr32_s32_to_f64>
8001f7ce:	30 08       	mov	r8,0
8001f7d0:	e0 69 80 00 	mov	r9,32768
8001f7d4:	ea 19 40 4f 	orh	r9,0x404f
8001f7d8:	e0 a0 17 d2 	rcall	8002277c <__avr32_f64_div>
8001f7dc:	e0 a0 16 8e 	rcall	800224f8 <__avr32_f64_to_s32>
8001f7e0:	6e 15       	ld.w	r5,r7[0x4]
8001f7e2:	ef 4c 0f fc 	st.w	r7[4092],r12
8001f7e6:	ea 04 01 0c 	sub	r12,r5,r4
8001f7ea:	e0 a0 16 9e 	rcall	80022526 <__avr32_s32_to_f64>
8001f7ee:	30 08       	mov	r8,0
8001f7f0:	e0 69 80 00 	mov	r9,32768
8001f7f4:	ea 19 40 4f 	orh	r9,0x404f
8001f7f8:	e0 a0 17 c2 	rcall	8002277c <__avr32_f64_div>
8001f7fc:	e0 a0 16 7e 	rcall	800224f8 <__avr32_f64_to_s32>
8001f800:	ef 4c 10 00 	st.w	r7[4096],r12
8001f804:	2f e6       	sub	r6,-2
8001f806:	2f 87       	sub	r7,-8
8001f808:	e0 46 03 fe 	cp.w	r6,1022
8001f80c:	cd c1       	brne	8001f7c4 <inputs_init+0x4d4>
8001f80e:	e6 f8 0f f8 	ld.w	r8,r3[4088]
8001f812:	e6 fc 0f fc 	ld.w	r12,r3[4092]
8001f816:	10 1c       	sub	r12,r8
8001f818:	e0 a0 16 87 	rcall	80022526 <__avr32_s32_to_f64>
8001f81c:	e0 69 80 00 	mov	r9,32768
8001f820:	ea 19 40 4f 	orh	r9,0x404f
8001f824:	30 08       	mov	r8,0
8001f826:	e0 a0 17 ab 	rcall	8002277c <__avr32_f64_div>
8001f82a:	e0 a0 16 67 	rcall	800224f8 <__avr32_f64_to_s32>
    /* print_dbg(" = 0x"); */
    /* print_dbg_hex((u32)sdif); */
    /* print_dbg(" ; delta: 0x"); */
    /* print_dbg_hex( tab->delta[i] ); */
  }
  tab->delta[TABLE_MAX] = tab->delta[TABLE_MAX - 1];
8001f82e:	e0 69 33 2c 	mov	r9,13100
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
    tab->delta[i] = (s32)f;
8001f832:	e7 4c 1f fc 	st.w	r3[8188],r12
// initialize tables

// FIXME: abstract some of this table stuff
//  and put it somewhere else
// maybe in aleph/audio
extern void inputs_init(void) {
8001f836:	e7 4c 1f f8 	st.w	r3[8184],r12
8001f83a:	30 06       	mov	r6,0
8001f83c:	72 03       	ld.w	r3,r9[0x0]
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f83e:	06 97       	mov	r7,r3
    tab->delta[i] = (s32)f;
8001f840:	0f 05       	ld.w	r5,r7++
8001f842:	6e 04       	ld.w	r4,r7[0x0]
8001f844:	e8 05 01 0c 	sub	r12,r4,r5
8001f848:	e0 a0 16 6f 	rcall	80022526 <__avr32_s32_to_f64>
8001f84c:	30 08       	mov	r8,0
8001f84e:	e0 69 80 00 	mov	r9,32768
8001f852:	ea 19 40 4f 	orh	r9,0x404f
8001f856:	e0 a0 17 93 	rcall	8002277c <__avr32_f64_div>
  double f;
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
8001f85a:	e0 a0 16 4f 	rcall	800224f8 <__avr32_f64_to_s32>
    tab->delta[i] = (s32)f;
8001f85e:	6e 15       	ld.w	r5,r7[0x4]
8001f860:	ef 4c 0f fc 	st.w	r7[4092],r12
8001f864:	ea 04 01 0c 	sub	r12,r5,r4
8001f868:	e0 a0 16 5f 	rcall	80022526 <__avr32_s32_to_f64>
8001f86c:	30 08       	mov	r8,0
8001f86e:	e0 69 80 00 	mov	r9,32768
8001f872:	ea 19 40 4f 	orh	r9,0x404f
8001f876:	e0 a0 17 83 	rcall	8002277c <__avr32_f64_div>
8001f87a:	e0 a0 16 3f 	rcall	800224f8 <__avr32_f64_to_s32>
8001f87e:	ef 4c 10 00 	st.w	r7[4096],r12
8001f882:	2f e6       	sub	r6,-2
8001f884:	2f 87       	sub	r7,-8
8001f886:	e0 46 03 fe 	cp.w	r6,1022
8001f88a:	cd c1       	brne	8001f842 <inputs_init+0x552>
8001f88c:	e6 f8 0f f8 	ld.w	r8,r3[4088]
8001f890:	e6 fc 0f fc 	ld.w	r12,r3[4092]
8001f894:	10 1c       	sub	r12,r8
8001f896:	e0 a0 16 48 	rcall	80022526 <__avr32_s32_to_f64>
8001f89a:	30 08       	mov	r8,0
8001f89c:	e0 69 80 00 	mov	r9,32768
8001f8a0:	ea 19 40 4f 	orh	r9,0x404f
8001f8a4:	e0 a0 17 6c 	rcall	8002277c <__avr32_f64_div>
    /* print_dbg(" = 0x"); */
    /* print_dbg_hex((u32)sdif); */
    /* print_dbg(" ; delta: 0x"); */
    /* print_dbg_hex( tab->delta[i] ); */
  }
  tab->delta[TABLE_MAX] = tab->delta[TABLE_MAX - 1];
8001f8a8:	e0 a0 16 28 	rcall	800224f8 <__avr32_f64_to_s32>
  //  print_dbg("\r\n calc_deltas : 0x");
  //  print_dbg_hex((u32)tab);
  for(i=0; i < (TABLE_MAX); i++) {
    sdif = tab->data[i+1] - tab->data[i];
    f = (double)(tab->data[i+1] - tab->data[i]) / (double)TABLE_MASK;
    tab->delta[i] = (s32)f;
8001f8ac:	e7 4c 1f fc 	st.w	r3[8188],r12
  /// calculate deltas 
  table_calc_deltas(tabHz);
  table_calc_deltas(tabFreq);
  
  // test
  print_dbg("\r\n testing hz lookup: ");
8001f8b0:	e7 4c 1f f8 	st.w	r3[8184],r12
8001f8b4:	fe cc 9f f0 	sub	r12,pc,-24592
  u32 eq;
  u32 dec; // count of decreasing 
  s32 last = 0x80000000;
  char strbuf[11] = "           ";
  strbuf[10] = 0;
  print_dbg("\r\n testing table lookup... ");
8001f8b8:	fe b0 9b 72 	rcall	80012f9c <print_dbg>
8001f8bc:	e0 68 33 38 	mov	r8,13112
8001f8c0:	fe cc 9f e4 	sub	r12,pc,-24604
8001f8c4:	70 07       	ld.w	r7,r8[0x0]
8001f8c6:	fe b0 9b 6b 	rcall	80012f9c <print_dbg>
8001f8ca:	30 06       	mov	r6,0
8001f8cc:	ee fc 10 00 	ld.w	r12,r7[4096]
8001f8d0:	0c 95       	mov	r5,r6
8001f8d2:	0c 94       	mov	r4,r6
  for(i=0; i<=IN_MAX; i++) {
    v = table_look(tab, i);
    if (v == last) {
      eq++;
    } else if( v > last) {
      inc++;
8001f8d4:	fc 1b 80 00 	movh	r11,0x8000
8001f8d8:	0c 98       	mov	r8,r6
      last = v;
    } else {
      dec++;
8001f8da:	0c 9a       	mov	r10,r6
8001f8dc:	c1 18       	rjmp	8001f8fe <inputs_init+0x60e>
  u32 dec; // count of decreasing 
  s32 last = 0x80000000;
  char strbuf[11] = "           ";
  strbuf[10] = 0;
  print_dbg("\r\n testing table lookup... ");
  for(i=0; i<=IN_MAX; i++) {
8001f8de:	16 39       	cp.w	r9,r11
8001f8e0:	f7 b5 09 ff 	subgt	r5,-1
8001f8e4:	f7 b6 0a ff 	suble	r6,-1
8001f8e8:	2f f8       	sub	r8,-1
8001f8ea:	e0 58 00 00 	cp.w	r8,65536
8001f8ee:	c1 50       	breq	8001f918 <inputs_init+0x628>
8001f8f0:	12 9b       	mov	r11,r9
8001f8f2:	f0 0a 16 06 	lsr	r10,r8,0x6

// lookup 
static s32 table_look(table* tab, u32 in) {
  u32 idx = in >> TABLE_RSHIFT;
  s32 mul = in & TABLE_MASK;
  s32 val = tab->data[idx] + (mul * tab->delta[idx]);
8001f8f6:	f4 c9 fc 00 	sub	r9,r10,-1024
8001f8fa:	ee 09 03 2c 	ld.w	r12,r7[r9<<0x2]
8001f8fe:	ee 0a 03 2a 	ld.w	r10,r7[r10<<0x2]
  char strbuf[11] = "           ";
  strbuf[10] = 0;
  print_dbg("\r\n testing table lookup... ");
  for(i=0; i<=IN_MAX; i++) {
    v = table_look(tab, i);
    if (v == last) {
8001f902:	f3 d8 c0 06 	bfextu	r9,r8,0x0,0x6
  u32 dec; // count of decreasing 
  s32 last = 0x80000000;
  char strbuf[11] = "           ";
  strbuf[10] = 0;
  print_dbg("\r\n testing table lookup... ");
  for(i=0; i<=IN_MAX; i++) {
8001f906:	b9 39       	mul	r9,r12
8001f908:	14 09       	add	r9,r10
8001f90a:	16 39       	cp.w	r9,r11
8001f90c:	ce 91       	brne	8001f8de <inputs_init+0x5ee>
    /* print_dbg_hex(i); */
    /* print_dbg(" ) : "); */
    /* print_fix16(strbuf, (fix16)v); */
    /* print_dbg(strbuf); */
  }
  print_dbg("\r\n tested ");
8001f90e:	2f f4       	sub	r4,-1
8001f910:	2f f8       	sub	r8,-1
8001f912:	e0 58 00 00 	cp.w	r8,65536
  print_dbg_ulong(i - 1);
8001f916:	ce d1       	brne	8001f8f0 <inputs_init+0x600>
8001f918:	fe cc a0 20 	sub	r12,pc,-24544
  print_dbg(" lookups. inc: ");
8001f91c:	fe b0 9b 40 	rcall	80012f9c <print_dbg>
8001f920:	e0 6c ff ff 	mov	r12,65535
  print_dbg_ulong(inc);
8001f924:	fe b0 9b 42 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg(" , dec: ");
8001f928:	fe cc a0 24 	sub	r12,pc,-24540
8001f92c:	fe b0 9b 38 	rcall	80012f9c <print_dbg>
  print_dbg_ulong(dec);  
8001f930:	0a 9c       	mov	r12,r5
8001f932:	fe b0 9b 3b 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg(" , eq: ");
8001f936:	fe cc a0 22 	sub	r12,pc,-24542
  print_dbg_ulong(eq);
8001f93a:	fe b0 9b 31 	rcall	80012f9c <print_dbg>
8001f93e:	0c 9c       	mov	r12,r6
  fill_amp_db_tables();
  fill_hz_freq_tables();

  // fill pan tables
  // ... TODO
}
8001f940:	fe b0 9b 34 	rcall	80012fa8 <print_dbg_ulong>
8001f944:	fe cc a0 24 	sub	r12,pc,-24540
8001f948:	fe b0 9b 2a 	rcall	80012f9c <print_dbg>
8001f94c:	08 9c       	mov	r12,r4
8001f94e:	fe b0 9b 2d 	rcall	80012fa8 <print_dbg_ulong>
8001f952:	2f dd       	sub	sp,-12
8001f954:	d8 32       	popm	r0-r7,pc
8001f956:	d7 03       	nop

8001f958 <render_sw_on>:
}


void render_sw_on(u8 sw, u8 on) {
  // highlight the footer
}
8001f958:	5e fc       	retal	r12
8001f95a:	d7 03       	nop

8001f95c <render_update>:
  region_string(&(foot[2]), "REC", 0, 0, 0xf, 0x0, 0);
  region_string(&(foot[3]), "PLAY", 0, 0, 0xf, 0x0, 0);
}

// update dirty regions
void render_update(void) {
8001f95c:	eb cd 40 e0 	pushm	r5-r7,lr
  region* r;  
  u8 i;
  app_pause();
8001f960:	fe b0 b7 42 	rcall	800167e4 <app_pause>

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f964:	30 06       	mov	r6,0
// array of pointers to all regoins.
// NOTE: regions can overlap,
// but the ordering of this list also determines drawing order.
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
8001f966:	32 c7       	mov	r7,44
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f968:	ef 38 00 0a 	ld.ub	r8,r7[10]
8001f96c:	ec 08 18 00 	cp.b	r8,r6
8001f970:	c2 a1       	brne	8001f9c4 <render_update+0x68>
// NOTE: regions can overlap,
// but the ordering of this list also determines drawing order.
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
  &bigtop,
8001f972:	33 c7       	mov	r7,60
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f974:	30 06       	mov	r6,0
8001f976:	ef 38 00 0a 	ld.ub	r8,r7[10]
8001f97a:	ec 08 18 00 	cp.b	r8,r6
8001f97e:	c6 21       	brne	8001fa42 <render_update+0xe6>
// but the ordering of this list also determines drawing order.
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
  &bigtop,
  &(foot[0]),
8001f980:	34 c7       	mov	r7,76
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f982:	30 06       	mov	r6,0
8001f984:	ef 38 00 0a 	ld.ub	r8,r7[10]
8001f988:	ec 08 18 00 	cp.b	r8,r6
8001f98c:	c4 f1       	brne	8001fa2a <render_update+0xce>
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
  &bigtop,
  &(foot[0]),
  &(foot[1]),
8001f98e:	ee c6 ff f0 	sub	r6,r7,-16
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f992:	30 05       	mov	r5,0
8001f994:	ed 38 00 0a 	ld.ub	r8,r6[10]
8001f998:	ea 08 18 00 	cp.b	r8,r5
8001f99c:	c3 b1       	brne	8001fa12 <render_update+0xb6>
static region * allRegions[] = {
  &status,
  &bigtop,
  &(foot[0]),
  &(foot[1]),
  &(foot[2]),
8001f99e:	ee c6 ff e0 	sub	r6,r7,-32
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f9a2:	30 05       	mov	r5,0
8001f9a4:	ed 38 00 0a 	ld.ub	r8,r6[10]
8001f9a8:	ea 08 18 00 	cp.b	r8,r5
8001f9ac:	c2 71       	brne	8001f9fa <render_update+0x9e>
  &status,
  &bigtop,
  &(foot[0]),
  &(foot[1]),
  &(foot[2]),
  &(foot[3]),
8001f9ae:	2d 07       	sub	r7,-48
  u8 i;
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
8001f9b0:	30 06       	mov	r6,0
8001f9b2:	ef 38 00 0a 	ld.ub	r8,r7[10]
8001f9b6:	ec 08 18 00 	cp.b	r8,r6
8001f9ba:	c1 11       	brne	8001f9dc <render_update+0x80>
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
      r->dirty = 0;
    }
  }
  app_resume();
8001f9bc:	fe b0 b7 10 	rcall	800167dc <app_resume>
}
8001f9c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001f9c4:	6e 38       	ld.w	r8,r7[0xc]
8001f9c6:	0f 99       	ld.ub	r9,r7[0x1]
8001f9c8:	0f 8a       	ld.ub	r10,r7[0x0]
8001f9ca:	ef 3b 00 09 	ld.ub	r11,r7[9]
8001f9ce:	ef 3c 00 08 	ld.ub	r12,r7[8]
8001f9d2:	fe b0 ce 25 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001f9d6:	ef 66 00 0a 	st.b	r7[10],r6
8001f9da:	cc cb       	rjmp	8001f972 <render_update+0x16>
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001f9dc:	6e 38       	ld.w	r8,r7[0xc]
8001f9de:	0f 99       	ld.ub	r9,r7[0x1]
8001f9e0:	0f 8a       	ld.ub	r10,r7[0x0]
8001f9e2:	ef 3b 00 09 	ld.ub	r11,r7[9]
8001f9e6:	ef 3c 00 08 	ld.ub	r12,r7[8]
8001f9ea:	fe b0 ce 19 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001f9ee:	ef 66 00 0a 	st.b	r7[10],r6
    }
  }
  app_resume();
8001f9f2:	fe b0 b6 f5 	rcall	800167dc <app_resume>
}
8001f9f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001f9fa:	6c 38       	ld.w	r8,r6[0xc]
8001f9fc:	0d 99       	ld.ub	r9,r6[0x1]
8001f9fe:	0d 8a       	ld.ub	r10,r6[0x0]
8001fa00:	ed 3b 00 09 	ld.ub	r11,r6[9]
8001fa04:	ed 3c 00 08 	ld.ub	r12,r6[8]
8001fa08:	fe b0 ce 0a 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001fa0c:	ed 65 00 0a 	st.b	r6[10],r5
8001fa10:	cc fb       	rjmp	8001f9ae <render_update+0x52>
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001fa12:	6c 38       	ld.w	r8,r6[0xc]
8001fa14:	0d 99       	ld.ub	r9,r6[0x1]
8001fa16:	0d 8a       	ld.ub	r10,r6[0x0]
8001fa18:	ed 3b 00 09 	ld.ub	r11,r6[9]
8001fa1c:	ed 3c 00 08 	ld.ub	r12,r6[8]
8001fa20:	fe b0 cd fe 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001fa24:	ed 65 00 0a 	st.b	r6[10],r5
8001fa28:	cb bb       	rjmp	8001f99e <render_update+0x42>
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001fa2a:	6e 38       	ld.w	r8,r7[0xc]
8001fa2c:	0f 99       	ld.ub	r9,r7[0x1]
8001fa2e:	0f 8a       	ld.ub	r10,r7[0x0]
8001fa30:	ef 3b 00 09 	ld.ub	r11,r7[9]
8001fa34:	ef 3c 00 08 	ld.ub	r12,r7[8]
8001fa38:	fe b0 cd f2 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001fa3c:	ef 66 00 0a 	st.b	r7[10],r6
8001fa40:	ca 7b       	rjmp	8001f98e <render_update+0x32>
  app_pause();

  for(i = 0; i<numRegions; i++) {
    r = allRegions[i]; 
    if(r->dirty) {
      screen_draw_region(r->x, r->y, r->w, r->h, r->data);
8001fa42:	6e 38       	ld.w	r8,r7[0xc]
8001fa44:	0f 99       	ld.ub	r9,r7[0x1]
8001fa46:	0f 8a       	ld.ub	r10,r7[0x0]
8001fa48:	ef 3b 00 09 	ld.ub	r11,r7[9]
8001fa4c:	ef 3c 00 08 	ld.ub	r12,r7[8]
8001fa50:	fe b0 cd e6 	rcall	8001961c <screen_draw_region>
      r->dirty = 0;
8001fa54:	ef 66 00 0a 	st.b	r7[10],r6
8001fa58:	c9 4b       	rjmp	8001f980 <render_update+0x24>
8001fa5a:	d7 03       	nop

8001fa5c <render_init>:
8001fa5c:	d4 21       	pushm	r4-r7,lr
8001fa5e:	fe c5 a1 36 	sub	r5,pc,-24266
8001fa62:	30 06       	mov	r6,0
8001fa64:	ea c4 ff e8 	sub	r4,r5,-24
8001fa68:	6a 07       	ld.w	r7,r5[0x0]
8001fa6a:	0f 88       	ld.ub	r8,r7[0x0]
8001fa6c:	0f 9c       	ld.ub	r12,r7[0x1]
8001fa6e:	b1 3c       	mul	r12,r8
8001fa70:	8f 1c       	st.w	r7[0x4],r12
8001fa72:	fe b0 c4 b9 	rcall	800183e4 <alloc_mem>

// allocate buffer
static void region_alloc(region* reg) {
  u32 i;
  reg->len = reg->w * reg->h;
  reg->data = (u8*)alloc_mem(reg->len);
8001fa76:	8f 3c       	st.w	r7[0xc],r12
  for(i=0; i<reg->len; i++) {
8001fa78:	6e 18       	ld.w	r8,r7[0x4]
8001fa7a:	58 08       	cp.w	r8,0
8001fa7c:	c0 a0       	breq	8001fa90 <render_init+0x34>
8001fa7e:	30 08       	mov	r8,0
8001fa80:	c0 28       	rjmp	8001fa84 <render_init+0x28>
8001fa82:	6e 3c       	ld.w	r12,r7[0xc]
    reg->data[i] = 0; 
8001fa84:	f8 08 0b 06 	st.b	r12[r8],r6
// allocate buffer
static void region_alloc(region* reg) {
  u32 i;
  reg->len = reg->w * reg->h;
  reg->data = (u8*)alloc_mem(reg->len);
  for(i=0; i<reg->len; i++) {
8001fa88:	2f f8       	sub	r8,-1
8001fa8a:	6e 19       	ld.w	r9,r7[0x4]
8001fa8c:	12 38       	cp.w	r8,r9
8001fa8e:	cf a3       	brcs	8001fa82 <render_init+0x26>
    reg->data[i] = 0; 
  }
  reg->dirty = 0;
8001fa90:	ef 66 00 0a 	st.b	r7[10],r6
8001fa94:	2f c5       	sub	r5,-4

// initialze renderer
void render_init(void) {
  u32 i;

  for(i = 0; i<numRegions; i++) {
8001fa96:	08 35       	cp.w	r5,r4
8001fa98:	ce 81       	brne	8001fa68 <render_init+0xc>
  }

  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
8001fa9a:	fe cc a1 5a 	sub	r12,pc,-24230
8001fa9e:	fe b0 9a 7f 	rcall	80012f9c <print_dbg>
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001faa2:	fe cc a1 52 	sub	r12,pc,-24238
    print_dbg_hex(i);
8001faa6:	fe b0 9a 7b 	rcall	80012f9c <print_dbg>
8001faaa:	30 0c       	mov	r12,0
    print_dbg(" ) @ 0x");
8001faac:	fe b0 9a a0 	rcall	80012fec <print_dbg_hex>
8001fab0:	fe cc a1 58 	sub	r12,pc,-24232
    print_dbg_hex((u32)(allRegions[i]));
8001fab4:	fe b0 9a 74 	rcall	80012f9c <print_dbg>
8001fab8:	32 c7       	mov	r7,44
    print_dbg(", data: @ 0x");
8001faba:	0e 9c       	mov	r12,r7
8001fabc:	fe b0 9a 98 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex((u32)(allRegions[i]->data));
8001fac0:	fe cc a1 60 	sub	r12,pc,-24224
8001fac4:	fe b0 9a 6c 	rcall	80012f9c <print_dbg>
    print_dbg(", w:");
8001fac8:	6e 3c       	ld.w	r12,r7[0xc]
8001faca:	fe b0 9a 91 	rcall	80012fec <print_dbg_hex>
    print_dbg_ulong((u32)(allRegions[i]->w));
8001face:	fe cc a1 5e 	sub	r12,pc,-24226
    print_dbg(", h:");
8001fad2:	fe b0 9a 65 	rcall	80012f9c <print_dbg>
8001fad6:	0f 8c       	ld.ub	r12,r7[0x0]
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fad8:	fe b0 9a 68 	rcall	80012fa8 <print_dbg_ulong>
8001fadc:	fe cc a1 64 	sub	r12,pc,-24220
    print_dbg(", len: 0x");
8001fae0:	fe b0 9a 5e 	rcall	80012f9c <print_dbg>
    print_dbg_hex((u32)(allRegions[i]->len));
8001fae4:	0f 9c       	ld.ub	r12,r7[0x1]
8001fae6:	fe b0 9a 61 	rcall	80012fa8 <print_dbg_ulong>
  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001faea:	fe cc a1 6a 	sub	r12,pc,-24214
8001faee:	fe b0 9a 57 	rcall	80012f9c <print_dbg>
    print_dbg_hex(i);
8001faf2:	6e 1c       	ld.w	r12,r7[0x4]
8001faf4:	fe b0 9a 7c 	rcall	80012fec <print_dbg_hex>
    print_dbg(" ) @ 0x");
8001faf8:	fe cc a1 a8 	sub	r12,pc,-24152
// NOTE: regions can overlap,
// but the ordering of this list also determines drawing order.
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
  &bigtop,
8001fafc:	fe b0 9a 50 	rcall	80012f9c <print_dbg>
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
    print_dbg_hex(i);
    print_dbg(" ) @ 0x");
    print_dbg_hex((u32)(allRegions[i]));
8001fb00:	30 1c       	mov	r12,1
8001fb02:	fe b0 9a 75 	rcall	80012fec <print_dbg_hex>
    print_dbg(", data: @ 0x");
8001fb06:	fe cc a1 ae 	sub	r12,pc,-24146
    print_dbg_hex((u32)(allRegions[i]->data));
8001fb0a:	fe b0 9a 49 	rcall	80012f9c <print_dbg>
8001fb0e:	33 c7       	mov	r7,60
    print_dbg(", w:");
8001fb10:	0e 9c       	mov	r12,r7
8001fb12:	fe b0 9a 6d 	rcall	80012fec <print_dbg_hex>
    print_dbg_ulong((u32)(allRegions[i]->w));
8001fb16:	fe cc a1 b6 	sub	r12,pc,-24138
8001fb1a:	fe b0 9a 41 	rcall	80012f9c <print_dbg>
    print_dbg(", h:");
8001fb1e:	6e 3c       	ld.w	r12,r7[0xc]
8001fb20:	fe b0 9a 66 	rcall	80012fec <print_dbg_hex>
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fb24:	fe cc a1 b4 	sub	r12,pc,-24140
    print_dbg(", len: 0x");
8001fb28:	fe b0 9a 3a 	rcall	80012f9c <print_dbg>
8001fb2c:	0f 8c       	ld.ub	r12,r7[0x0]
    print_dbg_hex((u32)(allRegions[i]->len));
8001fb2e:	fe b0 9a 3d 	rcall	80012fa8 <print_dbg_ulong>
8001fb32:	fe cc a1 ba 	sub	r12,pc,-24134
  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001fb36:	fe b0 9a 33 	rcall	80012f9c <print_dbg>
    print_dbg_hex(i);
8001fb3a:	0f 9c       	ld.ub	r12,r7[0x1]
8001fb3c:	fe b0 9a 36 	rcall	80012fa8 <print_dbg_ulong>
    print_dbg(" ) @ 0x");
8001fb40:	fe cc a1 c0 	sub	r12,pc,-24128
8001fb44:	fe b0 9a 2c 	rcall	80012f9c <print_dbg>
    print_dbg_hex((u32)(allRegions[i]));
8001fb48:	6e 1c       	ld.w	r12,r7[0x4]
8001fb4a:	fe b0 9a 51 	rcall	80012fec <print_dbg_hex>
    print_dbg(", data: @ 0x");
8001fb4e:	fe cc a1 fe 	sub	r12,pc,-24066
8001fb52:	fe b0 9a 25 	rcall	80012f9c <print_dbg>
    print_dbg_hex((u32)(allRegions[i]->data));
8001fb56:	30 2c       	mov	r12,2
8001fb58:	fe b0 9a 4a 	rcall	80012fec <print_dbg_hex>
    print_dbg(", w:");
8001fb5c:	fe cc a2 04 	sub	r12,pc,-24060
    print_dbg_ulong((u32)(allRegions[i]->w));
8001fb60:	fe b0 9a 1e 	rcall	80012f9c <print_dbg>
8001fb64:	34 c7       	mov	r7,76
    print_dbg(", h:");
8001fb66:	0e 9c       	mov	r12,r7
8001fb68:	fe b0 9a 42 	rcall	80012fec <print_dbg_hex>
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fb6c:	fe cc a2 0c 	sub	r12,pc,-24052
8001fb70:	fe b0 9a 16 	rcall	80012f9c <print_dbg>
    print_dbg(", len: 0x");
8001fb74:	6e 3c       	ld.w	r12,r7[0xc]
8001fb76:	fe b0 9a 3b 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex((u32)(allRegions[i]->len));
8001fb7a:	fe cc a2 0a 	sub	r12,pc,-24054
  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001fb7e:	fe b0 9a 0f 	rcall	80012f9c <print_dbg>
8001fb82:	0f 8c       	ld.ub	r12,r7[0x0]
    print_dbg_hex(i);
8001fb84:	fe b0 9a 12 	rcall	80012fa8 <print_dbg_ulong>
8001fb88:	fe cc a2 10 	sub	r12,pc,-24048
    print_dbg(" ) @ 0x");
8001fb8c:	fe b0 9a 08 	rcall	80012f9c <print_dbg>
// later entries will overwrite earlier entries in the esame redraw cycle.
static region * allRegions[] = {
  &status,
  &bigtop,
  &(foot[0]),
  &(foot[1]),
8001fb90:	0f 9c       	ld.ub	r12,r7[0x1]
8001fb92:	fe b0 9a 0b 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
    print_dbg_hex(i);
    print_dbg(" ) @ 0x");
    print_dbg_hex((u32)(allRegions[i]));
8001fb96:	fe cc a2 16 	sub	r12,pc,-24042
    print_dbg(", data: @ 0x");
8001fb9a:	fe b0 9a 01 	rcall	80012f9c <print_dbg>
8001fb9e:	6e 1c       	ld.w	r12,r7[0x4]
    print_dbg_hex((u32)(allRegions[i]->data));
8001fba0:	fe b0 9a 26 	rcall	80012fec <print_dbg_hex>
8001fba4:	fe cc a2 54 	sub	r12,pc,-23980
    print_dbg(", w:");
8001fba8:	fe b0 99 fa 	rcall	80012f9c <print_dbg>
    print_dbg_ulong((u32)(allRegions[i]->w));
8001fbac:	30 3c       	mov	r12,3
8001fbae:	fe b0 9a 1f 	rcall	80012fec <print_dbg_hex>
    print_dbg(", h:");
8001fbb2:	fe cc a2 5a 	sub	r12,pc,-23974
8001fbb6:	fe b0 99 f3 	rcall	80012f9c <print_dbg>
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fbba:	ee c6 ff f0 	sub	r6,r7,-16
    print_dbg(", len: 0x");
8001fbbe:	0c 9c       	mov	r12,r6
8001fbc0:	fe b0 9a 16 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex((u32)(allRegions[i]->len));
8001fbc4:	fe cc a2 64 	sub	r12,pc,-23964
8001fbc8:	fe b0 99 ea 	rcall	80012f9c <print_dbg>
  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001fbcc:	6c 3c       	ld.w	r12,r6[0xc]
8001fbce:	fe b0 9a 0f 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex(i);
8001fbd2:	fe cc a2 62 	sub	r12,pc,-23966
    print_dbg(" ) @ 0x");
8001fbd6:	fe b0 99 e3 	rcall	80012f9c <print_dbg>
8001fbda:	0d 8c       	ld.ub	r12,r6[0x0]
static region * allRegions[] = {
  &status,
  &bigtop,
  &(foot[0]),
  &(foot[1]),
  &(foot[2]),
8001fbdc:	fe b0 99 e6 	rcall	80012fa8 <print_dbg_ulong>
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
    print_dbg_hex(i);
    print_dbg(" ) @ 0x");
    print_dbg_hex((u32)(allRegions[i]));
8001fbe0:	fe cc a2 68 	sub	r12,pc,-23960
8001fbe4:	fe b0 99 dc 	rcall	80012f9c <print_dbg>
    print_dbg(", data: @ 0x");
8001fbe8:	0d 9c       	ld.ub	r12,r6[0x1]
8001fbea:	fe b0 99 df 	rcall	80012fa8 <print_dbg_ulong>
    print_dbg_hex((u32)(allRegions[i]->data));
8001fbee:	fe cc a2 6e 	sub	r12,pc,-23954
    print_dbg(", w:");
8001fbf2:	fe b0 99 d5 	rcall	80012f9c <print_dbg>
8001fbf6:	6c 1c       	ld.w	r12,r6[0x4]
    print_dbg_ulong((u32)(allRegions[i]->w));
8001fbf8:	fe b0 99 fa 	rcall	80012fec <print_dbg_hex>
8001fbfc:	fe cc a2 ac 	sub	r12,pc,-23892
    print_dbg(", h:");
8001fc00:	fe b0 99 ce 	rcall	80012f9c <print_dbg>
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fc04:	30 4c       	mov	r12,4
8001fc06:	fe b0 99 f3 	rcall	80012fec <print_dbg_hex>
    print_dbg(", len: 0x");
8001fc0a:	fe cc a2 b2 	sub	r12,pc,-23886
8001fc0e:	fe b0 99 c7 	rcall	80012f9c <print_dbg>
    print_dbg_hex((u32)(allRegions[i]->len));
8001fc12:	ee c6 ff e0 	sub	r6,r7,-32
  //  screen_clear();

  // test
  print_dbg("\r\n\r\n regions:");
  for(i = 0; i<numRegions; i++) {
    print_dbg("\r\n ( ");
8001fc16:	0c 9c       	mov	r12,r6
8001fc18:	fe b0 99 ea 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex(i);
8001fc1c:	fe cc a2 bc 	sub	r12,pc,-23876
8001fc20:	fe b0 99 be 	rcall	80012f9c <print_dbg>
    print_dbg(" ) @ 0x");
8001fc24:	6c 3c       	ld.w	r12,r6[0xc]
8001fc26:	fe b0 99 e3 	rcall	80012fec <print_dbg_hex>
    print_dbg_hex((u32)(allRegions[i]));
8001fc2a:	fe cc a2 ba 	sub	r12,pc,-23878
8001fc2e:	fe b0 99 b7 	rcall	80012f9c <print_dbg>
    print_dbg(", data: @ 0x");
8001fc32:	0d 8c       	ld.ub	r12,r6[0x0]
8001fc34:	fe b0 99 ba 	rcall	80012fa8 <print_dbg_ulong>
    print_dbg_hex((u32)(allRegions[i]->data));
8001fc38:	fe cc a2 c0 	sub	r12,pc,-23872
    print_dbg(", w:");
8001fc3c:	fe b0 99 b0 	rcall	80012f9c <print_dbg>
8001fc40:	0d 9c       	ld.ub	r12,r6[0x1]
    print_dbg_ulong((u32)(allRegions[i]->w));
8001fc42:	fe b0 99 b3 	rcall	80012fa8 <print_dbg_ulong>
8001fc46:	fe cc a2 c6 	sub	r12,pc,-23866
    print_dbg(", h:");
8001fc4a:	fe b0 99 a9 	rcall	80012f9c <print_dbg>
    print_dbg_ulong((u32)(allRegions[i]->h));
8001fc4e:	6c 1c       	ld.w	r12,r6[0x4]
8001fc50:	fe b0 99 ce 	rcall	80012fec <print_dbg_hex>
    print_dbg(", len: 0x");
8001fc54:	fe cc a3 04 	sub	r12,pc,-23804
8001fc58:	fe b0 99 a2 	rcall	80012f9c <print_dbg>
    print_dbg_hex((u32)(allRegions[i]->len));
8001fc5c:	30 5c       	mov	r12,5
8001fc5e:	fe b0 99 c7 	rcall	80012fec <print_dbg_hex>
  }
}
8001fc62:	fe cc a3 0a 	sub	r12,pc,-23798
8001fc66:	fe b0 99 9b 	rcall	80012f9c <print_dbg>
8001fc6a:	2d 07       	sub	r7,-48
8001fc6c:	0e 9c       	mov	r12,r7
8001fc6e:	fe b0 99 bf 	rcall	80012fec <print_dbg_hex>
8001fc72:	fe cc a3 12 	sub	r12,pc,-23790
8001fc76:	fe b0 99 93 	rcall	80012f9c <print_dbg>
8001fc7a:	6e 3c       	ld.w	r12,r7[0xc]
8001fc7c:	fe b0 99 b8 	rcall	80012fec <print_dbg_hex>
8001fc80:	fe cc a3 10 	sub	r12,pc,-23792
8001fc84:	fe b0 99 8c 	rcall	80012f9c <print_dbg>
8001fc88:	0f 8c       	ld.ub	r12,r7[0x0]
8001fc8a:	fe b0 99 8f 	rcall	80012fa8 <print_dbg_ulong>
8001fc8e:	fe cc a3 16 	sub	r12,pc,-23786
8001fc92:	fe b0 99 85 	rcall	80012f9c <print_dbg>
8001fc96:	0f 9c       	ld.ub	r12,r7[0x1]
8001fc98:	fe b0 99 88 	rcall	80012fa8 <print_dbg_ulong>
8001fc9c:	fe cc a3 1c 	sub	r12,pc,-23780
8001fca0:	fe b0 99 7e 	rcall	80012f9c <print_dbg>
8001fca4:	6e 1c       	ld.w	r12,r7[0x4]
8001fca6:	fe b0 99 a3 	rcall	80012fec <print_dbg_hex>
8001fcaa:	d8 22       	popm	r4-r7,pc

8001fcac <render_startup>:
  
  region_string(&status, str, 0, 0, 0xf, 0, 0);
}

// fill with initial graphics (id strings)
void render_startup(void) {
8001fcac:	eb cd 40 e0 	pushm	r5-r7,lr
  reg->dirty = 1;
}

static void region_fill(region* reg, u8 c) {
  u32 i;
  for(i=0; i<reg->len; i++) {
8001fcb0:	33 c7       	mov	r7,60
8001fcb2:	6e 18       	ld.w	r8,r7[0x4]
8001fcb4:	58 08       	cp.w	r8,0
8001fcb6:	c0 a0       	breq	8001fcca <render_startup+0x1e>
8001fcb8:	30 08       	mov	r8,0
    reg->data[i] = c; 
8001fcba:	30 5a       	mov	r10,5
8001fcbc:	6e 39       	ld.w	r9,r7[0xc]
8001fcbe:	f2 08 0b 0a 	st.b	r9[r8],r10
  reg->dirty = 1;
}

static void region_fill(region* reg, u8 c) {
  u32 i;
  for(i=0; i<reg->len; i++) {
8001fcc2:	2f f8       	sub	r8,-1
8001fcc4:	6e 19       	ld.w	r9,r7[0x4]
8001fcc6:	12 38       	cp.w	r8,r9
8001fcc8:	cf a3       	brcs	8001fcbc <render_startup+0x10>
    reg->data[i] = c; 
  }
  reg->dirty = 1;
8001fcca:	30 16       	mov	r6,1
8001fccc:	ef 66 00 0a 	st.b	r7[10],r6
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fcd0:	30 05       	mov	r5,0
8001fcd2:	1a d5       	st.w	--sp,r5
8001fcd4:	0f 88       	ld.ub	r8,r7[0x0]
8001fcd6:	10 99       	mov	r9,r8
8001fcd8:	f0 08 00 18 	add	r8,r8,r8<<0x1
8001fcdc:	a3 68       	lsl	r8,0x2
8001fcde:	2d 88       	sub	r8,-40
8001fce0:	6e 3b       	ld.w	r11,r7[0xc]
8001fce2:	6e 1a       	ld.w	r10,r7[0x4]
8001fce4:	10 0b       	add	r11,r8
8001fce6:	fe cc a3 5a 	sub	r12,pc,-23718
8001fcea:	30 f8       	mov	r8,15
8001fcec:	fe b0 bf ac 	rcall	80017c44 <font_string_bigbig>
  }
  reg->dirty = 1;
8001fcf0:	ef 66 00 0a 	st.b	r7[10],r6
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fcf4:	1a d5       	st.w	--sp,r5
8001fcf6:	34 c7       	mov	r7,76
8001fcf8:	30 f8       	mov	r8,15
8001fcfa:	0f 89       	ld.ub	r9,r7[0x0]
8001fcfc:	6e 1a       	ld.w	r10,r7[0x4]
8001fcfe:	6e 3b       	ld.w	r11,r7[0xc]
8001fd00:	fe cc a3 6c 	sub	r12,pc,-23700
8001fd04:	fe b0 be 50 	rcall	800179a4 <font_string>
8001fd08:	1a d5       	st.w	--sp,r5
8001fd0a:	30 f8       	mov	r8,15
8001fd0c:	ef 39 00 10 	ld.ub	r9,r7[16]
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fd10:	6e 5a       	ld.w	r10,r7[0x14]
8001fd12:	6e 7b       	ld.w	r11,r7[0x1c]
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fd14:	ef 66 00 0a 	st.b	r7[10],r6
8001fd18:	fe cc a3 7c 	sub	r12,pc,-23684
8001fd1c:	fe b0 be 44 	rcall	800179a4 <font_string>
8001fd20:	1a d5       	st.w	--sp,r5
8001fd22:	30 f8       	mov	r8,15
8001fd24:	ef 39 00 20 	ld.ub	r9,r7[32]
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fd28:	6e 9a       	ld.w	r10,r7[0x24]
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fd2a:	6e bb       	ld.w	r11,r7[0x2c]
8001fd2c:	ef 66 00 1a 	st.b	r7[26],r6
8001fd30:	fe cc a3 8c 	sub	r12,pc,-23668
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fd34:	fe b0 be 38 	rcall	800179a4 <font_string>
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fd38:	1a d5       	st.w	--sp,r5
8001fd3a:	ef 66 00 2a 	st.b	r7[42],r6
8001fd3e:	30 f8       	mov	r8,15
8001fd40:	ef 39 00 30 	ld.ub	r9,r7[48]
8001fd44:	6e da       	ld.w	r10,r7[0x34]
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fd46:	6e fb       	ld.w	r11,r7[0x3c]
8001fd48:	fe cc a3 a0 	sub	r12,pc,-23648
  region_string(&bigtop, "LPPR", 40, 12, 0xf, 0x0, 2);
  region_string(&(foot[0]), "TAP1", 0, 0, 0xf, 0x0, 0);
  region_string(&(foot[1]), "TAP2", 0, 0, 0xf, 0x0, 0);
  region_string(&(foot[2]), "REC", 0, 0, 0xf, 0x0, 0);
  region_string(&(foot[3]), "PLAY", 0, 0, 0xf, 0x0, 0);
}
8001fd4c:	fe b0 be 2c 	rcall	800179a4 <font_string>
8001fd50:	ef 66 00 3a 	st.b	r7[58],r6
8001fd54:	2f bd       	sub	sp,-20
8001fd56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001fd5a:	d7 03       	nop

8001fd5c <render_status>:
8001fd5c:	eb cd 40 80 	pushm	r7,lr
8001fd60:	e0 68 2a 90 	mov	r8,10896
8001fd64:	30 09       	mov	r9,0
8001fd66:	91 09       	st.w	r8[0x0],r9
8001fd68:	32 c7       	mov	r7,44
8001fd6a:	6e 1a       	ld.w	r10,r7[0x4]
8001fd6c:	58 0a       	cp.w	r10,0
8001fd6e:	c0 b0       	breq	8001fd84 <render_status+0x28>
8001fd70:	12 9b       	mov	r11,r9
8001fd72:	6e 3a       	ld.w	r10,r7[0xc]

// render text to statusbar
void render_status(const char* str) {
  static u32 i;
  for(i=0; i<(status.len); i++) {
    status.data[i] = 0;
8001fd74:	f4 09 0b 0b 	st.b	r10[r9],r11
}

// render text to statusbar
void render_status(const char* str) {
  static u32 i;
  for(i=0; i<(status.len); i++) {
8001fd78:	2f f9       	sub	r9,-1
8001fd7a:	6e 1a       	ld.w	r10,r7[0x4]
8001fd7c:	12 3a       	cp.w	r10,r9
8001fd7e:	fe 9b ff fa 	brhi	8001fd72 <render_status+0x16>
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fd82:	91 09       	st.w	r8[0x0],r9
8001fd84:	30 08       	mov	r8,0
8001fd86:	1a d8       	st.w	--sp,r8
8001fd88:	30 f8       	mov	r8,15
8001fd8a:	0f 89       	ld.ub	r9,r7[0x0]
8001fd8c:	6e 3b       	ld.w	r11,r7[0xc]
8001fd8e:	fe b0 be 0b 	rcall	800179a4 <font_string>
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fd92:	30 18       	mov	r8,1
8001fd94:	2f fd       	sub	sp,-4
8001fd96:	ef 68 00 0a 	st.b	r7[10],r8
  for(i=0; i<(status.len); i++) {
    status.data[i] = 0;
  }
  
  region_string(&status, str, 0, 0, 0xf, 0, 0);
}
8001fd9a:	e3 cd 80 80 	ldm	sp++,r7,pc
8001fd9e:	d7 03       	nop

8001fda0 <render_delay_time>:
8001fda0:	eb cd 40 f8 	pushm	r3-r7,lr
8001fda4:	e0 66 2a 94 	mov	r6,10900
void render_sw_on(u8 sw, u8 on) {
  // highlight the footer
}

// draw delay time
void render_delay_time(u8 id, u32 ms, u32 samps) {
8001fda8:	16 97       	mov	r7,r11
  static char strbuf[12];
  memset(strbuf, ' ', 12);
8001fdaa:	14 93       	mov	r3,r10
8001fdac:	32 0b       	mov	r11,32
8001fdae:	30 ca       	mov	r10,12
8001fdb0:	0c 9c       	mov	r12,r6
8001fdb2:	e0 a0 1d 2b 	rcall	80023808 <memset>
  //  itoa_whole(ms, strbuf, 12);
  itoa_whole_lj(ms, strbuf);
8001fdb6:	0c 9b       	mov	r11,r6
8001fdb8:	0e 9c       	mov	r12,r7
8001fdba:	fe b0 f5 bf 	rcall	8001e938 <itoa_whole_lj>
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fdbe:	33 c7       	mov	r7,60
8001fdc0:	0f 8a       	ld.ub	r10,r7[0x0]
8001fdc2:	14 99       	mov	r9,r10
8001fdc4:	f4 0a 00 2a 	add	r10,r10,r10<<0x2
8001fdc8:	a3 6a       	lsl	r10,0x2
8001fdca:	2e 2a       	sub	r10,-30
8001fdcc:	30 f8       	mov	r8,15
8001fdce:	6e 3b       	ld.w	r11,r7[0xc]
8001fdd0:	30 04       	mov	r4,0
8001fdd2:	14 0b       	add	r11,r10
8001fdd4:	1a d4       	st.w	--sp,r4
8001fdd6:	0c 9c       	mov	r12,r6
8001fdd8:	6e 1a       	ld.w	r10,r7[0x4]
8001fdda:	fe b0 be 7d 	rcall	80017ad4 <font_string_big>
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fdde:	30 ca       	mov	r10,12
  static char strbuf[12];
  memset(strbuf, ' ', 12);
  //  itoa_whole(ms, strbuf, 12);
  itoa_whole_lj(ms, strbuf);
  region_string(&bigtop, strbuf, 30, 20, 0xf, 0x0, 1);
  memset(strbuf, ' ', 12);
8001fde0:	30 15       	mov	r5,1
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fde2:	32 0b       	mov	r11,32
8001fde4:	ef 65 00 0a 	st.b	r7[10],r5
  static char strbuf[12];
  memset(strbuf, ' ', 12);
  //  itoa_whole(ms, strbuf, 12);
  itoa_whole_lj(ms, strbuf);
  region_string(&bigtop, strbuf, 30, 20, 0xf, 0x0, 1);
  memset(strbuf, ' ', 12);
8001fde8:	0c 9c       	mov	r12,r6
8001fdea:	e0 a0 1d 0f 	rcall	80023808 <memset>
  //  itoa_whole(samps, strbuf, 12);
  itoa_whole_lj(samps, strbuf);
8001fdee:	0c 9b       	mov	r11,r6
8001fdf0:	06 9c       	mov	r12,r3
8001fdf2:	fe b0 f5 a3 	rcall	8001e938 <itoa_whole_lj>
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fdf6:	1a d4       	st.w	--sp,r4
8001fdf8:	0f 88       	ld.ub	r8,r7[0x0]
8001fdfa:	10 99       	mov	r9,r8
8001fdfc:	f0 08 00 28 	add	r8,r8,r8<<0x2
8001fe00:	a3 78       	lsl	r8,0x3
8001fe02:	2e 28       	sub	r8,-30
8001fe04:	6e 3b       	ld.w	r11,r7[0xc]
8001fe06:	0c 9c       	mov	r12,r6
8001fe08:	10 0b       	add	r11,r8
8001fe0a:	6e 1a       	ld.w	r10,r7[0x4]
8001fe0c:	30 f8       	mov	r8,15
8001fe0e:	fe b0 be 63 	rcall	80017ad4 <font_string_big>
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fe12:	ef 65 00 0a 	st.b	r7[10],r5
  region_string(&bigtop, strbuf, 30, 20, 0xf, 0x0, 1);
  memset(strbuf, ' ', 12);
  //  itoa_whole(samps, strbuf, 12);
  itoa_whole_lj(samps, strbuf);
  region_string(&bigtop, strbuf, 30, 40, 0xf, 0x0, 1);
}
8001fe16:	2f ed       	sub	sp,-8
8001fe18:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8001fe1c <render_touched_delaytime>:
8001fe1c:	eb cd 40 f8 	pushm	r3-r7,lr
8001fe20:	33 c7       	mov	r7,60
8001fe22:	18 93       	mov	r3,r12
8001fe24:	6e 18       	ld.w	r8,r7[0x4]
8001fe26:	58 08       	cp.w	r8,0
8001fe28:	c0 a0       	breq	8001fe3c <render_touched_delaytime+0x20>
8001fe2a:	30 08       	mov	r8,0
8001fe2c:	10 9a       	mov	r10,r8
8001fe2e:	6e 39       	ld.w	r9,r7[0xc]
}

static void region_clear(region* reg) {
  u32 i;
  for(i=0; i<reg->len; i++) {
    reg->data[i] = 0; 
8001fe30:	f2 08 0b 0a 	st.b	r9[r8],r10
  reg->dirty = 1;
}

static void region_clear(region* reg) {
  u32 i;
  for(i=0; i<reg->len; i++) {
8001fe34:	2f f8       	sub	r8,-1
8001fe36:	6e 19       	ld.w	r9,r7[0x4]
8001fe38:	12 38       	cp.w	r8,r9
8001fe3a:	cf a3       	brcs	8001fe2e <render_touched_delaytime+0x12>
    reg->data[i] = 0; 
  }
  reg->dirty = 1;
8001fe3c:	30 15       	mov	r5,1
8001fe3e:	ef 65 00 0a 	st.b	r7[10],r5
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fe42:	30 34       	mov	r4,3
8001fe44:	30 a8       	mov	r8,10
8001fe46:	1a d4       	st.w	--sp,r4
8001fe48:	fe cc a4 98 	sub	r12,pc,-23400
8001fe4c:	0f 89       	ld.ub	r9,r7[0x0]
8001fe4e:	6e 1a       	ld.w	r10,r7[0x4]
8001fe50:	6e 3b       	ld.w	r11,r7[0xc]
8001fe52:	fe b0 bd a9 	rcall	800179a4 <font_string>
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fe56:	ef 65 00 0a 	st.b	r7[10],r5
static void region_clear(region* reg) {
  u32 i;
  for(i=0; i<reg->len; i++) {
    reg->data[i] = 0; 
  }
  reg->dirty = 1;
8001fe5a:	2f fd       	sub	sp,-4

// draw labels for delay time
extern void render_touched_delaytime(u8 id) {
  region_clear(&bigtop);
  region_string(&bigtop, "delay time", 0, 0, 0xa, 0x3, 0 );
  if(id) { region_string(&bigtop, "2", 40, 0, 0xa, 0x3, 1 ); }
8001fe5c:	33 c6       	mov	r6,60
8001fe5e:	58 03       	cp.w	r3,0
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fe60:	c3 31       	brne	8001fec6 <render_touched_delaytime+0xaa>
8001fe62:	1a d4       	st.w	--sp,r4
8001fe64:	30 a8       	mov	r8,10
8001fe66:	6c 3b       	ld.w	r11,r6[0xc]
8001fe68:	0d 89       	ld.ub	r9,r6[0x0]
8001fe6a:	2d 8b       	sub	r11,-40
8001fe6c:	6c 1a       	ld.w	r10,r6[0x4]
8001fe6e:	fe cc a4 ae 	sub	r12,pc,-23378
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fe72:	fe b0 be 31 	rcall	80017ad4 <font_string_big>
8001fe76:	ed 65 00 0a 	st.b	r6[10],r5
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fe7a:	2f fd       	sub	sp,-4
8001fe7c:	0f 88       	ld.ub	r8,r7[0x0]
8001fe7e:	6e 3a       	ld.w	r10,r7[0xc]
8001fe80:	10 99       	mov	r9,r8
8001fe82:	f0 08 00 28 	add	r8,r8,r8<<0x2
8001fe86:	30 06       	mov	r6,0
8001fe88:	f4 08 00 2b 	add	r11,r10,r8<<0x2
8001fe8c:	1a d6       	st.w	--sp,r6
8001fe8e:	30 d8       	mov	r8,13
8001fe90:	6e 1a       	ld.w	r10,r7[0x4]
8001fe92:	fe cc a4 ce 	sub	r12,pc,-23346
8001fe96:	fe b0 bd 87 	rcall	800179a4 <font_string>
8001fe9a:	1a d6       	st.w	--sp,r6
8001fe9c:	0f 88       	ld.ub	r8,r7[0x0]
8001fe9e:	6e 3a       	ld.w	r10,r7[0xc]
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fea0:	10 99       	mov	r9,r8
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fea2:	f0 08 00 28 	add	r8,r8,r8<<0x2
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fea6:	30 16       	mov	r6,1
8001fea8:	f4 08 00 3b 	add	r11,r10,r8<<0x3
				 u8 x, u8 y, 	 // offset
				 u8 a, u8 b, 	 // colors
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001feac:	ef 66 00 0a 	st.b	r7[10],r6
8001feb0:	30 d8       	mov	r8,13
8001feb2:	6e 1a       	ld.w	r10,r7[0x4]
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001feb4:	fe cc a4 e8 	sub	r12,pc,-23320
8001feb8:	fe b0 bd 76 	rcall	800179a4 <font_string>
  region_string(&bigtop, "ms : ", 	0, 20, 0xd, 0x0, 0 );
  region_string(&bigtop, "samples : ", 	0, 40, 0xd, 0x0, 0 );
  //  region_string(&bigtop, strbuf, 0, 0, 0xf, 0x0, 1);
  //  region_string(&bigtop, strbuf, 0, 17, 0xf, 0x0, 1);

}
8001febc:	ef 66 00 0a 	st.b	r7[10],r6
				 u8 sz)  // size levels (dimensions multiplied by 2**sz)
{
  if(sz == 0) {
    font_string(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  } else if (sz == 1) {
    font_string_big(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
8001fec0:	2f ed       	sub	sp,-8
8001fec2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8001fec6:	1a d4       	st.w	--sp,r4
8001fec8:	30 a8       	mov	r8,10
8001feca:	6c 3b       	ld.w	r11,r6[0xc]
8001fecc:	0d 89       	ld.ub	r9,r6[0x0]
8001fece:	2d 8b       	sub	r11,-40
  } else if (sz == 2) {
    font_string_bigbig(str, reg->data + (u32)reg->w * (u32)y + (u32)x, reg->len, reg->w, a, b);
  }
  reg->dirty = 1;
8001fed0:	6c 1a       	ld.w	r10,r6[0x4]
8001fed2:	fe cc a5 16 	sub	r12,pc,-23274
8001fed6:	fe b0 bd ff 	rcall	80017ad4 <font_string_big>
8001feda:	ed 65 00 0a 	st.b	r6[10],r5
8001fede:	2f fd       	sub	sp,-4
8001fee0:	cc eb       	rjmp	8001fe7c <render_touched_delaytime+0x60>
8001fee2:	d7 03       	nop

8001fee4 <_stext>:
8001fee4:	e0 7d 00 00 	mov	sp,65536
8001fee8:	fe c0 c2 e8 	sub	r0,pc,-15640
8001feec:	e3 b0 00 01 	mtsr	0x4,r0
8001fef0:	d5 53       	csrf	0x15
8001fef2:	30 80       	mov	r0,8
8001fef4:	e0 61 05 98 	mov	r1,1432
8001fef8:	02 30       	cp.w	r0,r1
8001fefa:	c0 72       	brcc	8001ff08 <idata_load_loop_end>
8001fefc:	fe c2 a0 a4 	sub	r2,pc,-24412

8001ff00 <idata_load_loop>:
8001ff00:	a5 05       	ld.d	r4,r2++
8001ff02:	a1 24       	st.d	r0++,r4
8001ff04:	02 30       	cp.w	r0,r1
8001ff06:	cf d3       	brcs	8001ff00 <idata_load_loop>

8001ff08 <idata_load_loop_end>:
8001ff08:	e0 60 05 98 	mov	r0,1432
8001ff0c:	e0 61 33 48 	mov	r1,13128
8001ff10:	02 30       	cp.w	r0,r1
8001ff12:	c0 62       	brcc	8001ff1e <udata_clear_loop_end>
8001ff14:	30 02       	mov	r2,0
8001ff16:	30 03       	mov	r3,0

8001ff18 <udata_clear_loop>:
8001ff18:	a1 22       	st.d	r0++,r2
8001ff1a:	02 30       	cp.w	r0,r1
8001ff1c:	cf e3       	brcs	8001ff18 <udata_clear_loop>

8001ff1e <udata_clear_loop_end>:
8001ff1e:	fe cf 5c 8a 	sub	pc,pc,23690
8001ff22:	d7 03       	nop

8001ff24 <sinf>:
8001ff24:	d4 01       	pushm	lr
8001ff26:	20 2d       	sub	sp,8
8001ff28:	e0 69 0f d8 	mov	r9,4056
8001ff2c:	ea 19 3f 49 	orh	r9,0x3f49
8001ff30:	18 9b       	mov	r11,r12
8001ff32:	f1 dc c0 1f 	bfextu	r8,r12,0x0,0x1f
8001ff36:	12 38       	cp.w	r8,r9
8001ff38:	e0 89 00 05 	brgt	8001ff42 <sinf+0x1e>
8001ff3c:	30 0a       	mov	r10,0
8001ff3e:	30 0b       	mov	r11,0
8001ff40:	c1 98       	rjmp	8001ff72 <sinf+0x4e>
8001ff42:	e0 69 ff ff 	mov	r9,65535
8001ff46:	ea 19 7f 7f 	orh	r9,0x7f7f
8001ff4a:	12 38       	cp.w	r8,r9
8001ff4c:	e0 8a 00 05 	brle	8001ff56 <sinf+0x32>
8001ff50:	e0 a0 16 54 	rcall	80022bf8 <__avr32_f32_sub>
8001ff54:	c2 18       	rjmp	8001ff96 <sinf+0x72>
8001ff56:	1a 9b       	mov	r11,sp
8001ff58:	e0 a0 07 06 	rcall	80020d64 <__ieee754_rem_pio2f>
8001ff5c:	f1 dc c0 02 	bfextu	r8,r12,0x0,0x2
8001ff60:	58 18       	cp.w	r8,1
8001ff62:	c0 b0       	breq	8001ff78 <sinf+0x54>
8001ff64:	58 28       	cp.w	r8,2
8001ff66:	c0 e0       	breq	8001ff82 <sinf+0x5e>
8001ff68:	40 1b       	lddsp	r11,sp[0x4]
8001ff6a:	40 0c       	lddsp	r12,sp[0x0]
8001ff6c:	58 08       	cp.w	r8,0
8001ff6e:	c1 01       	brne	8001ff8e <sinf+0x6a>
8001ff70:	30 1a       	mov	r10,1
8001ff72:	e0 a0 0e 9d 	rcall	80021cac <__kernel_sinf>
8001ff76:	c1 08       	rjmp	8001ff96 <sinf+0x72>
8001ff78:	40 1b       	lddsp	r11,sp[0x4]
8001ff7a:	40 0c       	lddsp	r12,sp[0x0]
8001ff7c:	e0 a0 0b 18 	rcall	800215ac <__kernel_cosf>
8001ff80:	c0 b8       	rjmp	8001ff96 <sinf+0x72>
8001ff82:	30 1a       	mov	r10,1
8001ff84:	40 1b       	lddsp	r11,sp[0x4]
8001ff86:	40 0c       	lddsp	r12,sp[0x0]
8001ff88:	e0 a0 0e 92 	rcall	80021cac <__kernel_sinf>
8001ff8c:	c0 38       	rjmp	8001ff92 <sinf+0x6e>
8001ff8e:	e0 a0 0b 0f 	rcall	800215ac <__kernel_cosf>
8001ff92:	ee 1c 80 00 	eorh	r12,0x8000
8001ff96:	2f ed       	sub	sp,-8
8001ff98:	d8 02       	popm	pc
8001ff9a:	d7 03       	nop

8001ff9c <fmod>:
8001ff9c:	d4 31       	pushm	r0-r7,lr
8001ff9e:	20 9d       	sub	sp,36
8001ffa0:	e0 67 00 8c 	mov	r7,140
8001ffa4:	10 94       	mov	r4,r8
8001ffa6:	14 92       	mov	r2,r10
8001ffa8:	16 93       	mov	r3,r11
8001ffaa:	12 95       	mov	r5,r9
8001ffac:	e0 a0 02 0e 	rcall	800203c8 <__ieee754_fmod>
8001ffb0:	6e 08       	ld.w	r8,r7[0x0]
8001ffb2:	14 90       	mov	r0,r10
8001ffb4:	16 91       	mov	r1,r11
8001ffb6:	5b f8       	cp.w	r8,-1
8001ffb8:	c3 e0       	breq	80020034 <fmod+0x98>
8001ffba:	08 9a       	mov	r10,r4
8001ffbc:	0a 9b       	mov	r11,r5
8001ffbe:	e0 a0 0f b7 	rcall	80021f2c <__isnand>
8001ffc2:	c3 91       	brne	80020034 <fmod+0x98>
8001ffc4:	04 9a       	mov	r10,r2
8001ffc6:	06 9b       	mov	r11,r3
8001ffc8:	e0 a0 0f b2 	rcall	80021f2c <__isnand>
8001ffcc:	18 96       	mov	r6,r12
8001ffce:	c3 31       	brne	80020034 <fmod+0x98>
8001ffd0:	30 08       	mov	r8,0
8001ffd2:	30 09       	mov	r9,0
8001ffd4:	08 9a       	mov	r10,r4
8001ffd6:	0a 9b       	mov	r11,r5
8001ffd8:	e0 a0 13 17 	rcall	80022606 <__avr32_f64_cmp_eq>
8001ffdc:	c2 c0       	breq	80020034 <fmod+0x98>
8001ffde:	30 18       	mov	r8,1
8001ffe0:	fa e5 00 10 	st.d	sp[16],r4
8001ffe4:	50 08       	stdsp	sp[0x0],r8
8001ffe6:	50 86       	stdsp	sp[0x20],r6
8001ffe8:	fe c8 a6 10 	sub	r8,pc,-23024
8001ffec:	fa e3 00 08 	st.d	sp[8],r2
8001fff0:	50 18       	stdsp	sp[0x4],r8
8001fff2:	6e 07       	ld.w	r7,r7[0x0]
8001fff4:	58 07       	cp.w	r7,0
8001fff6:	c0 41       	brne	8001fffe <fmod+0x62>
8001fff8:	fa e3 00 18 	st.d	sp[24],r2
8001fffc:	c0 b8       	rjmp	80020012 <fmod+0x76>
8001fffe:	30 08       	mov	r8,0
80020000:	30 09       	mov	r9,0
80020002:	10 9a       	mov	r10,r8
80020004:	12 9b       	mov	r11,r9
80020006:	e0 a0 13 bb 	rcall	8002277c <__avr32_f64_div>
8002000a:	fa eb 00 18 	st.d	sp[24],r10
8002000e:	58 27       	cp.w	r7,2
80020010:	c0 50       	breq	8002001a <fmod+0x7e>
80020012:	1a 9c       	mov	r12,sp
80020014:	e0 a0 0f 9a 	rcall	80021f48 <matherr>
80020018:	c0 51       	brne	80020022 <fmod+0x86>
8002001a:	e0 a0 19 25 	rcall	80023264 <__errno>
8002001e:	32 18       	mov	r8,33
80020020:	99 08       	st.w	r12[0x0],r8
80020022:	40 88       	lddsp	r8,sp[0x20]
80020024:	58 08       	cp.w	r8,0
80020026:	c0 50       	breq	80020030 <fmod+0x94>
80020028:	e0 a0 19 1e 	rcall	80023264 <__errno>
8002002c:	40 88       	lddsp	r8,sp[0x20]
8002002e:	99 08       	st.w	r12[0x0],r8
80020030:	fa e0 00 18 	ld.d	r0,sp[24]
80020034:	00 9a       	mov	r10,r0
80020036:	02 9b       	mov	r11,r1
80020038:	2f 7d       	sub	sp,-36
8002003a:	d8 32       	popm	r0-r7,pc

8002003c <powf>:
8002003c:	d4 31       	pushm	r0-r7,lr
8002003e:	20 bd       	sub	sp,44
80020040:	18 96       	mov	r6,r12
80020042:	16 97       	mov	r7,r11
80020044:	e0 a0 02 dc 	rcall	800205fc <__ieee754_powf>
80020048:	e0 65 00 8c 	mov	r5,140
8002004c:	18 93       	mov	r3,r12
8002004e:	6a 08       	ld.w	r8,r5[0x0]
80020050:	5b f8       	cp.w	r8,-1
80020052:	e0 80 01 53 	breq	800202f8 <powf+0x2bc>
80020056:	0e 9c       	mov	r12,r7
80020058:	e0 a0 0f 06 	rcall	80021e64 <isnanf>
8002005c:	18 94       	mov	r4,r12
8002005e:	e0 81 01 4d 	brne	800202f8 <powf+0x2bc>
80020062:	0c 9c       	mov	r12,r6
80020064:	e0 a0 0f 00 	rcall	80021e64 <isnanf>
80020068:	18 92       	mov	r2,r12
8002006a:	c2 70       	breq	800200b8 <powf+0x7c>
8002006c:	30 0b       	mov	r11,0
8002006e:	0e 9c       	mov	r12,r7
80020070:	e0 a0 13 46 	rcall	800226fc <__avr32_f32_cmp_eq>
80020074:	e0 80 01 42 	breq	800202f8 <powf+0x2bc>
80020078:	30 18       	mov	r8,1
8002007a:	50 28       	stdsp	sp[0x8],r8
8002007c:	fe c8 a6 9c 	sub	r8,pc,-22884
80020080:	0c 9c       	mov	r12,r6
80020082:	50 38       	stdsp	sp[0xc],r8
80020084:	50 a4       	stdsp	sp[0x28],r4
80020086:	e0 a0 17 31 	rcall	80022ee8 <__avr32_f32_to_f64>
8002008a:	0e 9c       	mov	r12,r7
8002008c:	fa eb 00 10 	st.d	sp[16],r10
80020090:	e0 a0 17 2c 	rcall	80022ee8 <__avr32_f32_to_f64>
80020094:	30 08       	mov	r8,0
80020096:	fa eb 00 18 	st.d	sp[24],r10
8002009a:	fc 19 3f f0 	movh	r9,0x3ff0
8002009e:	fa e9 00 20 	st.d	sp[32],r8
800200a2:	6a 0a       	ld.w	r10,r5[0x0]
800200a4:	5b fa       	cp.w	r10,-1
800200a6:	5f 0b       	sreq	r11
800200a8:	58 2a       	cp.w	r10,2
800200aa:	5f 0a       	sreq	r10
800200ac:	16 4a       	or	r10,r11
800200ae:	e8 0a 18 00 	cp.b	r10,r4
800200b2:	e0 81 01 17 	brne	800202e0 <powf+0x2a4>
800200b6:	c8 68       	rjmp	800201c2 <powf+0x186>
800200b8:	30 0b       	mov	r11,0
800200ba:	0c 9c       	mov	r12,r6
800200bc:	e0 a0 13 20 	rcall	800226fc <__avr32_f32_cmp_eq>
800200c0:	c4 a0       	breq	80020154 <powf+0x118>
800200c2:	30 0b       	mov	r11,0
800200c4:	0e 9c       	mov	r12,r7
800200c6:	e0 a0 13 1b 	rcall	800226fc <__avr32_f32_cmp_eq>
800200ca:	c1 e0       	breq	80020106 <powf+0xca>
800200cc:	30 18       	mov	r8,1
800200ce:	50 28       	stdsp	sp[0x8],r8
800200d0:	fe c8 a6 f0 	sub	r8,pc,-22800
800200d4:	0c 9c       	mov	r12,r6
800200d6:	50 38       	stdsp	sp[0xc],r8
800200d8:	50 a2       	stdsp	sp[0x28],r2
800200da:	e0 a0 17 07 	rcall	80022ee8 <__avr32_f32_to_f64>
800200de:	0e 9c       	mov	r12,r7
800200e0:	fa eb 00 10 	st.d	sp[16],r10
800200e4:	e0 a0 17 02 	rcall	80022ee8 <__avr32_f32_to_f64>
800200e8:	30 08       	mov	r8,0
800200ea:	30 09       	mov	r9,0
800200ec:	fa eb 00 18 	st.d	sp[24],r10
800200f0:	fa e9 00 20 	st.d	sp[32],r8
800200f4:	6a 08       	ld.w	r8,r5[0x0]
800200f6:	58 08       	cp.w	r8,0
800200f8:	c6 50       	breq	800201c2 <powf+0x186>
800200fa:	30 08       	mov	r8,0
800200fc:	fc 19 3f f0 	movh	r9,0x3ff0
80020100:	fa e9 00 20 	st.d	sp[32],r8
80020104:	ce e8       	rjmp	800202e0 <powf+0x2a4>
80020106:	0e 9c       	mov	r12,r7
80020108:	e0 a0 0e 57 	rcall	80021db6 <finitef>
8002010c:	e0 80 00 f6 	breq	800202f8 <powf+0x2bc>
80020110:	30 0b       	mov	r11,0
80020112:	0e 9c       	mov	r12,r7
80020114:	e0 a0 13 1a 	rcall	80022748 <__avr32_f32_cmp_lt>
80020118:	e0 80 00 f0 	breq	800202f8 <powf+0x2bc>
8002011c:	30 18       	mov	r8,1
8002011e:	50 28       	stdsp	sp[0x8],r8
80020120:	fe c8 a7 40 	sub	r8,pc,-22720
80020124:	0c 9c       	mov	r12,r6
80020126:	50 38       	stdsp	sp[0xc],r8
80020128:	50 a2       	stdsp	sp[0x28],r2
8002012a:	e0 a0 16 df 	rcall	80022ee8 <__avr32_f32_to_f64>
8002012e:	0e 9c       	mov	r12,r7
80020130:	fa eb 00 10 	st.d	sp[16],r10
80020134:	e0 a0 16 da 	rcall	80022ee8 <__avr32_f32_to_f64>
80020138:	fa eb 00 18 	st.d	sp[24],r10
8002013c:	6a 08       	ld.w	r8,r5[0x0]
8002013e:	58 08       	cp.w	r8,0
80020140:	c3 20       	breq	800201a4 <powf+0x168>
80020142:	30 0a       	mov	r10,0
80020144:	f0 6b 00 00 	mov	r11,-1048576
80020148:	fa eb 00 20 	st.d	sp[32],r10
8002014c:	58 28       	cp.w	r8,2
8002014e:	c4 00       	breq	800201ce <powf+0x192>
80020150:	c3 98       	rjmp	800201c2 <powf+0x186>
80020152:	d7 03       	nop
80020154:	06 9c       	mov	r12,r3
80020156:	e0 a0 0e 30 	rcall	80021db6 <finitef>
8002015a:	18 94       	mov	r4,r12
8002015c:	e0 81 00 92 	brne	80020280 <powf+0x244>
80020160:	0c 9c       	mov	r12,r6
80020162:	e0 a0 0e 2a 	rcall	80021db6 <finitef>
80020166:	e0 80 00 8d 	breq	80020280 <powf+0x244>
8002016a:	0e 9c       	mov	r12,r7
8002016c:	e0 a0 0e 25 	rcall	80021db6 <finitef>
80020170:	e0 80 00 88 	breq	80020280 <powf+0x244>
80020174:	06 9c       	mov	r12,r3
80020176:	e0 a0 0e 77 	rcall	80021e64 <isnanf>
8002017a:	fe c8 a7 9a 	sub	r8,pc,-22630
8002017e:	58 0c       	cp.w	r12,0
80020180:	c2 b0       	breq	800201d6 <powf+0x19a>
80020182:	50 38       	stdsp	sp[0xc],r8
80020184:	30 18       	mov	r8,1
80020186:	0c 9c       	mov	r12,r6
80020188:	50 28       	stdsp	sp[0x8],r8
8002018a:	50 a4       	stdsp	sp[0x28],r4
8002018c:	e0 a0 16 ae 	rcall	80022ee8 <__avr32_f32_to_f64>
80020190:	0e 9c       	mov	r12,r7
80020192:	fa eb 00 10 	st.d	sp[16],r10
80020196:	e0 a0 16 a9 	rcall	80022ee8 <__avr32_f32_to_f64>
8002019a:	fa eb 00 18 	st.d	sp[24],r10
8002019e:	6a 07       	ld.w	r7,r5[0x0]
800201a0:	58 07       	cp.w	r7,0
800201a2:	c0 61       	brne	800201ae <powf+0x172>
800201a4:	30 08       	mov	r8,0
800201a6:	30 09       	mov	r9,0
800201a8:	fa e9 00 20 	st.d	sp[32],r8
800201ac:	c0 b8       	rjmp	800201c2 <powf+0x186>
800201ae:	30 08       	mov	r8,0
800201b0:	30 09       	mov	r9,0
800201b2:	10 9a       	mov	r10,r8
800201b4:	12 9b       	mov	r11,r9
800201b6:	e0 a0 12 e3 	rcall	8002277c <__avr32_f64_div>
800201ba:	fa eb 00 20 	st.d	sp[32],r10
800201be:	58 27       	cp.w	r7,2
800201c0:	c0 70       	breq	800201ce <powf+0x192>
800201c2:	fa cc ff f8 	sub	r12,sp,-8
800201c6:	e0 a0 0e c1 	rcall	80021f48 <matherr>
800201ca:	e0 81 00 8b 	brne	800202e0 <powf+0x2a4>
800201ce:	e0 a0 18 4b 	rcall	80023264 <__errno>
800201d2:	32 18       	mov	r8,33
800201d4:	c8 58       	rjmp	800202de <powf+0x2a2>
800201d6:	50 38       	stdsp	sp[0xc],r8
800201d8:	30 38       	mov	r8,3
800201da:	50 ac       	stdsp	sp[0x28],r12
800201dc:	50 28       	stdsp	sp[0x8],r8
800201de:	0c 9c       	mov	r12,r6
800201e0:	e0 a0 16 84 	rcall	80022ee8 <__avr32_f32_to_f64>
800201e4:	0e 9c       	mov	r12,r7
800201e6:	fa eb 00 10 	st.d	sp[16],r10
800201ea:	e0 a0 16 7f 	rcall	80022ee8 <__avr32_f32_to_f64>
800201ee:	fa eb 00 18 	st.d	sp[24],r10
800201f2:	6a 08       	ld.w	r8,r5[0x0]
800201f4:	58 08       	cp.w	r8,0
800201f6:	c2 61       	brne	80020242 <powf+0x206>
800201f8:	fc 18 e0 00 	movh	r8,0xe000
800201fc:	e0 69 ff ff 	mov	r9,65535
80020200:	ea 19 47 ef 	orh	r9,0x47ef
80020204:	0c 9c       	mov	r12,r6
80020206:	fa e9 00 20 	st.d	sp[32],r8
8002020a:	30 0b       	mov	r11,0
8002020c:	e0 a0 12 9e 	rcall	80022748 <__avr32_f32_cmp_lt>
80020210:	c5 a0       	breq	800202c4 <powf+0x288>
80020212:	fc 1b 3f 00 	movh	r11,0x3f00
80020216:	0e 9c       	mov	r12,r7
80020218:	e0 a0 15 ae 	rcall	80022d74 <__avr32_f32_mul>
8002021c:	e0 a0 16 66 	rcall	80022ee8 <__avr32_f32_to_f64>
80020220:	16 99       	mov	r9,r11
80020222:	50 0a       	stdsp	sp[0x0],r10
80020224:	50 19       	stdsp	sp[0x4],r9
80020226:	e0 a0 0e 97 	rcall	80021f54 <rint>
8002022a:	40 19       	lddsp	r9,sp[0x4]
8002022c:	40 08       	lddsp	r8,sp[0x0]
8002022e:	e0 a0 11 ec 	rcall	80022606 <__avr32_f64_cmp_eq>
80020232:	c4 91       	brne	800202c4 <powf+0x288>
80020234:	fc 18 e0 00 	movh	r8,0xe000
80020238:	e0 69 ff ff 	mov	r9,65535
8002023c:	ea 19 c7 ef 	orh	r9,0xc7ef
80020240:	c4 08       	rjmp	800202c0 <powf+0x284>
80020242:	30 08       	mov	r8,0
80020244:	fc 19 7f f0 	movh	r9,0x7ff0
80020248:	0c 9c       	mov	r12,r6
8002024a:	fa e9 00 20 	st.d	sp[32],r8
8002024e:	30 0b       	mov	r11,0
80020250:	e0 a0 12 7c 	rcall	80022748 <__avr32_f32_cmp_lt>
80020254:	c3 80       	breq	800202c4 <powf+0x288>
80020256:	fc 1b 3f 00 	movh	r11,0x3f00
8002025a:	0e 9c       	mov	r12,r7
8002025c:	e0 a0 15 8c 	rcall	80022d74 <__avr32_f32_mul>
80020260:	e0 a0 16 44 	rcall	80022ee8 <__avr32_f32_to_f64>
80020264:	16 99       	mov	r9,r11
80020266:	50 0a       	stdsp	sp[0x0],r10
80020268:	50 19       	stdsp	sp[0x4],r9
8002026a:	e0 a0 0e 75 	rcall	80021f54 <rint>
8002026e:	40 19       	lddsp	r9,sp[0x4]
80020270:	40 08       	lddsp	r8,sp[0x0]
80020272:	e0 a0 11 ca 	rcall	80022606 <__avr32_f64_cmp_eq>
80020276:	c2 71       	brne	800202c4 <powf+0x288>
80020278:	30 08       	mov	r8,0
8002027a:	f0 69 00 00 	mov	r9,-1048576
8002027e:	c2 18       	rjmp	800202c0 <powf+0x284>
80020280:	30 0b       	mov	r11,0
80020282:	06 9c       	mov	r12,r3
80020284:	e0 a0 12 3c 	rcall	800226fc <__avr32_f32_cmp_eq>
80020288:	c3 80       	breq	800202f8 <powf+0x2bc>
8002028a:	0c 9c       	mov	r12,r6
8002028c:	e0 a0 0d 95 	rcall	80021db6 <finitef>
80020290:	c3 40       	breq	800202f8 <powf+0x2bc>
80020292:	0e 9c       	mov	r12,r7
80020294:	e0 a0 0d 91 	rcall	80021db6 <finitef>
80020298:	c3 00       	breq	800202f8 <powf+0x2bc>
8002029a:	30 48       	mov	r8,4
8002029c:	50 28       	stdsp	sp[0x8],r8
8002029e:	fe c8 a8 be 	sub	r8,pc,-22338
800202a2:	50 38       	stdsp	sp[0xc],r8
800202a4:	30 08       	mov	r8,0
800202a6:	0c 9c       	mov	r12,r6
800202a8:	50 a8       	stdsp	sp[0x28],r8
800202aa:	e0 a0 16 1f 	rcall	80022ee8 <__avr32_f32_to_f64>
800202ae:	0e 9c       	mov	r12,r7
800202b0:	fa eb 00 10 	st.d	sp[16],r10
800202b4:	e0 a0 16 1a 	rcall	80022ee8 <__avr32_f32_to_f64>
800202b8:	30 08       	mov	r8,0
800202ba:	fa eb 00 18 	st.d	sp[24],r10
800202be:	30 09       	mov	r9,0
800202c0:	fa e9 00 20 	st.d	sp[32],r8
800202c4:	e0 68 00 8c 	mov	r8,140
800202c8:	70 08       	ld.w	r8,r8[0x0]
800202ca:	58 28       	cp.w	r8,2
800202cc:	c0 60       	breq	800202d8 <powf+0x29c>
800202ce:	fa cc ff f8 	sub	r12,sp,-8
800202d2:	e0 a0 0e 3b 	rcall	80021f48 <matherr>
800202d6:	c0 51       	brne	800202e0 <powf+0x2a4>
800202d8:	e0 a0 17 c6 	rcall	80023264 <__errno>
800202dc:	32 28       	mov	r8,34
800202de:	99 08       	st.w	r12[0x0],r8
800202e0:	40 a8       	lddsp	r8,sp[0x28]
800202e2:	58 08       	cp.w	r8,0
800202e4:	c0 50       	breq	800202ee <powf+0x2b2>
800202e6:	e0 a0 17 bf 	rcall	80023264 <__errno>
800202ea:	40 a8       	lddsp	r8,sp[0x28]
800202ec:	99 08       	st.w	r12[0x0],r8
800202ee:	fa ea 00 20 	ld.d	r10,sp[32]
800202f2:	e0 a0 16 2b 	rcall	80022f48 <__avr32_f64_to_f32>
800202f6:	18 93       	mov	r3,r12
800202f8:	06 9c       	mov	r12,r3
800202fa:	2f 5d       	sub	sp,-44
800202fc:	d8 32       	popm	r0-r7,pc
800202fe:	d7 03       	nop

80020300 <log>:
80020300:	d4 31       	pushm	r0-r7,lr
80020302:	20 9d       	sub	sp,36
80020304:	e0 67 00 8c 	mov	r7,140
80020308:	14 94       	mov	r4,r10
8002030a:	16 95       	mov	r5,r11
8002030c:	e0 a0 07 32 	rcall	80021170 <__ieee754_log>
80020310:	6e 08       	ld.w	r8,r7[0x0]
80020312:	14 92       	mov	r2,r10
80020314:	16 93       	mov	r3,r11
80020316:	5b f8       	cp.w	r8,-1
80020318:	c5 40       	breq	800203c0 <log+0xc0>
8002031a:	08 9a       	mov	r10,r4
8002031c:	0a 9b       	mov	r11,r5
8002031e:	e0 a0 0e 07 	rcall	80021f2c <__isnand>
80020322:	18 96       	mov	r6,r12
80020324:	c4 e1       	brne	800203c0 <log+0xc0>
80020326:	08 98       	mov	r8,r4
80020328:	0a 99       	mov	r9,r5
8002032a:	30 0a       	mov	r10,0
8002032c:	30 0b       	mov	r11,0
8002032e:	e0 a0 11 b3 	rcall	80022694 <__avr32_f64_cmp_lt>
80020332:	c4 71       	brne	800203c0 <log+0xc0>
80020334:	fe c8 a9 4c 	sub	r8,pc,-22196
80020338:	50 86       	stdsp	sp[0x20],r6
8002033a:	fa e5 00 08 	st.d	sp[8],r4
8002033e:	fa e5 00 10 	st.d	sp[16],r4
80020342:	50 18       	stdsp	sp[0x4],r8
80020344:	6e 07       	ld.w	r7,r7[0x0]
80020346:	58 07       	cp.w	r7,0
80020348:	c0 81       	brne	80020358 <log+0x58>
8002034a:	fc 18 e0 00 	movh	r8,0xe000
8002034e:	e0 69 ff ff 	mov	r9,65535
80020352:	ea 19 c7 ef 	orh	r9,0xc7ef
80020356:	c0 48       	rjmp	8002035e <log+0x5e>
80020358:	30 08       	mov	r8,0
8002035a:	f0 69 00 00 	mov	r9,-1048576
8002035e:	fa e9 00 18 	st.d	sp[24],r8
80020362:	08 9a       	mov	r10,r4
80020364:	0a 9b       	mov	r11,r5
80020366:	30 08       	mov	r8,0
80020368:	30 09       	mov	r9,0
8002036a:	e0 a0 11 4e 	rcall	80022606 <__avr32_f64_cmp_eq>
8002036e:	c0 e0       	breq	8002038a <log+0x8a>
80020370:	30 28       	mov	r8,2
80020372:	50 08       	stdsp	sp[0x0],r8
80020374:	10 37       	cp.w	r7,r8
80020376:	c0 50       	breq	80020380 <log+0x80>
80020378:	1a 9c       	mov	r12,sp
8002037a:	e0 a0 0d e7 	rcall	80021f48 <matherr>
8002037e:	c1 81       	brne	800203ae <log+0xae>
80020380:	e0 a0 17 72 	rcall	80023264 <__errno>
80020384:	32 28       	mov	r8,34
80020386:	99 08       	st.w	r12[0x0],r8
80020388:	c1 38       	rjmp	800203ae <log+0xae>
8002038a:	30 18       	mov	r8,1
8002038c:	50 08       	stdsp	sp[0x0],r8
8002038e:	58 27       	cp.w	r7,2
80020390:	c0 50       	breq	8002039a <log+0x9a>
80020392:	1a 9c       	mov	r12,sp
80020394:	e0 a0 0d da 	rcall	80021f48 <matherr>
80020398:	c0 51       	brne	800203a2 <log+0xa2>
8002039a:	e0 a0 17 65 	rcall	80023264 <__errno>
8002039e:	32 18       	mov	r8,33
800203a0:	99 08       	st.w	r12[0x0],r8
800203a2:	fe cc c2 fe 	sub	r12,pc,-15618
800203a6:	e0 a0 0d d2 	rcall	80021f4a <nan>
800203aa:	fa eb 00 18 	st.d	sp[24],r10
800203ae:	40 88       	lddsp	r8,sp[0x20]
800203b0:	58 08       	cp.w	r8,0
800203b2:	c0 50       	breq	800203bc <log+0xbc>
800203b4:	e0 a0 17 58 	rcall	80023264 <__errno>
800203b8:	40 88       	lddsp	r8,sp[0x20]
800203ba:	99 08       	st.w	r12[0x0],r8
800203bc:	fa e2 00 18 	ld.d	r2,sp[24]
800203c0:	04 9a       	mov	r10,r2
800203c2:	06 9b       	mov	r11,r3
800203c4:	2f 7d       	sub	sp,-36
800203c6:	d8 32       	popm	r0-r7,pc

800203c8 <__ieee754_fmod>:
800203c8:	d4 31       	pushm	r0-r7,lr
800203ca:	e0 6c ff ff 	mov	r12,65535
800203ce:	ea 1c 7f ef 	orh	r12,0x7fef
800203d2:	ef d9 c0 1f 	bfextu	r7,r9,0x0,0x1f
800203d6:	ef e8 10 01 	or	r1,r7,r8
800203da:	5f 01       	sreq	r1
800203dc:	16 95       	mov	r5,r11
800203de:	ed db c0 1f 	bfextu	r6,r11,0x0,0x1f
800203e2:	14 94       	mov	r4,r10
800203e4:	18 36       	cp.w	r6,r12
800203e6:	5f 93       	srgt	r3
800203e8:	10 90       	mov	r0,r8
800203ea:	e3 e3 10 03 	or	r3,r1,r3
800203ee:	10 9e       	mov	lr,r8
800203f0:	14 9c       	mov	r12,r10
800203f2:	e6 15 80 00 	andh	r5,0x8000,COH
800203f6:	30 01       	mov	r1,0
800203f8:	e2 03 18 00 	cp.b	r3,r1
800203fc:	c0 b1       	brne	80020412 <__ieee754_fmod+0x4a>
800203fe:	f0 01 11 00 	rsub	r1,r8,0
80020402:	fc 14 7f f0 	movh	r4,0x7ff0
80020406:	10 41       	or	r1,r8
80020408:	ef e1 13 f1 	or	r1,r7,r1>>0x1f
8002040c:	08 31       	cp.w	r1,r4
8002040e:	e0 88 00 09 	brls	80020420 <__ieee754_fmod+0x58>
80020412:	e0 a0 0e 33 	rcall	80022078 <__avr32_f64_mul>
80020416:	14 98       	mov	r8,r10
80020418:	16 99       	mov	r9,r11
8002041a:	e0 a0 11 b1 	rcall	8002277c <__avr32_f64_div>
8002041e:	d8 32       	popm	r0-r7,pc
80020420:	0e 36       	cp.w	r6,r7
80020422:	e0 89 00 0e 	brgt	8002043e <__ieee754_fmod+0x76>
80020426:	5f 59       	srlt	r9
80020428:	10 3a       	cp.w	r10,r8
8002042a:	5f 38       	srlo	r8
8002042c:	f3 e8 10 08 	or	r8,r9,r8
80020430:	e6 08 18 00 	cp.b	r8,r3
80020434:	e0 81 00 e3 	brne	800205fa <__ieee754_fmod+0x232>
80020438:	00 3a       	cp.w	r10,r0
8002043a:	e0 80 00 a0 	breq	8002057a <__ieee754_fmod+0x1b2>
8002043e:	ee 56 ff ff 	cp.w	r6,1048575
80020442:	e0 89 00 19 	brgt	80020474 <__ieee754_fmod+0xac>
80020446:	58 06       	cp.w	r6,0
80020448:	c0 b1       	brne	8002045e <__ieee754_fmod+0x96>
8002044a:	18 98       	mov	r8,r12
8002044c:	fe 7a fb ed 	mov	r10,-1043
80020450:	c0 38       	rjmp	80020456 <__ieee754_fmod+0x8e>
80020452:	20 1a       	sub	r10,1
80020454:	a1 78       	lsl	r8,0x1
80020456:	58 08       	cp.w	r8,0
80020458:	fe 99 ff fd 	brgt	80020452 <__ieee754_fmod+0x8a>
8002045c:	c1 08       	rjmp	8002047c <__ieee754_fmod+0xb4>
8002045e:	ec 08 15 0b 	lsl	r8,r6,0xb
80020462:	fe 7a fc 02 	mov	r10,-1022
80020466:	c0 38       	rjmp	8002046c <__ieee754_fmod+0xa4>
80020468:	20 1a       	sub	r10,1
8002046a:	a1 78       	lsl	r8,0x1
8002046c:	58 08       	cp.w	r8,0
8002046e:	fe 99 ff fd 	brgt	80020468 <__ieee754_fmod+0xa0>
80020472:	c0 58       	rjmp	8002047c <__ieee754_fmod+0xb4>
80020474:	ec 0a 14 14 	asr	r10,r6,0x14
80020478:	f4 ca 03 ff 	sub	r10,r10,1023
8002047c:	ee 57 ff ff 	cp.w	r7,1048575
80020480:	e0 89 00 19 	brgt	800204b2 <__ieee754_fmod+0xea>
80020484:	58 07       	cp.w	r7,0
80020486:	c0 b1       	brne	8002049c <__ieee754_fmod+0xd4>
80020488:	1c 98       	mov	r8,lr
8002048a:	fe 79 fb ed 	mov	r9,-1043
8002048e:	c0 38       	rjmp	80020494 <__ieee754_fmod+0xcc>
80020490:	20 19       	sub	r9,1
80020492:	a1 78       	lsl	r8,0x1
80020494:	58 08       	cp.w	r8,0
80020496:	fe 99 ff fd 	brgt	80020490 <__ieee754_fmod+0xc8>
8002049a:	c1 08       	rjmp	800204ba <__ieee754_fmod+0xf2>
8002049c:	ee 08 15 0b 	lsl	r8,r7,0xb
800204a0:	fe 79 fc 02 	mov	r9,-1022
800204a4:	c0 38       	rjmp	800204aa <__ieee754_fmod+0xe2>
800204a6:	20 19       	sub	r9,1
800204a8:	a1 78       	lsl	r8,0x1
800204aa:	58 08       	cp.w	r8,0
800204ac:	fe 99 ff fd 	brgt	800204a6 <__ieee754_fmod+0xde>
800204b0:	c0 58       	rjmp	800204ba <__ieee754_fmod+0xf2>
800204b2:	ee 09 14 14 	asr	r9,r7,0x14
800204b6:	f2 c9 03 ff 	sub	r9,r9,1023
800204ba:	fe 5a fc 02 	cp.w	r10,-1022
800204be:	c0 55       	brlt	800204c8 <__ieee754_fmod+0x100>
800204c0:	f1 d6 c0 14 	bfextu	r8,r6,0x0,0x14
800204c4:	b5 a8       	sbr	r8,0x14
800204c6:	c1 48       	rjmp	800204ee <__ieee754_fmod+0x126>
800204c8:	fe 7b fc 02 	mov	r11,-1022
800204cc:	14 1b       	sub	r11,r10
800204ce:	59 fb       	cp.w	r11,31
800204d0:	e0 89 00 0c 	brgt	800204e8 <__ieee754_fmod+0x120>
800204d4:	ec 0b 09 46 	lsl	r6,r6,r11
800204d8:	f6 08 11 20 	rsub	r8,r11,32
800204dc:	f8 08 0a 48 	lsr	r8,r12,r8
800204e0:	f8 0b 09 4c 	lsl	r12,r12,r11
800204e4:	0c 48       	or	r8,r6
800204e6:	c0 48       	rjmp	800204ee <__ieee754_fmod+0x126>
800204e8:	f8 0b 09 48 	lsl	r8,r12,r11
800204ec:	30 0c       	mov	r12,0
800204ee:	fe 59 fc 02 	cp.w	r9,-1022
800204f2:	c0 55       	brlt	800204fc <__ieee754_fmod+0x134>
800204f4:	ef d7 c0 14 	bfextu	r7,r7,0x0,0x14
800204f8:	b5 a7       	sbr	r7,0x14
800204fa:	c1 58       	rjmp	80020524 <__ieee754_fmod+0x15c>
800204fc:	fe 7b fc 02 	mov	r11,-1022
80020500:	12 1b       	sub	r11,r9
80020502:	59 fb       	cp.w	r11,31
80020504:	e0 89 00 0d 	brgt	8002051e <__ieee754_fmod+0x156>
80020508:	ee 0b 09 47 	lsl	r7,r7,r11
8002050c:	f6 06 11 20 	rsub	r6,r11,32
80020510:	fc 06 0a 46 	lsr	r6,lr,r6
80020514:	fc 0b 09 4e 	lsl	lr,lr,r11
80020518:	ed e7 10 07 	or	r7,r6,r7
8002051c:	c0 48       	rjmp	80020524 <__ieee754_fmod+0x15c>
8002051e:	fc 0b 09 47 	lsl	r7,lr,r11
80020522:	30 0e       	mov	lr,0
80020524:	12 1a       	sub	r10,r9
80020526:	c1 88       	rjmp	80020556 <__ieee754_fmod+0x18e>
80020528:	1c 3c       	cp.w	r12,lr
8002052a:	f9 b3 03 ff 	movlo	r3,-1
8002052e:	f7 d3 e3 0b 	addcs	r11,r11,r3
80020532:	58 0b       	cp.w	r11,0
80020534:	c0 74       	brge	80020542 <__ieee754_fmod+0x17a>
80020536:	f8 0b 16 1f 	lsr	r11,r12,0x1f
8002053a:	a1 7c       	lsl	r12,0x1
8002053c:	f6 08 00 18 	add	r8,r11,r8<<0x1
80020540:	c0 a8       	rjmp	80020554 <__ieee754_fmod+0x18c>
80020542:	ec 0c 15 01 	lsl	r12,r6,0x1
80020546:	f7 e6 10 08 	or	r8,r11,r6
8002054a:	c1 80       	breq	8002057a <__ieee754_fmod+0x1b2>
8002054c:	ec 08 16 1f 	lsr	r8,r6,0x1f
80020550:	f0 0b 00 18 	add	r8,r8,r11<<0x1
80020554:	20 1a       	sub	r10,1
80020556:	f8 0e 01 06 	sub	r6,r12,lr
8002055a:	f0 07 01 0b 	sub	r11,r8,r7
8002055e:	58 0a       	cp.w	r10,0
80020560:	ce 41       	brne	80020528 <__ieee754_fmod+0x160>
80020562:	1c 3c       	cp.w	r12,lr
80020564:	f9 ba 03 ff 	movlo	r10,-1
80020568:	f7 da e3 0b 	addcs	r11,r11,r10
8002056c:	58 0b       	cp.w	r11,0
8002056e:	c0 35       	brlt	80020574 <__ieee754_fmod+0x1ac>
80020570:	1c 1c       	sub	r12,lr
80020572:	16 98       	mov	r8,r11
80020574:	f1 ec 10 0a 	or	r10,r8,r12
80020578:	c0 d1       	brne	80020592 <__ieee754_fmod+0x1ca>
8002057a:	bf 95       	lsr	r5,0x1f
8002057c:	fe c9 ab 90 	sub	r9,pc,-21616
80020580:	f2 05 02 3a 	ld.d	r10,r9[r5<<0x3]
80020584:	d8 32       	popm	r0-r7,pc
80020586:	f8 0a 16 1f 	lsr	r10,r12,0x1f
8002058a:	20 19       	sub	r9,1
8002058c:	f4 08 00 18 	add	r8,r10,r8<<0x1
80020590:	a1 7c       	lsl	r12,0x1
80020592:	ee 58 ff ff 	cp.w	r8,1048575
80020596:	fe 9a ff f8 	brle	80020586 <__ieee754_fmod+0x1be>
8002059a:	fe 59 fc 02 	cp.w	r9,-1022
8002059e:	c0 c5       	brlt	800205b6 <__ieee754_fmod+0x1ee>
800205a0:	f0 6a 00 00 	mov	r10,-1048576
800205a4:	f2 c9 fc 01 	sub	r9,r9,-1023
800205a8:	14 08       	add	r8,r10
800205aa:	18 9a       	mov	r10,r12
800205ac:	f1 e5 10 05 	or	r5,r8,r5
800205b0:	eb e9 11 4b 	or	r11,r5,r9<<0x14
800205b4:	d8 32       	popm	r0-r7,pc
800205b6:	fe 7a fc 02 	mov	r10,-1022
800205ba:	f4 09 01 09 	sub	r9,r10,r9
800205be:	59 49       	cp.w	r9,20
800205c0:	e0 89 00 0c 	brgt	800205d8 <__ieee754_fmod+0x210>
800205c4:	f0 09 08 4e 	asr	lr,r8,r9
800205c8:	f8 09 0a 4c 	lsr	r12,r12,r9
800205cc:	f2 09 11 20 	rsub	r9,r9,32
800205d0:	f0 09 09 48 	lsl	r8,r8,r9
800205d4:	18 48       	or	r8,r12
800205d6:	c0 f8       	rjmp	800205f4 <__ieee754_fmod+0x22c>
800205d8:	59 f9       	cp.w	r9,31
800205da:	e0 89 00 0a 	brgt	800205ee <__ieee754_fmod+0x226>
800205de:	f8 09 0a 4c 	lsr	r12,r12,r9
800205e2:	f2 09 11 20 	rsub	r9,r9,32
800205e6:	f0 09 09 48 	lsl	r8,r8,r9
800205ea:	18 48       	or	r8,r12
800205ec:	c0 38       	rjmp	800205f2 <__ieee754_fmod+0x22a>
800205ee:	f0 09 08 48 	asr	r8,r8,r9
800205f2:	0a 9e       	mov	lr,r5
800205f4:	fd e5 10 0b 	or	r11,lr,r5
800205f8:	10 9a       	mov	r10,r8
800205fa:	d8 32       	popm	r0-r7,pc

800205fc <__ieee754_powf>:
800205fc:	d4 31       	pushm	r0-r7,lr
800205fe:	20 6d       	sub	sp,24
80020600:	16 97       	mov	r7,r11
80020602:	18 9b       	mov	r11,r12
80020604:	0e 96       	mov	r6,r7
80020606:	e5 d7 c0 1f 	bfextu	r2,r7,0x0,0x1f
8002060a:	c4 50       	breq	80020694 <__ieee754_powf+0x98>
8002060c:	fc 19 7f 80 	movh	r9,0x7f80
80020610:	e9 dc c0 1f 	bfextu	r4,r12,0x0,0x1f
80020614:	12 32       	cp.w	r2,r9
80020616:	5f 99       	srgt	r9
80020618:	fc 18 7f 80 	movh	r8,0x7f80
8002061c:	18 93       	mov	r3,r12
8002061e:	10 34       	cp.w	r4,r8
80020620:	5f 98       	srgt	r8
80020622:	f3 e8 10 08 	or	r8,r9,r8
80020626:	c0 a0       	breq	8002063a <__ieee754_powf+0x3e>
80020628:	fc 19 3f 80 	movh	r9,0x3f80
8002062c:	12 34       	cp.w	r4,r9
8002062e:	c3 30       	breq	80020694 <__ieee754_powf+0x98>
80020630:	fe cc c5 8c 	sub	r12,pc,-14964
80020634:	e0 a0 0c 1f 	rcall	80021e72 <nanf>
80020638:	c8 48       	rjmp	80020740 <__ieee754_powf+0x144>
8002063a:	58 0c       	cp.w	r12,0
8002063c:	c2 34       	brge	80020682 <__ieee754_powf+0x86>
8002063e:	e0 68 ff ff 	mov	r8,65535
80020642:	ea 18 4b 7f 	orh	r8,0x4b7f
80020646:	10 32       	cp.w	r2,r8
80020648:	e0 8a 00 04 	brle	80020650 <__ieee754_powf+0x54>
8002064c:	30 25       	mov	r5,2
8002064e:	c1 b8       	rjmp	80020684 <__ieee754_powf+0x88>
80020650:	e0 69 ff ff 	mov	r9,65535
80020654:	ea 19 3f 7f 	orh	r9,0x3f7f
80020658:	12 32       	cp.w	r2,r9
8002065a:	e0 8a 03 81 	brle	80020d5c <__ieee754_powf+0x760>
8002065e:	e4 08 14 17 	asr	r8,r2,0x17
80020662:	e0 69 00 96 	mov	r9,150
80020666:	f2 08 01 08 	sub	r8,r9,r8
8002066a:	e4 08 08 45 	asr	r5,r2,r8
8002066e:	ea 08 09 48 	lsl	r8,r5,r8
80020672:	04 38       	cp.w	r8,r2
80020674:	e0 81 03 74 	brne	80020d5c <__ieee754_powf+0x760>
80020678:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8002067c:	ea 05 11 02 	rsub	r5,r5,2
80020680:	c1 c8       	rjmp	800206b8 <__ieee754_powf+0xbc>
80020682:	30 05       	mov	r5,0
80020684:	fc 18 7f 80 	movh	r8,0x7f80
80020688:	10 32       	cp.w	r2,r8
8002068a:	c1 71       	brne	800206b8 <__ieee754_powf+0xbc>
8002068c:	fc 19 3f 80 	movh	r9,0x3f80
80020690:	12 34       	cp.w	r4,r9
80020692:	c0 51       	brne	8002069c <__ieee754_powf+0xa0>
80020694:	fc 17 3f 80 	movh	r7,0x3f80
80020698:	e0 8f 03 5f 	bral	80020d56 <__ieee754_powf+0x75a>
8002069c:	fc 18 3f 80 	movh	r8,0x3f80
800206a0:	10 34       	cp.w	r4,r8
800206a2:	e0 8a 00 08 	brle	800206b2 <__ieee754_powf+0xb6>
800206a6:	30 09       	mov	r9,0
800206a8:	58 06       	cp.w	r6,0
800206aa:	f2 07 17 50 	movlt	r7,r9
800206ae:	e0 8f 03 54 	bral	80020d56 <__ieee754_powf+0x75a>
800206b2:	58 06       	cp.w	r6,0
800206b4:	c7 04       	brge	80020794 <__ieee754_powf+0x198>
800206b6:	c4 c8       	rjmp	8002074e <__ieee754_powf+0x152>
800206b8:	fc 18 3f 80 	movh	r8,0x3f80
800206bc:	10 32       	cp.w	r2,r8
800206be:	c0 71       	brne	800206cc <__ieee754_powf+0xd0>
800206c0:	58 06       	cp.w	r6,0
800206c2:	e0 84 03 49 	brge	80020d54 <__ieee754_powf+0x758>
800206c6:	fc 1c 3f 80 	movh	r12,0x3f80
800206ca:	c3 98       	rjmp	8002073c <__ieee754_powf+0x140>
800206cc:	fc 19 40 00 	movh	r9,0x4000
800206d0:	12 36       	cp.w	r6,r9
800206d2:	c6 80       	breq	800207a2 <__ieee754_powf+0x1a6>
800206d4:	fc 18 3f 00 	movh	r8,0x3f00
800206d8:	10 36       	cp.w	r6,r8
800206da:	c0 71       	brne	800206e8 <__ieee754_powf+0xec>
800206dc:	58 03       	cp.w	r3,0
800206de:	c0 55       	brlt	800206e8 <__ieee754_powf+0xec>
800206e0:	16 9c       	mov	r12,r11
800206e2:	e0 a0 04 e3 	rcall	800210a8 <__ieee754_sqrtf>
800206e6:	c2 d8       	rjmp	80020740 <__ieee754_powf+0x144>
800206e8:	16 9c       	mov	r12,r11
800206ea:	50 1b       	stdsp	sp[0x4],r11
800206ec:	e0 a0 0b 62 	rcall	80021db0 <fabsf>
800206f0:	58 04       	cp.w	r4,0
800206f2:	5f 0a       	sreq	r10
800206f4:	fc 19 7f 80 	movh	r9,0x7f80
800206f8:	18 98       	mov	r8,r12
800206fa:	12 34       	cp.w	r4,r9
800206fc:	5f 09       	sreq	r9
800206fe:	40 1b       	lddsp	r11,sp[0x4]
80020700:	f5 e9 10 09 	or	r9,r10,r9
80020704:	c0 51       	brne	8002070e <__ieee754_powf+0x112>
80020706:	fc 19 3f 80 	movh	r9,0x3f80
8002070a:	12 34       	cp.w	r4,r9
8002070c:	c2 61       	brne	80020758 <__ieee754_powf+0x15c>
8002070e:	58 06       	cp.w	r6,0
80020710:	c0 35       	brlt	80020716 <__ieee754_powf+0x11a>
80020712:	10 9b       	mov	r11,r8
80020714:	c0 78       	rjmp	80020722 <__ieee754_powf+0x126>
80020716:	10 9b       	mov	r11,r8
80020718:	fc 1c 3f 80 	movh	r12,0x3f80
8002071c:	e0 a0 11 bc 	rcall	80022a94 <__avr32_f32_div>
80020720:	18 9b       	mov	r11,r12
80020722:	58 03       	cp.w	r3,0
80020724:	e0 84 03 18 	brge	80020d54 <__ieee754_powf+0x758>
80020728:	fc 18 c0 80 	movh	r8,0xc080
8002072c:	10 04       	add	r4,r8
8002072e:	eb e4 10 04 	or	r4,r5,r4
80020732:	c0 a1       	brne	80020746 <__ieee754_powf+0x14a>
80020734:	16 9c       	mov	r12,r11
80020736:	e0 a0 12 61 	rcall	80022bf8 <__avr32_f32_sub>
8002073a:	18 9b       	mov	r11,r12
8002073c:	e0 a0 11 ac 	rcall	80022a94 <__avr32_f32_div>
80020740:	18 97       	mov	r7,r12
80020742:	e0 8f 03 0a 	bral	80020d56 <__ieee754_powf+0x75a>
80020746:	58 15       	cp.w	r5,1
80020748:	e0 81 03 06 	brne	80020d54 <__ieee754_powf+0x758>
8002074c:	16 97       	mov	r7,r11
8002074e:	ee 17 80 00 	eorh	r7,0x8000
80020752:	e0 8f 03 02 	bral	80020d56 <__ieee754_powf+0x75a>
80020756:	d7 03       	nop
80020758:	bf 93       	lsr	r3,0x1f
8002075a:	20 13       	sub	r3,1
8002075c:	50 43       	stdsp	sp[0x10],r3
8002075e:	eb e3 10 08 	or	r8,r5,r3
80020762:	ce 90       	breq	80020734 <__ieee754_powf+0x138>
80020764:	fc 18 4d 00 	movh	r8,0x4d00
80020768:	10 32       	cp.w	r2,r8
8002076a:	e0 8a 00 6a 	brle	8002083e <__ieee754_powf+0x242>
8002076e:	e0 69 ff f7 	mov	r9,65527
80020772:	ea 19 3f 7f 	orh	r9,0x3f7f
80020776:	12 34       	cp.w	r4,r9
80020778:	e0 89 00 05 	brgt	80020782 <__ieee754_powf+0x186>
8002077c:	58 06       	cp.w	r6,0
8002077e:	c0 b4       	brge	80020794 <__ieee754_powf+0x198>
80020780:	c0 d8       	rjmp	8002079a <__ieee754_powf+0x19e>
80020782:	30 78       	mov	r8,7
80020784:	ea 18 3f 80 	orh	r8,0x3f80
80020788:	10 34       	cp.w	r4,r8
8002078a:	e0 8a 00 0f 	brle	800207a8 <__ieee754_powf+0x1ac>
8002078e:	58 06       	cp.w	r6,0
80020790:	e0 89 00 05 	brgt	8002079a <__ieee754_powf+0x19e>
80020794:	30 07       	mov	r7,0
80020796:	e0 8f 02 e0 	bral	80020d56 <__ieee754_powf+0x75a>
8002079a:	e0 6b f2 ca 	mov	r11,62154
8002079e:	ea 1b 71 49 	orh	r11,0x7149
800207a2:	16 9c       	mov	r12,r11
800207a4:	e0 8f 02 d4 	bral	80020d4c <__ieee754_powf+0x750>
800207a8:	fc 1b 3f 80 	movh	r11,0x3f80
800207ac:	e0 a0 12 26 	rcall	80022bf8 <__avr32_f32_sub>
800207b0:	e0 6b aa 00 	mov	r11,43520
800207b4:	ea 1b 3f b8 	orh	r11,0x3fb8
800207b8:	18 94       	mov	r4,r12
800207ba:	e0 a0 12 dd 	rcall	80022d74 <__avr32_f32_mul>
800207be:	e0 6b a5 70 	mov	r11,42352
800207c2:	ea 1b 36 ec 	orh	r11,0x36ec
800207c6:	18 93       	mov	r3,r12
800207c8:	08 9c       	mov	r12,r4
800207ca:	e0 a0 12 d5 	rcall	80022d74 <__avr32_f32_mul>
800207ce:	08 9b       	mov	r11,r4
800207d0:	18 92       	mov	r2,r12
800207d2:	08 9c       	mov	r12,r4
800207d4:	e0 a0 12 d0 	rcall	80022d74 <__avr32_f32_mul>
800207d8:	fc 1b be 80 	movh	r11,0xbe80
800207dc:	18 91       	mov	r1,r12
800207de:	08 9c       	mov	r12,r4
800207e0:	e0 a0 12 ca 	rcall	80022d74 <__avr32_f32_mul>
800207e4:	e0 6b aa ab 	mov	r11,43691
800207e8:	ea 1b 3e aa 	orh	r11,0x3eaa
800207ec:	e0 a0 12 6e 	rcall	80022cc8 <__avr32_f32_add>
800207f0:	18 9b       	mov	r11,r12
800207f2:	08 9c       	mov	r12,r4
800207f4:	e0 a0 12 c0 	rcall	80022d74 <__avr32_f32_mul>
800207f8:	18 9b       	mov	r11,r12
800207fa:	fc 1c 3f 00 	movh	r12,0x3f00
800207fe:	e0 a0 11 fd 	rcall	80022bf8 <__avr32_f32_sub>
80020802:	18 9b       	mov	r11,r12
80020804:	02 9c       	mov	r12,r1
80020806:	e0 a0 12 b7 	rcall	80022d74 <__avr32_f32_mul>
8002080a:	e0 6b aa 3b 	mov	r11,43579
8002080e:	ea 1b bf b8 	orh	r11,0xbfb8
80020812:	e0 a0 12 b1 	rcall	80022d74 <__avr32_f32_mul>
80020816:	18 9b       	mov	r11,r12
80020818:	04 9c       	mov	r12,r2
8002081a:	e0 a0 12 57 	rcall	80022cc8 <__avr32_f32_add>
8002081e:	18 9b       	mov	r11,r12
80020820:	18 94       	mov	r4,r12
80020822:	06 9c       	mov	r12,r3
80020824:	e0 a0 12 52 	rcall	80022cc8 <__avr32_f32_add>
80020828:	06 9b       	mov	r11,r3
8002082a:	18 91       	mov	r1,r12
8002082c:	e0 11 f0 00 	andl	r1,0xf000
80020830:	02 9c       	mov	r12,r1
80020832:	e0 a0 11 e3 	rcall	80022bf8 <__avr32_f32_sub>
80020836:	18 9b       	mov	r11,r12
80020838:	08 9c       	mov	r12,r4
8002083a:	e0 8f 01 4c 	bral	80020ad2 <__ieee754_powf+0x4d6>
8002083e:	e0 69 ff ff 	mov	r9,65535
80020842:	ea 19 00 7f 	orh	r9,0x7f
80020846:	12 34       	cp.w	r4,r9
80020848:	e0 8a 00 04 	brle	80020850 <__ieee754_powf+0x254>
8002084c:	30 08       	mov	r8,0
8002084e:	c0 78       	rjmp	8002085c <__ieee754_powf+0x260>
80020850:	fc 1b 4b 80 	movh	r11,0x4b80
80020854:	e0 a0 12 90 	rcall	80022d74 <__avr32_f32_mul>
80020858:	3e 88       	mov	r8,-24
8002085a:	18 94       	mov	r4,r12
8002085c:	f0 c9 00 7f 	sub	r9,r8,127
80020860:	f1 d4 c0 17 	bfextu	r8,r4,0x0,0x17
80020864:	b7 54       	asr	r4,0x17
80020866:	f2 04 00 04 	add	r4,r9,r4
8002086a:	50 34       	stdsp	sp[0xc],r4
8002086c:	10 93       	mov	r3,r8
8002086e:	e0 69 c4 71 	mov	r9,50289
80020872:	ea 19 00 1c 	orh	r9,0x1c
80020876:	ea 13 3f 80 	orh	r3,0x3f80
8002087a:	12 38       	cp.w	r8,r9
8002087c:	e0 8a 00 11 	brle	8002089e <__ieee754_powf+0x2a2>
80020880:	e0 69 b3 d6 	mov	r9,46038
80020884:	ea 19 00 5d 	orh	r9,0x5d
80020888:	12 38       	cp.w	r8,r9
8002088a:	e0 89 00 04 	brgt	80020892 <__ieee754_powf+0x296>
8002088e:	30 14       	mov	r4,1
80020890:	c0 88       	rjmp	800208a0 <__ieee754_powf+0x2a4>
80020892:	fc 18 ff 80 	movh	r8,0xff80
80020896:	10 03       	add	r3,r8
80020898:	40 38       	lddsp	r8,sp[0xc]
8002089a:	2f f8       	sub	r8,-1
8002089c:	50 38       	stdsp	sp[0xc],r8
8002089e:	30 04       	mov	r4,0
800208a0:	fe c8 ae 94 	sub	r8,pc,-20844
800208a4:	06 9c       	mov	r12,r3
800208a6:	f0 04 03 20 	ld.w	r0,r8[r4<<0x2]
800208aa:	00 9b       	mov	r11,r0
800208ac:	e0 a0 11 a6 	rcall	80022bf8 <__avr32_f32_sub>
800208b0:	00 9b       	mov	r11,r0
800208b2:	50 2c       	stdsp	sp[0x8],r12
800208b4:	06 9c       	mov	r12,r3
800208b6:	e0 a0 12 09 	rcall	80022cc8 <__avr32_f32_add>
800208ba:	18 9b       	mov	r11,r12
800208bc:	fc 1c 3f 80 	movh	r12,0x3f80
800208c0:	e0 a0 10 ea 	rcall	80022a94 <__avr32_f32_div>
800208c4:	18 98       	mov	r8,r12
800208c6:	18 9b       	mov	r11,r12
800208c8:	50 08       	stdsp	sp[0x0],r8
800208ca:	40 2c       	lddsp	r12,sp[0x8]
800208cc:	e0 a0 12 54 	rcall	80022d74 <__avr32_f32_mul>
800208d0:	e6 09 14 01 	asr	r9,r3,0x1
800208d4:	e8 0a 15 15 	lsl	r10,r4,0x15
800208d8:	bd b9       	sbr	r9,0x1d
800208da:	fc 2a 00 00 	sub	r10,-262144
800208de:	f4 09 00 09 	add	r9,r10,r9
800208e2:	18 92       	mov	r2,r12
800208e4:	12 9b       	mov	r11,r9
800208e6:	06 91       	mov	r1,r3
800208e8:	50 19       	stdsp	sp[0x4],r9
800208ea:	18 93       	mov	r3,r12
800208ec:	e0 13 f0 00 	andl	r3,0xf000
800208f0:	06 9c       	mov	r12,r3
800208f2:	e0 a0 12 41 	rcall	80022d74 <__avr32_f32_mul>
800208f6:	18 9b       	mov	r11,r12
800208f8:	40 2c       	lddsp	r12,sp[0x8]
800208fa:	e0 a0 11 7f 	rcall	80022bf8 <__avr32_f32_sub>
800208fe:	40 19       	lddsp	r9,sp[0x4]
80020900:	18 9a       	mov	r10,r12
80020902:	00 9b       	mov	r11,r0
80020904:	12 9c       	mov	r12,r9
80020906:	50 1a       	stdsp	sp[0x4],r10
80020908:	e0 a0 11 78 	rcall	80022bf8 <__avr32_f32_sub>
8002090c:	18 9b       	mov	r11,r12
8002090e:	02 9c       	mov	r12,r1
80020910:	e0 a0 11 74 	rcall	80022bf8 <__avr32_f32_sub>
80020914:	18 9b       	mov	r11,r12
80020916:	06 9c       	mov	r12,r3
80020918:	e0 a0 12 2e 	rcall	80022d74 <__avr32_f32_mul>
8002091c:	40 1a       	lddsp	r10,sp[0x4]
8002091e:	18 9b       	mov	r11,r12
80020920:	14 9c       	mov	r12,r10
80020922:	e0 a0 11 6b 	rcall	80022bf8 <__avr32_f32_sub>
80020926:	40 08       	lddsp	r8,sp[0x0]
80020928:	18 9b       	mov	r11,r12
8002092a:	10 9c       	mov	r12,r8
8002092c:	e0 a0 12 24 	rcall	80022d74 <__avr32_f32_mul>
80020930:	04 9b       	mov	r11,r2
80020932:	50 2c       	stdsp	sp[0x8],r12
80020934:	04 9c       	mov	r12,r2
80020936:	e0 a0 12 1f 	rcall	80022d74 <__avr32_f32_mul>
8002093a:	18 91       	mov	r1,r12
8002093c:	18 9b       	mov	r11,r12
8002093e:	e0 a0 12 1b 	rcall	80022d74 <__avr32_f32_mul>
80020942:	e0 6b f1 42 	mov	r11,61762
80020946:	ea 1b 3e 53 	orh	r11,0x3e53
8002094a:	18 90       	mov	r0,r12
8002094c:	02 9c       	mov	r12,r1
8002094e:	e0 a0 12 13 	rcall	80022d74 <__avr32_f32_mul>
80020952:	e0 6b 32 55 	mov	r11,12885
80020956:	ea 1b 3e 6c 	orh	r11,0x3e6c
8002095a:	e0 a0 11 b7 	rcall	80022cc8 <__avr32_f32_add>
8002095e:	18 9b       	mov	r11,r12
80020960:	02 9c       	mov	r12,r1
80020962:	e0 a0 12 09 	rcall	80022d74 <__avr32_f32_mul>
80020966:	e0 6b a3 05 	mov	r11,41733
8002096a:	ea 1b 3e 8b 	orh	r11,0x3e8b
8002096e:	e0 a0 11 ad 	rcall	80022cc8 <__avr32_f32_add>
80020972:	18 9b       	mov	r11,r12
80020974:	02 9c       	mov	r12,r1
80020976:	e0 a0 11 ff 	rcall	80022d74 <__avr32_f32_mul>
8002097a:	e0 6b aa ab 	mov	r11,43691
8002097e:	ea 1b 3e aa 	orh	r11,0x3eaa
80020982:	e0 a0 11 a3 	rcall	80022cc8 <__avr32_f32_add>
80020986:	18 9b       	mov	r11,r12
80020988:	02 9c       	mov	r12,r1
8002098a:	e0 a0 11 f5 	rcall	80022d74 <__avr32_f32_mul>
8002098e:	e0 6b 6d b7 	mov	r11,28087
80020992:	ea 1b 3e db 	orh	r11,0x3edb
80020996:	e0 a0 11 99 	rcall	80022cc8 <__avr32_f32_add>
8002099a:	18 9b       	mov	r11,r12
8002099c:	02 9c       	mov	r12,r1
8002099e:	e0 a0 11 eb 	rcall	80022d74 <__avr32_f32_mul>
800209a2:	e0 6b 99 9a 	mov	r11,39322
800209a6:	ea 1b 3f 19 	orh	r11,0x3f19
800209aa:	e0 a0 11 8f 	rcall	80022cc8 <__avr32_f32_add>
800209ae:	18 9b       	mov	r11,r12
800209b0:	00 9c       	mov	r12,r0
800209b2:	e0 a0 11 e1 	rcall	80022d74 <__avr32_f32_mul>
800209b6:	04 9b       	mov	r11,r2
800209b8:	18 91       	mov	r1,r12
800209ba:	06 9c       	mov	r12,r3
800209bc:	e0 a0 11 86 	rcall	80022cc8 <__avr32_f32_add>
800209c0:	18 9b       	mov	r11,r12
800209c2:	40 2c       	lddsp	r12,sp[0x8]
800209c4:	e0 a0 11 d8 	rcall	80022d74 <__avr32_f32_mul>
800209c8:	18 9b       	mov	r11,r12
800209ca:	02 9c       	mov	r12,r1
800209cc:	e0 a0 11 7e 	rcall	80022cc8 <__avr32_f32_add>
800209d0:	06 9b       	mov	r11,r3
800209d2:	18 90       	mov	r0,r12
800209d4:	06 9c       	mov	r12,r3
800209d6:	e0 a0 11 cf 	rcall	80022d74 <__avr32_f32_mul>
800209da:	c0 18       	rjmp	800209dc <__ieee754_powf+0x3e0>
800209dc:	fc 1b 40 40 	movh	r11,0x4040
800209e0:	50 0c       	stdsp	sp[0x0],r12
800209e2:	e0 a0 11 73 	rcall	80022cc8 <__avr32_f32_add>
800209e6:	00 9b       	mov	r11,r0
800209e8:	e0 a0 11 70 	rcall	80022cc8 <__avr32_f32_add>
800209ec:	18 91       	mov	r1,r12
800209ee:	06 9c       	mov	r12,r3
800209f0:	e0 11 f0 00 	andl	r1,0xf000
800209f4:	02 9b       	mov	r11,r1
800209f6:	e0 a0 11 bf 	rcall	80022d74 <__avr32_f32_mul>
800209fa:	02 9b       	mov	r11,r1
800209fc:	50 5c       	stdsp	sp[0x14],r12
800209fe:	40 2c       	lddsp	r12,sp[0x8]
80020a00:	e0 a0 11 ba 	rcall	80022d74 <__avr32_f32_mul>
80020a04:	fc 1b 40 40 	movh	r11,0x4040
80020a08:	18 93       	mov	r3,r12
80020a0a:	02 9c       	mov	r12,r1
80020a0c:	e0 a0 10 f6 	rcall	80022bf8 <__avr32_f32_sub>
80020a10:	40 08       	lddsp	r8,sp[0x0]
80020a12:	10 9b       	mov	r11,r8
80020a14:	e0 a0 10 f2 	rcall	80022bf8 <__avr32_f32_sub>
80020a18:	18 9b       	mov	r11,r12
80020a1a:	00 9c       	mov	r12,r0
80020a1c:	e0 a0 10 ee 	rcall	80022bf8 <__avr32_f32_sub>
80020a20:	04 9b       	mov	r11,r2
80020a22:	e0 a0 11 a9 	rcall	80022d74 <__avr32_f32_mul>
80020a26:	18 9b       	mov	r11,r12
80020a28:	06 9c       	mov	r12,r3
80020a2a:	e0 a0 11 4f 	rcall	80022cc8 <__avr32_f32_add>
80020a2e:	18 91       	mov	r1,r12
80020a30:	18 9b       	mov	r11,r12
80020a32:	40 5c       	lddsp	r12,sp[0x14]
80020a34:	e0 a0 11 4a 	rcall	80022cc8 <__avr32_f32_add>
80020a38:	e0 6b 38 00 	mov	r11,14336
80020a3c:	ea 1b 3f 76 	orh	r11,0x3f76
80020a40:	18 93       	mov	r3,r12
80020a42:	e0 13 f0 00 	andl	r3,0xf000
80020a46:	06 9c       	mov	r12,r3
80020a48:	e0 a0 11 96 	rcall	80022d74 <__avr32_f32_mul>
80020a4c:	e0 6b c3 a0 	mov	r11,50080
80020a50:	ea 1b 36 9d 	orh	r11,0x369d
80020a54:	18 92       	mov	r2,r12
80020a56:	06 9c       	mov	r12,r3
80020a58:	e0 a0 11 8e 	rcall	80022d74 <__avr32_f32_mul>
80020a5c:	40 5b       	lddsp	r11,sp[0x14]
80020a5e:	18 90       	mov	r0,r12
80020a60:	06 9c       	mov	r12,r3
80020a62:	e0 a0 10 cb 	rcall	80022bf8 <__avr32_f32_sub>
80020a66:	18 9b       	mov	r11,r12
80020a68:	02 9c       	mov	r12,r1
80020a6a:	e0 a0 10 c7 	rcall	80022bf8 <__avr32_f32_sub>
80020a6e:	e0 6b 38 4f 	mov	r11,14415
80020a72:	ea 1b 3f 76 	orh	r11,0x3f76
80020a76:	e0 a0 11 7f 	rcall	80022d74 <__avr32_f32_mul>
80020a7a:	18 9b       	mov	r11,r12
80020a7c:	00 9c       	mov	r12,r0
80020a7e:	e0 a0 11 25 	rcall	80022cc8 <__avr32_f32_add>
80020a82:	fe c8 b0 7e 	sub	r8,pc,-20354
80020a86:	f0 04 03 2b 	ld.w	r11,r8[r4<<0x2]
80020a8a:	e0 a0 11 1f 	rcall	80022cc8 <__avr32_f32_add>
80020a8e:	18 93       	mov	r3,r12
80020a90:	40 3c       	lddsp	r12,sp[0xc]
80020a92:	e0 a0 11 e2 	rcall	80022e56 <__avr32_s32_to_f32>
80020a96:	fe c8 b0 9a 	sub	r8,pc,-20326
80020a9a:	18 91       	mov	r1,r12
80020a9c:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80020aa0:	06 9b       	mov	r11,r3
80020aa2:	04 9c       	mov	r12,r2
80020aa4:	e0 a0 11 12 	rcall	80022cc8 <__avr32_f32_add>
80020aa8:	08 9b       	mov	r11,r4
80020aaa:	e0 a0 11 0f 	rcall	80022cc8 <__avr32_f32_add>
80020aae:	02 9b       	mov	r11,r1
80020ab0:	e0 a0 11 0c 	rcall	80022cc8 <__avr32_f32_add>
80020ab4:	02 9b       	mov	r11,r1
80020ab6:	18 91       	mov	r1,r12
80020ab8:	e0 11 f0 00 	andl	r1,0xf000
80020abc:	02 9c       	mov	r12,r1
80020abe:	e0 a0 10 9d 	rcall	80022bf8 <__avr32_f32_sub>
80020ac2:	08 9b       	mov	r11,r4
80020ac4:	e0 a0 10 9a 	rcall	80022bf8 <__avr32_f32_sub>
80020ac8:	04 9b       	mov	r11,r2
80020aca:	e0 a0 10 97 	rcall	80022bf8 <__avr32_f32_sub>
80020ace:	18 9b       	mov	r11,r12
80020ad0:	06 9c       	mov	r12,r3
80020ad2:	e0 a0 10 93 	rcall	80022bf8 <__avr32_f32_sub>
80020ad6:	40 49       	lddsp	r9,sp[0x10]
80020ad8:	fc 18 bf 80 	movh	r8,0xbf80
80020adc:	20 15       	sub	r5,1
80020ade:	12 45       	or	r5,r9
80020ae0:	fc 19 3f 80 	movh	r9,0x3f80
80020ae4:	18 94       	mov	r4,r12
80020ae6:	58 05       	cp.w	r5,0
80020ae8:	f0 05 17 00 	moveq	r5,r8
80020aec:	f2 05 17 10 	movne	r5,r9
80020af0:	e0 16 f0 00 	andl	r6,0xf000
80020af4:	0e 9c       	mov	r12,r7
80020af6:	0c 9b       	mov	r11,r6
80020af8:	e0 a0 10 80 	rcall	80022bf8 <__avr32_f32_sub>
80020afc:	02 9b       	mov	r11,r1
80020afe:	e0 a0 11 3b 	rcall	80022d74 <__avr32_f32_mul>
80020b02:	08 9b       	mov	r11,r4
80020b04:	18 93       	mov	r3,r12
80020b06:	0e 9c       	mov	r12,r7
80020b08:	e0 a0 11 36 	rcall	80022d74 <__avr32_f32_mul>
80020b0c:	18 9b       	mov	r11,r12
80020b0e:	06 9c       	mov	r12,r3
80020b10:	e0 a0 10 dc 	rcall	80022cc8 <__avr32_f32_add>
80020b14:	02 9b       	mov	r11,r1
80020b16:	18 94       	mov	r4,r12
80020b18:	0c 9c       	mov	r12,r6
80020b1a:	e0 a0 11 2d 	rcall	80022d74 <__avr32_f32_mul>
80020b1e:	18 93       	mov	r3,r12
80020b20:	08 9c       	mov	r12,r4
80020b22:	06 9b       	mov	r11,r3
80020b24:	06 91       	mov	r1,r3
80020b26:	e0 a0 10 d1 	rcall	80022cc8 <__avr32_f32_add>
80020b2a:	18 96       	mov	r6,r12
80020b2c:	18 92       	mov	r2,r12
80020b2e:	ef dc c0 1f 	bfextu	r7,r12,0x0,0x1f
80020b32:	58 0c       	cp.w	r12,0
80020b34:	e0 8a 00 27 	brle	80020b82 <__ieee754_powf+0x586>
80020b38:	fc 18 43 00 	movh	r8,0x4300
80020b3c:	10 37       	cp.w	r7,r8
80020b3e:	e0 89 00 16 	brgt	80020b6a <__ieee754_powf+0x56e>
80020b42:	fc 19 43 00 	movh	r9,0x4300
80020b46:	12 37       	cp.w	r7,r9
80020b48:	c3 a1       	brne	80020bbc <__ieee754_powf+0x5c0>
80020b4a:	e0 6b aa 3c 	mov	r11,43580
80020b4e:	ea 1b 33 38 	orh	r11,0x3338
80020b52:	08 9c       	mov	r12,r4
80020b54:	e0 a0 10 ba 	rcall	80022cc8 <__avr32_f32_add>
80020b58:	06 9b       	mov	r11,r3
80020b5a:	18 91       	mov	r1,r12
80020b5c:	0c 9c       	mov	r12,r6
80020b5e:	e0 a0 10 4d 	rcall	80022bf8 <__avr32_f32_sub>
80020b62:	02 9b       	mov	r11,r1
80020b64:	e0 a0 0d f2 	rcall	80022748 <__avr32_f32_cmp_lt>
80020b68:	c3 10       	breq	80020bca <__ieee754_powf+0x5ce>
80020b6a:	e0 6b f2 ca 	mov	r11,62154
80020b6e:	ea 1b 71 49 	orh	r11,0x7149
80020b72:	0a 9c       	mov	r12,r5
80020b74:	e0 a0 11 00 	rcall	80022d74 <__avr32_f32_mul>
80020b78:	e0 6b f2 ca 	mov	r11,62154
80020b7c:	ea 1b 71 49 	orh	r11,0x7149
80020b80:	ce 68       	rjmp	80020d4c <__ieee754_powf+0x750>
80020b82:	fc 18 43 16 	movh	r8,0x4316
80020b86:	10 37       	cp.w	r7,r8
80020b88:	e0 89 00 0d 	brgt	80020ba2 <__ieee754_powf+0x5a6>
80020b8c:	fc 19 43 16 	movh	r9,0x4316
80020b90:	12 37       	cp.w	r7,r9
80020b92:	c1 51       	brne	80020bbc <__ieee754_powf+0x5c0>
80020b94:	06 9b       	mov	r11,r3
80020b96:	e0 a0 10 31 	rcall	80022bf8 <__avr32_f32_sub>
80020b9a:	08 9b       	mov	r11,r4
80020b9c:	e0 a0 0d bc 	rcall	80022714 <__avr32_f32_cmp_ge>
80020ba0:	c1 50       	breq	80020bca <__ieee754_powf+0x5ce>
80020ba2:	e0 6b 42 60 	mov	r11,16992
80020ba6:	ea 1b 0d a2 	orh	r11,0xda2
80020baa:	0a 9c       	mov	r12,r5
80020bac:	e0 a0 10 e4 	rcall	80022d74 <__avr32_f32_mul>
80020bb0:	e0 6b 42 60 	mov	r11,16992
80020bb4:	ea 1b 0d a2 	orh	r11,0xda2
80020bb8:	cc a8       	rjmp	80020d4c <__ieee754_powf+0x750>
80020bba:	d7 03       	nop
80020bbc:	fc 18 3f 00 	movh	r8,0x3f00
80020bc0:	10 37       	cp.w	r7,r8
80020bc2:	e0 89 00 04 	brgt	80020bca <__ieee754_powf+0x5ce>
80020bc6:	30 06       	mov	r6,0
80020bc8:	c2 28       	rjmp	80020c0c <__ieee754_powf+0x610>
80020bca:	fc 18 00 80 	movh	r8,0x80
80020bce:	e0 6b ff ff 	mov	r11,65535
80020bd2:	ea 1b 00 7f 	orh	r11,0x7f
80020bd6:	b7 57       	asr	r7,0x17
80020bd8:	27 e7       	sub	r7,126
80020bda:	f0 07 08 47 	asr	r7,r8,r7
80020bde:	04 07       	add	r7,r2
80020be0:	f1 d7 c2 e8 	bfextu	r8,r7,0x17,0x8
80020be4:	f3 d7 c0 17 	bfextu	r9,r7,0x0,0x17
80020be8:	27 f8       	sub	r8,127
80020bea:	b7 b9       	sbr	r9,0x17
80020bec:	f0 06 11 17 	rsub	r6,r8,23
80020bf0:	f6 08 08 48 	asr	r8,r11,r8
80020bf4:	f2 06 08 46 	asr	r6,r9,r6
80020bf8:	f0 0b 11 ff 	rsub	r11,r8,-1
80020bfc:	06 9c       	mov	r12,r3
80020bfe:	0e 6b       	and	r11,r7
80020c00:	58 02       	cp.w	r2,0
80020c02:	fb b6 05 00 	rsublt	r6,0
80020c06:	e0 a0 0f f9 	rcall	80022bf8 <__avr32_f32_sub>
80020c0a:	18 91       	mov	r1,r12
80020c0c:	02 9b       	mov	r11,r1
80020c0e:	08 9c       	mov	r12,r4
80020c10:	e0 a0 10 5c 	rcall	80022cc8 <__avr32_f32_add>
80020c14:	e0 6b 72 00 	mov	r11,29184
80020c18:	ea 1b 3f 31 	orh	r11,0x3f31
80020c1c:	18 97       	mov	r7,r12
80020c1e:	e0 17 f0 00 	andl	r7,0xf000
80020c22:	0e 9c       	mov	r12,r7
80020c24:	e0 a0 10 a8 	rcall	80022d74 <__avr32_f32_mul>
80020c28:	02 9b       	mov	r11,r1
80020c2a:	18 93       	mov	r3,r12
80020c2c:	0e 9c       	mov	r12,r7
80020c2e:	e0 a0 0f e5 	rcall	80022bf8 <__avr32_f32_sub>
80020c32:	18 9b       	mov	r11,r12
80020c34:	08 9c       	mov	r12,r4
80020c36:	e0 a0 0f e1 	rcall	80022bf8 <__avr32_f32_sub>
80020c3a:	e0 6b 72 18 	mov	r11,29208
80020c3e:	ea 1b 3f 31 	orh	r11,0x3f31
80020c42:	e0 a0 10 99 	rcall	80022d74 <__avr32_f32_mul>
80020c46:	e0 6b be 8c 	mov	r11,48780
80020c4a:	ea 1b 35 bf 	orh	r11,0x35bf
80020c4e:	18 94       	mov	r4,r12
80020c50:	0e 9c       	mov	r12,r7
80020c52:	e0 a0 10 91 	rcall	80022d74 <__avr32_f32_mul>
80020c56:	18 9b       	mov	r11,r12
80020c58:	08 9c       	mov	r12,r4
80020c5a:	e0 a0 10 37 	rcall	80022cc8 <__avr32_f32_add>
80020c5e:	18 94       	mov	r4,r12
80020c60:	18 9b       	mov	r11,r12
80020c62:	06 9c       	mov	r12,r3
80020c64:	e0 a0 10 32 	rcall	80022cc8 <__avr32_f32_add>
80020c68:	06 9b       	mov	r11,r3
80020c6a:	18 97       	mov	r7,r12
80020c6c:	e0 a0 0f c6 	rcall	80022bf8 <__avr32_f32_sub>
80020c70:	18 9b       	mov	r11,r12
80020c72:	08 9c       	mov	r12,r4
80020c74:	e0 a0 0f c2 	rcall	80022bf8 <__avr32_f32_sub>
80020c78:	0e 9b       	mov	r11,r7
80020c7a:	18 93       	mov	r3,r12
80020c7c:	0e 9c       	mov	r12,r7
80020c7e:	e0 a0 10 7b 	rcall	80022d74 <__avr32_f32_mul>
80020c82:	e0 6b bb 4c 	mov	r11,47948
80020c86:	ea 1b 33 31 	orh	r11,0x3331
80020c8a:	18 94       	mov	r4,r12
80020c8c:	e0 a0 10 74 	rcall	80022d74 <__avr32_f32_mul>
80020c90:	e0 6b ea 0e 	mov	r11,59918
80020c94:	ea 1b 35 dd 	orh	r11,0x35dd
80020c98:	e0 a0 0f b0 	rcall	80022bf8 <__avr32_f32_sub>
80020c9c:	18 9b       	mov	r11,r12
80020c9e:	08 9c       	mov	r12,r4
80020ca0:	e0 a0 10 6a 	rcall	80022d74 <__avr32_f32_mul>
80020ca4:	e0 6b b3 55 	mov	r11,45909
80020ca8:	ea 1b 38 8a 	orh	r11,0x388a
80020cac:	e0 a0 10 0e 	rcall	80022cc8 <__avr32_f32_add>
80020cb0:	18 9b       	mov	r11,r12
80020cb2:	08 9c       	mov	r12,r4
80020cb4:	e0 a0 10 60 	rcall	80022d74 <__avr32_f32_mul>
80020cb8:	e0 6b 0b 61 	mov	r11,2913
80020cbc:	ea 1b 3b 36 	orh	r11,0x3b36
80020cc0:	e0 a0 0f 9c 	rcall	80022bf8 <__avr32_f32_sub>
80020cc4:	18 9b       	mov	r11,r12
80020cc6:	08 9c       	mov	r12,r4
80020cc8:	e0 a0 10 56 	rcall	80022d74 <__avr32_f32_mul>
80020ccc:	e0 6b aa ab 	mov	r11,43691
80020cd0:	ea 1b 3e 2a 	orh	r11,0x3e2a
80020cd4:	e0 a0 0f fa 	rcall	80022cc8 <__avr32_f32_add>
80020cd8:	18 9b       	mov	r11,r12
80020cda:	08 9c       	mov	r12,r4
80020cdc:	e0 a0 10 4c 	rcall	80022d74 <__avr32_f32_mul>
80020ce0:	18 9b       	mov	r11,r12
80020ce2:	0e 9c       	mov	r12,r7
80020ce4:	e0 a0 0f 8a 	rcall	80022bf8 <__avr32_f32_sub>
80020ce8:	18 94       	mov	r4,r12
80020cea:	18 9b       	mov	r11,r12
80020cec:	0e 9c       	mov	r12,r7
80020cee:	e0 a0 10 43 	rcall	80022d74 <__avr32_f32_mul>
80020cf2:	fc 1b 40 00 	movh	r11,0x4000
80020cf6:	18 92       	mov	r2,r12
80020cf8:	08 9c       	mov	r12,r4
80020cfa:	e0 a0 0f 7f 	rcall	80022bf8 <__avr32_f32_sub>
80020cfe:	18 9b       	mov	r11,r12
80020d00:	04 9c       	mov	r12,r2
80020d02:	e0 a0 0e c9 	rcall	80022a94 <__avr32_f32_div>
80020d06:	06 9b       	mov	r11,r3
80020d08:	18 94       	mov	r4,r12
80020d0a:	0e 9c       	mov	r12,r7
80020d0c:	e0 a0 10 34 	rcall	80022d74 <__avr32_f32_mul>
80020d10:	18 9b       	mov	r11,r12
80020d12:	06 9c       	mov	r12,r3
80020d14:	e0 a0 0f da 	rcall	80022cc8 <__avr32_f32_add>
80020d18:	18 9b       	mov	r11,r12
80020d1a:	08 9c       	mov	r12,r4
80020d1c:	e0 a0 0f 6e 	rcall	80022bf8 <__avr32_f32_sub>
80020d20:	0e 9b       	mov	r11,r7
80020d22:	e0 a0 0f 6b 	rcall	80022bf8 <__avr32_f32_sub>
80020d26:	18 9b       	mov	r11,r12
80020d28:	fc 1c 3f 80 	movh	r12,0x3f80
80020d2c:	e0 a0 0f 66 	rcall	80022bf8 <__avr32_f32_sub>
80020d30:	ec 0b 15 17 	lsl	r11,r6,0x17
80020d34:	f8 0b 00 0b 	add	r11,r12,r11
80020d38:	f6 08 14 17 	asr	r8,r11,0x17
80020d3c:	58 08       	cp.w	r8,0
80020d3e:	e0 89 00 06 	brgt	80020d4a <__ieee754_powf+0x74e>
80020d42:	0c 9b       	mov	r11,r6
80020d44:	e0 a0 08 9a 	rcall	80021e78 <scalbnf>
80020d48:	18 9b       	mov	r11,r12
80020d4a:	0a 9c       	mov	r12,r5
80020d4c:	e0 a0 10 14 	rcall	80022d74 <__avr32_f32_mul>
80020d50:	fe 9f fc f8 	bral	80020740 <__ieee754_powf+0x144>
80020d54:	16 97       	mov	r7,r11
80020d56:	0e 9c       	mov	r12,r7
80020d58:	2f ad       	sub	sp,-24
80020d5a:	d8 32       	popm	r0-r7,pc
80020d5c:	30 05       	mov	r5,0
80020d5e:	fe 9f fc ad 	bral	800206b8 <__ieee754_powf+0xbc>
80020d62:	d7 03       	nop

80020d64 <__ieee754_rem_pio2f>:
80020d64:	d4 31       	pushm	r0-r7,lr
80020d66:	20 3d       	sub	sp,12
80020d68:	e0 68 0f d8 	mov	r8,4056
80020d6c:	ea 18 3f 49 	orh	r8,0x3f49
80020d70:	16 96       	mov	r6,r11
80020d72:	18 95       	mov	r5,r12
80020d74:	18 9b       	mov	r11,r12
80020d76:	e7 dc c0 1f 	bfextu	r3,r12,0x0,0x1f
80020d7a:	10 33       	cp.w	r3,r8
80020d7c:	e0 89 00 08 	brgt	80020d8c <__ieee754_rem_pio2f+0x28>
80020d80:	30 08       	mov	r8,0
80020d82:	8d 0c       	st.w	r6[0x0],r12
80020d84:	8d 18       	st.w	r6[0x4],r8
80020d86:	30 04       	mov	r4,0
80020d88:	e0 8f 01 8c 	bral	800210a0 <__ieee754_rem_pio2f+0x33c>
80020d8c:	e0 68 cb e3 	mov	r8,52195
80020d90:	ea 18 40 16 	orh	r8,0x4016
80020d94:	10 33       	cp.w	r3,r8
80020d96:	e0 89 00 7d 	brgt	80020e90 <__ieee754_rem_pio2f+0x12c>
80020d9a:	18 97       	mov	r7,r12
80020d9c:	e4 17 7f ff 	andh	r7,0x7fff
80020da0:	e0 17 ff f0 	andl	r7,0xfff0
80020da4:	58 0c       	cp.w	r12,0
80020da6:	e0 8a 00 3b 	brle	80020e1c <__ieee754_rem_pio2f+0xb8>
80020daa:	e0 6b 0f 80 	mov	r11,3968
80020dae:	ea 1b 3f c9 	orh	r11,0x3fc9
80020db2:	e0 a0 0f 23 	rcall	80022bf8 <__avr32_f32_sub>
80020db6:	e0 68 0f d0 	mov	r8,4048
80020dba:	ea 18 3f c9 	orh	r8,0x3fc9
80020dbe:	18 95       	mov	r5,r12
80020dc0:	10 37       	cp.w	r7,r8
80020dc2:	c1 20       	breq	80020de6 <__ieee754_rem_pio2f+0x82>
80020dc4:	e0 6b 44 43 	mov	r11,17475
80020dc8:	ea 1b 37 35 	orh	r11,0x3735
80020dcc:	e0 a0 0f 16 	rcall	80022bf8 <__avr32_f32_sub>
80020dd0:	18 98       	mov	r8,r12
80020dd2:	0a 9c       	mov	r12,r5
80020dd4:	10 9b       	mov	r11,r8
80020dd6:	8d 08       	st.w	r6[0x0],r8
80020dd8:	e0 a0 0f 10 	rcall	80022bf8 <__avr32_f32_sub>
80020ddc:	e0 6b 44 43 	mov	r11,17475
80020de0:	ea 1b 37 35 	orh	r11,0x3735
80020de4:	c1 88       	rjmp	80020e14 <__ieee754_rem_pio2f+0xb0>
80020de6:	e0 6b 44 00 	mov	r11,17408
80020dea:	ea 1b 37 35 	orh	r11,0x3735
80020dee:	e0 a0 0f 05 	rcall	80022bf8 <__avr32_f32_sub>
80020df2:	e0 6b a3 08 	mov	r11,41736
80020df6:	ea 1b 2e 85 	orh	r11,0x2e85
80020dfa:	18 97       	mov	r7,r12
80020dfc:	e0 a0 0e fe 	rcall	80022bf8 <__avr32_f32_sub>
80020e00:	18 98       	mov	r8,r12
80020e02:	0e 9c       	mov	r12,r7
80020e04:	10 9b       	mov	r11,r8
80020e06:	8d 08       	st.w	r6[0x0],r8
80020e08:	e0 a0 0e f8 	rcall	80022bf8 <__avr32_f32_sub>
80020e0c:	e0 6b a3 08 	mov	r11,41736
80020e10:	ea 1b 2e 85 	orh	r11,0x2e85
80020e14:	30 14       	mov	r4,1
80020e16:	e0 a0 0e f1 	rcall	80022bf8 <__avr32_f32_sub>
80020e1a:	c2 18       	rjmp	80020e5c <__ieee754_rem_pio2f+0xf8>
80020e1c:	e0 6b 0f 80 	mov	r11,3968
80020e20:	ea 1b 3f c9 	orh	r11,0x3fc9
80020e24:	e0 a0 0f 52 	rcall	80022cc8 <__avr32_f32_add>
80020e28:	e0 68 0f d0 	mov	r8,4048
80020e2c:	ea 18 3f c9 	orh	r8,0x3fc9
80020e30:	18 95       	mov	r5,r12
80020e32:	10 37       	cp.w	r7,r8
80020e34:	c1 60       	breq	80020e60 <__ieee754_rem_pio2f+0xfc>
80020e36:	e0 6b 44 43 	mov	r11,17475
80020e3a:	ea 1b 37 35 	orh	r11,0x3735
80020e3e:	e0 a0 0f 45 	rcall	80022cc8 <__avr32_f32_add>
80020e42:	18 98       	mov	r8,r12
80020e44:	0a 9c       	mov	r12,r5
80020e46:	10 9b       	mov	r11,r8
80020e48:	8d 08       	st.w	r6[0x0],r8
80020e4a:	e0 a0 0e d7 	rcall	80022bf8 <__avr32_f32_sub>
80020e4e:	e0 6b 44 43 	mov	r11,17475
80020e52:	ea 1b 37 35 	orh	r11,0x3735
80020e56:	3f f4       	mov	r4,-1
80020e58:	e0 a0 0f 38 	rcall	80022cc8 <__avr32_f32_add>
80020e5c:	8d 1c       	st.w	r6[0x4],r12
80020e5e:	c2 19       	rjmp	800210a0 <__ieee754_rem_pio2f+0x33c>
80020e60:	e0 6b 44 00 	mov	r11,17408
80020e64:	ea 1b 37 35 	orh	r11,0x3735
80020e68:	e0 a0 0f 30 	rcall	80022cc8 <__avr32_f32_add>
80020e6c:	e0 6b a3 08 	mov	r11,41736
80020e70:	ea 1b 2e 85 	orh	r11,0x2e85
80020e74:	18 97       	mov	r7,r12
80020e76:	e0 a0 0f 29 	rcall	80022cc8 <__avr32_f32_add>
80020e7a:	18 98       	mov	r8,r12
80020e7c:	0e 9c       	mov	r12,r7
80020e7e:	10 9b       	mov	r11,r8
80020e80:	8d 08       	st.w	r6[0x0],r8
80020e82:	e0 a0 0e bb 	rcall	80022bf8 <__avr32_f32_sub>
80020e86:	e0 6b a3 08 	mov	r11,41736
80020e8a:	ea 1b 2e 85 	orh	r11,0x2e85
80020e8e:	ce 4b       	rjmp	80020e56 <__ieee754_rem_pio2f+0xf2>
80020e90:	e0 68 0f 80 	mov	r8,3968
80020e94:	ea 18 43 49 	orh	r8,0x4349
80020e98:	10 33       	cp.w	r3,r8
80020e9a:	e0 89 00 ad 	brgt	80020ff4 <__ieee754_rem_pio2f+0x290>
80020e9e:	e0 a0 07 89 	rcall	80021db0 <fabsf>
80020ea2:	e0 6b f9 84 	mov	r11,63876
80020ea6:	ea 1b 3f 22 	orh	r11,0x3f22
80020eaa:	18 97       	mov	r7,r12
80020eac:	e0 a0 0f 64 	rcall	80022d74 <__avr32_f32_mul>
80020eb0:	fc 1b 3f 00 	movh	r11,0x3f00
80020eb4:	e0 a0 0f 0a 	rcall	80022cc8 <__avr32_f32_add>
80020eb8:	e0 a0 10 09 	rcall	80022eca <__avr32_f32_to_s32>
80020ebc:	18 94       	mov	r4,r12
80020ebe:	e0 a0 0f cc 	rcall	80022e56 <__avr32_s32_to_f32>
80020ec2:	e0 6b 0f 80 	mov	r11,3968
80020ec6:	ea 1b bf c9 	orh	r11,0xbfc9
80020eca:	18 91       	mov	r1,r12
80020ecc:	e0 a0 0f 54 	rcall	80022d74 <__avr32_f32_mul>
80020ed0:	18 9b       	mov	r11,r12
80020ed2:	0e 9c       	mov	r12,r7
80020ed4:	e0 a0 0e fa 	rcall	80022cc8 <__avr32_f32_add>
80020ed8:	e0 6b 44 43 	mov	r11,17475
80020edc:	ea 1b 37 35 	orh	r11,0x3735
80020ee0:	18 97       	mov	r7,r12
80020ee2:	02 9c       	mov	r12,r1
80020ee4:	e0 a0 0f 48 	rcall	80022d74 <__avr32_f32_mul>
80020ee8:	18 92       	mov	r2,r12
80020eea:	59 f4       	cp.w	r4,31
80020eec:	e0 89 00 0f 	brgt	80020f0a <__ieee754_rem_pio2f+0x1a6>
80020ef0:	e8 c9 00 01 	sub	r9,r4,1
80020ef4:	fe c8 b4 e0 	sub	r8,pc,-19232
80020ef8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80020efc:	0a 99       	mov	r9,r5
80020efe:	e4 19 7f ff 	andh	r9,0x7fff
80020f02:	e0 19 ff 00 	andl	r9,0xff00
80020f06:	10 39       	cp.w	r9,r8
80020f08:	c5 b1       	brne	80020fbe <__ieee754_rem_pio2f+0x25a>
80020f0a:	04 9b       	mov	r11,r2
80020f0c:	0e 9c       	mov	r12,r7
80020f0e:	e0 a0 0e 75 	rcall	80022bf8 <__avr32_f32_sub>
80020f12:	8d 0c       	st.w	r6[0x0],r12
80020f14:	b7 53       	asr	r3,0x17
80020f16:	f9 dc c2 e8 	bfextu	r12,r12,0x17,0x8
80020f1a:	e6 0c 01 0c 	sub	r12,r3,r12
80020f1e:	58 8c       	cp.w	r12,8
80020f20:	e0 8a 00 54 	brle	80020fc8 <__ieee754_rem_pio2f+0x264>
80020f24:	e0 6b 44 00 	mov	r11,17408
80020f28:	ea 1b 37 35 	orh	r11,0x3735
80020f2c:	02 9c       	mov	r12,r1
80020f2e:	e0 a0 0f 23 	rcall	80022d74 <__avr32_f32_mul>
80020f32:	18 92       	mov	r2,r12
80020f34:	18 9b       	mov	r11,r12
80020f36:	0e 9c       	mov	r12,r7
80020f38:	e0 a0 0e 60 	rcall	80022bf8 <__avr32_f32_sub>
80020f3c:	18 9b       	mov	r11,r12
80020f3e:	18 90       	mov	r0,r12
80020f40:	0e 9c       	mov	r12,r7
80020f42:	e0 a0 0e 5b 	rcall	80022bf8 <__avr32_f32_sub>
80020f46:	04 9b       	mov	r11,r2
80020f48:	e0 a0 0e 58 	rcall	80022bf8 <__avr32_f32_sub>
80020f4c:	e0 6b a3 08 	mov	r11,41736
80020f50:	ea 1b 2e 85 	orh	r11,0x2e85
80020f54:	18 97       	mov	r7,r12
80020f56:	02 9c       	mov	r12,r1
80020f58:	e0 a0 0f 0e 	rcall	80022d74 <__avr32_f32_mul>
80020f5c:	0e 9b       	mov	r11,r7
80020f5e:	e0 a0 0e 4d 	rcall	80022bf8 <__avr32_f32_sub>
80020f62:	18 9b       	mov	r11,r12
80020f64:	18 92       	mov	r2,r12
80020f66:	00 9c       	mov	r12,r0
80020f68:	e0 a0 0e 48 	rcall	80022bf8 <__avr32_f32_sub>
80020f6c:	8d 0c       	st.w	r6[0x0],r12
80020f6e:	f9 dc c2 e8 	bfextu	r12,r12,0x17,0x8
80020f72:	18 13       	sub	r3,r12
80020f74:	59 93       	cp.w	r3,25
80020f76:	e0 89 00 04 	brgt	80020f7e <__ieee754_rem_pio2f+0x21a>
80020f7a:	00 97       	mov	r7,r0
80020f7c:	c2 68       	rjmp	80020fc8 <__ieee754_rem_pio2f+0x264>
80020f7e:	e0 6b a3 00 	mov	r11,41728
80020f82:	ea 1b 2e 85 	orh	r11,0x2e85
80020f86:	02 9c       	mov	r12,r1
80020f88:	e0 a0 0e f6 	rcall	80022d74 <__avr32_f32_mul>
80020f8c:	18 93       	mov	r3,r12
80020f8e:	18 9b       	mov	r11,r12
80020f90:	00 9c       	mov	r12,r0
80020f92:	e0 a0 0e 33 	rcall	80022bf8 <__avr32_f32_sub>
80020f96:	18 97       	mov	r7,r12
80020f98:	18 9b       	mov	r11,r12
80020f9a:	00 9c       	mov	r12,r0
80020f9c:	e0 a0 0e 2e 	rcall	80022bf8 <__avr32_f32_sub>
80020fa0:	06 9b       	mov	r11,r3
80020fa2:	e0 a0 0e 2b 	rcall	80022bf8 <__avr32_f32_sub>
80020fa6:	e0 6b 31 32 	mov	r11,12594
80020faa:	ea 1b 24 8d 	orh	r11,0x248d
80020fae:	18 93       	mov	r3,r12
80020fb0:	02 9c       	mov	r12,r1
80020fb2:	e0 a0 0e e1 	rcall	80022d74 <__avr32_f32_mul>
80020fb6:	06 9b       	mov	r11,r3
80020fb8:	e0 a0 0e 20 	rcall	80022bf8 <__avr32_f32_sub>
80020fbc:	18 92       	mov	r2,r12
80020fbe:	04 9b       	mov	r11,r2
80020fc0:	0e 9c       	mov	r12,r7
80020fc2:	e0 a0 0e 1b 	rcall	80022bf8 <__avr32_f32_sub>
80020fc6:	8d 0c       	st.w	r6[0x0],r12
80020fc8:	6c 0b       	ld.w	r11,r6[0x0]
80020fca:	0e 9c       	mov	r12,r7
80020fcc:	ec c7 ff fc 	sub	r7,r6,-4
80020fd0:	e0 a0 0e 14 	rcall	80022bf8 <__avr32_f32_sub>
80020fd4:	04 9b       	mov	r11,r2
80020fd6:	e0 a0 0e 11 	rcall	80022bf8 <__avr32_f32_sub>
80020fda:	8f 0c       	st.w	r7[0x0],r12
80020fdc:	58 05       	cp.w	r5,0
80020fde:	c6 14       	brge	800210a0 <__ieee754_rem_pio2f+0x33c>
80020fe0:	6c 08       	ld.w	r8,r6[0x0]
80020fe2:	ee 18 80 00 	eorh	r8,0x8000
80020fe6:	8d 08       	st.w	r6[0x0],r8
80020fe8:	5c 34       	neg	r4
80020fea:	6e 08       	ld.w	r8,r7[0x0]
80020fec:	ee 18 80 00 	eorh	r8,0x8000
80020ff0:	8f 08       	st.w	r7[0x0],r8
80020ff2:	c5 78       	rjmp	800210a0 <__ieee754_rem_pio2f+0x33c>
80020ff4:	e0 68 ff ff 	mov	r8,65535
80020ff8:	ea 18 7f 7f 	orh	r8,0x7f7f
80020ffc:	10 33       	cp.w	r3,r8
80020ffe:	e0 8a 00 07 	brle	8002100c <__ieee754_rem_pio2f+0x2a8>
80021002:	e0 a0 0d fb 	rcall	80022bf8 <__avr32_f32_sub>
80021006:	30 04       	mov	r4,0
80021008:	8d 0c       	st.w	r6[0x0],r12
8002100a:	c2 9b       	rjmp	80020e5c <__ieee754_rem_pio2f+0xf8>
8002100c:	e6 04 14 17 	asr	r4,r3,0x17
80021010:	e8 c4 00 86 	sub	r4,r4,134
80021014:	e8 08 15 17 	lsl	r8,r4,0x17
80021018:	10 13       	sub	r3,r8
8002101a:	06 9c       	mov	r12,r3
8002101c:	e0 a0 0f 57 	rcall	80022eca <__avr32_f32_to_s32>
80021020:	e0 a0 0f 1b 	rcall	80022e56 <__avr32_s32_to_f32>
80021024:	18 98       	mov	r8,r12
80021026:	06 9c       	mov	r12,r3
80021028:	10 9b       	mov	r11,r8
8002102a:	50 08       	stdsp	sp[0x0],r8
8002102c:	e0 a0 0d e6 	rcall	80022bf8 <__avr32_f32_sub>
80021030:	fc 1b 43 80 	movh	r11,0x4380
80021034:	e0 a0 0e a0 	rcall	80022d74 <__avr32_f32_mul>
80021038:	18 97       	mov	r7,r12
8002103a:	e0 a0 0f 48 	rcall	80022eca <__avr32_f32_to_s32>
8002103e:	e0 a0 0f 0c 	rcall	80022e56 <__avr32_s32_to_f32>
80021042:	18 98       	mov	r8,r12
80021044:	0e 9c       	mov	r12,r7
80021046:	10 9b       	mov	r11,r8
80021048:	50 18       	stdsp	sp[0x4],r8
8002104a:	e0 a0 0d d7 	rcall	80022bf8 <__avr32_f32_sub>
8002104e:	fc 1b 43 80 	movh	r11,0x4380
80021052:	30 33       	mov	r3,3
80021054:	e0 a0 0e 90 	rcall	80022d74 <__avr32_f32_mul>
80021058:	fa c7 ff f4 	sub	r7,sp,-12
8002105c:	0e dc       	st.w	--r7,r12
8002105e:	6e 0c       	ld.w	r12,r7[0x0]
80021060:	06 92       	mov	r2,r3
80021062:	20 47       	sub	r7,4
80021064:	20 13       	sub	r3,1
80021066:	30 0b       	mov	r11,0
80021068:	e0 a0 0b 4a 	rcall	800226fc <__avr32_f32_cmp_eq>
8002106c:	cf 91       	brne	8002105e <__ieee754_rem_pio2f+0x2fa>
8002106e:	fe c8 b5 da 	sub	r8,pc,-18982
80021072:	08 9a       	mov	r10,r4
80021074:	1a d8       	st.w	--sp,r8
80021076:	04 99       	mov	r9,r2
80021078:	fa cc ff fc 	sub	r12,sp,-4
8002107c:	30 28       	mov	r8,2
8002107e:	0c 9b       	mov	r11,r6
80021080:	e0 a0 03 3a 	rcall	800216f4 <__kernel_rem_pio2f>
80021084:	2f fd       	sub	sp,-4
80021086:	18 94       	mov	r4,r12
80021088:	58 05       	cp.w	r5,0
8002108a:	c0 b4       	brge	800210a0 <__ieee754_rem_pio2f+0x33c>
8002108c:	6c 09       	ld.w	r9,r6[0x0]
8002108e:	ee 19 80 00 	eorh	r9,0x8000
80021092:	0c 98       	mov	r8,r6
80021094:	5c 34       	neg	r4
80021096:	10 a9       	st.w	r8++,r9
80021098:	70 09       	ld.w	r9,r8[0x0]
8002109a:	ee 19 80 00 	eorh	r9,0x8000
8002109e:	91 09       	st.w	r8[0x0],r9
800210a0:	08 9c       	mov	r12,r4
800210a2:	2f dd       	sub	sp,-12
800210a4:	d8 32       	popm	r0-r7,pc
800210a6:	d7 03       	nop

800210a8 <__ieee754_sqrtf>:
800210a8:	d4 21       	pushm	r4-r7,lr
800210aa:	e0 6b ff ff 	mov	r11,65535
800210ae:	ea 1b 7f 7f 	orh	r11,0x7f7f
800210b2:	18 97       	mov	r7,r12
800210b4:	18 98       	mov	r8,r12
800210b6:	f3 dc c0 1f 	bfextu	r9,r12,0x0,0x1f
800210ba:	16 39       	cp.w	r9,r11
800210bc:	e0 88 00 0a 	brls	800210d0 <__ieee754_sqrtf+0x28>
800210c0:	18 9b       	mov	r11,r12
800210c2:	e0 a0 0e 59 	rcall	80022d74 <__avr32_f32_mul>
800210c6:	18 9b       	mov	r11,r12
800210c8:	0e 9c       	mov	r12,r7
800210ca:	e0 a0 0d ff 	rcall	80022cc8 <__avr32_f32_add>
800210ce:	c0 b8       	rjmp	800210e4 <__ieee754_sqrtf+0x3c>
800210d0:	58 09       	cp.w	r9,0
800210d2:	c4 c0       	breq	8002116a <__ieee754_sqrtf+0xc2>
800210d4:	58 0c       	cp.w	r12,0
800210d6:	c0 94       	brge	800210e8 <__ieee754_sqrtf+0x40>
800210d8:	18 9b       	mov	r11,r12
800210da:	e0 a0 0d 8f 	rcall	80022bf8 <__avr32_f32_sub>
800210de:	18 9b       	mov	r11,r12
800210e0:	e0 a0 0c da 	rcall	80022a94 <__avr32_f32_div>
800210e4:	18 97       	mov	r7,r12
800210e6:	c4 28       	rjmp	8002116a <__ieee754_sqrtf+0xc2>
800210e8:	f8 0a 14 17 	asr	r10,r12,0x17
800210ec:	e0 6b ff ff 	mov	r11,65535
800210f0:	ea 1b 00 7f 	orh	r11,0x7f
800210f4:	16 39       	cp.w	r9,r11
800210f6:	e0 8b 00 0b 	brhi	8002110c <__ieee754_sqrtf+0x64>
800210fa:	30 09       	mov	r9,0
800210fc:	c0 38       	rjmp	80021102 <__ieee754_sqrtf+0x5a>
800210fe:	a1 78       	lsl	r8,0x1
80021100:	2f f9       	sub	r9,-1
80021102:	ed b8 00 17 	bld	r8,0x17
80021106:	cf c1       	brne	800210fe <__ieee754_sqrtf+0x56>
80021108:	2f fa       	sub	r10,-1
8002110a:	12 1a       	sub	r10,r9
8002110c:	f4 cc 00 7f 	sub	r12,r10,127
80021110:	f3 dc c0 01 	bfextu	r9,r12,0x0,0x1
80021114:	30 0a       	mov	r10,0
80021116:	f1 d8 c0 17 	bfextu	r8,r8,0x0,0x17
8002111a:	14 97       	mov	r7,r10
8002111c:	b7 b8       	sbr	r8,0x17
8002111e:	14 9e       	mov	lr,r10
80021120:	f0 0b 15 01 	lsl	r11,r8,0x1
80021124:	14 39       	cp.w	r9,r10
80021126:	f6 08 17 10 	movne	r8,r11
8002112a:	fc 19 01 00 	movh	r9,0x100
8002112e:	a1 78       	lsl	r8,0x1
80021130:	fc 09 00 0b 	add	r11,lr,r9
80021134:	2f fa       	sub	r10,-1
80021136:	10 3b       	cp.w	r11,r8
80021138:	f1 db ea 18 	suble	r8,r8,r11
8002113c:	ef d9 ea 07 	addle	r7,r7,r9
80021140:	f7 d9 ea 0e 	addle	lr,r11,r9
80021144:	a1 78       	lsl	r8,0x1
80021146:	a1 99       	lsr	r9,0x1
80021148:	59 9a       	cp.w	r10,25
8002114a:	cf 31       	brne	80021130 <__ieee754_sqrtf+0x88>
8002114c:	58 08       	cp.w	r8,0
8002114e:	f9 b9 01 01 	movne	r9,1
80021152:	ef d9 e1 28 	andne	r8,r7,r9
80021156:	f1 d7 e1 07 	addne	r7,r8,r7
8002115a:	a1 57       	asr	r7,0x1
8002115c:	a1 5c       	asr	r12,0x1
8002115e:	fc 18 3f 00 	movh	r8,0x3f00
80021162:	b7 7c       	lsl	r12,0x17
80021164:	10 0c       	add	r12,r8
80021166:	0e 0c       	add	r12,r7
80021168:	18 97       	mov	r7,r12
8002116a:	0e 9c       	mov	r12,r7
8002116c:	d8 22       	popm	r4-r7,pc
8002116e:	d7 03       	nop

80021170 <__ieee754_log>:
80021170:	d4 31       	pushm	r0-r7,lr
80021172:	20 7d       	sub	sp,28
80021174:	14 98       	mov	r8,r10
80021176:	16 99       	mov	r9,r11
80021178:	14 96       	mov	r6,r10
8002117a:	16 97       	mov	r7,r11
8002117c:	16 94       	mov	r4,r11
8002117e:	16 9c       	mov	r12,r11
80021180:	14 95       	mov	r5,r10
80021182:	ee 5b ff ff 	cp.w	r11,1048575
80021186:	e0 8a 00 04 	brle	8002118e <__ieee754_log+0x1e>
8002118a:	30 0a       	mov	r10,0
8002118c:	c2 18       	rjmp	800211ce <__ieee754_log+0x5e>
8002118e:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
80021192:	14 4c       	or	r12,r10
80021194:	c0 71       	brne	800211a2 <__ieee754_log+0x32>
80021196:	30 08       	mov	r8,0
80021198:	30 09       	mov	r9,0
8002119a:	30 0a       	mov	r10,0
8002119c:	fc 1b c3 50 	movh	r11,0xc350
800211a0:	c0 88       	rjmp	800211b0 <__ieee754_log+0x40>
800211a2:	16 94       	mov	r4,r11
800211a4:	58 0b       	cp.w	r11,0
800211a6:	c0 94       	brge	800211b8 <__ieee754_log+0x48>
800211a8:	e0 a0 08 54 	rcall	80022250 <__avr32_f64_sub>
800211ac:	30 08       	mov	r8,0
800211ae:	30 09       	mov	r9,0
800211b0:	e0 a0 0a e6 	rcall	8002277c <__avr32_f64_div>
800211b4:	e0 8f 01 fa 	bral	800215a8 <__ieee754_log+0x438>
800211b8:	30 08       	mov	r8,0
800211ba:	fc 19 43 50 	movh	r9,0x4350
800211be:	e0 a0 07 5d 	rcall	80022078 <__avr32_f64_mul>
800211c2:	14 98       	mov	r8,r10
800211c4:	16 99       	mov	r9,r11
800211c6:	3c aa       	mov	r10,-54
800211c8:	10 94       	mov	r4,r8
800211ca:	12 95       	mov	r5,r9
800211cc:	12 9c       	mov	r12,r9
800211ce:	e0 6b ff ff 	mov	r11,65535
800211d2:	ea 1b 7f ef 	orh	r11,0x7fef
800211d6:	16 3c       	cp.w	r12,r11
800211d8:	e0 8a 00 05 	brle	800211e2 <__ieee754_log+0x72>
800211dc:	10 9a       	mov	r10,r8
800211de:	12 9b       	mov	r11,r9
800211e0:	c4 d8       	rjmp	8002127a <__ieee754_log+0x10a>
800211e2:	e8 79 5f 64 	mov	r9,614244
800211e6:	e9 dc c0 14 	bfextu	r4,r12,0x0,0x14
800211ea:	f4 c5 03 ff 	sub	r5,r10,1023
800211ee:	b5 4c       	asr	r12,0x14
800211f0:	10 9a       	mov	r10,r8
800211f2:	e8 09 00 08 	add	r8,r4,r9
800211f6:	e6 18 00 10 	andh	r8,0x10,COH
800211fa:	f0 09 14 14 	asr	r9,r8,0x14
800211fe:	ee 18 3f f0 	eorh	r8,0x3ff0
80021202:	18 05       	add	r5,r12
80021204:	f1 e4 10 0b 	or	r11,r8,r4
80021208:	12 05       	add	r5,r9
8002120a:	30 08       	mov	r8,0
8002120c:	fc 19 3f f0 	movh	r9,0x3ff0
80021210:	e0 a0 08 20 	rcall	80022250 <__avr32_f64_sub>
80021214:	e8 c8 ff fe 	sub	r8,r4,-2
80021218:	14 96       	mov	r6,r10
8002121a:	16 97       	mov	r7,r11
8002121c:	f1 d8 c0 14 	bfextu	r8,r8,0x0,0x14
80021220:	58 28       	cp.w	r8,2
80021222:	e0 89 00 80 	brgt	80021322 <__ieee754_log+0x1b2>
80021226:	30 08       	mov	r8,0
80021228:	30 09       	mov	r9,0
8002122a:	e0 a0 09 ee 	rcall	80022606 <__avr32_f64_cmp_eq>
8002122e:	c2 a0       	breq	80021282 <__ieee754_log+0x112>
80021230:	58 05       	cp.w	r5,0
80021232:	c0 51       	brne	8002123c <__ieee754_log+0xcc>
80021234:	30 0a       	mov	r10,0
80021236:	30 0b       	mov	r11,0
80021238:	e0 8f 01 b8 	bral	800215a8 <__ieee754_log+0x438>
8002123c:	0a 9c       	mov	r12,r5
8002123e:	e0 a0 09 74 	rcall	80022526 <__avr32_s32_to_f64>
80021242:	fc 18 fe e0 	movh	r8,0xfee0
80021246:	14 94       	mov	r4,r10
80021248:	16 95       	mov	r5,r11
8002124a:	e0 69 2e 42 	mov	r9,11842
8002124e:	ea 19 3f e6 	orh	r9,0x3fe6
80021252:	e0 a0 07 13 	rcall	80022078 <__avr32_f64_mul>
80021256:	e0 68 3c 76 	mov	r8,15478
8002125a:	ea 18 35 79 	orh	r8,0x3579
8002125e:	16 97       	mov	r7,r11
80021260:	14 96       	mov	r6,r10
80021262:	e0 69 39 ef 	mov	r9,14831
80021266:	ea 19 3d ea 	orh	r9,0x3dea
8002126a:	08 9a       	mov	r10,r4
8002126c:	0a 9b       	mov	r11,r5
8002126e:	e0 a0 07 05 	rcall	80022078 <__avr32_f64_mul>
80021272:	14 98       	mov	r8,r10
80021274:	16 99       	mov	r9,r11
80021276:	0c 9a       	mov	r10,r6
80021278:	0e 9b       	mov	r11,r7
8002127a:	e0 a0 08 b9 	rcall	800223ec <__avr32_f64_add>
8002127e:	e0 8f 01 95 	bral	800215a8 <__ieee754_log+0x438>
80021282:	0c 98       	mov	r8,r6
80021284:	0e 99       	mov	r9,r7
80021286:	0c 9a       	mov	r10,r6
80021288:	0e 9b       	mov	r11,r7
8002128a:	e0 a0 06 f7 	rcall	80022078 <__avr32_f64_mul>
8002128e:	e0 68 55 55 	mov	r8,21845
80021292:	ea 18 55 55 	orh	r8,0x5555
80021296:	14 92       	mov	r2,r10
80021298:	16 93       	mov	r3,r11
8002129a:	e0 69 55 55 	mov	r9,21845
8002129e:	ea 19 bf d5 	orh	r9,0xbfd5
800212a2:	0c 9a       	mov	r10,r6
800212a4:	0e 9b       	mov	r11,r7
800212a6:	e0 a0 06 e9 	rcall	80022078 <__avr32_f64_mul>
800212aa:	30 08       	mov	r8,0
800212ac:	fc 19 3f e0 	movh	r9,0x3fe0
800212b0:	e0 a0 08 9e 	rcall	800223ec <__avr32_f64_add>
800212b4:	14 98       	mov	r8,r10
800212b6:	16 99       	mov	r9,r11
800212b8:	04 9a       	mov	r10,r2
800212ba:	06 9b       	mov	r11,r3
800212bc:	e0 a0 06 de 	rcall	80022078 <__avr32_f64_mul>
800212c0:	14 92       	mov	r2,r10
800212c2:	16 93       	mov	r3,r11
800212c4:	58 05       	cp.w	r5,0
800212c6:	c0 41       	brne	800212ce <__ieee754_log+0x15e>
800212c8:	14 98       	mov	r8,r10
800212ca:	06 99       	mov	r9,r3
800212cc:	c3 59       	rjmp	80021536 <__ieee754_log+0x3c6>
800212ce:	0a 9c       	mov	r12,r5
800212d0:	e0 a0 09 2b 	rcall	80022526 <__avr32_s32_to_f64>
800212d4:	fc 18 fe e0 	movh	r8,0xfee0
800212d8:	14 94       	mov	r4,r10
800212da:	16 95       	mov	r5,r11
800212dc:	e0 69 2e 42 	mov	r9,11842
800212e0:	ea 19 3f e6 	orh	r9,0x3fe6
800212e4:	e0 a0 06 ca 	rcall	80022078 <__avr32_f64_mul>
800212e8:	e0 68 3c 76 	mov	r8,15478
800212ec:	ea 18 35 79 	orh	r8,0x3579
800212f0:	14 90       	mov	r0,r10
800212f2:	16 91       	mov	r1,r11
800212f4:	e0 69 39 ef 	mov	r9,14831
800212f8:	ea 19 bd ea 	orh	r9,0xbdea
800212fc:	08 9a       	mov	r10,r4
800212fe:	0a 9b       	mov	r11,r5
80021300:	e0 a0 06 bc 	rcall	80022078 <__avr32_f64_mul>
80021304:	14 98       	mov	r8,r10
80021306:	16 99       	mov	r9,r11
80021308:	04 9a       	mov	r10,r2
8002130a:	06 9b       	mov	r11,r3
8002130c:	e0 a0 08 70 	rcall	800223ec <__avr32_f64_add>
80021310:	0c 98       	mov	r8,r6
80021312:	0e 99       	mov	r9,r7
80021314:	e0 a0 07 9e 	rcall	80022250 <__avr32_f64_sub>
80021318:	14 98       	mov	r8,r10
8002131a:	16 99       	mov	r9,r11
8002131c:	00 9a       	mov	r10,r0
8002131e:	02 9b       	mov	r11,r1
80021320:	c4 29       	rjmp	800215a4 <__ieee754_log+0x434>
80021322:	30 08       	mov	r8,0
80021324:	fc 19 40 00 	movh	r9,0x4000
80021328:	e0 a0 08 62 	rcall	800223ec <__avr32_f64_add>
8002132c:	14 98       	mov	r8,r10
8002132e:	16 99       	mov	r9,r11
80021330:	0c 9a       	mov	r10,r6
80021332:	0e 9b       	mov	r11,r7
80021334:	e0 a0 0a 24 	rcall	8002277c <__avr32_f64_div>
80021338:	0a 9c       	mov	r12,r5
8002133a:	14 90       	mov	r0,r10
8002133c:	16 91       	mov	r1,r11
8002133e:	e0 a0 08 f4 	rcall	80022526 <__avr32_s32_to_f64>
80021342:	00 98       	mov	r8,r0
80021344:	02 99       	mov	r9,r1
80021346:	fa eb 00 0c 	st.d	sp[12],r10
8002134a:	00 9a       	mov	r10,r0
8002134c:	02 9b       	mov	r11,r1
8002134e:	e0 a0 06 95 	rcall	80022078 <__avr32_f64_mul>
80021352:	14 98       	mov	r8,r10
80021354:	16 99       	mov	r9,r11
80021356:	fa eb 00 04 	st.d	sp[4],r10
8002135a:	e0 a0 06 8f 	rcall	80022078 <__avr32_f64_mul>
8002135e:	e0 68 52 44 	mov	r8,21060
80021362:	ea 18 df 3e 	orh	r8,0xdf3e
80021366:	14 92       	mov	r2,r10
80021368:	16 93       	mov	r3,r11
8002136a:	e0 69 f1 12 	mov	r9,61714
8002136e:	ea 19 3f c2 	orh	r9,0x3fc2
80021372:	e0 a0 06 83 	rcall	80022078 <__avr32_f64_mul>
80021376:	e0 68 03 de 	mov	r8,990
8002137a:	ea 18 96 cb 	orh	r8,0x96cb
8002137e:	e0 69 46 64 	mov	r9,18020
80021382:	ea 19 3f c7 	orh	r9,0x3fc7
80021386:	e0 a0 08 33 	rcall	800223ec <__avr32_f64_add>
8002138a:	14 98       	mov	r8,r10
8002138c:	16 99       	mov	r9,r11
8002138e:	04 9a       	mov	r10,r2
80021390:	06 9b       	mov	r11,r3
80021392:	e0 a0 06 73 	rcall	80022078 <__avr32_f64_mul>
80021396:	e0 68 93 59 	mov	r8,37721
8002139a:	ea 18 94 22 	orh	r8,0x9422
8002139e:	e0 69 49 24 	mov	r9,18724
800213a2:	ea 19 3f d2 	orh	r9,0x3fd2
800213a6:	e0 a0 08 23 	rcall	800223ec <__avr32_f64_add>
800213aa:	14 98       	mov	r8,r10
800213ac:	16 99       	mov	r9,r11
800213ae:	04 9a       	mov	r10,r2
800213b0:	06 9b       	mov	r11,r3
800213b2:	e0 a0 06 63 	rcall	80022078 <__avr32_f64_mul>
800213b6:	e0 68 55 93 	mov	r8,21907
800213ba:	ea 18 55 55 	orh	r8,0x5555
800213be:	e0 69 55 55 	mov	r9,21845
800213c2:	ea 19 3f e5 	orh	r9,0x3fe5
800213c6:	e0 a0 08 13 	rcall	800223ec <__avr32_f64_add>
800213ca:	14 98       	mov	r8,r10
800213cc:	16 99       	mov	r9,r11
800213ce:	fa ea 00 04 	ld.d	r10,sp[4]
800213d2:	e0 a0 06 53 	rcall	80022078 <__avr32_f64_mul>
800213d6:	e0 68 c6 9f 	mov	r8,50847
800213da:	ea 18 d0 78 	orh	r8,0xd078
800213de:	fa eb 00 04 	st.d	sp[4],r10
800213e2:	e0 69 9a 09 	mov	r9,39433
800213e6:	ea 19 3f c3 	orh	r9,0x3fc3
800213ea:	04 9a       	mov	r10,r2
800213ec:	06 9b       	mov	r11,r3
800213ee:	e0 a0 06 45 	rcall	80022078 <__avr32_f64_mul>
800213f2:	e0 68 78 af 	mov	r8,30895
800213f6:	ea 18 1d 8e 	orh	r8,0x1d8e
800213fa:	e0 69 71 c5 	mov	r9,29125
800213fe:	ea 19 3f cc 	orh	r9,0x3fcc
80021402:	e0 a0 07 f5 	rcall	800223ec <__avr32_f64_add>
80021406:	14 98       	mov	r8,r10
80021408:	16 99       	mov	r9,r11
8002140a:	04 9a       	mov	r10,r2
8002140c:	06 9b       	mov	r11,r3
8002140e:	e0 a0 06 35 	rcall	80022078 <__avr32_f64_mul>
80021412:	f8 78 eb 86 	mov	r8,-398458
80021416:	e8 08 00 0c 	add	r12,r4,r8
8002141a:	e0 69 99 99 	mov	r9,39321
8002141e:	ea 19 3f d9 	orh	r9,0x3fd9
80021422:	50 0c       	stdsp	sp[0x0],r12
80021424:	e0 68 fa 04 	mov	r8,64004
80021428:	ea 18 99 97 	orh	r8,0x9997
8002142c:	e0 a0 07 e0 	rcall	800223ec <__avr32_f64_add>
80021430:	14 98       	mov	r8,r10
80021432:	16 99       	mov	r9,r11
80021434:	04 9a       	mov	r10,r2
80021436:	06 9b       	mov	r11,r3
80021438:	e0 a0 06 20 	rcall	80022078 <__avr32_f64_mul>
8002143c:	14 98       	mov	r8,r10
8002143e:	16 99       	mov	r9,r11
80021440:	fa ea 00 04 	ld.d	r10,sp[4]
80021444:	e0 a0 07 d4 	rcall	800223ec <__avr32_f64_add>
80021448:	40 0c       	lddsp	r12,sp[0x0]
8002144a:	16 93       	mov	r3,r11
8002144c:	14 92       	mov	r2,r10
8002144e:	e6 6b b8 51 	mov	r11,440401
80021452:	f6 04 01 04 	sub	r4,r11,r4
80021456:	e9 ec 10 0c 	or	r12,r4,r12
8002145a:	58 0c       	cp.w	r12,0
8002145c:	e0 8a 00 5d 	brle	80021516 <__ieee754_log+0x3a6>
80021460:	30 08       	mov	r8,0
80021462:	fc 19 3f e0 	movh	r9,0x3fe0
80021466:	0c 9a       	mov	r10,r6
80021468:	0e 9b       	mov	r11,r7
8002146a:	e0 a0 06 07 	rcall	80022078 <__avr32_f64_mul>
8002146e:	0c 98       	mov	r8,r6
80021470:	0e 99       	mov	r9,r7
80021472:	e0 a0 06 03 	rcall	80022078 <__avr32_f64_mul>
80021476:	fa eb 00 04 	st.d	sp[4],r10
8002147a:	58 05       	cp.w	r5,0
8002147c:	c1 21       	brne	800214a0 <__ieee754_log+0x330>
8002147e:	04 98       	mov	r8,r2
80021480:	06 99       	mov	r9,r3
80021482:	e0 a0 07 b5 	rcall	800223ec <__avr32_f64_add>
80021486:	14 98       	mov	r8,r10
80021488:	16 99       	mov	r9,r11
8002148a:	00 9a       	mov	r10,r0
8002148c:	02 9b       	mov	r11,r1
8002148e:	e0 a0 05 f5 	rcall	80022078 <__avr32_f64_mul>
80021492:	14 98       	mov	r8,r10
80021494:	16 99       	mov	r9,r11
80021496:	fa ea 00 04 	ld.d	r10,sp[4]
8002149a:	e0 a0 06 db 	rcall	80022250 <__avr32_f64_sub>
8002149e:	c4 a8       	rjmp	80021532 <__ieee754_log+0x3c2>
800214a0:	fc 18 fe e0 	movh	r8,0xfee0
800214a4:	e0 69 2e 42 	mov	r9,11842
800214a8:	ea 19 3f e6 	orh	r9,0x3fe6
800214ac:	fa ea 00 0c 	ld.d	r10,sp[12]
800214b0:	e0 a0 05 e4 	rcall	80022078 <__avr32_f64_mul>
800214b4:	04 98       	mov	r8,r2
800214b6:	fa eb 00 14 	st.d	sp[20],r10
800214ba:	06 99       	mov	r9,r3
800214bc:	fa ea 00 04 	ld.d	r10,sp[4]
800214c0:	e0 a0 07 96 	rcall	800223ec <__avr32_f64_add>
800214c4:	14 98       	mov	r8,r10
800214c6:	16 99       	mov	r9,r11
800214c8:	00 9a       	mov	r10,r0
800214ca:	02 9b       	mov	r11,r1
800214cc:	e0 a0 05 d6 	rcall	80022078 <__avr32_f64_mul>
800214d0:	e0 68 3c 76 	mov	r8,15478
800214d4:	ea 18 35 79 	orh	r8,0x3579
800214d8:	14 94       	mov	r4,r10
800214da:	16 95       	mov	r5,r11
800214dc:	e0 69 39 ef 	mov	r9,14831
800214e0:	ea 19 3d ea 	orh	r9,0x3dea
800214e4:	fa ea 00 0c 	ld.d	r10,sp[12]
800214e8:	e0 a0 05 c8 	rcall	80022078 <__avr32_f64_mul>
800214ec:	14 98       	mov	r8,r10
800214ee:	16 99       	mov	r9,r11
800214f0:	08 9a       	mov	r10,r4
800214f2:	0a 9b       	mov	r11,r5
800214f4:	e0 a0 07 7c 	rcall	800223ec <__avr32_f64_add>
800214f8:	14 98       	mov	r8,r10
800214fa:	16 99       	mov	r9,r11
800214fc:	fa ea 00 04 	ld.d	r10,sp[4]
80021500:	e0 a0 06 a8 	rcall	80022250 <__avr32_f64_sub>
80021504:	0c 98       	mov	r8,r6
80021506:	0e 99       	mov	r9,r7
80021508:	e0 a0 06 a4 	rcall	80022250 <__avr32_f64_sub>
8002150c:	14 98       	mov	r8,r10
8002150e:	16 99       	mov	r9,r11
80021510:	fa ea 00 14 	ld.d	r10,sp[20]
80021514:	c4 88       	rjmp	800215a4 <__ieee754_log+0x434>
80021516:	58 05       	cp.w	r5,0
80021518:	c1 21       	brne	8002153c <__ieee754_log+0x3cc>
8002151a:	14 98       	mov	r8,r10
8002151c:	06 99       	mov	r9,r3
8002151e:	0c 9a       	mov	r10,r6
80021520:	0e 9b       	mov	r11,r7
80021522:	e0 a0 06 97 	rcall	80022250 <__avr32_f64_sub>
80021526:	14 98       	mov	r8,r10
80021528:	16 99       	mov	r9,r11
8002152a:	00 9a       	mov	r10,r0
8002152c:	02 9b       	mov	r11,r1
8002152e:	e0 a0 05 a5 	rcall	80022078 <__avr32_f64_mul>
80021532:	14 98       	mov	r8,r10
80021534:	16 99       	mov	r9,r11
80021536:	0c 9a       	mov	r10,r6
80021538:	0e 9b       	mov	r11,r7
8002153a:	c3 58       	rjmp	800215a4 <__ieee754_log+0x434>
8002153c:	fc 18 fe e0 	movh	r8,0xfee0
80021540:	e0 69 2e 42 	mov	r9,11842
80021544:	ea 19 3f e6 	orh	r9,0x3fe6
80021548:	fa ea 00 0c 	ld.d	r10,sp[12]
8002154c:	e0 a0 05 96 	rcall	80022078 <__avr32_f64_mul>
80021550:	04 98       	mov	r8,r2
80021552:	fa eb 00 04 	st.d	sp[4],r10
80021556:	06 99       	mov	r9,r3
80021558:	0c 9a       	mov	r10,r6
8002155a:	0e 9b       	mov	r11,r7
8002155c:	e0 a0 06 7a 	rcall	80022250 <__avr32_f64_sub>
80021560:	14 98       	mov	r8,r10
80021562:	16 99       	mov	r9,r11
80021564:	00 9a       	mov	r10,r0
80021566:	02 9b       	mov	r11,r1
80021568:	e0 a0 05 88 	rcall	80022078 <__avr32_f64_mul>
8002156c:	e0 68 3c 76 	mov	r8,15478
80021570:	ea 18 35 79 	orh	r8,0x3579
80021574:	14 94       	mov	r4,r10
80021576:	16 95       	mov	r5,r11
80021578:	e0 69 39 ef 	mov	r9,14831
8002157c:	ea 19 bd ea 	orh	r9,0xbdea
80021580:	fa ea 00 0c 	ld.d	r10,sp[12]
80021584:	e0 a0 05 7a 	rcall	80022078 <__avr32_f64_mul>
80021588:	14 98       	mov	r8,r10
8002158a:	16 99       	mov	r9,r11
8002158c:	08 9a       	mov	r10,r4
8002158e:	0a 9b       	mov	r11,r5
80021590:	e0 a0 07 2e 	rcall	800223ec <__avr32_f64_add>
80021594:	0c 98       	mov	r8,r6
80021596:	0e 99       	mov	r9,r7
80021598:	e0 a0 06 5c 	rcall	80022250 <__avr32_f64_sub>
8002159c:	14 98       	mov	r8,r10
8002159e:	16 99       	mov	r9,r11
800215a0:	fa ea 00 04 	ld.d	r10,sp[4]
800215a4:	e0 a0 06 56 	rcall	80022250 <__avr32_f64_sub>
800215a8:	2f 9d       	sub	sp,-28
800215aa:	d8 32       	popm	r0-r7,pc

800215ac <__kernel_cosf>:
800215ac:	d4 31       	pushm	r0-r7,lr
800215ae:	e0 68 ff ff 	mov	r8,65535
800215b2:	ea 18 31 ff 	orh	r8,0x31ff
800215b6:	16 94       	mov	r4,r11
800215b8:	18 96       	mov	r6,r12
800215ba:	eb dc c0 1f 	bfextu	r5,r12,0x0,0x1f
800215be:	10 35       	cp.w	r5,r8
800215c0:	e0 89 00 08 	brgt	800215d0 <__kernel_cosf+0x24>
800215c4:	e0 a0 0c 83 	rcall	80022eca <__avr32_f32_to_s32>
800215c8:	c0 41       	brne	800215d0 <__kernel_cosf+0x24>
800215ca:	fc 1c 3f 80 	movh	r12,0x3f80
800215ce:	d8 32       	popm	r0-r7,pc
800215d0:	0c 9b       	mov	r11,r6
800215d2:	0c 9c       	mov	r12,r6
800215d4:	e0 a0 0b d0 	rcall	80022d74 <__avr32_f32_mul>
800215d8:	e0 6b d7 4e 	mov	r11,55118
800215dc:	ea 1b ad 47 	orh	r11,0xad47
800215e0:	18 97       	mov	r7,r12
800215e2:	e0 a0 0b c9 	rcall	80022d74 <__avr32_f32_mul>
800215e6:	e0 6b 74 f6 	mov	r11,29942
800215ea:	ea 1b 31 0f 	orh	r11,0x310f
800215ee:	e0 a0 0b 6d 	rcall	80022cc8 <__avr32_f32_add>
800215f2:	18 9b       	mov	r11,r12
800215f4:	0e 9c       	mov	r12,r7
800215f6:	e0 a0 0b bf 	rcall	80022d74 <__avr32_f32_mul>
800215fa:	e0 6b f2 7c 	mov	r11,62076
800215fe:	ea 1b 34 93 	orh	r11,0x3493
80021602:	e0 a0 0a fb 	rcall	80022bf8 <__avr32_f32_sub>
80021606:	18 9b       	mov	r11,r12
80021608:	0e 9c       	mov	r12,r7
8002160a:	e0 a0 0b b5 	rcall	80022d74 <__avr32_f32_mul>
8002160e:	e0 6b 0d 01 	mov	r11,3329
80021612:	ea 1b 37 d0 	orh	r11,0x37d0
80021616:	e0 a0 0b 59 	rcall	80022cc8 <__avr32_f32_add>
8002161a:	18 9b       	mov	r11,r12
8002161c:	0e 9c       	mov	r12,r7
8002161e:	e0 a0 0b ab 	rcall	80022d74 <__avr32_f32_mul>
80021622:	e0 6b 0b 61 	mov	r11,2913
80021626:	ea 1b 3a b6 	orh	r11,0x3ab6
8002162a:	e0 a0 0a e7 	rcall	80022bf8 <__avr32_f32_sub>
8002162e:	18 9b       	mov	r11,r12
80021630:	0e 9c       	mov	r12,r7
80021632:	e0 a0 0b a1 	rcall	80022d74 <__avr32_f32_mul>
80021636:	e0 6b aa ab 	mov	r11,43691
8002163a:	ea 1b 3d 2a 	orh	r11,0x3d2a
8002163e:	e0 a0 0b 45 	rcall	80022cc8 <__avr32_f32_add>
80021642:	18 9b       	mov	r11,r12
80021644:	0e 9c       	mov	r12,r7
80021646:	e0 a0 0b 97 	rcall	80022d74 <__avr32_f32_mul>
8002164a:	e0 68 99 99 	mov	r8,39321
8002164e:	ea 18 3e 99 	orh	r8,0x3e99
80021652:	18 93       	mov	r3,r12
80021654:	10 35       	cp.w	r5,r8
80021656:	e0 89 00 1f 	brgt	80021694 <__kernel_cosf+0xe8>
8002165a:	fc 1b 3f 00 	movh	r11,0x3f00
8002165e:	0e 9c       	mov	r12,r7
80021660:	e0 a0 0b 8a 	rcall	80022d74 <__avr32_f32_mul>
80021664:	06 9b       	mov	r11,r3
80021666:	18 95       	mov	r5,r12
80021668:	0e 9c       	mov	r12,r7
8002166a:	e0 a0 0b 85 	rcall	80022d74 <__avr32_f32_mul>
8002166e:	08 9b       	mov	r11,r4
80021670:	18 97       	mov	r7,r12
80021672:	0c 9c       	mov	r12,r6
80021674:	e0 a0 0b 80 	rcall	80022d74 <__avr32_f32_mul>
80021678:	18 9b       	mov	r11,r12
8002167a:	0e 9c       	mov	r12,r7
8002167c:	e0 a0 0a be 	rcall	80022bf8 <__avr32_f32_sub>
80021680:	18 9b       	mov	r11,r12
80021682:	0a 9c       	mov	r12,r5
80021684:	e0 a0 0a ba 	rcall	80022bf8 <__avr32_f32_sub>
80021688:	18 9b       	mov	r11,r12
8002168a:	fc 1c 3f 80 	movh	r12,0x3f80
8002168e:	e0 a0 0a b5 	rcall	80022bf8 <__avr32_f32_sub>
80021692:	d8 32       	popm	r0-r7,pc
80021694:	fc 18 3f 48 	movh	r8,0x3f48
80021698:	10 35       	cp.w	r5,r8
8002169a:	e0 8a 00 05 	brle	800216a4 <__kernel_cosf+0xf8>
8002169e:	fc 15 3e 90 	movh	r5,0x3e90
800216a2:	c0 48       	rjmp	800216aa <__kernel_cosf+0xfe>
800216a4:	fc 18 ff 00 	movh	r8,0xff00
800216a8:	10 05       	add	r5,r8
800216aa:	0a 9b       	mov	r11,r5
800216ac:	fc 1c 3f 80 	movh	r12,0x3f80
800216b0:	e0 a0 0a a4 	rcall	80022bf8 <__avr32_f32_sub>
800216b4:	fc 1b 3f 00 	movh	r11,0x3f00
800216b8:	18 92       	mov	r2,r12
800216ba:	0e 9c       	mov	r12,r7
800216bc:	e0 a0 0b 5c 	rcall	80022d74 <__avr32_f32_mul>
800216c0:	0a 9b       	mov	r11,r5
800216c2:	e0 a0 0a 9b 	rcall	80022bf8 <__avr32_f32_sub>
800216c6:	06 9b       	mov	r11,r3
800216c8:	18 95       	mov	r5,r12
800216ca:	0e 9c       	mov	r12,r7
800216cc:	e0 a0 0b 54 	rcall	80022d74 <__avr32_f32_mul>
800216d0:	08 9b       	mov	r11,r4
800216d2:	18 97       	mov	r7,r12
800216d4:	0c 9c       	mov	r12,r6
800216d6:	e0 a0 0b 4f 	rcall	80022d74 <__avr32_f32_mul>
800216da:	18 9b       	mov	r11,r12
800216dc:	0e 9c       	mov	r12,r7
800216de:	e0 a0 0a 8d 	rcall	80022bf8 <__avr32_f32_sub>
800216e2:	18 9b       	mov	r11,r12
800216e4:	0a 9c       	mov	r12,r5
800216e6:	e0 a0 0a 89 	rcall	80022bf8 <__avr32_f32_sub>
800216ea:	18 9b       	mov	r11,r12
800216ec:	04 9c       	mov	r12,r2
800216ee:	e0 a0 0a 85 	rcall	80022bf8 <__avr32_f32_sub>
800216f2:	d8 32       	popm	r0-r7,pc

800216f4 <__kernel_rem_pio2f>:
800216f4:	d4 31       	pushm	r0-r7,lr
800216f6:	fa cd 01 78 	sub	sp,sp,376
800216fa:	50 99       	stdsp	sp[0x24],r9
800216fc:	46 79       	lddsp	r9,sp[0x19c]
800216fe:	50 48       	stdsp	sp[0x10],r8
80021700:	50 a9       	stdsp	sp[0x28],r9
80021702:	16 95       	mov	r5,r11
80021704:	40 98       	lddsp	r8,sp[0x24]
80021706:	fe c9 b9 5a 	sub	r9,pc,-18086
8002170a:	20 18       	sub	r8,1
8002170c:	40 4b       	lddsp	r11,sp[0x10]
8002170e:	f2 0b 03 29 	ld.w	r9,r9[r11<<0x2]
80021712:	50 28       	stdsp	sp[0x8],r8
80021714:	50 39       	stdsp	sp[0xc],r9
80021716:	30 08       	mov	r8,0
80021718:	f4 c9 00 03 	sub	r9,r10,3
8002171c:	10 97       	mov	r7,r8
8002171e:	30 83       	mov	r3,8
80021720:	f2 03 0c 02 	divs	r2,r9,r3
80021724:	f0 02 0c 48 	max	r8,r8,r2
80021728:	40 29       	lddsp	r9,sp[0x8]
8002172a:	10 96       	mov	r6,r8
8002172c:	10 93       	mov	r3,r8
8002172e:	50 58       	stdsp	sp[0x14],r8
80021730:	40 32       	lddsp	r2,sp[0xc]
80021732:	5c d6       	com	r6
80021734:	12 13       	sub	r3,r9
80021736:	40 a8       	lddsp	r8,sp[0x28]
80021738:	50 8c       	stdsp	sp[0x20],r12
8002173a:	12 02       	add	r2,r9
8002173c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80021740:	fa c1 ff 28 	sub	r1,sp,-216
80021744:	f0 03 00 24 	add	r4,r8,r3<<0x2
80021748:	c0 c8       	rjmp	80021760 <__kernel_rem_pio2f+0x6c>
8002174a:	ee 03 00 08 	add	r8,r7,r3
8002174e:	c0 37       	brpl	80021754 <__kernel_rem_pio2f+0x60>
80021750:	30 0c       	mov	r12,0
80021752:	c0 48       	rjmp	8002175a <__kernel_rem_pio2f+0x66>
80021754:	68 0c       	ld.w	r12,r4[0x0]
80021756:	e0 a0 0b 80 	rcall	80022e56 <__avr32_s32_to_f32>
8002175a:	02 ac       	st.w	r1++,r12
8002175c:	2f f7       	sub	r7,-1
8002175e:	2f c4       	sub	r4,-4
80021760:	04 37       	cp.w	r7,r2
80021762:	fe 9a ff f4 	brle	8002174a <__kernel_rem_pio2f+0x56>
80021766:	fa c8 ff c8 	sub	r8,sp,-56
8002176a:	40 24       	lddsp	r4,sp[0x8]
8002176c:	30 07       	mov	r7,0
8002176e:	fa c9 ff 28 	sub	r9,sp,-216
80021772:	10 91       	mov	r1,r8
80021774:	0c 90       	mov	r0,r6
80021776:	c1 88       	rjmp	800217a6 <__kernel_rem_pio2f+0xb2>
80021778:	64 0b       	ld.w	r11,r2[0x0]
8002177a:	50 1a       	stdsp	sp[0x4],r10
8002177c:	50 09       	stdsp	sp[0x0],r9
8002177e:	0f 0c       	ld.w	r12,r7++
80021780:	e0 a0 0a fa 	rcall	80022d74 <__avr32_f32_mul>
80021784:	18 9b       	mov	r11,r12
80021786:	06 9c       	mov	r12,r3
80021788:	e0 a0 0a a0 	rcall	80022cc8 <__avr32_f32_add>
8002178c:	2f f6       	sub	r6,-1
8002178e:	20 42       	sub	r2,4
80021790:	18 93       	mov	r3,r12
80021792:	40 09       	lddsp	r9,sp[0x0]
80021794:	40 1a       	lddsp	r10,sp[0x4]
80021796:	40 2b       	lddsp	r11,sp[0x8]
80021798:	16 36       	cp.w	r6,r11
8002179a:	fe 9a ff ef 	brle	80021778 <__kernel_rem_pio2f+0x84>
8002179e:	14 97       	mov	r7,r10
800217a0:	02 a3       	st.w	r1++,r3
800217a2:	2f f7       	sub	r7,-1
800217a4:	2f f4       	sub	r4,-1
800217a6:	40 3a       	lddsp	r10,sp[0xc]
800217a8:	14 37       	cp.w	r7,r10
800217aa:	e0 89 00 0a 	brgt	800217be <__kernel_rem_pio2f+0xca>
800217ae:	40 88       	lddsp	r8,sp[0x20]
800217b0:	0e 9a       	mov	r10,r7
800217b2:	f2 04 00 22 	add	r2,r9,r4<<0x2
800217b6:	30 03       	mov	r3,0
800217b8:	30 06       	mov	r6,0
800217ba:	10 97       	mov	r7,r8
800217bc:	ce db       	rjmp	80021796 <__kernel_rem_pio2f+0xa2>
800217be:	40 38       	lddsp	r8,sp[0xc]
800217c0:	fa c9 fe d8 	sub	r9,sp,-296
800217c4:	20 18       	sub	r8,1
800217c6:	00 96       	mov	r6,r0
800217c8:	f2 08 00 29 	add	r9,r9,r8<<0x2
800217cc:	40 37       	lddsp	r7,sp[0xc]
800217ce:	50 d9       	stdsp	sp[0x34],r9
800217d0:	50 c5       	stdsp	sp[0x30],r5
800217d2:	fa cb fe 88 	sub	r11,sp,-376
800217d6:	ee c5 00 01 	sub	r5,r7,1
800217da:	f6 07 00 28 	add	r8,r11,r7<<0x2
800217de:	fa c3 fe d8 	sub	r3,sp,-296
800217e2:	fa ca ff c8 	sub	r10,sp,-56
800217e6:	f0 f4 fe c0 	ld.w	r4,r8[-320]
800217ea:	f4 05 00 21 	add	r1,r10,r5<<0x2
800217ee:	06 90       	mov	r0,r3
800217f0:	0e 92       	mov	r2,r7
800217f2:	c1 b8       	rjmp	80021828 <__kernel_rem_pio2f+0x134>
800217f4:	e0 a0 0a c0 	rcall	80022d74 <__avr32_f32_mul>
800217f8:	e0 a0 0b 69 	rcall	80022eca <__avr32_f32_to_s32>
800217fc:	e0 a0 0b 2d 	rcall	80022e56 <__avr32_s32_to_f32>
80021800:	fc 1b c3 80 	movh	r11,0xc380
80021804:	50 1c       	stdsp	sp[0x4],r12
80021806:	e0 a0 0a b7 	rcall	80022d74 <__avr32_f32_mul>
8002180a:	18 9b       	mov	r11,r12
8002180c:	08 9c       	mov	r12,r4
8002180e:	e0 a0 0a 5d 	rcall	80022cc8 <__avr32_f32_add>
80021812:	e0 a0 0b 5c 	rcall	80022eca <__avr32_f32_to_s32>
80021816:	40 18       	lddsp	r8,sp[0x4]
80021818:	00 ac       	st.w	r0++,r12
8002181a:	62 0b       	ld.w	r11,r1[0x0]
8002181c:	10 9c       	mov	r12,r8
8002181e:	20 12       	sub	r2,1
80021820:	e0 a0 0a 54 	rcall	80022cc8 <__avr32_f32_add>
80021824:	20 41       	sub	r1,4
80021826:	18 94       	mov	r4,r12
80021828:	fc 1b 3b 80 	movh	r11,0x3b80
8002182c:	08 9c       	mov	r12,r4
8002182e:	58 02       	cp.w	r2,0
80021830:	fe 99 ff e2 	brgt	800217f4 <__kernel_rem_pio2f+0x100>
80021834:	0c 9b       	mov	r11,r6
80021836:	e0 a0 03 21 	rcall	80021e78 <scalbnf>
8002183a:	fc 1b 3e 00 	movh	r11,0x3e00
8002183e:	18 94       	mov	r4,r12
80021840:	e0 a0 0a 9a 	rcall	80022d74 <__avr32_f32_mul>
80021844:	e0 a0 02 c2 	rcall	80021dc8 <floorf>
80021848:	fc 1b c1 00 	movh	r11,0xc100
8002184c:	e0 a0 0a 94 	rcall	80022d74 <__avr32_f32_mul>
80021850:	18 9b       	mov	r11,r12
80021852:	08 9c       	mov	r12,r4
80021854:	e0 a0 0a 3a 	rcall	80022cc8 <__avr32_f32_add>
80021858:	18 94       	mov	r4,r12
8002185a:	e0 a0 0b 38 	rcall	80022eca <__avr32_f32_to_s32>
8002185e:	18 91       	mov	r1,r12
80021860:	e0 a0 0a fb 	rcall	80022e56 <__avr32_s32_to_f32>
80021864:	18 9b       	mov	r11,r12
80021866:	08 9c       	mov	r12,r4
80021868:	e0 a0 09 c8 	rcall	80022bf8 <__avr32_f32_sub>
8002186c:	18 92       	mov	r2,r12
8002186e:	58 06       	cp.w	r6,0
80021870:	e0 8a 00 18 	brle	800218a0 <__kernel_rem_pio2f+0x1ac>
80021874:	fa c8 fe 88 	sub	r8,sp,-376
80021878:	ec 0b 11 08 	rsub	r11,r6,8
8002187c:	f0 05 00 29 	add	r9,r8,r5<<0x2
80021880:	ec 0c 11 07 	rsub	r12,r6,7
80021884:	f2 fa ff b0 	ld.w	r10,r9[-80]
80021888:	f4 0b 08 48 	asr	r8,r10,r11
8002188c:	f0 0b 09 4b 	lsl	r11,r8,r11
80021890:	10 01       	add	r1,r8
80021892:	f4 0b 01 0b 	sub	r11,r10,r11
80021896:	f3 4b ff b0 	st.w	r9[-80],r11
8002189a:	f6 0c 08 44 	asr	r4,r11,r12
8002189e:	c1 48       	rjmp	800218c6 <__kernel_rem_pio2f+0x1d2>
800218a0:	58 06       	cp.w	r6,0
800218a2:	c0 91       	brne	800218b4 <__kernel_rem_pio2f+0x1c0>
800218a4:	fa cb fe 88 	sub	r11,sp,-376
800218a8:	f6 05 00 28 	add	r8,r11,r5<<0x2
800218ac:	f0 f4 ff b0 	ld.w	r4,r8[-80]
800218b0:	a9 44       	asr	r4,0x8
800218b2:	c0 a8       	rjmp	800218c6 <__kernel_rem_pio2f+0x1d2>
800218b4:	fc 1b 3f 00 	movh	r11,0x3f00
800218b8:	e0 a0 07 2e 	rcall	80022714 <__avr32_f32_cmp_ge>
800218bc:	c0 31       	brne	800218c2 <__kernel_rem_pio2f+0x1ce>
800218be:	30 04       	mov	r4,0
800218c0:	c4 c8       	rjmp	80021958 <__kernel_rem_pio2f+0x264>
800218c2:	30 24       	mov	r4,2
800218c4:	c0 48       	rjmp	800218cc <__kernel_rem_pio2f+0x1d8>
800218c6:	58 04       	cp.w	r4,0
800218c8:	e0 8a 00 48 	brle	80021958 <__kernel_rem_pio2f+0x264>
800218cc:	30 08       	mov	r8,0
800218ce:	2f f1       	sub	r1,-1
800218d0:	10 90       	mov	r0,r8
800218d2:	c1 28       	rjmp	800218f6 <__kernel_rem_pio2f+0x202>
800218d4:	66 09       	ld.w	r9,r3[0x0]
800218d6:	58 00       	cp.w	r0,0
800218d8:	c0 81       	brne	800218e8 <__kernel_rem_pio2f+0x1f4>
800218da:	58 09       	cp.w	r9,0
800218dc:	c0 b0       	breq	800218f2 <__kernel_rem_pio2f+0x1fe>
800218de:	e0 6a 01 00 	mov	r10,256
800218e2:	12 1a       	sub	r10,r9
800218e4:	87 0a       	st.w	r3[0x0],r10
800218e6:	c0 58       	rjmp	800218f0 <__kernel_rem_pio2f+0x1fc>
800218e8:	e0 6b 00 ff 	mov	r11,255
800218ec:	12 1b       	sub	r11,r9
800218ee:	87 0b       	st.w	r3[0x0],r11
800218f0:	30 10       	mov	r0,1
800218f2:	2f f8       	sub	r8,-1
800218f4:	2f c3       	sub	r3,-4
800218f6:	0e 38       	cp.w	r8,r7
800218f8:	ce e5       	brlt	800218d4 <__kernel_rem_pio2f+0x1e0>
800218fa:	58 06       	cp.w	r6,0
800218fc:	e0 8a 00 1a 	brle	80021930 <__kernel_rem_pio2f+0x23c>
80021900:	58 16       	cp.w	r6,1
80021902:	c0 40       	breq	8002190a <__kernel_rem_pio2f+0x216>
80021904:	58 26       	cp.w	r6,2
80021906:	c1 51       	brne	80021930 <__kernel_rem_pio2f+0x23c>
80021908:	c0 a8       	rjmp	8002191c <__kernel_rem_pio2f+0x228>
8002190a:	fa ca fe 88 	sub	r10,sp,-376
8002190e:	f4 05 00 28 	add	r8,r10,r5<<0x2
80021912:	f0 f9 ff b0 	ld.w	r9,r8[-80]
80021916:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8002191a:	c0 98       	rjmp	8002192c <__kernel_rem_pio2f+0x238>
8002191c:	fa c9 fe 88 	sub	r9,sp,-376
80021920:	f2 05 00 28 	add	r8,r9,r5<<0x2
80021924:	f0 f9 ff b0 	ld.w	r9,r8[-80]
80021928:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
8002192c:	f1 49 ff b0 	st.w	r8[-80],r9
80021930:	58 24       	cp.w	r4,2
80021932:	c1 31       	brne	80021958 <__kernel_rem_pio2f+0x264>
80021934:	04 9b       	mov	r11,r2
80021936:	fc 1c 3f 80 	movh	r12,0x3f80
8002193a:	e0 a0 09 5f 	rcall	80022bf8 <__avr32_f32_sub>
8002193e:	18 92       	mov	r2,r12
80021940:	58 00       	cp.w	r0,0
80021942:	c0 b0       	breq	80021958 <__kernel_rem_pio2f+0x264>
80021944:	0c 9b       	mov	r11,r6
80021946:	fc 1c 3f 80 	movh	r12,0x3f80
8002194a:	e0 a0 02 97 	rcall	80021e78 <scalbnf>
8002194e:	18 9b       	mov	r11,r12
80021950:	04 9c       	mov	r12,r2
80021952:	e0 a0 09 53 	rcall	80022bf8 <__avr32_f32_sub>
80021956:	18 92       	mov	r2,r12
80021958:	30 0b       	mov	r11,0
8002195a:	04 9c       	mov	r12,r2
8002195c:	e0 a0 06 d0 	rcall	800226fc <__avr32_f32_cmp_eq>
80021960:	c5 c0       	breq	80021a18 <__kernel_rem_pio2f+0x324>
80021962:	fa c8 fe d8 	sub	r8,sp,-296
80021966:	f0 05 00 29 	add	r9,r8,r5<<0x2
8002196a:	30 08       	mov	r8,0
8002196c:	c0 58       	rjmp	80021976 <__kernel_rem_pio2f+0x282>
8002196e:	72 0a       	ld.w	r10,r9[0x0]
80021970:	20 15       	sub	r5,1
80021972:	14 48       	or	r8,r10
80021974:	20 49       	sub	r9,4
80021976:	40 3b       	lddsp	r11,sp[0xc]
80021978:	16 35       	cp.w	r5,r11
8002197a:	cf a4       	brge	8002196e <__kernel_rem_pio2f+0x27a>
8002197c:	58 08       	cp.w	r8,0
8002197e:	c5 11       	brne	80021a20 <__kernel_rem_pio2f+0x32c>
80021980:	40 d9       	lddsp	r9,sp[0x34]
80021982:	30 18       	mov	r8,1
80021984:	c0 28       	rjmp	80021988 <__kernel_rem_pio2f+0x294>
80021986:	2f f8       	sub	r8,-1
80021988:	72 0a       	ld.w	r10,r9[0x0]
8002198a:	20 49       	sub	r9,4
8002198c:	58 0a       	cp.w	r10,0
8002198e:	cf c0       	breq	80021986 <__kernel_rem_pio2f+0x292>
80021990:	0e 08       	add	r8,r7
80021992:	40 59       	lddsp	r9,sp[0x14]
80021994:	2f f9       	sub	r9,-1
80021996:	ee c5 ff ff 	sub	r5,r7,-1
8002199a:	50 b8       	stdsp	sp[0x2c],r8
8002199c:	40 9a       	lddsp	r10,sp[0x24]
8002199e:	fa c8 ff 28 	sub	r8,sp,-216
800219a2:	ee 0a 00 04 	add	r4,r7,r10
800219a6:	fa cb ff c8 	sub	r11,sp,-56
800219aa:	f2 07 00 07 	add	r7,r9,r7
800219ae:	08 93       	mov	r3,r4
800219b0:	40 a9       	lddsp	r9,sp[0x28]
800219b2:	f6 05 00 2b 	add	r11,r11,r5<<0x2
800219b6:	f2 07 00 27 	add	r7,r9,r7<<0x2
800219ba:	50 6b       	stdsp	sp[0x18],r11
800219bc:	f0 04 00 24 	add	r4,r8,r4<<0x2
800219c0:	c2 68       	rjmp	80021a0c <__kernel_rem_pio2f+0x318>
800219c2:	40 8a       	lddsp	r10,sp[0x20]
800219c4:	fa c9 ff 28 	sub	r9,sp,-216
800219c8:	6e 0c       	ld.w	r12,r7[0x0]
800219ca:	50 7a       	stdsp	sp[0x1c],r10
800219cc:	f2 03 00 20 	add	r0,r9,r3<<0x2
800219d0:	30 01       	mov	r1,0
800219d2:	e0 a0 0a 42 	rcall	80022e56 <__avr32_s32_to_f32>
800219d6:	30 02       	mov	r2,0
800219d8:	89 0c       	st.w	r4[0x0],r12
800219da:	c0 e8       	rjmp	800219f6 <__kernel_rem_pio2f+0x302>
800219dc:	40 78       	lddsp	r8,sp[0x1c]
800219de:	60 0b       	ld.w	r11,r0[0x0]
800219e0:	11 0c       	ld.w	r12,r8++
800219e2:	50 78       	stdsp	sp[0x1c],r8
800219e4:	e0 a0 09 c8 	rcall	80022d74 <__avr32_f32_mul>
800219e8:	2f f1       	sub	r1,-1
800219ea:	18 9b       	mov	r11,r12
800219ec:	20 40       	sub	r0,4
800219ee:	04 9c       	mov	r12,r2
800219f0:	e0 a0 09 6c 	rcall	80022cc8 <__avr32_f32_add>
800219f4:	18 92       	mov	r2,r12
800219f6:	40 2b       	lddsp	r11,sp[0x8]
800219f8:	16 31       	cp.w	r1,r11
800219fa:	fe 9a ff f1 	brle	800219dc <__kernel_rem_pio2f+0x2e8>
800219fe:	40 6a       	lddsp	r10,sp[0x18]
80021a00:	2f f5       	sub	r5,-1
80021a02:	14 a2       	st.w	r10++,r2
80021a04:	2f c7       	sub	r7,-4
80021a06:	50 6a       	stdsp	sp[0x18],r10
80021a08:	2f c4       	sub	r4,-4
80021a0a:	2f f3       	sub	r3,-1
80021a0c:	40 b9       	lddsp	r9,sp[0x2c]
80021a0e:	12 35       	cp.w	r5,r9
80021a10:	fe 9a ff d9 	brle	800219c2 <__kernel_rem_pio2f+0x2ce>
80021a14:	12 97       	mov	r7,r9
80021a16:	cd ea       	rjmp	800217d2 <__kernel_rem_pio2f+0xde>
80021a18:	40 c5       	lddsp	r5,sp[0x30]
80021a1a:	58 0c       	cp.w	r12,0
80021a1c:	c1 10       	breq	80021a3e <__kernel_rem_pio2f+0x34a>
80021a1e:	c0 28       	rjmp	80021a22 <__kernel_rem_pio2f+0x32e>
80021a20:	40 c5       	lddsp	r5,sp[0x30]
80021a22:	20 17       	sub	r7,1
80021a24:	fa c8 fe d8 	sub	r8,sp,-296
80021a28:	20 86       	sub	r6,8
80021a2a:	f0 07 00 28 	add	r8,r8,r7<<0x2
80021a2e:	c0 38       	rjmp	80021a34 <__kernel_rem_pio2f+0x340>
80021a30:	20 17       	sub	r7,1
80021a32:	20 86       	sub	r6,8
80021a34:	70 09       	ld.w	r9,r8[0x0]
80021a36:	20 48       	sub	r8,4
80021a38:	58 09       	cp.w	r9,0
80021a3a:	cf b0       	breq	80021a30 <__kernel_rem_pio2f+0x33c>
80021a3c:	c3 b8       	rjmp	80021ab2 <__kernel_rem_pio2f+0x3be>
80021a3e:	04 9c       	mov	r12,r2
80021a40:	ec 0b 11 00 	rsub	r11,r6,0
80021a44:	e0 a0 02 1a 	rcall	80021e78 <scalbnf>
80021a48:	fc 1b 43 80 	movh	r11,0x4380
80021a4c:	18 93       	mov	r3,r12
80021a4e:	ee 02 15 02 	lsl	r2,r7,0x2
80021a52:	e0 a0 06 61 	rcall	80022714 <__avr32_f32_cmp_ge>
80021a56:	c2 50       	breq	80021aa0 <__kernel_rem_pio2f+0x3ac>
80021a58:	fc 1b 3b 80 	movh	r11,0x3b80
80021a5c:	06 9c       	mov	r12,r3
80021a5e:	e0 a0 09 8b 	rcall	80022d74 <__avr32_f32_mul>
80021a62:	e0 a0 0a 34 	rcall	80022eca <__avr32_f32_to_s32>
80021a66:	e0 a0 09 f8 	rcall	80022e56 <__avr32_s32_to_f32>
80021a6a:	fc 1b c3 80 	movh	r11,0xc380
80021a6e:	18 90       	mov	r0,r12
80021a70:	e0 a0 09 82 	rcall	80022d74 <__avr32_f32_mul>
80021a74:	18 9b       	mov	r11,r12
80021a76:	06 9c       	mov	r12,r3
80021a78:	e0 a0 09 28 	rcall	80022cc8 <__avr32_f32_add>
80021a7c:	e0 a0 0a 27 	rcall	80022eca <__avr32_f32_to_s32>
80021a80:	fa c8 fe 88 	sub	r8,sp,-376
80021a84:	2f f7       	sub	r7,-1
80021a86:	f0 02 00 02 	add	r2,r8,r2
80021a8a:	f0 07 00 23 	add	r3,r8,r7<<0x2
80021a8e:	e5 4c ff b0 	st.w	r2[-80],r12
80021a92:	2f 86       	sub	r6,-8
80021a94:	00 9c       	mov	r12,r0
80021a96:	e0 a0 0a 1a 	rcall	80022eca <__avr32_f32_to_s32>
80021a9a:	e7 4c ff b0 	st.w	r3[-80],r12
80021a9e:	c0 a8       	rjmp	80021ab2 <__kernel_rem_pio2f+0x3be>
80021aa0:	fa cb fe 88 	sub	r11,sp,-376
80021aa4:	06 9c       	mov	r12,r3
80021aa6:	f6 02 00 02 	add	r2,r11,r2
80021aaa:	e0 a0 0a 10 	rcall	80022eca <__avr32_f32_to_s32>
80021aae:	e5 4c ff b0 	st.w	r2[-80],r12
80021ab2:	0c 9b       	mov	r11,r6
80021ab4:	fc 1c 3f 80 	movh	r12,0x3f80
80021ab8:	ce 0d       	rcall	80021e78 <scalbnf>
80021aba:	ee 08 15 02 	lsl	r8,r7,0x2
80021abe:	fa c3 fe d8 	sub	r3,sp,-296
80021ac2:	fa c6 ff c8 	sub	r6,sp,-56
80021ac6:	0e 90       	mov	r0,r7
80021ac8:	18 92       	mov	r2,r12
80021aca:	10 03       	add	r3,r8
80021acc:	10 06       	add	r6,r8
80021ace:	c1 28       	rjmp	80021af2 <__kernel_rem_pio2f+0x3fe>
80021ad0:	66 0c       	ld.w	r12,r3[0x0]
80021ad2:	e0 a0 09 c2 	rcall	80022e56 <__avr32_s32_to_f32>
80021ad6:	18 9b       	mov	r11,r12
80021ad8:	04 9c       	mov	r12,r2
80021ada:	e0 a0 09 4d 	rcall	80022d74 <__avr32_f32_mul>
80021ade:	fc 1b 3b 80 	movh	r11,0x3b80
80021ae2:	8d 0c       	st.w	r6[0x0],r12
80021ae4:	20 10       	sub	r0,1
80021ae6:	04 9c       	mov	r12,r2
80021ae8:	20 43       	sub	r3,4
80021aea:	e0 a0 09 45 	rcall	80022d74 <__avr32_f32_mul>
80021aee:	20 46       	sub	r6,4
80021af0:	18 92       	mov	r2,r12
80021af2:	58 00       	cp.w	r0,0
80021af4:	ce e4       	brge	80021ad0 <__kernel_rem_pio2f+0x3dc>
80021af6:	fa ca ff 78 	sub	r10,sp,-136
80021afa:	0e 96       	mov	r6,r7
80021afc:	30 02       	mov	r2,0
80021afe:	fa c8 ff c8 	sub	r8,sp,-56
80021b02:	14 90       	mov	r0,r10
80021b04:	50 24       	stdsp	sp[0x8],r4
80021b06:	c1 98       	rjmp	80021b38 <__kernel_rem_pio2f+0x444>
80021b08:	50 18       	stdsp	sp[0x4],r8
80021b0a:	0d 0b       	ld.w	r11,r6++
80021b0c:	01 0c       	ld.w	r12,r0++
80021b0e:	e0 a0 09 33 	rcall	80022d74 <__avr32_f32_mul>
80021b12:	18 9b       	mov	r11,r12
80021b14:	06 9c       	mov	r12,r3
80021b16:	e0 a0 08 d9 	rcall	80022cc8 <__avr32_f32_add>
80021b1a:	2f f4       	sub	r4,-1
80021b1c:	18 93       	mov	r3,r12
80021b1e:	40 18       	lddsp	r8,sp[0x4]
80021b20:	40 3a       	lddsp	r10,sp[0xc]
80021b22:	14 34       	cp.w	r4,r10
80021b24:	e0 89 00 05 	brgt	80021b2e <__kernel_rem_pio2f+0x43a>
80021b28:	04 34       	cp.w	r4,r2
80021b2a:	fe 9a ff ef 	brle	80021b08 <__kernel_rem_pio2f+0x414>
80021b2e:	40 56       	lddsp	r6,sp[0x14]
80021b30:	40 60       	lddsp	r0,sp[0x18]
80021b32:	20 16       	sub	r6,1
80021b34:	00 a3       	st.w	r0++,r3
80021b36:	2f f2       	sub	r2,-1
80021b38:	58 06       	cp.w	r6,0
80021b3a:	c0 c5       	brlt	80021b52 <__kernel_rem_pio2f+0x45e>
80021b3c:	fe c9 bd 84 	sub	r9,pc,-17020
80021b40:	f0 06 00 2a 	add	r10,r8,r6<<0x2
80021b44:	50 56       	stdsp	sp[0x14],r6
80021b46:	50 60       	stdsp	sp[0x18],r0
80021b48:	30 03       	mov	r3,0
80021b4a:	30 04       	mov	r4,0
80021b4c:	14 96       	mov	r6,r10
80021b4e:	12 90       	mov	r0,r9
80021b50:	ce 8b       	rjmp	80021b20 <__kernel_rem_pio2f+0x42c>
80021b52:	40 24       	lddsp	r4,sp[0x8]
80021b54:	40 49       	lddsp	r9,sp[0x10]
80021b56:	58 29       	cp.w	r9,2
80021b58:	e0 89 00 07 	brgt	80021b66 <__kernel_rem_pio2f+0x472>
80021b5c:	58 19       	cp.w	r9,1
80021b5e:	c1 14       	brge	80021b80 <__kernel_rem_pio2f+0x48c>
80021b60:	58 09       	cp.w	r9,0
80021b62:	c1 60       	breq	80021b8e <__kernel_rem_pio2f+0x49a>
80021b64:	c9 f8       	rjmp	80021ca2 <__kernel_rem_pio2f+0x5ae>
80021b66:	40 48       	lddsp	r8,sp[0x10]
80021b68:	58 38       	cp.w	r8,3
80021b6a:	e0 81 00 9c 	brne	80021ca2 <__kernel_rem_pio2f+0x5ae>
80021b6e:	ee c6 00 01 	sub	r6,r7,1
80021b72:	fa c8 ff 78 	sub	r8,sp,-136
80021b76:	0e 92       	mov	r2,r7
80021b78:	f0 06 00 26 	add	r6,r8,r6<<0x2
80021b7c:	0c 93       	mov	r3,r6
80021b7e:	c5 48       	rjmp	80021c26 <__kernel_rem_pio2f+0x532>
80021b80:	fa c3 ff 78 	sub	r3,sp,-136
80021b84:	0e 96       	mov	r6,r7
80021b86:	e6 07 00 23 	add	r3,r3,r7<<0x2
80021b8a:	30 0c       	mov	r12,0
80021b8c:	c1 a8       	rjmp	80021bc0 <__kernel_rem_pio2f+0x4cc>
80021b8e:	0e 96       	mov	r6,r7
80021b90:	fa c8 ff 78 	sub	r8,sp,-136
80021b94:	30 0c       	mov	r12,0
80021b96:	f0 07 00 27 	add	r7,r8,r7<<0x2
80021b9a:	c0 68       	rjmp	80021ba6 <__kernel_rem_pio2f+0x4b2>
80021b9c:	6e 0b       	ld.w	r11,r7[0x0]
80021b9e:	20 16       	sub	r6,1
80021ba0:	20 47       	sub	r7,4
80021ba2:	e0 a0 08 93 	rcall	80022cc8 <__avr32_f32_add>
80021ba6:	58 06       	cp.w	r6,0
80021ba8:	cf a4       	brge	80021b9c <__kernel_rem_pio2f+0x4a8>
80021baa:	58 04       	cp.w	r4,0
80021bac:	c0 30       	breq	80021bb2 <__kernel_rem_pio2f+0x4be>
80021bae:	ee 1c 80 00 	eorh	r12,0x8000
80021bb2:	8b 0c       	st.w	r5[0x0],r12
80021bb4:	c7 78       	rjmp	80021ca2 <__kernel_rem_pio2f+0x5ae>
80021bb6:	66 0b       	ld.w	r11,r3[0x0]
80021bb8:	20 16       	sub	r6,1
80021bba:	20 43       	sub	r3,4
80021bbc:	e0 a0 08 86 	rcall	80022cc8 <__avr32_f32_add>
80021bc0:	58 06       	cp.w	r6,0
80021bc2:	cf a4       	brge	80021bb6 <__kernel_rem_pio2f+0x4c2>
80021bc4:	18 9b       	mov	r11,r12
80021bc6:	58 04       	cp.w	r4,0
80021bc8:	c0 30       	breq	80021bce <__kernel_rem_pio2f+0x4da>
80021bca:	ee 1c 80 00 	eorh	r12,0x8000
80021bce:	8b 0c       	st.w	r5[0x0],r12
80021bd0:	fa c3 ff 74 	sub	r3,sp,-140
80021bd4:	42 2c       	lddsp	r12,sp[0x88]
80021bd6:	30 16       	mov	r6,1
80021bd8:	e0 a0 08 10 	rcall	80022bf8 <__avr32_f32_sub>
80021bdc:	c0 58       	rjmp	80021be6 <__kernel_rem_pio2f+0x4f2>
80021bde:	2f f6       	sub	r6,-1
80021be0:	07 0b       	ld.w	r11,r3++
80021be2:	e0 a0 08 73 	rcall	80022cc8 <__avr32_f32_add>
80021be6:	0e 36       	cp.w	r6,r7
80021be8:	fe 9a ff fb 	brle	80021bde <__kernel_rem_pio2f+0x4ea>
80021bec:	58 04       	cp.w	r4,0
80021bee:	c0 30       	breq	80021bf4 <__kernel_rem_pio2f+0x500>
80021bf0:	ee 1c 80 00 	eorh	r12,0x8000
80021bf4:	8b 1c       	st.w	r5[0x4],r12
80021bf6:	c5 68       	rjmp	80021ca2 <__kernel_rem_pio2f+0x5ae>
80021bf8:	66 19       	ld.w	r9,r3[0x4]
80021bfa:	66 08       	ld.w	r8,r3[0x0]
80021bfc:	12 9b       	mov	r11,r9
80021bfe:	50 09       	stdsp	sp[0x0],r9
80021c00:	10 9c       	mov	r12,r8
80021c02:	50 18       	stdsp	sp[0x4],r8
80021c04:	e0 a0 08 62 	rcall	80022cc8 <__avr32_f32_add>
80021c08:	40 18       	lddsp	r8,sp[0x4]
80021c0a:	18 9b       	mov	r11,r12
80021c0c:	18 90       	mov	r0,r12
80021c0e:	10 9c       	mov	r12,r8
80021c10:	e0 a0 07 f4 	rcall	80022bf8 <__avr32_f32_sub>
80021c14:	40 09       	lddsp	r9,sp[0x0]
80021c16:	18 9b       	mov	r11,r12
80021c18:	20 12       	sub	r2,1
80021c1a:	12 9c       	mov	r12,r9
80021c1c:	e0 a0 08 56 	rcall	80022cc8 <__avr32_f32_add>
80021c20:	87 00       	st.w	r3[0x0],r0
80021c22:	87 1c       	st.w	r3[0x4],r12
80021c24:	20 43       	sub	r3,4
80021c26:	58 02       	cp.w	r2,0
80021c28:	fe 99 ff e8 	brgt	80021bf8 <__kernel_rem_pio2f+0x504>
80021c2c:	0e 93       	mov	r3,r7
80021c2e:	c1 68       	rjmp	80021c5a <__kernel_rem_pio2f+0x566>
80021c30:	6c 18       	ld.w	r8,r6[0x4]
80021c32:	6c 00       	ld.w	r0,r6[0x0]
80021c34:	10 9b       	mov	r11,r8
80021c36:	50 18       	stdsp	sp[0x4],r8
80021c38:	00 9c       	mov	r12,r0
80021c3a:	e0 a0 08 47 	rcall	80022cc8 <__avr32_f32_add>
80021c3e:	18 9b       	mov	r11,r12
80021c40:	18 92       	mov	r2,r12
80021c42:	00 9c       	mov	r12,r0
80021c44:	e0 a0 07 da 	rcall	80022bf8 <__avr32_f32_sub>
80021c48:	40 18       	lddsp	r8,sp[0x4]
80021c4a:	18 9b       	mov	r11,r12
80021c4c:	20 13       	sub	r3,1
80021c4e:	10 9c       	mov	r12,r8
80021c50:	e0 a0 08 3c 	rcall	80022cc8 <__avr32_f32_add>
80021c54:	8d 02       	st.w	r6[0x0],r2
80021c56:	8d 1c       	st.w	r6[0x4],r12
80021c58:	20 46       	sub	r6,4
80021c5a:	58 13       	cp.w	r3,1
80021c5c:	fe 99 ff ea 	brgt	80021c30 <__kernel_rem_pio2f+0x53c>
80021c60:	0e 96       	mov	r6,r7
80021c62:	fa c8 ff 78 	sub	r8,sp,-136
80021c66:	30 0c       	mov	r12,0
80021c68:	f0 07 00 27 	add	r7,r8,r7<<0x2
80021c6c:	c0 68       	rjmp	80021c78 <__kernel_rem_pio2f+0x584>
80021c6e:	6e 0b       	ld.w	r11,r7[0x0]
80021c70:	20 16       	sub	r6,1
80021c72:	20 47       	sub	r7,4
80021c74:	e0 a0 08 2a 	rcall	80022cc8 <__avr32_f32_add>
80021c78:	58 16       	cp.w	r6,1
80021c7a:	fe 99 ff fa 	brgt	80021c6e <__kernel_rem_pio2f+0x57a>
80021c7e:	58 04       	cp.w	r4,0
80021c80:	c0 61       	brne	80021c8c <__kernel_rem_pio2f+0x598>
80021c82:	8b 2c       	st.w	r5[0x8],r12
80021c84:	42 28       	lddsp	r8,sp[0x88]
80021c86:	8b 08       	st.w	r5[0x0],r8
80021c88:	42 38       	lddsp	r8,sp[0x8c]
80021c8a:	c0 b8       	rjmp	80021ca0 <__kernel_rem_pio2f+0x5ac>
80021c8c:	ee 1c 80 00 	eorh	r12,0x8000
80021c90:	8b 2c       	st.w	r5[0x8],r12
80021c92:	42 28       	lddsp	r8,sp[0x88]
80021c94:	ee 18 80 00 	eorh	r8,0x8000
80021c98:	8b 08       	st.w	r5[0x0],r8
80021c9a:	42 38       	lddsp	r8,sp[0x8c]
80021c9c:	ee 18 80 00 	eorh	r8,0x8000
80021ca0:	8b 18       	st.w	r5[0x4],r8
80021ca2:	f9 d1 c0 03 	bfextu	r12,r1,0x0,0x3
80021ca6:	2a 2d       	sub	sp,-376
80021ca8:	d8 32       	popm	r0-r7,pc
80021caa:	d7 03       	nop

80021cac <__kernel_sinf>:
80021cac:	d4 31       	pushm	r0-r7,lr
80021cae:	e0 69 ff ff 	mov	r9,65535
80021cb2:	ea 19 31 ff 	orh	r9,0x31ff
80021cb6:	16 97       	mov	r7,r11
80021cb8:	14 92       	mov	r2,r10
80021cba:	18 96       	mov	r6,r12
80021cbc:	f1 dc c0 1f 	bfextu	r8,r12,0x0,0x1f
80021cc0:	12 38       	cp.w	r8,r9
80021cc2:	e0 89 00 05 	brgt	80021ccc <__kernel_sinf+0x20>
80021cc6:	e0 a0 09 02 	rcall	80022eca <__avr32_f32_to_s32>
80021cca:	c7 10       	breq	80021dac <__kernel_sinf+0x100>
80021ccc:	0c 9b       	mov	r11,r6
80021cce:	0c 9c       	mov	r12,r6
80021cd0:	e0 a0 08 52 	rcall	80022d74 <__avr32_f32_mul>
80021cd4:	0c 9b       	mov	r11,r6
80021cd6:	18 95       	mov	r5,r12
80021cd8:	e0 a0 08 4e 	rcall	80022d74 <__avr32_f32_mul>
80021cdc:	e0 6b c9 d3 	mov	r11,51667
80021ce0:	ea 1b 2f 2e 	orh	r11,0x2f2e
80021ce4:	18 94       	mov	r4,r12
80021ce6:	0a 9c       	mov	r12,r5
80021ce8:	e0 a0 08 46 	rcall	80022d74 <__avr32_f32_mul>
80021cec:	e0 6b 2f 34 	mov	r11,12084
80021cf0:	ea 1b 32 d7 	orh	r11,0x32d7
80021cf4:	e0 a0 07 82 	rcall	80022bf8 <__avr32_f32_sub>
80021cf8:	18 9b       	mov	r11,r12
80021cfa:	0a 9c       	mov	r12,r5
80021cfc:	e0 a0 08 3c 	rcall	80022d74 <__avr32_f32_mul>
80021d00:	e0 6b ef 1b 	mov	r11,61211
80021d04:	ea 1b 36 38 	orh	r11,0x3638
80021d08:	e0 a0 07 e0 	rcall	80022cc8 <__avr32_f32_add>
80021d0c:	18 9b       	mov	r11,r12
80021d0e:	0a 9c       	mov	r12,r5
80021d10:	e0 a0 08 32 	rcall	80022d74 <__avr32_f32_mul>
80021d14:	e0 6b 0d 01 	mov	r11,3329
80021d18:	ea 1b 39 50 	orh	r11,0x3950
80021d1c:	e0 a0 07 6e 	rcall	80022bf8 <__avr32_f32_sub>
80021d20:	18 9b       	mov	r11,r12
80021d22:	0a 9c       	mov	r12,r5
80021d24:	e0 a0 08 28 	rcall	80022d74 <__avr32_f32_mul>
80021d28:	e0 6b 88 89 	mov	r11,34953
80021d2c:	ea 1b 3c 08 	orh	r11,0x3c08
80021d30:	e0 a0 07 cc 	rcall	80022cc8 <__avr32_f32_add>
80021d34:	18 93       	mov	r3,r12
80021d36:	58 02       	cp.w	r2,0
80021d38:	c1 41       	brne	80021d60 <__kernel_sinf+0xb4>
80021d3a:	18 9b       	mov	r11,r12
80021d3c:	0a 9c       	mov	r12,r5
80021d3e:	e0 a0 08 1b 	rcall	80022d74 <__avr32_f32_mul>
80021d42:	e0 6b aa ab 	mov	r11,43691
80021d46:	ea 1b 3e 2a 	orh	r11,0x3e2a
80021d4a:	e0 a0 07 57 	rcall	80022bf8 <__avr32_f32_sub>
80021d4e:	18 9b       	mov	r11,r12
80021d50:	08 9c       	mov	r12,r4
80021d52:	e0 a0 08 11 	rcall	80022d74 <__avr32_f32_mul>
80021d56:	18 9b       	mov	r11,r12
80021d58:	0c 9c       	mov	r12,r6
80021d5a:	e0 a0 07 b7 	rcall	80022cc8 <__avr32_f32_add>
80021d5e:	c2 68       	rjmp	80021daa <__kernel_sinf+0xfe>
80021d60:	fc 1b 3f 00 	movh	r11,0x3f00
80021d64:	0e 9c       	mov	r12,r7
80021d66:	e0 a0 08 07 	rcall	80022d74 <__avr32_f32_mul>
80021d6a:	06 9b       	mov	r11,r3
80021d6c:	18 92       	mov	r2,r12
80021d6e:	08 9c       	mov	r12,r4
80021d70:	e0 a0 08 02 	rcall	80022d74 <__avr32_f32_mul>
80021d74:	18 9b       	mov	r11,r12
80021d76:	04 9c       	mov	r12,r2
80021d78:	e0 a0 07 40 	rcall	80022bf8 <__avr32_f32_sub>
80021d7c:	18 9b       	mov	r11,r12
80021d7e:	0a 9c       	mov	r12,r5
80021d80:	e0 a0 07 fa 	rcall	80022d74 <__avr32_f32_mul>
80021d84:	0e 9b       	mov	r11,r7
80021d86:	e0 a0 07 39 	rcall	80022bf8 <__avr32_f32_sub>
80021d8a:	e0 6b aa ab 	mov	r11,43691
80021d8e:	ea 1b 3e 2a 	orh	r11,0x3e2a
80021d92:	18 97       	mov	r7,r12
80021d94:	08 9c       	mov	r12,r4
80021d96:	e0 a0 07 ef 	rcall	80022d74 <__avr32_f32_mul>
80021d9a:	18 9b       	mov	r11,r12
80021d9c:	0e 9c       	mov	r12,r7
80021d9e:	e0 a0 07 95 	rcall	80022cc8 <__avr32_f32_add>
80021da2:	18 9b       	mov	r11,r12
80021da4:	0c 9c       	mov	r12,r6
80021da6:	e0 a0 07 29 	rcall	80022bf8 <__avr32_f32_sub>
80021daa:	18 96       	mov	r6,r12
80021dac:	0c 9c       	mov	r12,r6
80021dae:	d8 32       	popm	r0-r7,pc

80021db0 <fabsf>:
80021db0:	f9 dc c0 1f 	bfextu	r12,r12,0x0,0x1f
80021db4:	5e fc       	retal	r12

80021db6 <finitef>:
80021db6:	e0 68 ff ff 	mov	r8,65535
80021dba:	ea 18 7f 7f 	orh	r8,0x7f7f
80021dbe:	f9 dc c0 1f 	bfextu	r12,r12,0x0,0x1f
80021dc2:	10 3c       	cp.w	r12,r8
80021dc4:	5f ac       	srle	r12
80021dc6:	5e fc       	retal	r12

80021dc8 <floorf>:
80021dc8:	d4 21       	pushm	r4-r7,lr
80021dca:	eb dc c0 1f 	bfextu	r5,r12,0x0,0x1f
80021dce:	18 9b       	mov	r11,r12
80021dd0:	ea 06 16 17 	lsr	r6,r5,0x17
80021dd4:	18 97       	mov	r7,r12
80021dd6:	27 f6       	sub	r6,127
80021dd8:	59 66       	cp.w	r6,22
80021dda:	e0 89 00 35 	brgt	80021e44 <floorf+0x7c>
80021dde:	58 06       	cp.w	r6,0
80021de0:	c1 44       	brge	80021e08 <floorf+0x40>
80021de2:	e0 6b f2 ca 	mov	r11,62154
80021de6:	ea 1b 71 49 	orh	r11,0x7149
80021dea:	e0 a0 07 6f 	rcall	80022cc8 <__avr32_f32_add>
80021dee:	18 9b       	mov	r11,r12
80021df0:	30 0c       	mov	r12,0
80021df2:	e0 a0 04 ab 	rcall	80022748 <__avr32_f32_cmp_lt>
80021df6:	c3 30       	breq	80021e5c <floorf+0x94>
80021df8:	58 07       	cp.w	r7,0
80021dfa:	c3 04       	brge	80021e5a <floorf+0x92>
80021dfc:	fc 18 bf 80 	movh	r8,0xbf80
80021e00:	58 05       	cp.w	r5,0
80021e02:	f0 07 17 10 	movne	r7,r8
80021e06:	c2 b8       	rjmp	80021e5c <floorf+0x94>
80021e08:	e0 65 ff ff 	mov	r5,65535
80021e0c:	ea 15 00 7f 	orh	r5,0x7f
80021e10:	ea 06 08 45 	asr	r5,r5,r6
80021e14:	eb ec 00 08 	and	r8,r5,r12
80021e18:	c2 30       	breq	80021e5e <floorf+0x96>
80021e1a:	e0 6b f2 ca 	mov	r11,62154
80021e1e:	ea 1b 71 49 	orh	r11,0x7149
80021e22:	e0 a0 07 53 	rcall	80022cc8 <__avr32_f32_add>
80021e26:	18 9b       	mov	r11,r12
80021e28:	30 0c       	mov	r12,0
80021e2a:	e0 a0 04 8f 	rcall	80022748 <__avr32_f32_cmp_lt>
80021e2e:	c1 70       	breq	80021e5c <floorf+0x94>
80021e30:	58 07       	cp.w	r7,0
80021e32:	c0 64       	brge	80021e3e <floorf+0x76>
80021e34:	fc 18 00 80 	movh	r8,0x80
80021e38:	f0 06 08 46 	asr	r6,r8,r6
80021e3c:	0c 07       	add	r7,r6
80021e3e:	5c d5       	com	r5
80021e40:	0a 67       	and	r7,r5
80021e42:	c0 d8       	rjmp	80021e5c <floorf+0x94>
80021e44:	e0 68 ff ff 	mov	r8,65535
80021e48:	ea 18 7f 7f 	orh	r8,0x7f7f
80021e4c:	10 35       	cp.w	r5,r8
80021e4e:	e0 88 00 08 	brls	80021e5e <floorf+0x96>
80021e52:	e0 a0 07 3b 	rcall	80022cc8 <__avr32_f32_add>
80021e56:	18 9b       	mov	r11,r12
80021e58:	c0 38       	rjmp	80021e5e <floorf+0x96>
80021e5a:	30 07       	mov	r7,0
80021e5c:	0e 9b       	mov	r11,r7
80021e5e:	16 9c       	mov	r12,r11
80021e60:	d8 22       	popm	r4-r7,pc
80021e62:	d7 03       	nop

80021e64 <isnanf>:
80021e64:	fc 18 7f 80 	movh	r8,0x7f80
80021e68:	f9 dc c0 1f 	bfextu	r12,r12,0x0,0x1f
80021e6c:	10 3c       	cp.w	r12,r8
80021e6e:	5f 9c       	srgt	r12
80021e70:	5e fc       	retal	r12

80021e72 <nanf>:
80021e72:	fc 1c 7f c0 	movh	r12,0x7fc0
80021e76:	5e fc       	retal	r12

80021e78 <scalbnf>:
80021e78:	d4 21       	pushm	r4-r7,lr
80021e7a:	16 97       	mov	r7,r11
80021e7c:	18 99       	mov	r9,r12
80021e7e:	18 9b       	mov	r11,r12
80021e80:	f1 dc c0 1f 	bfextu	r8,r12,0x0,0x1f
80021e84:	c5 10       	breq	80021f26 <scalbnf+0xae>
80021e86:	e0 6a ff ff 	mov	r10,65535
80021e8a:	ea 1a 7f 7f 	orh	r10,0x7f7f
80021e8e:	14 38       	cp.w	r8,r10
80021e90:	e0 88 00 05 	brls	80021e9a <scalbnf+0x22>
80021e94:	e0 a0 07 1a 	rcall	80022cc8 <__avr32_f32_add>
80021e98:	c4 68       	rjmp	80021f24 <scalbnf+0xac>
80021e9a:	e0 6a ff ff 	mov	r10,65535
80021e9e:	ea 1a 00 7f 	orh	r10,0x7f
80021ea2:	14 38       	cp.w	r8,r10
80021ea4:	e0 8b 00 0f 	brhi	80021ec2 <scalbnf+0x4a>
80021ea8:	fc 1b 4c 00 	movh	r11,0x4c00
80021eac:	e0 a0 07 64 	rcall	80022d74 <__avr32_f32_mul>
80021eb0:	18 9b       	mov	r11,r12
80021eb2:	fe 57 3c b0 	cp.w	r7,-50000
80021eb6:	c2 95       	brlt	80021f08 <scalbnf+0x90>
80021eb8:	f1 dc c2 e8 	bfextu	r8,r12,0x17,0x8
80021ebc:	18 99       	mov	r9,r12
80021ebe:	21 98       	sub	r8,25
80021ec0:	c0 28       	rjmp	80021ec4 <scalbnf+0x4c>
80021ec2:	b7 98       	lsr	r8,0x17
80021ec4:	0e 08       	add	r8,r7
80021ec6:	e0 48 00 fe 	cp.w	r8,254
80021eca:	e0 89 00 10 	brgt	80021eea <scalbnf+0x72>
80021ece:	58 08       	cp.w	r8,0
80021ed0:	e0 8a 00 07 	brle	80021ede <scalbnf+0x66>
80021ed4:	e4 19 80 7f 	andh	r9,0x807f
80021ed8:	f3 e8 11 7b 	or	r11,r9,r8<<0x17
80021edc:	c2 58       	rjmp	80021f26 <scalbnf+0xae>
80021ede:	5a a8       	cp.w	r8,-22
80021ee0:	c1 94       	brge	80021f12 <scalbnf+0x9a>
80021ee2:	e0 47 c3 50 	cp.w	r7,50000
80021ee6:	e0 8a 00 0c 	brle	80021efe <scalbnf+0x86>
80021eea:	e0 6c f2 ca 	mov	r12,62154
80021eee:	ea 1c 71 49 	orh	r12,0x7149
80021ef2:	cb bc       	rcall	80022068 <copysignf>
80021ef4:	e0 6b f2 ca 	mov	r11,62154
80021ef8:	ea 1b 71 49 	orh	r11,0x7149
80021efc:	c1 28       	rjmp	80021f20 <scalbnf+0xa8>
80021efe:	e0 6c 42 60 	mov	r12,16992
80021f02:	ea 1c 0d a2 	orh	r12,0xda2
80021f06:	cb 1c       	rcall	80022068 <copysignf>
80021f08:	e0 6b 42 60 	mov	r11,16992
80021f0c:	ea 1b 0d a2 	orh	r11,0xda2
80021f10:	c0 88       	rjmp	80021f20 <scalbnf+0xa8>
80021f12:	2e 78       	sub	r8,-25
80021f14:	e4 19 80 7f 	andh	r9,0x807f
80021f18:	fc 1b 33 00 	movh	r11,0x3300
80021f1c:	f3 e8 11 7c 	or	r12,r9,r8<<0x17
80021f20:	e0 a0 07 2a 	rcall	80022d74 <__avr32_f32_mul>
80021f24:	18 9b       	mov	r11,r12
80021f26:	16 9c       	mov	r12,r11
80021f28:	d8 22       	popm	r4-r7,pc
80021f2a:	d7 03       	nop

80021f2c <__isnand>:
80021f2c:	14 98       	mov	r8,r10
80021f2e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80021f32:	f0 0c 11 00 	rsub	r12,r8,0
80021f36:	10 4c       	or	r12,r8
80021f38:	fc 18 7f f0 	movh	r8,0x7ff0
80021f3c:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80021f40:	f0 0c 01 0c 	sub	r12,r8,r12
80021f44:	bf 9c       	lsr	r12,0x1f
80021f46:	5e fc       	retal	r12

80021f48 <matherr>:
80021f48:	5e fd       	retal	0

80021f4a <nan>:
80021f4a:	30 0a       	mov	r10,0
80021f4c:	fc 1b 7f f8 	movh	r11,0x7ff8
80021f50:	5e fc       	retal	r12
80021f52:	d7 03       	nop

80021f54 <rint>:
80021f54:	d4 21       	pushm	r4-r7,lr
80021f56:	20 2d       	sub	sp,8
80021f58:	ed db c2 8b 	bfextu	r6,r11,0x14,0xb
80021f5c:	14 94       	mov	r4,r10
80021f5e:	16 95       	mov	r5,r11
80021f60:	14 98       	mov	r8,r10
80021f62:	16 9e       	mov	lr,r11
80021f64:	16 9c       	mov	r12,r11
80021f66:	f6 07 16 1f 	lsr	r7,r11,0x1f
80021f6a:	ec c9 03 ff 	sub	r9,r6,1023
80021f6e:	59 39       	cp.w	r9,19
80021f70:	e0 89 00 4a 	brgt	80022004 <rint+0xb0>
80021f74:	58 09       	cp.w	r9,0
80021f76:	c2 c4       	brge	80021fce <rint+0x7a>
80021f78:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
80021f7c:	14 49       	or	r9,r10
80021f7e:	c7 10       	breq	80022060 <rint+0x10c>
80021f80:	fd db c0 14 	bfextu	lr,r11,0x0,0x14
80021f84:	fe cc c1 a0 	sub	r12,pc,-15968
80021f88:	fd e4 10 08 	or	r8,lr,r4
80021f8c:	16 99       	mov	r9,r11
80021f8e:	f0 0e 11 00 	rsub	lr,r8,0
80021f92:	e6 19 ff fe 	andh	r9,0xfffe,COH
80021f96:	fd e8 10 08 	or	r8,lr,r8
80021f9a:	ad 88       	lsr	r8,0xc
80021f9c:	e6 18 00 08 	andh	r8,0x8,COH
80021fa0:	f1 e9 10 0b 	or	r11,r8,r9
80021fa4:	f8 07 02 34 	ld.d	r4,r12[r7<<0x3]
80021fa8:	14 98       	mov	r8,r10
80021faa:	16 99       	mov	r9,r11
80021fac:	08 9a       	mov	r10,r4
80021fae:	0a 9b       	mov	r11,r5
80021fb0:	e0 a0 02 1e 	rcall	800223ec <__avr32_f64_add>
80021fb4:	08 98       	mov	r8,r4
80021fb6:	fa eb 00 00 	st.d	sp[0],r10
80021fba:	0a 99       	mov	r9,r5
80021fbc:	fa ea 00 00 	ld.d	r10,sp[0]
80021fc0:	c4 8d       	rcall	80022250 <__avr32_f64_sub>
80021fc2:	f7 db c0 1f 	bfextu	r11,r11,0x0,0x1f
80021fc6:	14 94       	mov	r4,r10
80021fc8:	f7 e7 11 f5 	or	r5,r11,r7<<0x1f
80021fcc:	c4 a8       	rjmp	80022060 <rint+0x10c>
80021fce:	ee 7a ff ff 	mov	r10,1048575
80021fd2:	f4 09 08 4a 	asr	r10,r10,r9
80021fd6:	f5 eb 00 0b 	and	r11,r10,r11
80021fda:	08 4b       	or	r11,r4
80021fdc:	c4 20       	breq	80022060 <rint+0x10c>
80021fde:	a1 9a       	lsr	r10,0x1
80021fe0:	f5 e5 00 0b 	and	r11,r10,r5
80021fe4:	08 4b       	or	r11,r4
80021fe6:	c0 31       	brne	80021fec <rint+0x98>
80021fe8:	16 98       	mov	r8,r11
80021fea:	c2 a8       	rjmp	8002203e <rint+0xea>
80021fec:	59 39       	cp.w	r9,19
80021fee:	c0 41       	brne	80021ff6 <rint+0xa2>
80021ff0:	fc 18 40 00 	movh	r8,0x4000
80021ff4:	c2 58       	rjmp	8002203e <rint+0xea>
80021ff6:	14 8c       	andn	r12,r10
80021ff8:	e2 6a 00 00 	mov	r10,131072
80021ffc:	f4 09 08 49 	asr	r9,r10,r9
80022000:	12 4c       	or	r12,r9
80022002:	c1 e8       	rjmp	8002203e <rint+0xea>
80022004:	e0 49 00 33 	cp.w	r9,51
80022008:	e0 8a 00 09 	brle	8002201a <rint+0xc6>
8002200c:	e0 49 04 00 	cp.w	r9,1024
80022010:	c2 81       	brne	80022060 <rint+0x10c>
80022012:	14 98       	mov	r8,r10
80022014:	16 99       	mov	r9,r11
80022016:	ce bd       	rcall	800223ec <__avr32_f64_add>
80022018:	c2 28       	rjmp	8002205c <rint+0x108>
8002201a:	ec c6 04 13 	sub	r6,r6,1043
8002201e:	3f f9       	mov	r9,-1
80022020:	f2 06 0a 49 	lsr	r9,r9,r6
80022024:	f3 ea 00 0a 	and	r10,r9,r10
80022028:	c1 c0       	breq	80022060 <rint+0x10c>
8002202a:	a1 99       	lsr	r9,0x1
8002202c:	f3 e4 00 0a 	and	r10,r9,r4
80022030:	c0 70       	breq	8002203e <rint+0xea>
80022032:	12 88       	andn	r8,r9
80022034:	fc 19 40 00 	movh	r9,0x4000
80022038:	f2 06 08 46 	asr	r6,r9,r6
8002203c:	0c 48       	or	r8,r6
8002203e:	fe ca c2 5a 	sub	r10,pc,-15782
80022042:	18 99       	mov	r9,r12
80022044:	f4 07 02 36 	ld.d	r6,r10[r7<<0x3]
80022048:	0c 9a       	mov	r10,r6
8002204a:	0e 9b       	mov	r11,r7
8002204c:	cd 0d       	rcall	800223ec <__avr32_f64_add>
8002204e:	0c 98       	mov	r8,r6
80022050:	fa eb 00 00 	st.d	sp[0],r10
80022054:	0e 99       	mov	r9,r7
80022056:	fa ea 00 00 	ld.d	r10,sp[0]
8002205a:	cf bc       	rcall	80022250 <__avr32_f64_sub>
8002205c:	14 94       	mov	r4,r10
8002205e:	16 95       	mov	r5,r11
80022060:	08 9a       	mov	r10,r4
80022062:	0a 9b       	mov	r11,r5
80022064:	2f ed       	sub	sp,-8
80022066:	d8 22       	popm	r4-r7,pc

80022068 <copysignf>:
80022068:	e6 1b 80 00 	andh	r11,0x8000,COH
8002206c:	f9 dc c0 1f 	bfextu	r12,r12,0x0,0x1f
80022070:	f7 ec 10 0c 	or	r12,r11,r12
80022074:	5e fc       	retal	r12
80022076:	d7 03       	nop

80022078 <__avr32_f64_mul>:
80022078:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8002207c:	e0 80 00 dc 	breq	80022234 <__avr32_f64_mul_op1_zero>
80022080:	d4 21       	pushm	r4-r7,lr
80022082:	f7 e9 20 0e 	eor	lr,r11,r9
80022086:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8002208a:	30 15       	mov	r5,1
8002208c:	c4 30       	breq	80022112 <__avr32_f64_mul_op1_subnormal>
8002208e:	ab 6b       	lsl	r11,0xa
80022090:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80022094:	ab 6a       	lsl	r10,0xa
80022096:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8002209a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8002209e:	c5 c0       	breq	80022156 <__avr32_f64_mul_op2_subnormal>
800220a0:	a1 78       	lsl	r8,0x1
800220a2:	5c f9       	rol	r9
800220a4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
800220a8:	e0 47 07 ff 	cp.w	r7,2047
800220ac:	c7 70       	breq	8002219a <__avr32_f64_mul_op_nan_or_inf>
800220ae:	e0 46 07 ff 	cp.w	r6,2047
800220b2:	c7 40       	breq	8002219a <__avr32_f64_mul_op_nan_or_inf>
800220b4:	ee 06 00 0c 	add	r12,r7,r6
800220b8:	e0 2c 03 fe 	sub	r12,1022
800220bc:	f6 08 06 44 	mulu.d	r4,r11,r8
800220c0:	f4 09 07 44 	macu.d	r4,r10,r9
800220c4:	f4 08 06 46 	mulu.d	r6,r10,r8
800220c8:	f6 09 06 4a 	mulu.d	r10,r11,r9
800220cc:	08 07       	add	r7,r4
800220ce:	f4 05 00 4a 	adc	r10,r10,r5
800220d2:	5c 0b       	acr	r11
800220d4:	ed bb 00 14 	bld	r11,0x14
800220d8:	c0 50       	breq	800220e2 <__avr32_f64_mul+0x6a>
800220da:	a1 77       	lsl	r7,0x1
800220dc:	5c fa       	rol	r10
800220de:	5c fb       	rol	r11
800220e0:	20 1c       	sub	r12,1
800220e2:	58 0c       	cp.w	r12,0
800220e4:	e0 8a 00 6f 	brle	800221c2 <__avr32_f64_mul_res_subnormal>
800220e8:	e0 4c 07 ff 	cp.w	r12,2047
800220ec:	e0 84 00 9c 	brge	80022224 <__avr32_f64_mul_res_inf>
800220f0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
800220f4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
800220f8:	ef e6 12 17 	or	r7,r7,r6>>0x1
800220fc:	ee 17 80 00 	eorh	r7,0x8000
80022100:	f1 b7 04 20 	satu	r7,0x1
80022104:	0e 0a       	add	r10,r7
80022106:	5c 0b       	acr	r11
80022108:	ed be 00 1f 	bld	lr,0x1f
8002210c:	ef bb 00 1f 	bst	r11,0x1f
80022110:	d8 22       	popm	r4-r7,pc

80022112 <__avr32_f64_mul_op1_subnormal>:
80022112:	e4 1b 00 0f 	andh	r11,0xf
80022116:	f4 0c 12 00 	clz	r12,r10
8002211a:	f6 06 12 00 	clz	r6,r11
8002211e:	f7 bc 03 e1 	sublo	r12,-31
80022122:	f8 06 17 30 	movlo	r6,r12
80022126:	f7 b6 02 01 	subhs	r6,1
8002212a:	e0 46 00 20 	cp.w	r6,32
8002212e:	c0 d4       	brge	80022148 <__avr32_f64_mul_op1_subnormal+0x36>
80022130:	ec 0c 11 20 	rsub	r12,r6,32
80022134:	f6 06 09 4b 	lsl	r11,r11,r6
80022138:	f4 0c 0a 4c 	lsr	r12,r10,r12
8002213c:	18 4b       	or	r11,r12
8002213e:	f4 06 09 4a 	lsl	r10,r10,r6
80022142:	20 b6       	sub	r6,11
80022144:	0c 17       	sub	r7,r6
80022146:	ca ab       	rjmp	8002209a <__avr32_f64_mul+0x22>
80022148:	f4 06 09 4b 	lsl	r11,r10,r6
8002214c:	c6 40       	breq	80022214 <__avr32_f64_mul_res_zero>
8002214e:	30 0a       	mov	r10,0
80022150:	20 b6       	sub	r6,11
80022152:	0c 17       	sub	r7,r6
80022154:	ca 3b       	rjmp	8002209a <__avr32_f64_mul+0x22>

80022156 <__avr32_f64_mul_op2_subnormal>:
80022156:	e4 19 00 0f 	andh	r9,0xf
8002215a:	f0 0c 12 00 	clz	r12,r8
8002215e:	f2 05 12 00 	clz	r5,r9
80022162:	f7 bc 03 ea 	sublo	r12,-22
80022166:	f8 05 17 30 	movlo	r5,r12
8002216a:	f7 b5 02 0a 	subhs	r5,10
8002216e:	e0 45 00 20 	cp.w	r5,32
80022172:	c0 d4       	brge	8002218c <__avr32_f64_mul_op2_subnormal+0x36>
80022174:	ea 0c 11 20 	rsub	r12,r5,32
80022178:	f2 05 09 49 	lsl	r9,r9,r5
8002217c:	f0 0c 0a 4c 	lsr	r12,r8,r12
80022180:	18 49       	or	r9,r12
80022182:	f0 05 09 48 	lsl	r8,r8,r5
80022186:	20 25       	sub	r5,2
80022188:	0a 16       	sub	r6,r5
8002218a:	c8 fb       	rjmp	800220a8 <__avr32_f64_mul+0x30>
8002218c:	f0 05 09 49 	lsl	r9,r8,r5
80022190:	c4 20       	breq	80022214 <__avr32_f64_mul_res_zero>
80022192:	30 08       	mov	r8,0
80022194:	20 25       	sub	r5,2
80022196:	0a 16       	sub	r6,r5
80022198:	c8 8b       	rjmp	800220a8 <__avr32_f64_mul+0x30>

8002219a <__avr32_f64_mul_op_nan_or_inf>:
8002219a:	e4 19 00 0f 	andh	r9,0xf
8002219e:	e4 1b 00 0f 	andh	r11,0xf
800221a2:	14 4b       	or	r11,r10
800221a4:	10 49       	or	r9,r8
800221a6:	e0 47 07 ff 	cp.w	r7,2047
800221aa:	c0 91       	brne	800221bc <__avr32_f64_mul_op1_not_naninf>
800221ac:	58 0b       	cp.w	r11,0
800221ae:	c3 81       	brne	8002221e <__avr32_f64_mul_res_nan>
800221b0:	e0 46 07 ff 	cp.w	r6,2047
800221b4:	c3 81       	brne	80022224 <__avr32_f64_mul_res_inf>
800221b6:	58 09       	cp.w	r9,0
800221b8:	c3 60       	breq	80022224 <__avr32_f64_mul_res_inf>
800221ba:	c3 28       	rjmp	8002221e <__avr32_f64_mul_res_nan>

800221bc <__avr32_f64_mul_op1_not_naninf>:
800221bc:	58 09       	cp.w	r9,0
800221be:	c3 30       	breq	80022224 <__avr32_f64_mul_res_inf>
800221c0:	c2 f8       	rjmp	8002221e <__avr32_f64_mul_res_nan>

800221c2 <__avr32_f64_mul_res_subnormal>:
800221c2:	5c 3c       	neg	r12
800221c4:	2f fc       	sub	r12,-1
800221c6:	f1 bc 04 c0 	satu	r12,0x6
800221ca:	e0 4c 00 20 	cp.w	r12,32
800221ce:	c1 14       	brge	800221f0 <__avr32_f64_mul_res_subnormal+0x2e>
800221d0:	f8 08 11 20 	rsub	r8,r12,32
800221d4:	0e 46       	or	r6,r7
800221d6:	ee 0c 0a 47 	lsr	r7,r7,r12
800221da:	f4 08 09 49 	lsl	r9,r10,r8
800221de:	12 47       	or	r7,r9
800221e0:	f4 0c 0a 4a 	lsr	r10,r10,r12
800221e4:	f6 08 09 49 	lsl	r9,r11,r8
800221e8:	12 4a       	or	r10,r9
800221ea:	f6 0c 0a 4b 	lsr	r11,r11,r12
800221ee:	c8 3b       	rjmp	800220f4 <__avr32_f64_mul+0x7c>
800221f0:	f8 08 11 20 	rsub	r8,r12,32
800221f4:	f9 b9 00 00 	moveq	r9,0
800221f8:	c0 30       	breq	800221fe <__avr32_f64_mul_res_subnormal+0x3c>
800221fa:	f6 08 09 49 	lsl	r9,r11,r8
800221fe:	0e 46       	or	r6,r7
80022200:	ed ea 10 16 	or	r6,r6,r10<<0x1
80022204:	f4 0c 0a 4a 	lsr	r10,r10,r12
80022208:	f3 ea 10 07 	or	r7,r9,r10
8002220c:	f6 0c 0a 4a 	lsr	r10,r11,r12
80022210:	30 0b       	mov	r11,0
80022212:	c7 1b       	rjmp	800220f4 <__avr32_f64_mul+0x7c>

80022214 <__avr32_f64_mul_res_zero>:
80022214:	1c 9b       	mov	r11,lr
80022216:	e6 1b 80 00 	andh	r11,0x8000,COH
8002221a:	30 0a       	mov	r10,0
8002221c:	d8 22       	popm	r4-r7,pc

8002221e <__avr32_f64_mul_res_nan>:
8002221e:	3f fb       	mov	r11,-1
80022220:	3f fa       	mov	r10,-1
80022222:	d8 22       	popm	r4-r7,pc

80022224 <__avr32_f64_mul_res_inf>:
80022224:	f0 6b 00 00 	mov	r11,-1048576
80022228:	ed be 00 1f 	bld	lr,0x1f
8002222c:	ef bb 00 1f 	bst	r11,0x1f
80022230:	30 0a       	mov	r10,0
80022232:	d8 22       	popm	r4-r7,pc

80022234 <__avr32_f64_mul_op1_zero>:
80022234:	f7 e9 20 0b 	eor	r11,r11,r9
80022238:	e6 1b 80 00 	andh	r11,0x8000,COH
8002223c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80022240:	e0 4c 07 ff 	cp.w	r12,2047
80022244:	5e 1c       	retne	r12
80022246:	3f fa       	mov	r10,-1
80022248:	3f fb       	mov	r11,-1
8002224a:	5e fc       	retal	r12

8002224c <__avr32_f64_sub_from_add>:
8002224c:	ee 19 80 00 	eorh	r9,0x8000

80022250 <__avr32_f64_sub>:
80022250:	f7 e9 20 0c 	eor	r12,r11,r9
80022254:	e0 86 00 ca 	brmi	800223e8 <__avr32_f64_add_from_sub>
80022258:	eb cd 40 e0 	pushm	r5-r7,lr
8002225c:	16 9c       	mov	r12,r11
8002225e:	e6 1c 80 00 	andh	r12,0x8000,COH
80022262:	bf db       	cbr	r11,0x1f
80022264:	bf d9       	cbr	r9,0x1f
80022266:	10 3a       	cp.w	r10,r8
80022268:	f2 0b 13 00 	cpc	r11,r9
8002226c:	c0 92       	brcc	8002227e <__avr32_f64_sub+0x2e>
8002226e:	16 97       	mov	r7,r11
80022270:	12 9b       	mov	r11,r9
80022272:	0e 99       	mov	r9,r7
80022274:	14 97       	mov	r7,r10
80022276:	10 9a       	mov	r10,r8
80022278:	0e 98       	mov	r8,r7
8002227a:	ee 1c 80 00 	eorh	r12,0x8000
8002227e:	f6 07 16 14 	lsr	r7,r11,0x14
80022282:	ab 7b       	lsl	r11,0xb
80022284:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80022288:	ab 7a       	lsl	r10,0xb
8002228a:	bf bb       	sbr	r11,0x1f
8002228c:	f2 06 16 14 	lsr	r6,r9,0x14
80022290:	c4 40       	breq	80022318 <__avr32_f64_sub_opL_subnormal>
80022292:	ab 79       	lsl	r9,0xb
80022294:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80022298:	ab 78       	lsl	r8,0xb
8002229a:	bf b9       	sbr	r9,0x1f

8002229c <__avr32_f64_sub_opL_subnormal_done>:
8002229c:	e0 47 07 ff 	cp.w	r7,2047
800222a0:	c4 f0       	breq	8002233e <__avr32_f64_sub_opH_nan_or_inf>
800222a2:	0e 26       	rsub	r6,r7
800222a4:	c1 20       	breq	800222c8 <__avr32_f64_sub_shift_done>
800222a6:	ec 05 11 20 	rsub	r5,r6,32
800222aa:	e0 46 00 20 	cp.w	r6,32
800222ae:	c7 c2       	brcc	800223a6 <__avr32_f64_sub_longshift>
800222b0:	f0 05 09 4e 	lsl	lr,r8,r5
800222b4:	f2 05 09 45 	lsl	r5,r9,r5
800222b8:	f0 06 0a 48 	lsr	r8,r8,r6
800222bc:	f2 06 0a 49 	lsr	r9,r9,r6
800222c0:	0a 48       	or	r8,r5
800222c2:	58 0e       	cp.w	lr,0
800222c4:	5f 1e       	srne	lr
800222c6:	1c 48       	or	r8,lr

800222c8 <__avr32_f64_sub_shift_done>:
800222c8:	10 1a       	sub	r10,r8
800222ca:	f6 09 01 4b 	sbc	r11,r11,r9
800222ce:	f6 06 12 00 	clz	r6,r11
800222d2:	c0 e0       	breq	800222ee <__avr32_f64_sub_longnormalize_done>
800222d4:	c7 83       	brcs	800223c4 <__avr32_f64_sub_longnormalize>
800222d6:	ec 0e 11 20 	rsub	lr,r6,32
800222da:	f6 06 09 4b 	lsl	r11,r11,r6
800222de:	f4 0e 0a 4e 	lsr	lr,r10,lr
800222e2:	1c 4b       	or	r11,lr
800222e4:	f4 06 09 4a 	lsl	r10,r10,r6
800222e8:	0c 17       	sub	r7,r6
800222ea:	e0 8a 00 39 	brle	8002235c <__avr32_f64_sub_subnormal_result>

800222ee <__avr32_f64_sub_longnormalize_done>:
800222ee:	f4 09 15 15 	lsl	r9,r10,0x15
800222f2:	ab 9a       	lsr	r10,0xb
800222f4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800222f8:	ab 9b       	lsr	r11,0xb
800222fa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800222fe:	18 4b       	or	r11,r12

80022300 <__avr32_f64_sub_round>:
80022300:	fc 17 80 00 	movh	r7,0x8000
80022304:	ed ba 00 00 	bld	r10,0x0
80022308:	f7 b7 01 ff 	subne	r7,-1
8002230c:	0e 39       	cp.w	r9,r7
8002230e:	5f 29       	srhs	r9
80022310:	12 0a       	add	r10,r9
80022312:	5c 0b       	acr	r11
80022314:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80022318 <__avr32_f64_sub_opL_subnormal>:
80022318:	ab 79       	lsl	r9,0xb
8002231a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8002231e:	ab 78       	lsl	r8,0xb
80022320:	f3 e8 10 0e 	or	lr,r9,r8
80022324:	f9 b6 01 01 	movne	r6,1
80022328:	ee 0e 11 00 	rsub	lr,r7,0
8002232c:	f9 b7 00 01 	moveq	r7,1
80022330:	ef bb 00 1f 	bst	r11,0x1f
80022334:	f7 ea 10 0e 	or	lr,r11,r10
80022338:	f9 b7 00 00 	moveq	r7,0
8002233c:	cb 0b       	rjmp	8002229c <__avr32_f64_sub_opL_subnormal_done>

8002233e <__avr32_f64_sub_opH_nan_or_inf>:
8002233e:	bf db       	cbr	r11,0x1f
80022340:	f7 ea 10 0e 	or	lr,r11,r10
80022344:	c0 81       	brne	80022354 <__avr32_f64_sub_return_nan>
80022346:	e0 46 07 ff 	cp.w	r6,2047
8002234a:	c0 50       	breq	80022354 <__avr32_f64_sub_return_nan>
8002234c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80022350:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80022354 <__avr32_f64_sub_return_nan>:
80022354:	3f fa       	mov	r10,-1
80022356:	3f fb       	mov	r11,-1
80022358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8002235c <__avr32_f64_sub_subnormal_result>:
8002235c:	5c 37       	neg	r7
8002235e:	2f f7       	sub	r7,-1
80022360:	f1 b7 04 c0 	satu	r7,0x6
80022364:	e0 47 00 20 	cp.w	r7,32
80022368:	c1 14       	brge	8002238a <__avr32_f64_sub_subnormal_result+0x2e>
8002236a:	ee 08 11 20 	rsub	r8,r7,32
8002236e:	f4 08 09 49 	lsl	r9,r10,r8
80022372:	5f 16       	srne	r6
80022374:	f4 07 0a 4a 	lsr	r10,r10,r7
80022378:	0c 4a       	or	r10,r6
8002237a:	f6 08 09 49 	lsl	r9,r11,r8
8002237e:	f5 e9 10 0a 	or	r10,r10,r9
80022382:	f4 07 0a 4b 	lsr	r11,r10,r7
80022386:	30 07       	mov	r7,0
80022388:	cb 3b       	rjmp	800222ee <__avr32_f64_sub_longnormalize_done>
8002238a:	ee 08 11 40 	rsub	r8,r7,64
8002238e:	f6 08 09 49 	lsl	r9,r11,r8
80022392:	14 49       	or	r9,r10
80022394:	5f 16       	srne	r6
80022396:	f6 07 0a 4a 	lsr	r10,r11,r7
8002239a:	0c 4a       	or	r10,r6
8002239c:	30 0b       	mov	r11,0
8002239e:	30 07       	mov	r7,0
800223a0:	ca 7b       	rjmp	800222ee <__avr32_f64_sub_longnormalize_done>
800223a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800223a6 <__avr32_f64_sub_longshift>:
800223a6:	f1 b6 04 c0 	satu	r6,0x6
800223aa:	f0 0e 17 00 	moveq	lr,r8
800223ae:	c0 40       	breq	800223b6 <__avr32_f64_sub_longshift+0x10>
800223b0:	f2 05 09 4e 	lsl	lr,r9,r5
800223b4:	10 4e       	or	lr,r8
800223b6:	f2 06 0a 48 	lsr	r8,r9,r6
800223ba:	30 09       	mov	r9,0
800223bc:	58 0e       	cp.w	lr,0
800223be:	5f 1e       	srne	lr
800223c0:	1c 48       	or	r8,lr
800223c2:	c8 3b       	rjmp	800222c8 <__avr32_f64_sub_shift_done>

800223c4 <__avr32_f64_sub_longnormalize>:
800223c4:	f4 06 12 00 	clz	r6,r10
800223c8:	f9 b7 03 00 	movlo	r7,0
800223cc:	f9 b6 03 00 	movlo	r6,0
800223d0:	f9 bc 03 00 	movlo	r12,0
800223d4:	f7 b6 02 e0 	subhs	r6,-32
800223d8:	f4 06 09 4b 	lsl	r11,r10,r6
800223dc:	30 0a       	mov	r10,0
800223de:	0c 17       	sub	r7,r6
800223e0:	fe 9a ff be 	brle	8002235c <__avr32_f64_sub_subnormal_result>
800223e4:	c8 5b       	rjmp	800222ee <__avr32_f64_sub_longnormalize_done>
800223e6:	d7 03       	nop

800223e8 <__avr32_f64_add_from_sub>:
800223e8:	ee 19 80 00 	eorh	r9,0x8000

800223ec <__avr32_f64_add>:
800223ec:	f7 e9 20 0c 	eor	r12,r11,r9
800223f0:	fe 96 ff 2e 	brmi	8002224c <__avr32_f64_sub_from_add>
800223f4:	eb cd 40 e0 	pushm	r5-r7,lr
800223f8:	16 9c       	mov	r12,r11
800223fa:	e6 1c 80 00 	andh	r12,0x8000,COH
800223fe:	bf db       	cbr	r11,0x1f
80022400:	bf d9       	cbr	r9,0x1f
80022402:	12 3b       	cp.w	r11,r9
80022404:	c0 72       	brcc	80022412 <__avr32_f64_add+0x26>
80022406:	16 97       	mov	r7,r11
80022408:	12 9b       	mov	r11,r9
8002240a:	0e 99       	mov	r9,r7
8002240c:	14 97       	mov	r7,r10
8002240e:	10 9a       	mov	r10,r8
80022410:	0e 98       	mov	r8,r7
80022412:	30 0e       	mov	lr,0
80022414:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80022418:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8002241c:	b5 ab       	sbr	r11,0x14
8002241e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80022422:	c5 f0       	breq	800224e0 <__avr32_f64_add_op2_subnormal>
80022424:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80022428:	b5 a9       	sbr	r9,0x14
8002242a:	e0 47 07 ff 	cp.w	r7,2047
8002242e:	c2 50       	breq	80022478 <__avr32_f64_add_opH_nan_or_inf>
80022430:	0e 26       	rsub	r6,r7
80022432:	c0 f0       	breq	80022450 <__avr32_f64_add_shift_done>
80022434:	ec 05 11 20 	rsub	r5,r6,32
80022438:	e0 46 00 20 	cp.w	r6,32
8002243c:	c3 52       	brcc	800224a6 <__avr32_f64_add_longshift>
8002243e:	f0 05 09 4e 	lsl	lr,r8,r5
80022442:	f2 05 09 45 	lsl	r5,r9,r5
80022446:	f0 06 0a 48 	lsr	r8,r8,r6
8002244a:	f2 06 0a 49 	lsr	r9,r9,r6
8002244e:	0a 48       	or	r8,r5

80022450 <__avr32_f64_add_shift_done>:
80022450:	10 0a       	add	r10,r8
80022452:	f6 09 00 4b 	adc	r11,r11,r9
80022456:	ed bb 00 15 	bld	r11,0x15
8002245a:	c3 40       	breq	800224c2 <__avr32_f64_add_res_of>

8002245c <__avr32_f64_add_res_of_done>:
8002245c:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80022460:	18 4b       	or	r11,r12

80022462 <__avr32_f64_add_round>:
80022462:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80022466:	18 4e       	or	lr,r12
80022468:	ee 1e 80 00 	eorh	lr,0x8000
8002246c:	f1 be 04 20 	satu	lr,0x1
80022470:	1c 0a       	add	r10,lr
80022472:	5c 0b       	acr	r11
80022474:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80022478 <__avr32_f64_add_opH_nan_or_inf>:
80022478:	b5 cb       	cbr	r11,0x14
8002247a:	f7 ea 10 0e 	or	lr,r11,r10
8002247e:	c1 01       	brne	8002249e <__avr32_f64_add_return_nan>
80022480:	e0 46 07 ff 	cp.w	r6,2047
80022484:	c0 30       	breq	8002248a <__avr32_f64_add_opL_nan_or_inf>
80022486:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8002248a <__avr32_f64_add_opL_nan_or_inf>:
8002248a:	b5 c9       	cbr	r9,0x14
8002248c:	f3 e8 10 0e 	or	lr,r9,r8
80022490:	c0 71       	brne	8002249e <__avr32_f64_add_return_nan>
80022492:	30 0a       	mov	r10,0
80022494:	fc 1b 7f f0 	movh	r11,0x7ff0
80022498:	18 4b       	or	r11,r12
8002249a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8002249e <__avr32_f64_add_return_nan>:
8002249e:	3f fa       	mov	r10,-1
800224a0:	3f fb       	mov	r11,-1
800224a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800224a6 <__avr32_f64_add_longshift>:
800224a6:	f1 b6 04 c0 	satu	r6,0x6
800224aa:	f0 0e 17 00 	moveq	lr,r8
800224ae:	c0 60       	breq	800224ba <__avr32_f64_add_longshift+0x14>
800224b0:	f2 05 09 4e 	lsl	lr,r9,r5
800224b4:	58 08       	cp.w	r8,0
800224b6:	5f 18       	srne	r8
800224b8:	10 4e       	or	lr,r8
800224ba:	f2 06 0a 48 	lsr	r8,r9,r6
800224be:	30 09       	mov	r9,0
800224c0:	cc 8b       	rjmp	80022450 <__avr32_f64_add_shift_done>

800224c2 <__avr32_f64_add_res_of>:
800224c2:	fd ee 10 1e 	or	lr,lr,lr<<0x1
800224c6:	a1 9b       	lsr	r11,0x1
800224c8:	5d 0a       	ror	r10
800224ca:	5d 0e       	ror	lr
800224cc:	2f f7       	sub	r7,-1
800224ce:	e0 47 07 ff 	cp.w	r7,2047
800224d2:	f9 ba 00 00 	moveq	r10,0
800224d6:	f9 bb 00 00 	moveq	r11,0
800224da:	f9 be 00 00 	moveq	lr,0
800224de:	cb fb       	rjmp	8002245c <__avr32_f64_add_res_of_done>

800224e0 <__avr32_f64_add_op2_subnormal>:
800224e0:	30 16       	mov	r6,1
800224e2:	58 07       	cp.w	r7,0
800224e4:	ca 31       	brne	8002242a <__avr32_f64_add+0x3e>
800224e6:	b5 cb       	cbr	r11,0x14
800224e8:	10 0a       	add	r10,r8
800224ea:	f6 09 00 4b 	adc	r11,r11,r9
800224ee:	18 4b       	or	r11,r12
800224f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800224f4 <__avr32_f64_to_u32>:
800224f4:	58 0b       	cp.w	r11,0
800224f6:	5e 6d       	retmi	0

800224f8 <__avr32_f64_to_s32>:
800224f8:	f6 0c 15 01 	lsl	r12,r11,0x1
800224fc:	b5 9c       	lsr	r12,0x15
800224fe:	e0 2c 03 ff 	sub	r12,1023
80022502:	5e 3d       	retlo	0
80022504:	f8 0c 11 1f 	rsub	r12,r12,31
80022508:	16 99       	mov	r9,r11
8002250a:	ab 7b       	lsl	r11,0xb
8002250c:	bf bb       	sbr	r11,0x1f
8002250e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80022512:	f6 0c 0a 4b 	lsr	r11,r11,r12
80022516:	a1 79       	lsl	r9,0x1
80022518:	5e 2b       	reths	r11
8002251a:	5c 3b       	neg	r11
8002251c:	5e fb       	retal	r11

8002251e <__avr32_u32_to_f64>:
8002251e:	f8 cb 00 00 	sub	r11,r12,0
80022522:	30 0c       	mov	r12,0
80022524:	c0 38       	rjmp	8002252a <__avr32_s32_to_f64+0x4>

80022526 <__avr32_s32_to_f64>:
80022526:	18 9b       	mov	r11,r12
80022528:	5c 4b       	abs	r11
8002252a:	30 0a       	mov	r10,0
8002252c:	5e 0b       	reteq	r11
8002252e:	d4 01       	pushm	lr
80022530:	e0 69 04 1e 	mov	r9,1054
80022534:	f6 08 12 00 	clz	r8,r11
80022538:	c1 70       	breq	80022566 <__avr32_s32_to_f64+0x40>
8002253a:	c0 c3       	brcs	80022552 <__avr32_s32_to_f64+0x2c>
8002253c:	f0 0e 11 20 	rsub	lr,r8,32
80022540:	f6 08 09 4b 	lsl	r11,r11,r8
80022544:	f4 0e 0a 4e 	lsr	lr,r10,lr
80022548:	1c 4b       	or	r11,lr
8002254a:	f4 08 09 4a 	lsl	r10,r10,r8
8002254e:	10 19       	sub	r9,r8
80022550:	c0 b8       	rjmp	80022566 <__avr32_s32_to_f64+0x40>
80022552:	f4 08 12 00 	clz	r8,r10
80022556:	f9 b8 03 00 	movlo	r8,0
8002255a:	f7 b8 02 e0 	subhs	r8,-32
8002255e:	f4 08 09 4b 	lsl	r11,r10,r8
80022562:	30 0a       	mov	r10,0
80022564:	10 19       	sub	r9,r8
80022566:	58 09       	cp.w	r9,0
80022568:	e0 89 00 30 	brgt	800225c8 <__avr32_s32_to_f64+0xa2>
8002256c:	5c 39       	neg	r9
8002256e:	2f f9       	sub	r9,-1
80022570:	e0 49 00 36 	cp.w	r9,54
80022574:	c0 43       	brcs	8002257c <__avr32_s32_to_f64+0x56>
80022576:	30 0b       	mov	r11,0
80022578:	30 0a       	mov	r10,0
8002257a:	c2 68       	rjmp	800225c6 <__avr32_s32_to_f64+0xa0>
8002257c:	2f 69       	sub	r9,-10
8002257e:	f2 08 11 20 	rsub	r8,r9,32
80022582:	e0 49 00 20 	cp.w	r9,32
80022586:	c0 b2       	brcc	8002259c <__avr32_s32_to_f64+0x76>
80022588:	f4 08 09 4e 	lsl	lr,r10,r8
8002258c:	f6 08 09 48 	lsl	r8,r11,r8
80022590:	f4 09 0a 4a 	lsr	r10,r10,r9
80022594:	f6 09 0a 4b 	lsr	r11,r11,r9
80022598:	10 4b       	or	r11,r8
8002259a:	c0 88       	rjmp	800225aa <__avr32_s32_to_f64+0x84>
8002259c:	f6 08 09 4e 	lsl	lr,r11,r8
800225a0:	14 4e       	or	lr,r10
800225a2:	16 9a       	mov	r10,r11
800225a4:	30 0b       	mov	r11,0
800225a6:	f4 09 0a 4a 	lsr	r10,r10,r9
800225aa:	ed ba 00 00 	bld	r10,0x0
800225ae:	c0 92       	brcc	800225c0 <__avr32_s32_to_f64+0x9a>
800225b0:	1c 7e       	tst	lr,lr
800225b2:	c0 41       	brne	800225ba <__avr32_s32_to_f64+0x94>
800225b4:	ed ba 00 01 	bld	r10,0x1
800225b8:	c0 42       	brcc	800225c0 <__avr32_s32_to_f64+0x9a>
800225ba:	2f fa       	sub	r10,-1
800225bc:	f7 bb 02 ff 	subhs	r11,-1
800225c0:	5c fc       	rol	r12
800225c2:	5d 0b       	ror	r11
800225c4:	5d 0a       	ror	r10
800225c6:	d8 02       	popm	pc
800225c8:	e0 68 03 ff 	mov	r8,1023
800225cc:	ed ba 00 0b 	bld	r10,0xb
800225d0:	f7 b8 00 ff 	subeq	r8,-1
800225d4:	10 0a       	add	r10,r8
800225d6:	5c 0b       	acr	r11
800225d8:	f7 b9 03 fe 	sublo	r9,-2
800225dc:	e0 49 07 ff 	cp.w	r9,2047
800225e0:	c0 55       	brlt	800225ea <__avr32_s32_to_f64+0xc4>
800225e2:	30 0a       	mov	r10,0
800225e4:	fc 1b ff e0 	movh	r11,0xffe0
800225e8:	c0 c8       	rjmp	80022600 <__floatsidf_return_op1>
800225ea:	ed bb 00 1f 	bld	r11,0x1f
800225ee:	f7 b9 01 01 	subne	r9,1
800225f2:	ab 9a       	lsr	r10,0xb
800225f4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800225f8:	a1 7b       	lsl	r11,0x1
800225fa:	ab 9b       	lsr	r11,0xb
800225fc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80022600 <__floatsidf_return_op1>:
80022600:	a1 7c       	lsl	r12,0x1
80022602:	5d 0b       	ror	r11
80022604:	d8 02       	popm	pc

80022606 <__avr32_f64_cmp_eq>:
80022606:	10 3a       	cp.w	r10,r8
80022608:	f2 0b 13 00 	cpc	r11,r9
8002260c:	c0 80       	breq	8002261c <__avr32_f64_cmp_eq+0x16>
8002260e:	a1 7b       	lsl	r11,0x1
80022610:	a1 79       	lsl	r9,0x1
80022612:	14 4b       	or	r11,r10
80022614:	12 4b       	or	r11,r9
80022616:	10 4b       	or	r11,r8
80022618:	5e 0f       	reteq	1
8002261a:	5e fd       	retal	0
8002261c:	a1 7b       	lsl	r11,0x1
8002261e:	fc 1c ff e0 	movh	r12,0xffe0
80022622:	58 0a       	cp.w	r10,0
80022624:	f8 0b 13 00 	cpc	r11,r12
80022628:	5e 8f       	retls	1
8002262a:	5e fd       	retal	0

8002262c <__avr32_f64_cmp_ge>:
8002262c:	1a de       	st.w	--sp,lr
8002262e:	1a d7       	st.w	--sp,r7
80022630:	a1 7b       	lsl	r11,0x1
80022632:	5f 3c       	srlo	r12
80022634:	a1 79       	lsl	r9,0x1
80022636:	5f 37       	srlo	r7
80022638:	5c fc       	rol	r12
8002263a:	fc 1e ff e0 	movh	lr,0xffe0
8002263e:	58 0a       	cp.w	r10,0
80022640:	fc 0b 13 00 	cpc	r11,lr
80022644:	e0 8b 00 1d 	brhi	8002267e <__avr32_f64_cmp_ge+0x52>
80022648:	58 08       	cp.w	r8,0
8002264a:	fc 09 13 00 	cpc	r9,lr
8002264e:	e0 8b 00 18 	brhi	8002267e <__avr32_f64_cmp_ge+0x52>
80022652:	58 0b       	cp.w	r11,0
80022654:	f5 ba 00 00 	subfeq	r10,0
80022658:	c1 50       	breq	80022682 <__avr32_f64_cmp_ge+0x56>
8002265a:	1b 07       	ld.w	r7,sp++
8002265c:	1b 0e       	ld.w	lr,sp++
8002265e:	58 3c       	cp.w	r12,3
80022660:	c0 a0       	breq	80022674 <__avr32_f64_cmp_ge+0x48>
80022662:	58 1c       	cp.w	r12,1
80022664:	c0 33       	brcs	8002266a <__avr32_f64_cmp_ge+0x3e>
80022666:	5e 0f       	reteq	1
80022668:	5e 1d       	retne	0
8002266a:	10 3a       	cp.w	r10,r8
8002266c:	f2 0b 13 00 	cpc	r11,r9
80022670:	5e 2f       	reths	1
80022672:	5e 3d       	retlo	0
80022674:	14 38       	cp.w	r8,r10
80022676:	f6 09 13 00 	cpc	r9,r11
8002267a:	5e 2f       	reths	1
8002267c:	5e 3d       	retlo	0
8002267e:	1b 07       	ld.w	r7,sp++
80022680:	d8 0a       	popm	pc,r12=0
80022682:	58 17       	cp.w	r7,1
80022684:	5f 0c       	sreq	r12
80022686:	58 09       	cp.w	r9,0
80022688:	f5 b8 00 00 	subfeq	r8,0
8002268c:	1b 07       	ld.w	r7,sp++
8002268e:	1b 0e       	ld.w	lr,sp++
80022690:	5e 0f       	reteq	1
80022692:	5e fc       	retal	r12

80022694 <__avr32_f64_cmp_lt>:
80022694:	1a de       	st.w	--sp,lr
80022696:	1a d7       	st.w	--sp,r7
80022698:	a1 7b       	lsl	r11,0x1
8002269a:	5f 3c       	srlo	r12
8002269c:	a1 79       	lsl	r9,0x1
8002269e:	5f 37       	srlo	r7
800226a0:	5c fc       	rol	r12
800226a2:	fc 1e ff e0 	movh	lr,0xffe0
800226a6:	58 0a       	cp.w	r10,0
800226a8:	fc 0b 13 00 	cpc	r11,lr
800226ac:	e0 8b 00 1d 	brhi	800226e6 <__avr32_f64_cmp_lt+0x52>
800226b0:	58 08       	cp.w	r8,0
800226b2:	fc 09 13 00 	cpc	r9,lr
800226b6:	e0 8b 00 18 	brhi	800226e6 <__avr32_f64_cmp_lt+0x52>
800226ba:	58 0b       	cp.w	r11,0
800226bc:	f5 ba 00 00 	subfeq	r10,0
800226c0:	c1 50       	breq	800226ea <__avr32_f64_cmp_lt+0x56>
800226c2:	1b 07       	ld.w	r7,sp++
800226c4:	1b 0e       	ld.w	lr,sp++
800226c6:	58 3c       	cp.w	r12,3
800226c8:	c0 a0       	breq	800226dc <__avr32_f64_cmp_lt+0x48>
800226ca:	58 1c       	cp.w	r12,1
800226cc:	c0 33       	brcs	800226d2 <__avr32_f64_cmp_lt+0x3e>
800226ce:	5e 0d       	reteq	0
800226d0:	5e 1f       	retne	1
800226d2:	10 3a       	cp.w	r10,r8
800226d4:	f2 0b 13 00 	cpc	r11,r9
800226d8:	5e 2d       	reths	0
800226da:	5e 3f       	retlo	1
800226dc:	14 38       	cp.w	r8,r10
800226de:	f6 09 13 00 	cpc	r9,r11
800226e2:	5e 2d       	reths	0
800226e4:	5e 3f       	retlo	1
800226e6:	1b 07       	ld.w	r7,sp++
800226e8:	d8 0a       	popm	pc,r12=0
800226ea:	58 17       	cp.w	r7,1
800226ec:	5f 1c       	srne	r12
800226ee:	58 09       	cp.w	r9,0
800226f0:	f5 b8 00 00 	subfeq	r8,0
800226f4:	1b 07       	ld.w	r7,sp++
800226f6:	1b 0e       	ld.w	lr,sp++
800226f8:	5e 0d       	reteq	0
800226fa:	5e fc       	retal	r12

800226fc <__avr32_f32_cmp_eq>:
800226fc:	16 3c       	cp.w	r12,r11
800226fe:	c0 50       	breq	80022708 <__avr32_f32_cmp_eq+0xc>
80022700:	16 4c       	or	r12,r11
80022702:	a1 7c       	lsl	r12,0x1
80022704:	5e 0f       	reteq	1
80022706:	5e fd       	retal	0
80022708:	fc 1b ff 00 	movh	r11,0xff00
8002270c:	a1 7c       	lsl	r12,0x1
8002270e:	16 3c       	cp.w	r12,r11
80022710:	5e 8f       	retls	1
80022712:	5e fd       	retal	0

80022714 <__avr32_f32_cmp_ge>:
80022714:	f8 0a 15 01 	lsl	r10,r12,0x1
80022718:	f6 09 15 01 	lsl	r9,r11,0x1
8002271c:	f5 ba 00 00 	subfeq	r10,0
80022720:	5e 0f       	reteq	1
80022722:	fc 18 ff 00 	movh	r8,0xff00
80022726:	10 3a       	cp.w	r10,r8
80022728:	5e bd       	rethi	0
8002272a:	10 39       	cp.w	r9,r8
8002272c:	5e bd       	rethi	0
8002272e:	f7 ec 20 08 	eor	r8,r11,r12
80022732:	ed bc 00 1f 	bld	r12,0x1f
80022736:	5f 28       	srhs	r8
80022738:	5e 68       	retmi	r8
8002273a:	c0 43       	brcs	80022742 <__avr32_f32_cmp_ge+0x2e>
8002273c:	16 3c       	cp.w	r12,r11
8002273e:	5e 2f       	reths	1
80022740:	5e 3d       	retlo	0
80022742:	18 3b       	cp.w	r11,r12
80022744:	5e 2f       	reths	1
80022746:	5e 3d       	retlo	0

80022748 <__avr32_f32_cmp_lt>:
80022748:	f8 0a 15 01 	lsl	r10,r12,0x1
8002274c:	f6 09 15 01 	lsl	r9,r11,0x1
80022750:	f5 ba 00 00 	subfeq	r10,0
80022754:	5e 0d       	reteq	0
80022756:	fc 18 ff 00 	movh	r8,0xff00
8002275a:	10 3a       	cp.w	r10,r8
8002275c:	5e bd       	rethi	0
8002275e:	10 39       	cp.w	r9,r8
80022760:	5e bd       	rethi	0
80022762:	f7 ec 20 08 	eor	r8,r11,r12
80022766:	ed bc 00 1f 	bld	r12,0x1f
8002276a:	5f 38       	srlo	r8
8002276c:	5e 68       	retmi	r8
8002276e:	c0 43       	brcs	80022776 <__avr32_f32_cmp_lt+0x2e>
80022770:	16 3c       	cp.w	r12,r11
80022772:	5e 2d       	reths	0
80022774:	5e 3f       	retlo	1
80022776:	18 3b       	cp.w	r11,r12
80022778:	5e 2d       	reths	0
8002277a:	5e 3f       	retlo	1

8002277c <__avr32_f64_div>:
8002277c:	eb cd 40 ff 	pushm	r0-r7,lr
80022780:	f7 e9 20 0e 	eor	lr,r11,r9
80022784:	f6 07 16 14 	lsr	r7,r11,0x14
80022788:	a9 7b       	lsl	r11,0x9
8002278a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8002278e:	a9 7a       	lsl	r10,0x9
80022790:	bd bb       	sbr	r11,0x1d
80022792:	e4 1b 3f ff 	andh	r11,0x3fff
80022796:	ab d7       	cbr	r7,0xb
80022798:	e0 80 00 cc 	breq	80022930 <__avr32_f64_div_round_subnormal+0x54>
8002279c:	e0 47 07 ff 	cp.w	r7,2047
800227a0:	e0 84 00 b5 	brge	8002290a <__avr32_f64_div_round_subnormal+0x2e>
800227a4:	f2 06 16 14 	lsr	r6,r9,0x14
800227a8:	a9 79       	lsl	r9,0x9
800227aa:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800227ae:	a9 78       	lsl	r8,0x9
800227b0:	bd b9       	sbr	r9,0x1d
800227b2:	e4 19 3f ff 	andh	r9,0x3fff
800227b6:	ab d6       	cbr	r6,0xb
800227b8:	e0 80 00 e2 	breq	8002297c <__avr32_f64_div_round_subnormal+0xa0>
800227bc:	e0 46 07 ff 	cp.w	r6,2047
800227c0:	e0 84 00 b2 	brge	80022924 <__avr32_f64_div_round_subnormal+0x48>
800227c4:	0c 17       	sub	r7,r6
800227c6:	fe 37 fc 01 	sub	r7,-1023
800227ca:	fc 1c 80 00 	movh	r12,0x8000
800227ce:	f8 03 16 01 	lsr	r3,r12,0x1
800227d2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800227d6:	5c d4       	com	r4
800227d8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800227dc:	e6 09 06 44 	mulu.d	r4,r3,r9
800227e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800227e4:	e6 05 06 44 	mulu.d	r4,r3,r5
800227e8:	ea 03 15 02 	lsl	r3,r5,0x2
800227ec:	e6 09 06 44 	mulu.d	r4,r3,r9
800227f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800227f4:	e6 05 06 44 	mulu.d	r4,r3,r5
800227f8:	ea 03 15 02 	lsl	r3,r5,0x2
800227fc:	e6 09 06 44 	mulu.d	r4,r3,r9
80022800:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80022804:	e6 05 06 44 	mulu.d	r4,r3,r5
80022808:	ea 03 15 02 	lsl	r3,r5,0x2
8002280c:	e6 08 06 40 	mulu.d	r0,r3,r8
80022810:	e4 09 07 40 	macu.d	r0,r2,r9
80022814:	e6 09 06 44 	mulu.d	r4,r3,r9
80022818:	02 04       	add	r4,r1
8002281a:	5c 05       	acr	r5
8002281c:	a3 65       	lsl	r5,0x2
8002281e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80022822:	a3 64       	lsl	r4,0x2
80022824:	5c 34       	neg	r4
80022826:	f8 05 01 45 	sbc	r5,r12,r5
8002282a:	e6 04 06 40 	mulu.d	r0,r3,r4
8002282e:	e4 05 07 40 	macu.d	r0,r2,r5
80022832:	e6 05 06 44 	mulu.d	r4,r3,r5
80022836:	02 04       	add	r4,r1
80022838:	5c 05       	acr	r5
8002283a:	ea 03 15 02 	lsl	r3,r5,0x2
8002283e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80022842:	e8 02 15 02 	lsl	r2,r4,0x2
80022846:	e6 08 06 40 	mulu.d	r0,r3,r8
8002284a:	e4 09 07 40 	macu.d	r0,r2,r9
8002284e:	e6 09 06 44 	mulu.d	r4,r3,r9
80022852:	02 04       	add	r4,r1
80022854:	5c 05       	acr	r5
80022856:	a3 65       	lsl	r5,0x2
80022858:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8002285c:	a3 64       	lsl	r4,0x2
8002285e:	5c 34       	neg	r4
80022860:	f8 05 01 45 	sbc	r5,r12,r5
80022864:	e6 04 06 40 	mulu.d	r0,r3,r4
80022868:	e4 05 07 40 	macu.d	r0,r2,r5
8002286c:	e6 05 06 44 	mulu.d	r4,r3,r5
80022870:	02 04       	add	r4,r1
80022872:	5c 05       	acr	r5
80022874:	ea 03 15 02 	lsl	r3,r5,0x2
80022878:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8002287c:	e8 02 15 02 	lsl	r2,r4,0x2
80022880:	e6 0a 06 40 	mulu.d	r0,r3,r10
80022884:	e4 0b 07 40 	macu.d	r0,r2,r11
80022888:	e6 0b 06 42 	mulu.d	r2,r3,r11
8002288c:	02 02       	add	r2,r1
8002288e:	5c 03       	acr	r3
80022890:	ed b3 00 1c 	bld	r3,0x1c
80022894:	c0 90       	breq	800228a6 <__avr32_f64_div+0x12a>
80022896:	a1 72       	lsl	r2,0x1
80022898:	5c f3       	rol	r3
8002289a:	20 17       	sub	r7,1
8002289c:	a3 9a       	lsr	r10,0x3
8002289e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800228a2:	a3 9b       	lsr	r11,0x3
800228a4:	c0 58       	rjmp	800228ae <__avr32_f64_div+0x132>
800228a6:	a5 8a       	lsr	r10,0x4
800228a8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800228ac:	a5 8b       	lsr	r11,0x4
800228ae:	58 07       	cp.w	r7,0
800228b0:	e0 8a 00 8b 	brle	800229c6 <__avr32_f64_div_res_subnormal>
800228b4:	e0 12 ff 00 	andl	r2,0xff00
800228b8:	e8 12 00 80 	orl	r2,0x80
800228bc:	e6 08 06 40 	mulu.d	r0,r3,r8
800228c0:	e4 09 07 40 	macu.d	r0,r2,r9
800228c4:	e4 08 06 44 	mulu.d	r4,r2,r8
800228c8:	e6 09 06 48 	mulu.d	r8,r3,r9
800228cc:	00 05       	add	r5,r0
800228ce:	f0 01 00 48 	adc	r8,r8,r1
800228d2:	5c 09       	acr	r9
800228d4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800228d8:	58 04       	cp.w	r4,0
800228da:	5c 25       	cpc	r5

800228dc <__avr32_f64_div_round_subnormal>:
800228dc:	f4 08 13 00 	cpc	r8,r10
800228e0:	f6 09 13 00 	cpc	r9,r11
800228e4:	5f 36       	srlo	r6
800228e6:	f8 06 17 00 	moveq	r6,r12
800228ea:	e4 0a 16 08 	lsr	r10,r2,0x8
800228ee:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800228f2:	e6 0b 16 08 	lsr	r11,r3,0x8
800228f6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800228fa:	ed be 00 1f 	bld	lr,0x1f
800228fe:	ef bb 00 1f 	bst	r11,0x1f
80022902:	0c 0a       	add	r10,r6
80022904:	5c 0b       	acr	r11
80022906:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8002290a:	e4 1b 00 0f 	andh	r11,0xf
8002290e:	14 4b       	or	r11,r10
80022910:	e0 81 00 a7 	brne	80022a5e <__avr32_f64_div_res_subnormal+0x98>
80022914:	f2 06 16 14 	lsr	r6,r9,0x14
80022918:	ab d6       	cbr	r6,0xb
8002291a:	e0 46 07 ff 	cp.w	r6,2047
8002291e:	e0 81 00 a4 	brne	80022a66 <__avr32_f64_div_res_subnormal+0xa0>
80022922:	c9 e8       	rjmp	80022a5e <__avr32_f64_div_res_subnormal+0x98>
80022924:	e4 19 00 0f 	andh	r9,0xf
80022928:	10 49       	or	r9,r8
8002292a:	e0 81 00 9a 	brne	80022a5e <__avr32_f64_div_res_subnormal+0x98>
8002292e:	c9 28       	rjmp	80022a52 <__avr32_f64_div_res_subnormal+0x8c>
80022930:	a3 7b       	lsl	r11,0x3
80022932:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
80022936:	a3 7a       	lsl	r10,0x3
80022938:	f5 eb 10 04 	or	r4,r10,r11
8002293c:	e0 80 00 a0 	breq	80022a7c <__avr32_f64_div_op1_zero>
80022940:	f6 04 12 00 	clz	r4,r11
80022944:	c1 70       	breq	80022972 <__avr32_f64_div_round_subnormal+0x96>
80022946:	c0 c3       	brcs	8002295e <__avr32_f64_div_round_subnormal+0x82>
80022948:	e8 05 11 20 	rsub	r5,r4,32
8002294c:	f6 04 09 4b 	lsl	r11,r11,r4
80022950:	f4 05 0a 45 	lsr	r5,r10,r5
80022954:	0a 4b       	or	r11,r5
80022956:	f4 04 09 4a 	lsl	r10,r10,r4
8002295a:	08 17       	sub	r7,r4
8002295c:	c0 b8       	rjmp	80022972 <__avr32_f64_div_round_subnormal+0x96>
8002295e:	f4 04 12 00 	clz	r4,r10
80022962:	f9 b4 03 00 	movlo	r4,0
80022966:	f7 b4 02 e0 	subhs	r4,-32
8002296a:	f4 04 09 4b 	lsl	r11,r10,r4
8002296e:	30 0a       	mov	r10,0
80022970:	08 17       	sub	r7,r4
80022972:	a3 8a       	lsr	r10,0x2
80022974:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80022978:	a3 8b       	lsr	r11,0x2
8002297a:	c1 1b       	rjmp	8002279c <__avr32_f64_div+0x20>
8002297c:	a3 79       	lsl	r9,0x3
8002297e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
80022982:	a3 78       	lsl	r8,0x3
80022984:	f3 e8 10 04 	or	r4,r9,r8
80022988:	c6 f0       	breq	80022a66 <__avr32_f64_div_res_subnormal+0xa0>
8002298a:	f2 04 12 00 	clz	r4,r9
8002298e:	c1 70       	breq	800229bc <__avr32_f64_div_round_subnormal+0xe0>
80022990:	c0 c3       	brcs	800229a8 <__avr32_f64_div_round_subnormal+0xcc>
80022992:	e8 05 11 20 	rsub	r5,r4,32
80022996:	f2 04 09 49 	lsl	r9,r9,r4
8002299a:	f0 05 0a 45 	lsr	r5,r8,r5
8002299e:	0a 49       	or	r9,r5
800229a0:	f0 04 09 48 	lsl	r8,r8,r4
800229a4:	08 16       	sub	r6,r4
800229a6:	c0 b8       	rjmp	800229bc <__avr32_f64_div_round_subnormal+0xe0>
800229a8:	f0 04 12 00 	clz	r4,r8
800229ac:	f9 b4 03 00 	movlo	r4,0
800229b0:	f7 b4 02 e0 	subhs	r4,-32
800229b4:	f0 04 09 49 	lsl	r9,r8,r4
800229b8:	30 08       	mov	r8,0
800229ba:	08 16       	sub	r6,r4
800229bc:	a3 88       	lsr	r8,0x2
800229be:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800229c2:	a3 89       	lsr	r9,0x2
800229c4:	cf ca       	rjmp	800227bc <__avr32_f64_div+0x40>

800229c6 <__avr32_f64_div_res_subnormal>:
800229c6:	5c 37       	neg	r7
800229c8:	2f f7       	sub	r7,-1
800229ca:	f1 b7 04 c0 	satu	r7,0x6
800229ce:	e0 47 00 20 	cp.w	r7,32
800229d2:	c1 54       	brge	800229fc <__avr32_f64_div_res_subnormal+0x36>
800229d4:	ee 06 11 20 	rsub	r6,r7,32
800229d8:	e4 07 0a 42 	lsr	r2,r2,r7
800229dc:	e6 06 09 4c 	lsl	r12,r3,r6
800229e0:	18 42       	or	r2,r12
800229e2:	e6 07 0a 43 	lsr	r3,r3,r7
800229e6:	f4 06 09 41 	lsl	r1,r10,r6
800229ea:	f4 07 0a 4a 	lsr	r10,r10,r7
800229ee:	f6 06 09 4c 	lsl	r12,r11,r6
800229f2:	18 4a       	or	r10,r12
800229f4:	f6 07 0a 4b 	lsr	r11,r11,r7
800229f8:	30 00       	mov	r0,0
800229fa:	c1 58       	rjmp	80022a24 <__avr32_f64_div_res_subnormal+0x5e>
800229fc:	ee 06 11 20 	rsub	r6,r7,32
80022a00:	f9 b0 00 00 	moveq	r0,0
80022a04:	f9 bc 00 00 	moveq	r12,0
80022a08:	c0 50       	breq	80022a12 <__avr32_f64_div_res_subnormal+0x4c>
80022a0a:	f4 06 09 40 	lsl	r0,r10,r6
80022a0e:	f6 06 09 4c 	lsl	r12,r11,r6
80022a12:	e6 07 0a 42 	lsr	r2,r3,r7
80022a16:	30 03       	mov	r3,0
80022a18:	f4 07 0a 41 	lsr	r1,r10,r7
80022a1c:	18 41       	or	r1,r12
80022a1e:	f6 07 0a 4a 	lsr	r10,r11,r7
80022a22:	30 0b       	mov	r11,0
80022a24:	e0 12 ff 00 	andl	r2,0xff00
80022a28:	e8 12 00 80 	orl	r2,0x80
80022a2c:	e6 08 06 46 	mulu.d	r6,r3,r8
80022a30:	e4 09 07 46 	macu.d	r6,r2,r9
80022a34:	e4 08 06 44 	mulu.d	r4,r2,r8
80022a38:	e6 09 06 48 	mulu.d	r8,r3,r9
80022a3c:	0c 05       	add	r5,r6
80022a3e:	f0 07 00 48 	adc	r8,r8,r7
80022a42:	5c 09       	acr	r9
80022a44:	30 07       	mov	r7,0
80022a46:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80022a4a:	00 34       	cp.w	r4,r0
80022a4c:	e2 05 13 00 	cpc	r5,r1
80022a50:	c4 6b       	rjmp	800228dc <__avr32_f64_div_round_subnormal>
80022a52:	1c 9b       	mov	r11,lr
80022a54:	e6 1b 80 00 	andh	r11,0x8000,COH
80022a58:	30 0a       	mov	r10,0
80022a5a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80022a5e:	3f fb       	mov	r11,-1
80022a60:	30 0a       	mov	r10,0
80022a62:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80022a66:	f5 eb 10 04 	or	r4,r10,r11
80022a6a:	c0 90       	breq	80022a7c <__avr32_f64_div_op1_zero>
80022a6c:	1c 9b       	mov	r11,lr
80022a6e:	e6 1b 80 00 	andh	r11,0x8000,COH
80022a72:	ea 1b 7f f0 	orh	r11,0x7ff0
80022a76:	30 0a       	mov	r10,0
80022a78:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80022a7c <__avr32_f64_div_op1_zero>:
80022a7c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80022a80:	ce f0       	breq	80022a5e <__avr32_f64_div_res_subnormal+0x98>
80022a82:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
80022a86:	e0 44 07 ff 	cp.w	r4,2047
80022a8a:	ce 41       	brne	80022a52 <__avr32_f64_div_res_subnormal+0x8c>
80022a8c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80022a90:	ce 10       	breq	80022a52 <__avr32_f64_div_res_subnormal+0x8c>
80022a92:	ce 6b       	rjmp	80022a5e <__avr32_f64_div_res_subnormal+0x98>

80022a94 <__avr32_f32_div>:
80022a94:	f7 ec 20 08 	eor	r8,r11,r12
80022a98:	a1 7c       	lsl	r12,0x1
80022a9a:	a1 7b       	lsl	r11,0x1
80022a9c:	c7 a0       	breq	80022b90 <__divsf_return_op1+0x16>
80022a9e:	18 7c       	tst	r12,r12
80022aa0:	f9 b9 00 00 	moveq	r9,0
80022aa4:	c0 90       	breq	80022ab6 <__avr32_f32_div+0x22>
80022aa6:	f8 09 16 18 	lsr	r9,r12,0x18
80022aaa:	c7 e0       	breq	80022ba6 <__divsf_return_op1+0x2c>
80022aac:	e0 49 00 ff 	cp.w	r9,255
80022ab0:	c6 82       	brcc	80022b80 <__divsf_return_op1+0x6>
80022ab2:	a7 7c       	lsl	r12,0x7
80022ab4:	bf bc       	sbr	r12,0x1f
80022ab6:	f6 0a 16 18 	lsr	r10,r11,0x18
80022aba:	c7 e0       	breq	80022bb6 <__divsf_return_op1+0x3c>
80022abc:	e0 4a 00 ff 	cp.w	r10,255
80022ac0:	c6 62       	brcc	80022b8c <__divsf_return_op1+0x12>
80022ac2:	a7 7b       	lsl	r11,0x7
80022ac4:	bf bb       	sbr	r11,0x1f
80022ac6:	58 09       	cp.w	r9,0
80022ac8:	f5 bc 00 00 	subfeq	r12,0
80022acc:	5e 0d       	reteq	0
80022ace:	1a d5       	st.w	--sp,r5
80022ad0:	bb 27       	st.d	--sp,r6
80022ad2:	14 19       	sub	r9,r10
80022ad4:	28 19       	sub	r9,-127
80022ad6:	fc 1a 80 00 	movh	r10,0x8000
80022ada:	a3 8c       	lsr	r12,0x2
80022adc:	f6 05 16 02 	lsr	r5,r11,0x2
80022ae0:	f4 0b 16 01 	lsr	r11,r10,0x1
80022ae4:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
80022ae8:	5c d6       	com	r6
80022aea:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
80022aee:	f6 05 06 46 	mulu.d	r6,r11,r5
80022af2:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80022af6:	f6 07 06 46 	mulu.d	r6,r11,r7
80022afa:	ee 0b 15 02 	lsl	r11,r7,0x2
80022afe:	f6 05 06 46 	mulu.d	r6,r11,r5
80022b02:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80022b06:	f6 07 06 46 	mulu.d	r6,r11,r7
80022b0a:	ee 0b 15 02 	lsl	r11,r7,0x2
80022b0e:	f6 05 06 46 	mulu.d	r6,r11,r5
80022b12:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80022b16:	f6 07 06 46 	mulu.d	r6,r11,r7
80022b1a:	ee 0b 15 02 	lsl	r11,r7,0x2
80022b1e:	f6 05 06 46 	mulu.d	r6,r11,r5
80022b22:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80022b26:	f6 07 06 46 	mulu.d	r6,r11,r7
80022b2a:	ee 0b 15 02 	lsl	r11,r7,0x2
80022b2e:	f6 0c 06 46 	mulu.d	r6,r11,r12
80022b32:	a5 8c       	lsr	r12,0x4
80022b34:	ed b7 00 1c 	bld	r7,0x1c
80022b38:	c0 40       	breq	80022b40 <__avr32_f32_div+0xac>
80022b3a:	a1 77       	lsl	r7,0x1
80022b3c:	20 19       	sub	r9,1
80022b3e:	a1 7c       	lsl	r12,0x1
80022b40:	58 09       	cp.w	r9,0
80022b42:	e0 8a 00 42 	brle	80022bc6 <__avr32_f32_div_res_subnormal>
80022b46:	e0 17 ff e0 	andl	r7,0xffe0
80022b4a:	e8 17 00 10 	orl	r7,0x10
80022b4e:	ea 07 06 4a 	mulu.d	r10,r5,r7
80022b52:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
80022b56:	58 0a       	cp.w	r10,0

80022b58 <__avr32_f32_div_round_subnormal>:
80022b58:	f8 0b 13 00 	cpc	r11,r12
80022b5c:	5f 3b       	srlo	r11
80022b5e:	ea 0b 17 00 	moveq	r11,r5
80022b62:	ee 0c 16 05 	lsr	r12,r7,0x5
80022b66:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
80022b6a:	bb 07       	ld.d	r6,sp++
80022b6c:	1b 05       	ld.w	r5,sp++
80022b6e:	ed b8 00 1f 	bld	r8,0x1f
80022b72:	ef bc 00 1f 	bst	r12,0x1f
80022b76:	16 0c       	add	r12,r11
80022b78:	5e fc       	retal	r12

80022b7a <__divsf_return_op1>:
80022b7a:	a1 78       	lsl	r8,0x1
80022b7c:	5d 0c       	ror	r12
80022b7e:	5e fc       	retal	r12
80022b80:	5e 1e       	retne	-1
80022b82:	fc 19 ff 00 	movh	r9,0xff00
80022b86:	12 3b       	cp.w	r11,r9
80022b88:	cf 93       	brcs	80022b7a <__divsf_return_op1>
80022b8a:	5e fe       	retal	-1
80022b8c:	5e 0d       	reteq	0
80022b8e:	5e fe       	retal	-1
80022b90:	18 7c       	tst	r12,r12
80022b92:	5e 0e       	reteq	-1
80022b94:	f8 09 16 18 	lsr	r9,r12,0x18
80022b98:	c0 70       	breq	80022ba6 <__divsf_return_op1+0x2c>
80022b9a:	e0 49 00 ff 	cp.w	r9,255
80022b9e:	cf 12       	brcc	80022b80 <__divsf_return_op1+0x6>
80022ba0:	fc 1c ff 00 	movh	r12,0xff00
80022ba4:	ce bb       	rjmp	80022b7a <__divsf_return_op1>
80022ba6:	a7 7c       	lsl	r12,0x7
80022ba8:	f8 09 12 00 	clz	r9,r12
80022bac:	f8 09 09 4c 	lsl	r12,r12,r9
80022bb0:	f2 09 11 01 	rsub	r9,r9,1
80022bb4:	c8 1b       	rjmp	80022ab6 <__avr32_f32_div+0x22>
80022bb6:	a7 7b       	lsl	r11,0x7
80022bb8:	f6 0a 12 00 	clz	r10,r11
80022bbc:	f6 0a 09 4b 	lsl	r11,r11,r10
80022bc0:	f4 0a 11 01 	rsub	r10,r10,1
80022bc4:	c8 5b       	rjmp	80022ace <__avr32_f32_div+0x3a>

80022bc6 <__avr32_f32_div_res_subnormal>:
80022bc6:	5c 39       	neg	r9
80022bc8:	2f f9       	sub	r9,-1
80022bca:	f1 b9 04 a0 	satu	r9,0x5
80022bce:	f2 0a 11 20 	rsub	r10,r9,32
80022bd2:	ee 09 0a 47 	lsr	r7,r7,r9
80022bd6:	f8 0a 09 46 	lsl	r6,r12,r10
80022bda:	f8 09 0a 4c 	lsr	r12,r12,r9
80022bde:	e0 17 ff e0 	andl	r7,0xffe0
80022be2:	e8 17 00 10 	orl	r7,0x10
80022be6:	ea 07 06 4a 	mulu.d	r10,r5,r7
80022bea:	30 09       	mov	r9,0
80022bec:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
80022bf0:	0c 3a       	cp.w	r10,r6
80022bf2:	cb 3b       	rjmp	80022b58 <__avr32_f32_div_round_subnormal>

80022bf4 <__avr32_f32_sub_from_add>:
80022bf4:	ee 1b 80 00 	eorh	r11,0x8000

80022bf8 <__avr32_f32_sub>:
80022bf8:	f7 ec 20 08 	eor	r8,r11,r12
80022bfc:	c6 46       	brmi	80022cc4 <__avr32_f32_add_from_sub>
80022bfe:	18 98       	mov	r8,r12
80022c00:	e6 1c 80 00 	andh	r12,0x8000,COH
80022c04:	bf db       	cbr	r11,0x1f
80022c06:	bf d8       	cbr	r8,0x1f
80022c08:	f0 0b 0c 4a 	max	r10,r8,r11
80022c0c:	f0 0b 0d 49 	min	r9,r8,r11
80022c10:	10 3a       	cp.w	r10,r8
80022c12:	f7 bc 01 01 	subne	r12,1
80022c16:	e6 1c 80 00 	andh	r12,0x8000,COH
80022c1a:	f4 08 15 08 	lsl	r8,r10,0x8
80022c1e:	bf b8       	sbr	r8,0x1f
80022c20:	b7 9a       	lsr	r10,0x17
80022c22:	e0 4a 00 ff 	cp.w	r10,255
80022c26:	c3 80       	breq	80022c96 <__avr32_f32_sub_op1_nan_or_inf>
80022c28:	f2 0b 15 08 	lsl	r11,r9,0x8
80022c2c:	bf bb       	sbr	r11,0x1f
80022c2e:	b7 99       	lsr	r9,0x17
80022c30:	1a dc       	st.w	--sp,r12
80022c32:	c2 90       	breq	80022c84 <__avr32_f32_sub_op2_subnormal>
80022c34:	f4 09 01 0c 	sub	r12,r10,r9
80022c38:	c0 c0       	breq	80022c50 <__avr32_f32_sub_shift_done>
80022c3a:	f1 bc 04 a0 	satu	r12,0x5
80022c3e:	f8 09 11 20 	rsub	r9,r12,32
80022c42:	f6 09 09 49 	lsl	r9,r11,r9
80022c46:	f7 b8 01 01 	subne	r8,1
80022c4a:	5f 19       	srne	r9
80022c4c:	f6 0c 0a 4b 	lsr	r11,r11,r12

80022c50 <__avr32_f32_sub_shift_done>:
80022c50:	16 18       	sub	r8,r11
80022c52:	1b 0c       	ld.w	r12,sp++
80022c54:	f0 0b 12 00 	clz	r11,r8
80022c58:	5e 3d       	retlo	0
80022c5a:	f0 0b 09 48 	lsl	r8,r8,r11
80022c5e:	16 1a       	sub	r10,r11
80022c60:	e0 8a 00 26 	brle	80022cac <__avr32_f32_sub_subnormal_result>
80022c64:	f3 e8 11 89 	or	r9,r9,r8<<0x18
80022c68:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
80022c6c:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8

80022c70 <__avr32_f32_sub_round>:
80022c70:	fc 1a 80 00 	movh	r10,0x8000
80022c74:	ed bc 00 00 	bld	r12,0x0
80022c78:	f7 ba 01 ff 	subne	r10,-1
80022c7c:	14 39       	cp.w	r9,r10
80022c7e:	f7 bc 02 ff 	subhs	r12,-1
80022c82:	5e fc       	retal	r12

80022c84 <__avr32_f32_sub_op2_subnormal>:
80022c84:	bf db       	cbr	r11,0x1f
80022c86:	f9 b9 01 01 	movne	r9,1
80022c8a:	58 0a       	cp.w	r10,0
80022c8c:	cd 41       	brne	80022c34 <__avr32_f32_sub+0x3c>
80022c8e:	bf d8       	cbr	r8,0x1f
80022c90:	f9 ba 01 01 	movne	r10,1
80022c94:	cd 0b       	rjmp	80022c34 <__avr32_f32_sub+0x3c>

80022c96 <__avr32_f32_sub_op1_nan_or_inf>:
80022c96:	f0 0b 15 01 	lsl	r11,r8,0x1
80022c9a:	5e 1e       	retne	-1
80022c9c:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80022ca0:	f2 0b 16 17 	lsr	r11,r9,0x17
80022ca4:	e0 4b 00 ff 	cp.w	r11,255
80022ca8:	5e 1c       	retne	r12
80022caa:	5e fe       	retal	-1

80022cac <__avr32_f32_sub_subnormal_result>:
80022cac:	f4 0a 11 09 	rsub	r10,r10,9
80022cb0:	f4 0b 11 20 	rsub	r11,r10,32
80022cb4:	5e 3d       	retlo	0
80022cb6:	f0 0a 0a 4a 	lsr	r10,r8,r10
80022cba:	14 4c       	or	r12,r10
80022cbc:	f0 0b 09 48 	lsl	r8,r8,r11
80022cc0:	10 49       	or	r9,r8
80022cc2:	cd 7b       	rjmp	80022c70 <__avr32_f32_sub_round>

80022cc4 <__avr32_f32_add_from_sub>:
80022cc4:	ee 1b 80 00 	eorh	r11,0x8000

80022cc8 <__avr32_f32_add>:
80022cc8:	f7 ec 20 08 	eor	r8,r11,r12
80022ccc:	c9 46       	brmi	80022bf4 <__avr32_f32_sub_from_add>
80022cce:	18 98       	mov	r8,r12
80022cd0:	e6 1c 80 00 	andh	r12,0x8000,COH
80022cd4:	bf db       	cbr	r11,0x1f
80022cd6:	bf d8       	cbr	r8,0x1f
80022cd8:	f0 0b 0c 4a 	max	r10,r8,r11
80022cdc:	f0 0b 0d 49 	min	r9,r8,r11
80022ce0:	f4 08 15 08 	lsl	r8,r10,0x8
80022ce4:	bf b8       	sbr	r8,0x1f
80022ce6:	b7 9a       	lsr	r10,0x17
80022ce8:	e0 4a 00 ff 	cp.w	r10,255
80022cec:	c2 d0       	breq	80022d46 <__avr32_f32_add_op1_nan_or_inf>
80022cee:	f2 0b 15 08 	lsl	r11,r9,0x8
80022cf2:	bf bb       	sbr	r11,0x1f
80022cf4:	b7 99       	lsr	r9,0x17
80022cf6:	c1 e0       	breq	80022d32 <__avr32_f32_add_op2_subnormal>
80022cf8:	1a dc       	st.w	--sp,r12
80022cfa:	14 29       	rsub	r9,r10
80022cfc:	f1 b9 04 a0 	satu	r9,0x5
80022d00:	f6 09 0a 4c 	lsr	r12,r11,r9
80022d04:	f2 09 11 18 	rsub	r9,r9,24
80022d08:	f6 09 09 4b 	lsl	r11,r11,r9
80022d0c:	f7 dc d3 08 	bfins	r11,r12,0x18,0x8
80022d10:	18 08       	add	r8,r12
80022d12:	1b 0c       	ld.w	r12,sp++
80022d14:	c2 63       	brcs	80022d60 <__avr32_f32_add_res_of>
80022d16:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
80022d1a:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80022d1e:	fc 1a 80 00 	movh	r10,0x8000
80022d22:	ed bc 00 00 	bld	r12,0x0
80022d26:	f7 ba 01 ff 	subne	r10,-1
80022d2a:	14 3b       	cp.w	r11,r10
80022d2c:	f7 bc 02 ff 	subhs	r12,-1
80022d30:	5e fc       	retal	r12

80022d32 <__avr32_f32_add_op2_subnormal>:
80022d32:	bf db       	cbr	r11,0x1f
80022d34:	f9 b9 01 01 	movne	r9,1
80022d38:	58 0a       	cp.w	r10,0
80022d3a:	cd f1       	brne	80022cf8 <__avr32_f32_add+0x30>
80022d3c:	bf d8       	cbr	r8,0x1f
80022d3e:	10 0b       	add	r11,r8
80022d40:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
80022d44:	5e fc       	retal	r12

80022d46 <__avr32_f32_add_op1_nan_or_inf>:
80022d46:	f0 0b 15 01 	lsl	r11,r8,0x1
80022d4a:	5e 1e       	retne	-1
80022d4c:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80022d50:	f2 0b 16 17 	lsr	r11,r9,0x17
80022d54:	e0 4b 00 ff 	cp.w	r11,255
80022d58:	5e 1c       	retne	r12
80022d5a:	a9 79       	lsl	r9,0x9
80022d5c:	5e 0c       	reteq	r12
80022d5e:	5e fe       	retal	-1

80022d60 <__avr32_f32_add_res_of>:
80022d60:	a1 98       	lsr	r8,0x1
80022d62:	2f fa       	sub	r10,-1
80022d64:	e0 4a 00 ff 	cp.w	r10,255
80022d68:	f9 b8 00 00 	moveq	r8,0
80022d6c:	f9 bb 00 00 	moveq	r11,0
80022d70:	cd 3b       	rjmp	80022d16 <__avr32_f32_add+0x4e>
80022d72:	d7 03       	nop

80022d74 <__avr32_f32_mul>:
80022d74:	18 98       	mov	r8,r12
80022d76:	16 5c       	eor	r12,r11
80022d78:	e6 1c 80 00 	andh	r12,0x8000,COH
80022d7c:	bf d8       	cbr	r8,0x1f
80022d7e:	c6 60       	breq	80022e4a <__avr32_f32_mul_op1_zero>
80022d80:	bf db       	cbr	r11,0x1f
80022d82:	f0 0b 0c 4a 	max	r10,r8,r11
80022d86:	f0 0b 0d 49 	min	r9,r8,r11
80022d8a:	f4 08 15 08 	lsl	r8,r10,0x8
80022d8e:	bf b8       	sbr	r8,0x1f
80022d90:	b7 9a       	lsr	r10,0x17
80022d92:	e0 4a 00 ff 	cp.w	r10,255
80022d96:	c3 d0       	breq	80022e10 <__avr32_f32_mul_op1_nan_or_inf>
80022d98:	f2 0b 15 08 	lsl	r11,r9,0x8
80022d9c:	bf bb       	sbr	r11,0x1f
80022d9e:	b7 99       	lsr	r9,0x17
80022da0:	c2 40       	breq	80022de8 <__avr32_f32_mul_op2_subnormal>
80022da2:	14 09       	add	r9,r10
80022da4:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80022da8:	f6 08 15 01 	lsl	r8,r11,0x1
80022dac:	f0 0b 17 20 	movhs	r11,r8
80022db0:	f7 b9 02 01 	subhs	r9,1
80022db4:	a9 8a       	lsr	r10,0x8
80022db6:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
80022dba:	27 e9       	sub	r9,126
80022dbc:	e0 8a 00 39 	brle	80022e2e <__avr32_f32_mul_res_subnormal>
80022dc0:	e0 49 00 ff 	cp.w	r9,255
80022dc4:	c0 f4       	brge	80022de2 <__avr32_f32_mul_round+0x14>
80022dc6:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
80022dca:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

80022dce <__avr32_f32_mul_round>:
80022dce:	fc 18 80 00 	movh	r8,0x8000
80022dd2:	ed bc 00 00 	bld	r12,0x0
80022dd6:	f7 b8 01 ff 	subne	r8,-1
80022dda:	10 3a       	cp.w	r10,r8
80022ddc:	f7 bc 02 ff 	subhs	r12,-1
80022de0:	5e fc       	retal	r12
80022de2:	ea 1c 7f 80 	orh	r12,0x7f80
80022de6:	5e fc       	retal	r12

80022de8 <__avr32_f32_mul_op2_subnormal>:
80022de8:	bf db       	cbr	r11,0x1f
80022dea:	f6 09 12 00 	clz	r9,r11
80022dee:	5e 3d       	retlo	0
80022df0:	20 89       	sub	r9,8
80022df2:	f6 09 09 4b 	lsl	r11,r11,r9
80022df6:	f2 09 11 01 	rsub	r9,r9,1
80022dfa:	14 7a       	tst	r10,r10
80022dfc:	cd 31       	brne	80022da2 <__avr32_f32_mul+0x2e>
80022dfe:	bf d8       	cbr	r8,0x1f
80022e00:	f6 0a 12 00 	clz	r10,r11
80022e04:	5e 3d       	retlo	0
80022e06:	f0 0a 09 48 	lsl	r8,r8,r10
80022e0a:	f4 0a 11 01 	rsub	r10,r10,1
80022e0e:	cc ab       	rjmp	80022da2 <__avr32_f32_mul+0x2e>

80022e10 <__avr32_f32_mul_op1_nan_or_inf>:
80022e10:	f0 0b 15 01 	lsl	r11,r8,0x1
80022e14:	5e 1e       	retne	-1
80022e16:	12 79       	tst	r9,r9
80022e18:	5e 0e       	reteq	-1
80022e1a:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80022e1e:	f2 0b 16 17 	lsr	r11,r9,0x17
80022e22:	e0 4b 00 ff 	cp.w	r11,255
80022e26:	5e 1c       	retne	r12
80022e28:	a9 79       	lsl	r9,0x9
80022e2a:	5e 0c       	reteq	r12
80022e2c:	5e fe       	retal	-1

80022e2e <__avr32_f32_mul_res_subnormal>:
80022e2e:	f2 09 11 09 	rsub	r9,r9,9
80022e32:	f2 08 11 20 	rsub	r8,r9,32
80022e36:	5e 3d       	retlo	0
80022e38:	f6 09 0a 49 	lsr	r9,r11,r9
80022e3c:	12 4c       	or	r12,r9
80022e3e:	f6 08 09 4b 	lsl	r11,r11,r8
80022e42:	e4 1a 00 ff 	andh	r10,0xff
80022e46:	16 4a       	or	r10,r11
80022e48:	cc 3b       	rjmp	80022dce <__avr32_f32_mul_round>

80022e4a <__avr32_f32_mul_op1_zero>:
80022e4a:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
80022e4e:	e0 4a 00 ff 	cp.w	r10,255
80022e52:	5e 1c       	retne	r12
80022e54:	5e 0e       	reteq	-1

80022e56 <__avr32_s32_to_f32>:
80022e56:	58 0c       	cp.w	r12,0
80022e58:	5e 0c       	reteq	r12
80022e5a:	18 9b       	mov	r11,r12
80022e5c:	5c 4c       	abs	r12
80022e5e:	e0 6a 00 9e 	mov	r10,158
80022e62:	f8 09 12 00 	clz	r9,r12
80022e66:	12 1a       	sub	r10,r9
80022e68:	f8 09 09 4c 	lsl	r12,r12,r9
80022e6c:	58 0a       	cp.w	r10,0
80022e6e:	e0 8a 00 15 	brle	80022e98 <__avr32_s32_to_f32_subnormal>
80022e72:	37 f9       	mov	r9,127
80022e74:	ed bc 00 08 	bld	r12,0x8
80022e78:	f7 b9 00 ff 	subeq	r9,-1
80022e7c:	12 0c       	add	r12,r9
80022e7e:	f7 ba 03 fe 	sublo	r10,-2
80022e82:	ed bc 00 1f 	bld	r12,0x1f
80022e86:	f7 ba 01 01 	subne	r10,1
80022e8a:	f8 0c 16 07 	lsr	r12,r12,0x7
80022e8e:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
80022e92:	a1 7b       	lsl	r11,0x1
80022e94:	5d 0c       	ror	r12
80022e96:	5e fc       	retal	r12

80022e98 <__avr32_s32_to_f32_subnormal>:
80022e98:	f4 0a 11 01 	rsub	r10,r10,1
80022e9c:	59 9a       	cp.w	r10,25
80022e9e:	f9 bc 02 00 	movhs	r12,0
80022ea2:	c1 32       	brcc	80022ec8 <__avr32_s32_to_f32_subnormal+0x30>
80022ea4:	f4 09 11 20 	rsub	r9,r10,32
80022ea8:	f8 09 09 49 	lsl	r9,r12,r9
80022eac:	5f 19       	srne	r9
80022eae:	f8 0a 0a 4c 	lsr	r12,r12,r10
80022eb2:	12 4c       	or	r12,r9
80022eb4:	37 f9       	mov	r9,127
80022eb6:	ed bc 00 08 	bld	r12,0x8
80022eba:	f7 b9 00 ff 	subeq	r9,-1
80022ebe:	12 0c       	add	r12,r9
80022ec0:	f8 0c 16 07 	lsr	r12,r12,0x7
80022ec4:	a1 7b       	lsl	r11,0x1
80022ec6:	5d 0c       	ror	r12
80022ec8:	5e fc       	retal	r12

80022eca <__avr32_f32_to_s32>:
80022eca:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
80022ece:	27 fb       	sub	r11,127
80022ed0:	5e 3d       	retlo	0
80022ed2:	f6 0b 11 1f 	rsub	r11,r11,31
80022ed6:	f8 0a 15 08 	lsl	r10,r12,0x8
80022eda:	bf ba       	sbr	r10,0x1f
80022edc:	f4 0b 0a 4a 	lsr	r10,r10,r11
80022ee0:	a1 7c       	lsl	r12,0x1
80022ee2:	5e 2a       	reths	r10
80022ee4:	5c 3a       	neg	r10
80022ee6:	5e fa       	retal	r10

80022ee8 <__avr32_f32_to_f64>:
80022ee8:	f8 0b 15 01 	lsl	r11,r12,0x1
80022eec:	f9 ba 00 00 	moveq	r10,0
80022ef0:	5e 0b       	reteq	r11
80022ef2:	f3 db c3 08 	bfextu	r9,r11,0x18,0x8
80022ef6:	e0 49 00 ff 	cp.w	r9,255
80022efa:	c1 e0       	breq	80022f36 <__extendsfdf_return_op1+0x6>
80022efc:	a7 7b       	lsl	r11,0x7
80022efe:	30 0a       	mov	r10,0
80022f00:	58 09       	cp.w	r9,0
80022f02:	f7 b9 00 ff 	subeq	r9,-1
80022f06:	5f 18       	srne	r8
80022f08:	f7 e8 11 fb 	or	r11,r11,r8<<0x1f
80022f0c:	fe 39 fc 80 	sub	r9,-896
80022f10:	f6 08 12 00 	clz	r8,r11
80022f14:	10 19       	sub	r9,r8
80022f16:	f6 08 09 4b 	lsl	r11,r11,r8
80022f1a:	ed bb 00 1f 	bld	r11,0x1f
80022f1e:	f7 b9 01 01 	subne	r9,1
80022f22:	ab 9a       	lsr	r10,0xb
80022f24:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80022f28:	a1 7b       	lsl	r11,0x1
80022f2a:	ab 9b       	lsr	r11,0xb
80022f2c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80022f30 <__extendsfdf_return_op1>:
80022f30:	a1 7c       	lsl	r12,0x1
80022f32:	5d 0b       	ror	r11
80022f34:	5e fb       	retal	r11
80022f36:	fc 1a ff e0 	movh	r10,0xffe0
80022f3a:	a9 6b       	lsl	r11,0x8
80022f3c:	f9 bb 01 ff 	movne	r11,-1
80022f40:	f4 0b 17 00 	moveq	r11,r10
80022f44:	30 0a       	mov	r10,0
80022f46:	cf 5b       	rjmp	80022f30 <__extendsfdf_return_op1>

80022f48 <__avr32_f64_to_f32>:
80022f48:	f6 09 15 01 	lsl	r9,r11,0x1
80022f4c:	b5 99       	lsr	r9,0x15
80022f4e:	5e 0d       	reteq	0
80022f50:	f6 08 15 0a 	lsl	r8,r11,0xa
80022f54:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
80022f58:	ab 6a       	lsl	r10,0xa
80022f5a:	5c 3a       	neg	r10
80022f5c:	5c fc       	rol	r12
80022f5e:	e0 49 07 ff 	cp.w	r9,2047
80022f62:	c1 a0       	breq	80022f96 <__truncdfsf_return_op1+0x6>
80022f64:	e0 29 03 80 	sub	r9,896
80022f68:	bf bc       	sbr	r12,0x1f
80022f6a:	58 09       	cp.w	r9,0
80022f6c:	e0 8a 00 1a 	brle	80022fa0 <__truncdfsf_return_op1+0x10>
80022f70:	37 fa       	mov	r10,127
80022f72:	ed bc 00 08 	bld	r12,0x8
80022f76:	f7 ba 00 ff 	subeq	r10,-1
80022f7a:	14 0c       	add	r12,r10
80022f7c:	f7 b9 03 fe 	sublo	r9,-2
80022f80:	ed bc 00 1f 	bld	r12,0x1f
80022f84:	f7 b9 01 01 	subne	r9,1
80022f88:	f8 0c 16 07 	lsr	r12,r12,0x7
80022f8c:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

80022f90 <__truncdfsf_return_op1>:
80022f90:	a1 7b       	lsl	r11,0x1
80022f92:	5d 0c       	ror	r12
80022f94:	5e fc       	retal	r12
80022f96:	bf dc       	cbr	r12,0x1f
80022f98:	5e 1e       	retne	-1
80022f9a:	fc 1c 7f 80 	movh	r12,0x7f80
80022f9e:	5e fc       	retal	r12
80022fa0:	f2 09 11 01 	rsub	r9,r9,1
80022fa4:	59 99       	cp.w	r9,25
80022fa6:	f9 bc 02 00 	movhs	r12,0
80022faa:	c1 32       	brcc	80022fd0 <__truncdfsf_return_op1+0x40>
80022fac:	f2 0a 11 20 	rsub	r10,r9,32
80022fb0:	f8 0a 09 4a 	lsl	r10,r12,r10
80022fb4:	5f 1a       	srne	r10
80022fb6:	f8 09 0a 4c 	lsr	r12,r12,r9
80022fba:	14 4c       	or	r12,r10
80022fbc:	37 fa       	mov	r10,127
80022fbe:	ed bc 00 08 	bld	r12,0x8
80022fc2:	f7 ba 00 ff 	subeq	r10,-1
80022fc6:	14 0c       	add	r12,r10
80022fc8:	f8 0c 16 07 	lsr	r12,r12,0x7
80022fcc:	a1 7b       	lsl	r11,0x1
80022fce:	5d 0c       	ror	r12
80022fd0:	5e fc       	retal	r12

80022fd2 <__avr32_udiv64>:
80022fd2:	d4 31       	pushm	r0-r7,lr
80022fd4:	1a 97       	mov	r7,sp
80022fd6:	20 2d       	sub	sp,8
80022fd8:	10 9e       	mov	lr,r8
80022fda:	12 95       	mov	r5,r9
80022fdc:	14 96       	mov	r6,r10
80022fde:	58 09       	cp.w	r9,0
80022fe0:	c4 91       	brne	80023072 <__avr32_udiv64+0xa0>
80022fe2:	16 38       	cp.w	r8,r11
80022fe4:	e0 88 00 57 	brls	80023092 <__avr32_udiv64+0xc0>
80022fe8:	f0 08 12 00 	clz	r8,r8
80022fec:	c0 d0       	breq	80023006 <__avr32_udiv64+0x34>
80022fee:	f6 08 09 4b 	lsl	r11,r11,r8
80022ff2:	f0 09 11 20 	rsub	r9,r8,32
80022ff6:	fc 08 09 4e 	lsl	lr,lr,r8
80022ffa:	f4 09 0a 49 	lsr	r9,r10,r9
80022ffe:	f4 08 09 46 	lsl	r6,r10,r8
80023002:	f3 eb 10 0b 	or	r11,r9,r11
80023006:	fc 05 16 10 	lsr	r5,lr,0x10
8002300a:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
8002300e:	f6 05 0d 0a 	divu	r10,r11,r5
80023012:	ec 08 16 10 	lsr	r8,r6,0x10
80023016:	14 99       	mov	r9,r10
80023018:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8002301c:	b9 3a       	mul	r10,r12
8002301e:	10 3a       	cp.w	r10,r8
80023020:	e0 88 00 0c 	brls	80023038 <__avr32_udiv64+0x66>
80023024:	20 19       	sub	r9,1
80023026:	1c 08       	add	r8,lr
80023028:	10 3e       	cp.w	lr,r8
8002302a:	e0 8b 00 07 	brhi	80023038 <__avr32_udiv64+0x66>
8002302e:	10 3a       	cp.w	r10,r8
80023030:	f7 b9 0b 01 	subhi	r9,1
80023034:	f1 de eb 08 	addhi	r8,r8,lr
80023038:	f0 0a 01 0b 	sub	r11,r8,r10
8002303c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80023040:	f6 05 0d 0a 	divu	r10,r11,r5
80023044:	ed eb 11 06 	or	r6,r6,r11<<0x10
80023048:	14 98       	mov	r8,r10
8002304a:	f4 0c 02 4c 	mul	r12,r10,r12
8002304e:	0c 3c       	cp.w	r12,r6
80023050:	e0 88 00 0a 	brls	80023064 <__avr32_udiv64+0x92>
80023054:	20 18       	sub	r8,1
80023056:	1c 06       	add	r6,lr
80023058:	0c 3e       	cp.w	lr,r6
8002305a:	e0 8b 00 05 	brhi	80023064 <__avr32_udiv64+0x92>
8002305e:	0c 3c       	cp.w	r12,r6
80023060:	f7 b8 0b 01 	subhi	r8,1
80023064:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
80023068:	30 0c       	mov	r12,0
8002306a:	16 9a       	mov	r10,r11
8002306c:	18 9b       	mov	r11,r12
8002306e:	2f ed       	sub	sp,-8
80023070:	d8 32       	popm	r0-r7,pc
80023072:	16 39       	cp.w	r9,r11
80023074:	e0 8b 00 51 	brhi	80023116 <__avr32_udiv64+0x144>
80023078:	f2 0c 12 00 	clz	r12,r9
8002307c:	c5 31       	brne	80023122 <__avr32_udiv64+0x150>
8002307e:	14 38       	cp.w	r8,r10
80023080:	5f 89       	srls	r9
80023082:	16 35       	cp.w	r5,r11
80023084:	5f 38       	srlo	r8
80023086:	10 49       	or	r9,r8
80023088:	f8 09 18 00 	cp.b	r9,r12
8002308c:	c4 50       	breq	80023116 <__avr32_udiv64+0x144>
8002308e:	30 1b       	mov	r11,1
80023090:	c4 58       	rjmp	8002311a <__avr32_udiv64+0x148>
80023092:	58 08       	cp.w	r8,0
80023094:	c0 51       	brne	8002309e <__avr32_udiv64+0xcc>
80023096:	30 19       	mov	r9,1
80023098:	f2 08 0d 08 	divu	r8,r9,r8
8002309c:	10 9e       	mov	lr,r8
8002309e:	fc 08 12 00 	clz	r8,lr
800230a2:	e0 81 00 91 	brne	800231c4 <__avr32_udiv64+0x1f2>
800230a6:	1c 1b       	sub	r11,lr
800230a8:	fc 05 16 10 	lsr	r5,lr,0x10
800230ac:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
800230b0:	30 1c       	mov	r12,1
800230b2:	f6 05 0d 0a 	divu	r10,r11,r5
800230b6:	ec 08 16 10 	lsr	r8,r6,0x10
800230ba:	f4 09 02 43 	mul	r3,r10,r9
800230be:	f1 eb 11 08 	or	r8,r8,r11<<0x10
800230c2:	14 9b       	mov	r11,r10
800230c4:	10 33       	cp.w	r3,r8
800230c6:	e0 88 00 0c 	brls	800230de <__avr32_udiv64+0x10c>
800230ca:	20 1b       	sub	r11,1
800230cc:	1c 08       	add	r8,lr
800230ce:	10 3e       	cp.w	lr,r8
800230d0:	e0 8b 00 07 	brhi	800230de <__avr32_udiv64+0x10c>
800230d4:	10 33       	cp.w	r3,r8
800230d6:	f7 bb 0b 01 	subhi	r11,1
800230da:	f1 de eb 08 	addhi	r8,r8,lr
800230de:	f0 03 01 03 	sub	r3,r8,r3
800230e2:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800230e6:	e6 05 0d 02 	divu	r2,r3,r5
800230ea:	ed e3 11 06 	or	r6,r6,r3<<0x10
800230ee:	04 98       	mov	r8,r2
800230f0:	e4 09 02 49 	mul	r9,r2,r9
800230f4:	0c 39       	cp.w	r9,r6
800230f6:	e0 88 00 0a 	brls	8002310a <__avr32_udiv64+0x138>
800230fa:	20 18       	sub	r8,1
800230fc:	1c 06       	add	r6,lr
800230fe:	0c 3e       	cp.w	lr,r6
80023100:	e0 8b 00 05 	brhi	8002310a <__avr32_udiv64+0x138>
80023104:	0c 39       	cp.w	r9,r6
80023106:	f7 b8 0b 01 	subhi	r8,1
8002310a:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
8002310e:	16 9a       	mov	r10,r11
80023110:	18 9b       	mov	r11,r12
80023112:	2f ed       	sub	sp,-8
80023114:	d8 32       	popm	r0-r7,pc
80023116:	30 0b       	mov	r11,0
80023118:	16 9c       	mov	r12,r11
8002311a:	16 9a       	mov	r10,r11
8002311c:	18 9b       	mov	r11,r12
8002311e:	2f ed       	sub	sp,-8
80023120:	d8 32       	popm	r0-r7,pc
80023122:	f2 0c 09 45 	lsl	r5,r9,r12
80023126:	f8 0e 11 20 	rsub	lr,r12,32
8002312a:	f0 0c 09 43 	lsl	r3,r8,r12
8002312e:	f4 0e 0a 46 	lsr	r6,r10,lr
80023132:	f0 0e 0a 48 	lsr	r8,r8,lr
80023136:	f6 0e 0a 4e 	lsr	lr,r11,lr
8002313a:	0a 48       	or	r8,r5
8002313c:	f0 01 16 10 	lsr	r1,r8,0x10
80023140:	fc 01 0d 04 	divu	r4,lr,r1
80023144:	ee e5 ff f8 	st.d	r7[-8],r4
80023148:	f6 0c 09 49 	lsl	r9,r11,r12
8002314c:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
80023150:	ed e9 10 09 	or	r9,r6,r9
80023154:	08 96       	mov	r6,r4
80023156:	f2 0e 16 10 	lsr	lr,r9,0x10
8002315a:	ee f4 ff f8 	ld.w	r4,r7[-8]
8002315e:	ec 05 02 4b 	mul	r11,r6,r5
80023162:	fd e4 11 0e 	or	lr,lr,r4<<0x10
80023166:	1c 3b       	cp.w	r11,lr
80023168:	e0 88 00 07 	brls	80023176 <__avr32_udiv64+0x1a4>
8002316c:	20 16       	sub	r6,1
8002316e:	10 0e       	add	lr,r8
80023170:	1c 38       	cp.w	r8,lr
80023172:	e0 88 00 6d 	brls	8002324c <__avr32_udiv64+0x27a>
80023176:	16 1e       	sub	lr,r11
80023178:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8002317c:	fc 01 0d 00 	divu	r0,lr,r1
80023180:	f3 e1 11 09 	or	r9,r9,r1<<0x10
80023184:	00 9b       	mov	r11,r0
80023186:	e0 05 02 4e 	mul	lr,r0,r5
8002318a:	12 3e       	cp.w	lr,r9
8002318c:	e0 88 00 07 	brls	8002319a <__avr32_udiv64+0x1c8>
80023190:	20 1b       	sub	r11,1
80023192:	10 09       	add	r9,r8
80023194:	12 38       	cp.w	r8,r9
80023196:	e0 88 00 55 	brls	80023240 <__avr32_udiv64+0x26e>
8002319a:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
8002319e:	1c 19       	sub	r9,lr
800231a0:	f6 03 06 42 	mulu.d	r2,r11,r3
800231a4:	06 39       	cp.w	r9,r3
800231a6:	c0 93       	brcs	800231b8 <__avr32_udiv64+0x1e6>
800231a8:	5f 09       	sreq	r9
800231aa:	f4 0c 09 4c 	lsl	r12,r10,r12
800231ae:	04 3c       	cp.w	r12,r2
800231b0:	5f 38       	srlo	r8
800231b2:	f3 e8 00 08 	and	r8,r9,r8
800231b6:	c0 20       	breq	800231ba <__avr32_udiv64+0x1e8>
800231b8:	20 1b       	sub	r11,1
800231ba:	30 0c       	mov	r12,0
800231bc:	16 9a       	mov	r10,r11
800231be:	18 9b       	mov	r11,r12
800231c0:	2f ed       	sub	sp,-8
800231c2:	d8 32       	popm	r0-r7,pc
800231c4:	f6 08 09 49 	lsl	r9,r11,r8
800231c8:	fc 08 09 4e 	lsl	lr,lr,r8
800231cc:	f0 01 11 20 	rsub	r1,r8,32
800231d0:	fc 05 16 10 	lsr	r5,lr,0x10
800231d4:	f4 01 0a 42 	lsr	r2,r10,r1
800231d8:	f6 01 0a 41 	lsr	r1,r11,r1
800231dc:	12 42       	or	r2,r9
800231de:	e2 05 0d 00 	divu	r0,r1,r5
800231e2:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
800231e6:	e4 06 16 10 	lsr	r6,r2,0x10
800231ea:	00 93       	mov	r3,r0
800231ec:	ed e1 11 06 	or	r6,r6,r1<<0x10
800231f0:	e0 09 02 4c 	mul	r12,r0,r9
800231f4:	0c 3c       	cp.w	r12,r6
800231f6:	e0 88 00 07 	brls	80023204 <__avr32_udiv64+0x232>
800231fa:	20 13       	sub	r3,1
800231fc:	1c 06       	add	r6,lr
800231fe:	0c 3e       	cp.w	lr,r6
80023200:	e0 88 00 2c 	brls	80023258 <__avr32_udiv64+0x286>
80023204:	ec 0c 01 01 	sub	r1,r6,r12
80023208:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8002320c:	e2 05 0d 00 	divu	r0,r1,r5
80023210:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80023214:	00 9c       	mov	r12,r0
80023216:	e0 09 02 41 	mul	r1,r0,r9
8002321a:	16 31       	cp.w	r1,r11
8002321c:	e0 88 00 0c 	brls	80023234 <__avr32_udiv64+0x262>
80023220:	20 1c       	sub	r12,1
80023222:	1c 0b       	add	r11,lr
80023224:	16 3e       	cp.w	lr,r11
80023226:	e0 8b 00 07 	brhi	80023234 <__avr32_udiv64+0x262>
8002322a:	16 31       	cp.w	r1,r11
8002322c:	f7 bc 0b 01 	subhi	r12,1
80023230:	f7 de eb 0b 	addhi	r11,r11,lr
80023234:	f4 08 09 46 	lsl	r6,r10,r8
80023238:	02 1b       	sub	r11,r1
8002323a:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
8002323e:	c3 ab       	rjmp	800230b2 <__avr32_udiv64+0xe0>
80023240:	12 3e       	cp.w	lr,r9
80023242:	f3 d8 eb 09 	addhi	r9,r9,r8
80023246:	f7 bb 0b 01 	subhi	r11,1
8002324a:	ca 8b       	rjmp	8002319a <__avr32_udiv64+0x1c8>
8002324c:	1c 3b       	cp.w	r11,lr
8002324e:	f7 b6 0b 01 	subhi	r6,1
80023252:	fd d8 eb 0e 	addhi	lr,lr,r8
80023256:	c9 0b       	rjmp	80023176 <__avr32_udiv64+0x1a4>
80023258:	0c 3c       	cp.w	r12,r6
8002325a:	f7 b3 0b 01 	subhi	r3,1
8002325e:	ed de eb 06 	addhi	r6,r6,lr
80023262:	cd 1b       	rjmp	80023204 <__avr32_udiv64+0x232>

80023264 <__errno>:
80023264:	e0 68 01 80 	mov	r8,384
80023268:	70 0c       	ld.w	r12,r8[0x0]
8002326a:	2f 4c       	sub	r12,-12
8002326c:	5e fc       	retal	r12
8002326e:	d7 03       	nop

80023270 <free>:
80023270:	d4 01       	pushm	lr
80023272:	e0 68 01 80 	mov	r8,384
80023276:	18 9b       	mov	r11,r12
80023278:	70 0c       	ld.w	r12,r8[0x0]
8002327a:	e0 a0 03 b5 	rcall	800239e4 <_free_r>
8002327e:	d8 02       	popm	pc

80023280 <malloc>:
80023280:	d4 01       	pushm	lr
80023282:	e0 68 01 80 	mov	r8,384
80023286:	18 9b       	mov	r11,r12
80023288:	70 0c       	ld.w	r12,r8[0x0]
8002328a:	c0 3c       	rcall	80023290 <_malloc_r>
8002328c:	d8 02       	popm	pc
8002328e:	d7 03       	nop

80023290 <_malloc_r>:
80023290:	d4 31       	pushm	r0-r7,lr
80023292:	f6 c7 ff f5 	sub	r7,r11,-11
80023296:	18 95       	mov	r5,r12
80023298:	59 67       	cp.w	r7,22
8002329a:	f9 b7 08 10 	movls	r7,16
8002329e:	f9 b8 0b f8 	movhi	r8,-8
800232a2:	ef d8 eb 27 	andhi	r7,r7,r8
800232a6:	16 37       	cp.w	r7,r11
800232a8:	5f 38       	srlo	r8
800232aa:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800232ae:	c0 50       	breq	800232b8 <_malloc_r+0x28>
800232b0:	30 c8       	mov	r8,12
800232b2:	99 38       	st.w	r12[0xc],r8
800232b4:	e0 8f 01 f7 	bral	800236a2 <_malloc_r+0x412>
800232b8:	e0 a0 02 af 	rcall	80023816 <__malloc_lock>
800232bc:	e0 47 01 f7 	cp.w	r7,503
800232c0:	e0 8b 00 1d 	brhi	800232fa <_malloc_r+0x6a>
800232c4:	ee 03 16 03 	lsr	r3,r7,0x3
800232c8:	e0 68 01 84 	mov	r8,388
800232cc:	f0 03 00 38 	add	r8,r8,r3<<0x3
800232d0:	70 36       	ld.w	r6,r8[0xc]
800232d2:	10 36       	cp.w	r6,r8
800232d4:	c0 61       	brne	800232e0 <_malloc_r+0x50>
800232d6:	ec c8 ff f8 	sub	r8,r6,-8
800232da:	70 36       	ld.w	r6,r8[0xc]
800232dc:	10 36       	cp.w	r6,r8
800232de:	c0 c0       	breq	800232f6 <_malloc_r+0x66>
800232e0:	6c 18       	ld.w	r8,r6[0x4]
800232e2:	e0 18 ff fc 	andl	r8,0xfffc
800232e6:	6c 3a       	ld.w	r10,r6[0xc]
800232e8:	ec 08 00 09 	add	r9,r6,r8
800232ec:	0a 9c       	mov	r12,r5
800232ee:	6c 28       	ld.w	r8,r6[0x8]
800232f0:	95 28       	st.w	r10[0x8],r8
800232f2:	91 3a       	st.w	r8[0xc],r10
800232f4:	c4 88       	rjmp	80023384 <_malloc_r+0xf4>
800232f6:	2f e3       	sub	r3,-2
800232f8:	c4 e8       	rjmp	80023394 <_malloc_r+0x104>
800232fa:	ee 08 16 09 	lsr	r8,r7,0x9
800232fe:	c0 41       	brne	80023306 <_malloc_r+0x76>
80023300:	ee 03 16 03 	lsr	r3,r7,0x3
80023304:	c2 78       	rjmp	80023352 <_malloc_r+0xc2>
80023306:	58 48       	cp.w	r8,4
80023308:	e0 8b 00 06 	brhi	80023314 <_malloc_r+0x84>
8002330c:	ee 03 16 06 	lsr	r3,r7,0x6
80023310:	2c 83       	sub	r3,-56
80023312:	c2 08       	rjmp	80023352 <_malloc_r+0xc2>
80023314:	59 48       	cp.w	r8,20
80023316:	e0 8b 00 05 	brhi	80023320 <_malloc_r+0x90>
8002331a:	f0 c3 ff a5 	sub	r3,r8,-91
8002331e:	c1 a8       	rjmp	80023352 <_malloc_r+0xc2>
80023320:	e0 48 00 54 	cp.w	r8,84
80023324:	e0 8b 00 06 	brhi	80023330 <_malloc_r+0xa0>
80023328:	ee 03 16 0c 	lsr	r3,r7,0xc
8002332c:	29 23       	sub	r3,-110
8002332e:	c1 28       	rjmp	80023352 <_malloc_r+0xc2>
80023330:	e0 48 01 54 	cp.w	r8,340
80023334:	e0 8b 00 06 	brhi	80023340 <_malloc_r+0xb0>
80023338:	ee 03 16 0f 	lsr	r3,r7,0xf
8002333c:	28 93       	sub	r3,-119
8002333e:	c0 a8       	rjmp	80023352 <_malloc_r+0xc2>
80023340:	ee 03 16 12 	lsr	r3,r7,0x12
80023344:	e0 48 05 54 	cp.w	r8,1364
80023348:	e0 88 00 04 	brls	80023350 <_malloc_r+0xc0>
8002334c:	37 e3       	mov	r3,126
8002334e:	c0 28       	rjmp	80023352 <_malloc_r+0xc2>
80023350:	28 43       	sub	r3,-124
80023352:	e0 6a 01 84 	mov	r10,388
80023356:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8002335a:	74 36       	ld.w	r6,r10[0xc]
8002335c:	c1 98       	rjmp	8002338e <_malloc_r+0xfe>
8002335e:	6c 19       	ld.w	r9,r6[0x4]
80023360:	e0 19 ff fc 	andl	r9,0xfffc
80023364:	f2 07 01 0b 	sub	r11,r9,r7
80023368:	58 fb       	cp.w	r11,15
8002336a:	e0 8a 00 04 	brle	80023372 <_malloc_r+0xe2>
8002336e:	20 13       	sub	r3,1
80023370:	c1 18       	rjmp	80023392 <_malloc_r+0x102>
80023372:	6c 38       	ld.w	r8,r6[0xc]
80023374:	58 0b       	cp.w	r11,0
80023376:	c0 b5       	brlt	8002338c <_malloc_r+0xfc>
80023378:	6c 2a       	ld.w	r10,r6[0x8]
8002337a:	ec 09 00 09 	add	r9,r6,r9
8002337e:	0a 9c       	mov	r12,r5
80023380:	91 2a       	st.w	r8[0x8],r10
80023382:	95 38       	st.w	r10[0xc],r8
80023384:	72 18       	ld.w	r8,r9[0x4]
80023386:	a1 a8       	sbr	r8,0x0
80023388:	93 18       	st.w	r9[0x4],r8
8002338a:	cb d8       	rjmp	80023504 <_malloc_r+0x274>
8002338c:	10 96       	mov	r6,r8
8002338e:	14 36       	cp.w	r6,r10
80023390:	ce 71       	brne	8002335e <_malloc_r+0xce>
80023392:	2f f3       	sub	r3,-1
80023394:	e0 6a 01 84 	mov	r10,388
80023398:	f4 cc ff f8 	sub	r12,r10,-8
8002339c:	78 26       	ld.w	r6,r12[0x8]
8002339e:	18 36       	cp.w	r6,r12
800233a0:	c6 d0       	breq	8002347a <_malloc_r+0x1ea>
800233a2:	6c 19       	ld.w	r9,r6[0x4]
800233a4:	e0 19 ff fc 	andl	r9,0xfffc
800233a8:	f2 07 01 08 	sub	r8,r9,r7
800233ac:	58 f8       	cp.w	r8,15
800233ae:	e0 89 00 90 	brgt	800234ce <_malloc_r+0x23e>
800233b2:	99 3c       	st.w	r12[0xc],r12
800233b4:	99 2c       	st.w	r12[0x8],r12
800233b6:	58 08       	cp.w	r8,0
800233b8:	c0 55       	brlt	800233c2 <_malloc_r+0x132>
800233ba:	ec 09 00 09 	add	r9,r6,r9
800233be:	0a 9c       	mov	r12,r5
800233c0:	ce 2b       	rjmp	80023384 <_malloc_r+0xf4>
800233c2:	e0 49 01 ff 	cp.w	r9,511
800233c6:	e0 8b 00 13 	brhi	800233ec <_malloc_r+0x15c>
800233ca:	a3 99       	lsr	r9,0x3
800233cc:	f4 09 00 38 	add	r8,r10,r9<<0x3
800233d0:	70 2b       	ld.w	r11,r8[0x8]
800233d2:	8d 38       	st.w	r6[0xc],r8
800233d4:	8d 2b       	st.w	r6[0x8],r11
800233d6:	97 36       	st.w	r11[0xc],r6
800233d8:	91 26       	st.w	r8[0x8],r6
800233da:	a3 49       	asr	r9,0x2
800233dc:	74 18       	ld.w	r8,r10[0x4]
800233de:	30 1b       	mov	r11,1
800233e0:	f6 09 09 49 	lsl	r9,r11,r9
800233e4:	f1 e9 10 09 	or	r9,r8,r9
800233e8:	95 19       	st.w	r10[0x4],r9
800233ea:	c4 88       	rjmp	8002347a <_malloc_r+0x1ea>
800233ec:	f2 08 16 09 	lsr	r8,r9,0x9
800233f0:	58 48       	cp.w	r8,4
800233f2:	e0 8b 00 07 	brhi	80023400 <_malloc_r+0x170>
800233f6:	f2 0a 16 06 	lsr	r10,r9,0x6
800233fa:	2c 8a       	sub	r10,-56
800233fc:	c2 18       	rjmp	8002343e <_malloc_r+0x1ae>
800233fe:	d7 03       	nop
80023400:	59 48       	cp.w	r8,20
80023402:	e0 8b 00 05 	brhi	8002340c <_malloc_r+0x17c>
80023406:	f0 ca ff a5 	sub	r10,r8,-91
8002340a:	c1 a8       	rjmp	8002343e <_malloc_r+0x1ae>
8002340c:	e0 48 00 54 	cp.w	r8,84
80023410:	e0 8b 00 06 	brhi	8002341c <_malloc_r+0x18c>
80023414:	f2 0a 16 0c 	lsr	r10,r9,0xc
80023418:	29 2a       	sub	r10,-110
8002341a:	c1 28       	rjmp	8002343e <_malloc_r+0x1ae>
8002341c:	e0 48 01 54 	cp.w	r8,340
80023420:	e0 8b 00 06 	brhi	8002342c <_malloc_r+0x19c>
80023424:	f2 0a 16 0f 	lsr	r10,r9,0xf
80023428:	28 9a       	sub	r10,-119
8002342a:	c0 a8       	rjmp	8002343e <_malloc_r+0x1ae>
8002342c:	f2 0a 16 12 	lsr	r10,r9,0x12
80023430:	e0 48 05 54 	cp.w	r8,1364
80023434:	e0 88 00 04 	brls	8002343c <_malloc_r+0x1ac>
80023438:	37 ea       	mov	r10,126
8002343a:	c0 28       	rjmp	8002343e <_malloc_r+0x1ae>
8002343c:	28 4a       	sub	r10,-124
8002343e:	e0 6b 01 84 	mov	r11,388
80023442:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80023446:	68 28       	ld.w	r8,r4[0x8]
80023448:	08 38       	cp.w	r8,r4
8002344a:	c0 e1       	brne	80023466 <_malloc_r+0x1d6>
8002344c:	76 19       	ld.w	r9,r11[0x4]
8002344e:	a3 4a       	asr	r10,0x2
80023450:	30 1e       	mov	lr,1
80023452:	fc 0a 09 4a 	lsl	r10,lr,r10
80023456:	f3 ea 10 0a 	or	r10,r9,r10
8002345a:	10 99       	mov	r9,r8
8002345c:	97 1a       	st.w	r11[0x4],r10
8002345e:	c0 a8       	rjmp	80023472 <_malloc_r+0x1e2>
80023460:	70 28       	ld.w	r8,r8[0x8]
80023462:	08 38       	cp.w	r8,r4
80023464:	c0 60       	breq	80023470 <_malloc_r+0x1e0>
80023466:	70 1a       	ld.w	r10,r8[0x4]
80023468:	e0 1a ff fc 	andl	r10,0xfffc
8002346c:	14 39       	cp.w	r9,r10
8002346e:	cf 93       	brcs	80023460 <_malloc_r+0x1d0>
80023470:	70 39       	ld.w	r9,r8[0xc]
80023472:	8d 39       	st.w	r6[0xc],r9
80023474:	8d 28       	st.w	r6[0x8],r8
80023476:	91 36       	st.w	r8[0xc],r6
80023478:	93 26       	st.w	r9[0x8],r6
8002347a:	e6 08 14 02 	asr	r8,r3,0x2
8002347e:	30 1b       	mov	r11,1
80023480:	e0 64 01 84 	mov	r4,388
80023484:	f6 08 09 4b 	lsl	r11,r11,r8
80023488:	68 18       	ld.w	r8,r4[0x4]
8002348a:	10 3b       	cp.w	r11,r8
8002348c:	e0 8b 00 6a 	brhi	80023560 <_malloc_r+0x2d0>
80023490:	f7 e8 00 09 	and	r9,r11,r8
80023494:	c0 b1       	brne	800234aa <_malloc_r+0x21a>
80023496:	e0 13 ff fc 	andl	r3,0xfffc
8002349a:	a1 7b       	lsl	r11,0x1
8002349c:	2f c3       	sub	r3,-4
8002349e:	c0 38       	rjmp	800234a4 <_malloc_r+0x214>
800234a0:	2f c3       	sub	r3,-4
800234a2:	a1 7b       	lsl	r11,0x1
800234a4:	f7 e8 00 09 	and	r9,r11,r8
800234a8:	cf c0       	breq	800234a0 <_malloc_r+0x210>
800234aa:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800234ae:	06 92       	mov	r2,r3
800234b0:	1c 91       	mov	r1,lr
800234b2:	62 36       	ld.w	r6,r1[0xc]
800234b4:	c2 d8       	rjmp	8002350e <_malloc_r+0x27e>
800234b6:	6c 1a       	ld.w	r10,r6[0x4]
800234b8:	e0 1a ff fc 	andl	r10,0xfffc
800234bc:	f4 07 01 08 	sub	r8,r10,r7
800234c0:	58 f8       	cp.w	r8,15
800234c2:	e0 8a 00 15 	brle	800234ec <_malloc_r+0x25c>
800234c6:	6c 3a       	ld.w	r10,r6[0xc]
800234c8:	6c 29       	ld.w	r9,r6[0x8]
800234ca:	95 29       	st.w	r10[0x8],r9
800234cc:	93 3a       	st.w	r9[0xc],r10
800234ce:	0e 99       	mov	r9,r7
800234d0:	ec 07 00 07 	add	r7,r6,r7
800234d4:	a1 a9       	sbr	r9,0x0
800234d6:	99 37       	st.w	r12[0xc],r7
800234d8:	99 27       	st.w	r12[0x8],r7
800234da:	8d 19       	st.w	r6[0x4],r9
800234dc:	ee 08 09 08 	st.w	r7[r8],r8
800234e0:	8f 2c       	st.w	r7[0x8],r12
800234e2:	8f 3c       	st.w	r7[0xc],r12
800234e4:	a1 a8       	sbr	r8,0x0
800234e6:	0a 9c       	mov	r12,r5
800234e8:	8f 18       	st.w	r7[0x4],r8
800234ea:	c0 d8       	rjmp	80023504 <_malloc_r+0x274>
800234ec:	6c 39       	ld.w	r9,r6[0xc]
800234ee:	58 08       	cp.w	r8,0
800234f0:	c0 e5       	brlt	8002350c <_malloc_r+0x27c>
800234f2:	ec 0a 00 0a 	add	r10,r6,r10
800234f6:	74 18       	ld.w	r8,r10[0x4]
800234f8:	a1 a8       	sbr	r8,0x0
800234fa:	0a 9c       	mov	r12,r5
800234fc:	95 18       	st.w	r10[0x4],r8
800234fe:	6c 28       	ld.w	r8,r6[0x8]
80023500:	93 28       	st.w	r9[0x8],r8
80023502:	91 39       	st.w	r8[0xc],r9
80023504:	c8 ad       	rcall	80023818 <__malloc_unlock>
80023506:	ec cc ff f8 	sub	r12,r6,-8
8002350a:	d8 32       	popm	r0-r7,pc
8002350c:	12 96       	mov	r6,r9
8002350e:	02 36       	cp.w	r6,r1
80023510:	cd 31       	brne	800234b6 <_malloc_r+0x226>
80023512:	2f f2       	sub	r2,-1
80023514:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80023518:	c0 30       	breq	8002351e <_malloc_r+0x28e>
8002351a:	2f 81       	sub	r1,-8
8002351c:	cc bb       	rjmp	800234b2 <_malloc_r+0x222>
8002351e:	1c 98       	mov	r8,lr
80023520:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80023524:	c0 81       	brne	80023534 <_malloc_r+0x2a4>
80023526:	68 19       	ld.w	r9,r4[0x4]
80023528:	f6 08 11 ff 	rsub	r8,r11,-1
8002352c:	f3 e8 00 08 	and	r8,r9,r8
80023530:	89 18       	st.w	r4[0x4],r8
80023532:	c0 78       	rjmp	80023540 <_malloc_r+0x2b0>
80023534:	f0 c9 00 08 	sub	r9,r8,8
80023538:	20 13       	sub	r3,1
8002353a:	70 08       	ld.w	r8,r8[0x0]
8002353c:	12 38       	cp.w	r8,r9
8002353e:	cf 10       	breq	80023520 <_malloc_r+0x290>
80023540:	a1 7b       	lsl	r11,0x1
80023542:	68 18       	ld.w	r8,r4[0x4]
80023544:	10 3b       	cp.w	r11,r8
80023546:	e0 8b 00 0d 	brhi	80023560 <_malloc_r+0x2d0>
8002354a:	58 0b       	cp.w	r11,0
8002354c:	c0 a0       	breq	80023560 <_malloc_r+0x2d0>
8002354e:	04 93       	mov	r3,r2
80023550:	c0 38       	rjmp	80023556 <_malloc_r+0x2c6>
80023552:	2f c3       	sub	r3,-4
80023554:	a1 7b       	lsl	r11,0x1
80023556:	f7 e8 00 09 	and	r9,r11,r8
8002355a:	ca 81       	brne	800234aa <_malloc_r+0x21a>
8002355c:	cf bb       	rjmp	80023552 <_malloc_r+0x2c2>
8002355e:	d7 03       	nop
80023560:	68 23       	ld.w	r3,r4[0x8]
80023562:	66 12       	ld.w	r2,r3[0x4]
80023564:	e0 12 ff fc 	andl	r2,0xfffc
80023568:	0e 32       	cp.w	r2,r7
8002356a:	5f 39       	srlo	r9
8002356c:	e4 07 01 08 	sub	r8,r2,r7
80023570:	58 f8       	cp.w	r8,15
80023572:	5f aa       	srle	r10
80023574:	f5 e9 10 09 	or	r9,r10,r9
80023578:	e0 80 00 96 	breq	800236a4 <_malloc_r+0x414>
8002357c:	e0 68 2a a8 	mov	r8,10920
80023580:	70 01       	ld.w	r1,r8[0x0]
80023582:	e0 68 05 90 	mov	r8,1424
80023586:	2f 01       	sub	r1,-16
80023588:	70 08       	ld.w	r8,r8[0x0]
8002358a:	0e 01       	add	r1,r7
8002358c:	5b f8       	cp.w	r8,-1
8002358e:	c0 40       	breq	80023596 <_malloc_r+0x306>
80023590:	28 11       	sub	r1,-127
80023592:	e0 11 ff 80 	andl	r1,0xff80
80023596:	02 9b       	mov	r11,r1
80023598:	0a 9c       	mov	r12,r5
8002359a:	c4 1d       	rcall	8002381c <_sbrk_r>
8002359c:	18 96       	mov	r6,r12
8002359e:	5b fc       	cp.w	r12,-1
800235a0:	c7 30       	breq	80023686 <_malloc_r+0x3f6>
800235a2:	e6 02 00 08 	add	r8,r3,r2
800235a6:	10 3c       	cp.w	r12,r8
800235a8:	c0 32       	brcc	800235ae <_malloc_r+0x31e>
800235aa:	08 33       	cp.w	r3,r4
800235ac:	c6 d1       	brne	80023686 <_malloc_r+0x3f6>
800235ae:	e0 6a 2a ac 	mov	r10,10924
800235b2:	74 09       	ld.w	r9,r10[0x0]
800235b4:	e2 09 00 09 	add	r9,r1,r9
800235b8:	95 09       	st.w	r10[0x0],r9
800235ba:	10 36       	cp.w	r6,r8
800235bc:	c0 a1       	brne	800235d0 <_malloc_r+0x340>
800235be:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800235c2:	c0 71       	brne	800235d0 <_malloc_r+0x340>
800235c4:	e2 02 00 02 	add	r2,r1,r2
800235c8:	68 28       	ld.w	r8,r4[0x8]
800235ca:	a1 a2       	sbr	r2,0x0
800235cc:	91 12       	st.w	r8[0x4],r2
800235ce:	c4 d8       	rjmp	80023668 <_malloc_r+0x3d8>
800235d0:	e0 6a 05 90 	mov	r10,1424
800235d4:	74 0b       	ld.w	r11,r10[0x0]
800235d6:	5b fb       	cp.w	r11,-1
800235d8:	c0 31       	brne	800235de <_malloc_r+0x34e>
800235da:	95 06       	st.w	r10[0x0],r6
800235dc:	c0 78       	rjmp	800235ea <_malloc_r+0x35a>
800235de:	ec 09 00 09 	add	r9,r6,r9
800235e2:	e0 6a 2a ac 	mov	r10,10924
800235e6:	10 19       	sub	r9,r8
800235e8:	95 09       	st.w	r10[0x0],r9
800235ea:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800235ee:	f0 09 11 08 	rsub	r9,r8,8
800235f2:	58 08       	cp.w	r8,0
800235f4:	f2 08 17 10 	movne	r8,r9
800235f8:	ed d8 e1 06 	addne	r6,r6,r8
800235fc:	28 08       	sub	r8,-128
800235fe:	ec 01 00 01 	add	r1,r6,r1
80023602:	0a 9c       	mov	r12,r5
80023604:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80023608:	f0 01 01 01 	sub	r1,r8,r1
8002360c:	02 9b       	mov	r11,r1
8002360e:	c0 7d       	rcall	8002381c <_sbrk_r>
80023610:	e0 68 2a ac 	mov	r8,10924
80023614:	5b fc       	cp.w	r12,-1
80023616:	ec 0c 17 00 	moveq	r12,r6
8002361a:	f9 b1 00 00 	moveq	r1,0
8002361e:	70 09       	ld.w	r9,r8[0x0]
80023620:	0c 1c       	sub	r12,r6
80023622:	89 26       	st.w	r4[0x8],r6
80023624:	02 0c       	add	r12,r1
80023626:	12 01       	add	r1,r9
80023628:	a1 ac       	sbr	r12,0x0
8002362a:	91 01       	st.w	r8[0x0],r1
8002362c:	8d 1c       	st.w	r6[0x4],r12
8002362e:	08 33       	cp.w	r3,r4
80023630:	c1 c0       	breq	80023668 <_malloc_r+0x3d8>
80023632:	58 f2       	cp.w	r2,15
80023634:	e0 8b 00 05 	brhi	8002363e <_malloc_r+0x3ae>
80023638:	30 18       	mov	r8,1
8002363a:	8d 18       	st.w	r6[0x4],r8
8002363c:	c2 58       	rjmp	80023686 <_malloc_r+0x3f6>
8002363e:	30 59       	mov	r9,5
80023640:	20 c2       	sub	r2,12
80023642:	e0 12 ff f8 	andl	r2,0xfff8
80023646:	e6 02 00 08 	add	r8,r3,r2
8002364a:	91 29       	st.w	r8[0x8],r9
8002364c:	91 19       	st.w	r8[0x4],r9
8002364e:	66 18       	ld.w	r8,r3[0x4]
80023650:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80023654:	e5 e8 10 08 	or	r8,r2,r8
80023658:	87 18       	st.w	r3[0x4],r8
8002365a:	58 f2       	cp.w	r2,15
8002365c:	e0 88 00 06 	brls	80023668 <_malloc_r+0x3d8>
80023660:	e6 cb ff f8 	sub	r11,r3,-8
80023664:	0a 9c       	mov	r12,r5
80023666:	cb fd       	rcall	800239e4 <_free_r>
80023668:	e0 69 2a a4 	mov	r9,10916
8002366c:	72 0a       	ld.w	r10,r9[0x0]
8002366e:	e0 68 2a ac 	mov	r8,10924
80023672:	70 08       	ld.w	r8,r8[0x0]
80023674:	14 38       	cp.w	r8,r10
80023676:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8002367a:	e0 69 2a a0 	mov	r9,10912
8002367e:	72 0a       	ld.w	r10,r9[0x0]
80023680:	14 38       	cp.w	r8,r10
80023682:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80023686:	68 28       	ld.w	r8,r4[0x8]
80023688:	70 18       	ld.w	r8,r8[0x4]
8002368a:	e0 18 ff fc 	andl	r8,0xfffc
8002368e:	0e 38       	cp.w	r8,r7
80023690:	5f 39       	srlo	r9
80023692:	0e 18       	sub	r8,r7
80023694:	58 f8       	cp.w	r8,15
80023696:	5f aa       	srle	r10
80023698:	f5 e9 10 09 	or	r9,r10,r9
8002369c:	c0 40       	breq	800236a4 <_malloc_r+0x414>
8002369e:	0a 9c       	mov	r12,r5
800236a0:	cb cc       	rcall	80023818 <__malloc_unlock>
800236a2:	d8 3a       	popm	r0-r7,pc,r12=0
800236a4:	68 26       	ld.w	r6,r4[0x8]
800236a6:	a1 a8       	sbr	r8,0x0
800236a8:	0e 99       	mov	r9,r7
800236aa:	a1 a9       	sbr	r9,0x0
800236ac:	8d 19       	st.w	r6[0x4],r9
800236ae:	ec 07 00 07 	add	r7,r6,r7
800236b2:	0a 9c       	mov	r12,r5
800236b4:	89 27       	st.w	r4[0x8],r7
800236b6:	8f 18       	st.w	r7[0x4],r8
800236b8:	cb 0c       	rcall	80023818 <__malloc_unlock>
800236ba:	ec cc ff f8 	sub	r12,r6,-8
800236be:	d8 32       	popm	r0-r7,pc

800236c0 <memcpy>:
800236c0:	58 8a       	cp.w	r10,8
800236c2:	c2 f5       	brlt	80023720 <memcpy+0x60>
800236c4:	f9 eb 10 09 	or	r9,r12,r11
800236c8:	e2 19 00 03 	andl	r9,0x3,COH
800236cc:	e0 81 00 97 	brne	800237fa <memcpy+0x13a>
800236d0:	e0 4a 00 20 	cp.w	r10,32
800236d4:	c3 b4       	brge	8002374a <memcpy+0x8a>
800236d6:	f4 08 14 02 	asr	r8,r10,0x2
800236da:	f0 09 11 08 	rsub	r9,r8,8
800236de:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800236e2:	76 69       	ld.w	r9,r11[0x18]
800236e4:	99 69       	st.w	r12[0x18],r9
800236e6:	76 59       	ld.w	r9,r11[0x14]
800236e8:	99 59       	st.w	r12[0x14],r9
800236ea:	76 49       	ld.w	r9,r11[0x10]
800236ec:	99 49       	st.w	r12[0x10],r9
800236ee:	76 39       	ld.w	r9,r11[0xc]
800236f0:	99 39       	st.w	r12[0xc],r9
800236f2:	76 29       	ld.w	r9,r11[0x8]
800236f4:	99 29       	st.w	r12[0x8],r9
800236f6:	76 19       	ld.w	r9,r11[0x4]
800236f8:	99 19       	st.w	r12[0x4],r9
800236fa:	76 09       	ld.w	r9,r11[0x0]
800236fc:	99 09       	st.w	r12[0x0],r9
800236fe:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80023702:	f8 08 00 28 	add	r8,r12,r8<<0x2
80023706:	e0 1a 00 03 	andl	r10,0x3
8002370a:	f4 0a 11 04 	rsub	r10,r10,4
8002370e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80023712:	17 a9       	ld.ub	r9,r11[0x2]
80023714:	b0 a9       	st.b	r8[0x2],r9
80023716:	17 99       	ld.ub	r9,r11[0x1]
80023718:	b0 99       	st.b	r8[0x1],r9
8002371a:	17 89       	ld.ub	r9,r11[0x0]
8002371c:	b0 89       	st.b	r8[0x0],r9
8002371e:	5e fc       	retal	r12
80023720:	f4 0a 11 09 	rsub	r10,r10,9
80023724:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80023728:	17 f9       	ld.ub	r9,r11[0x7]
8002372a:	b8 f9       	st.b	r12[0x7],r9
8002372c:	17 e9       	ld.ub	r9,r11[0x6]
8002372e:	b8 e9       	st.b	r12[0x6],r9
80023730:	17 d9       	ld.ub	r9,r11[0x5]
80023732:	b8 d9       	st.b	r12[0x5],r9
80023734:	17 c9       	ld.ub	r9,r11[0x4]
80023736:	b8 c9       	st.b	r12[0x4],r9
80023738:	17 b9       	ld.ub	r9,r11[0x3]
8002373a:	b8 b9       	st.b	r12[0x3],r9
8002373c:	17 a9       	ld.ub	r9,r11[0x2]
8002373e:	b8 a9       	st.b	r12[0x2],r9
80023740:	17 99       	ld.ub	r9,r11[0x1]
80023742:	b8 99       	st.b	r12[0x1],r9
80023744:	17 89       	ld.ub	r9,r11[0x0]
80023746:	b8 89       	st.b	r12[0x0],r9
80023748:	5e fc       	retal	r12
8002374a:	eb cd 40 c0 	pushm	r6-r7,lr
8002374e:	18 99       	mov	r9,r12
80023750:	22 0a       	sub	r10,32
80023752:	b7 07       	ld.d	r6,r11++
80023754:	b3 26       	st.d	r9++,r6
80023756:	b7 07       	ld.d	r6,r11++
80023758:	b3 26       	st.d	r9++,r6
8002375a:	b7 07       	ld.d	r6,r11++
8002375c:	b3 26       	st.d	r9++,r6
8002375e:	b7 07       	ld.d	r6,r11++
80023760:	b3 26       	st.d	r9++,r6
80023762:	22 0a       	sub	r10,32
80023764:	cf 74       	brge	80023752 <memcpy+0x92>
80023766:	2f 0a       	sub	r10,-16
80023768:	c0 65       	brlt	80023774 <memcpy+0xb4>
8002376a:	b7 07       	ld.d	r6,r11++
8002376c:	b3 26       	st.d	r9++,r6
8002376e:	b7 07       	ld.d	r6,r11++
80023770:	b3 26       	st.d	r9++,r6
80023772:	21 0a       	sub	r10,16
80023774:	5c 3a       	neg	r10
80023776:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8002377a:	d7 03       	nop
8002377c:	d7 03       	nop
8002377e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80023782:	f3 66 00 0e 	st.b	r9[14],r6
80023786:	f7 36 00 0d 	ld.ub	r6,r11[13]
8002378a:	f3 66 00 0d 	st.b	r9[13],r6
8002378e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80023792:	f3 66 00 0c 	st.b	r9[12],r6
80023796:	f7 36 00 0b 	ld.ub	r6,r11[11]
8002379a:	f3 66 00 0b 	st.b	r9[11],r6
8002379e:	f7 36 00 0a 	ld.ub	r6,r11[10]
800237a2:	f3 66 00 0a 	st.b	r9[10],r6
800237a6:	f7 36 00 09 	ld.ub	r6,r11[9]
800237aa:	f3 66 00 09 	st.b	r9[9],r6
800237ae:	f7 36 00 08 	ld.ub	r6,r11[8]
800237b2:	f3 66 00 08 	st.b	r9[8],r6
800237b6:	f7 36 00 07 	ld.ub	r6,r11[7]
800237ba:	f3 66 00 07 	st.b	r9[7],r6
800237be:	f7 36 00 06 	ld.ub	r6,r11[6]
800237c2:	f3 66 00 06 	st.b	r9[6],r6
800237c6:	f7 36 00 05 	ld.ub	r6,r11[5]
800237ca:	f3 66 00 05 	st.b	r9[5],r6
800237ce:	f7 36 00 04 	ld.ub	r6,r11[4]
800237d2:	f3 66 00 04 	st.b	r9[4],r6
800237d6:	f7 36 00 03 	ld.ub	r6,r11[3]
800237da:	f3 66 00 03 	st.b	r9[3],r6
800237de:	f7 36 00 02 	ld.ub	r6,r11[2]
800237e2:	f3 66 00 02 	st.b	r9[2],r6
800237e6:	f7 36 00 01 	ld.ub	r6,r11[1]
800237ea:	f3 66 00 01 	st.b	r9[1],r6
800237ee:	f7 36 00 00 	ld.ub	r6,r11[0]
800237f2:	f3 66 00 00 	st.b	r9[0],r6
800237f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800237fa:	20 1a       	sub	r10,1
800237fc:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80023800:	f8 0a 0b 09 	st.b	r12[r10],r9
80023804:	cf b1       	brne	800237fa <memcpy+0x13a>
80023806:	5e fc       	retal	r12

80023808 <memset>:
80023808:	18 98       	mov	r8,r12
8002380a:	c0 38       	rjmp	80023810 <memset+0x8>
8002380c:	10 cb       	st.b	r8++,r11
8002380e:	20 1a       	sub	r10,1
80023810:	58 0a       	cp.w	r10,0
80023812:	cf d1       	brne	8002380c <memset+0x4>
80023814:	5e fc       	retal	r12

80023816 <__malloc_lock>:
80023816:	5e fc       	retal	r12

80023818 <__malloc_unlock>:
80023818:	5e fc       	retal	r12
8002381a:	d7 03       	nop

8002381c <_sbrk_r>:
8002381c:	d4 21       	pushm	r4-r7,lr
8002381e:	30 08       	mov	r8,0
80023820:	18 97       	mov	r7,r12
80023822:	e0 66 33 40 	mov	r6,13120
80023826:	16 9c       	mov	r12,r11
80023828:	8d 08       	st.w	r6[0x0],r8
8002382a:	c7 bc       	rcall	80023920 <_sbrk>
8002382c:	5b fc       	cp.w	r12,-1
8002382e:	c0 51       	brne	80023838 <_sbrk_r+0x1c>
80023830:	6c 08       	ld.w	r8,r6[0x0]
80023832:	58 08       	cp.w	r8,0
80023834:	ef f8 1a 03 	st.wne	r7[0xc],r8
80023838:	d8 22       	popm	r4-r7,pc
8002383a:	d7 03       	nop

8002383c <strcmp>:
8002383c:	f9 eb 10 0a 	or	r10,r12,r11
80023840:	e2 1a 00 03 	andl	r10,0x3,COH
80023844:	c3 41       	brne	800238ac <strcmp+0x70>
80023846:	78 0a       	ld.w	r10,r12[0x0]
80023848:	76 09       	ld.w	r9,r11[0x0]
8002384a:	5c ea       	tnbz	r10
8002384c:	c1 70       	breq	8002387a <strcmp+0x3e>
8002384e:	12 3a       	cp.w	r10,r9
80023850:	c1 51       	brne	8002387a <strcmp+0x3e>
80023852:	78 1a       	ld.w	r10,r12[0x4]
80023854:	76 19       	ld.w	r9,r11[0x4]
80023856:	5c ea       	tnbz	r10
80023858:	c1 10       	breq	8002387a <strcmp+0x3e>
8002385a:	12 3a       	cp.w	r10,r9
8002385c:	c0 f1       	brne	8002387a <strcmp+0x3e>
8002385e:	78 2a       	ld.w	r10,r12[0x8]
80023860:	76 29       	ld.w	r9,r11[0x8]
80023862:	5c ea       	tnbz	r10
80023864:	c0 b0       	breq	8002387a <strcmp+0x3e>
80023866:	12 3a       	cp.w	r10,r9
80023868:	c0 91       	brne	8002387a <strcmp+0x3e>
8002386a:	78 3a       	ld.w	r10,r12[0xc]
8002386c:	76 39       	ld.w	r9,r11[0xc]
8002386e:	5c ea       	tnbz	r10
80023870:	c0 50       	breq	8002387a <strcmp+0x3e>
80023872:	2f 0c       	sub	r12,-16
80023874:	2f 0b       	sub	r11,-16
80023876:	12 3a       	cp.w	r10,r9
80023878:	ce 70       	breq	80023846 <strcmp+0xa>
8002387a:	f9 da c3 08 	bfextu	r12,r10,0x18,0x8
8002387e:	f7 d9 c3 08 	bfextu	r11,r9,0x18,0x8
80023882:	5e 0c       	reteq	r12
80023884:	16 1c       	sub	r12,r11
80023886:	5e 1c       	retne	r12
80023888:	f9 da c2 08 	bfextu	r12,r10,0x10,0x8
8002388c:	f7 d9 c2 08 	bfextu	r11,r9,0x10,0x8
80023890:	5e 0c       	reteq	r12
80023892:	16 1c       	sub	r12,r11
80023894:	5e 1c       	retne	r12
80023896:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
8002389a:	f7 d9 c1 08 	bfextu	r11,r9,0x8,0x8
8002389e:	5e 0c       	reteq	r12
800238a0:	16 1c       	sub	r12,r11
800238a2:	5e 1c       	retne	r12
800238a4:	5c 5a       	castu.b	r10
800238a6:	5c 59       	castu.b	r9
800238a8:	12 1a       	sub	r10,r9
800238aa:	5e fa       	retal	r10
800238ac:	17 8a       	ld.ub	r10,r11[0x0]
800238ae:	19 89       	ld.ub	r9,r12[0x0]
800238b0:	58 0a       	cp.w	r10,0
800238b2:	5e 09       	reteq	r9
800238b4:	14 19       	sub	r9,r10
800238b6:	5e 19       	retne	r9
800238b8:	17 9a       	ld.ub	r10,r11[0x1]
800238ba:	19 99       	ld.ub	r9,r12[0x1]
800238bc:	58 0a       	cp.w	r10,0
800238be:	5e 09       	reteq	r9
800238c0:	14 19       	sub	r9,r10
800238c2:	5e 19       	retne	r9
800238c4:	17 aa       	ld.ub	r10,r11[0x2]
800238c6:	19 a9       	ld.ub	r9,r12[0x2]
800238c8:	58 0a       	cp.w	r10,0
800238ca:	5e 09       	reteq	r9
800238cc:	14 19       	sub	r9,r10
800238ce:	5e 19       	retne	r9
800238d0:	17 ba       	ld.ub	r10,r11[0x3]
800238d2:	19 b9       	ld.ub	r9,r12[0x3]
800238d4:	58 0a       	cp.w	r10,0
800238d6:	5e 09       	reteq	r9
800238d8:	14 19       	sub	r9,r10
800238da:	5e 19       	retne	r9
800238dc:	2f cb       	sub	r11,-4
800238de:	2f cc       	sub	r12,-4
800238e0:	ce 6b       	rjmp	800238ac <strcmp+0x70>
800238e2:	d7 03       	nop

800238e4 <strlen>:
800238e4:	30 09       	mov	r9,0
800238e6:	18 98       	mov	r8,r12
800238e8:	c0 28       	rjmp	800238ec <strlen+0x8>
800238ea:	2f f8       	sub	r8,-1
800238ec:	11 8a       	ld.ub	r10,r8[0x0]
800238ee:	f2 0a 18 00 	cp.b	r10,r9
800238f2:	cf c1       	brne	800238ea <strlen+0x6>
800238f4:	f0 0c 01 0c 	sub	r12,r8,r12
800238f8:	5e fc       	retal	r12

800238fa <strncmp>:
800238fa:	58 0a       	cp.w	r10,0
800238fc:	c0 81       	brne	8002390c <strncmp+0x12>
800238fe:	5e fa       	retal	r10
80023900:	58 0a       	cp.w	r10,0
80023902:	c0 b0       	breq	80023918 <strncmp+0x1e>
80023904:	58 08       	cp.w	r8,0
80023906:	c0 90       	breq	80023918 <strncmp+0x1e>
80023908:	2f fc       	sub	r12,-1
8002390a:	2f fb       	sub	r11,-1
8002390c:	20 1a       	sub	r10,1
8002390e:	19 88       	ld.ub	r8,r12[0x0]
80023910:	17 89       	ld.ub	r9,r11[0x0]
80023912:	f0 09 18 00 	cp.b	r9,r8
80023916:	cf 50       	breq	80023900 <strncmp+0x6>
80023918:	19 8c       	ld.ub	r12,r12[0x0]
8002391a:	17 88       	ld.ub	r8,r11[0x0]
8002391c:	10 1c       	sub	r12,r8
8002391e:	5e fc       	retal	r12

80023920 <_sbrk>:
80023920:	d4 01       	pushm	lr
80023922:	e0 68 2a d4 	mov	r8,10964
80023926:	70 09       	ld.w	r9,r8[0x0]
80023928:	58 09       	cp.w	r9,0
8002392a:	c0 41       	brne	80023932 <_sbrk+0x12>
8002392c:	e0 69 33 48 	mov	r9,13128
80023930:	91 09       	st.w	r8[0x0],r9
80023932:	e0 69 2a d4 	mov	r9,10964
80023936:	e0 6a f0 00 	mov	r10,61440
8002393a:	72 08       	ld.w	r8,r9[0x0]
8002393c:	f0 0c 00 0c 	add	r12,r8,r12
80023940:	14 3c       	cp.w	r12,r10
80023942:	e0 8b 00 04 	brhi	8002394a <_sbrk+0x2a>
80023946:	93 0c       	st.w	r9[0x0],r12
80023948:	c0 68       	rjmp	80023954 <_sbrk+0x34>
8002394a:	fe b0 fc 8d 	rcall	80023264 <__errno>
8002394e:	30 c8       	mov	r8,12
80023950:	99 08       	st.w	r12[0x0],r8
80023952:	3f f8       	mov	r8,-1
80023954:	10 9c       	mov	r12,r8
80023956:	d8 02       	popm	pc

80023958 <_malloc_trim_r>:
80023958:	d4 21       	pushm	r4-r7,lr
8002395a:	16 95       	mov	r5,r11
8002395c:	18 97       	mov	r7,r12
8002395e:	c5 cf       	rcall	80023816 <__malloc_lock>
80023960:	e0 64 01 84 	mov	r4,388
80023964:	68 28       	ld.w	r8,r4[0x8]
80023966:	70 16       	ld.w	r6,r8[0x4]
80023968:	e0 16 ff fc 	andl	r6,0xfffc
8002396c:	ec c8 ff 91 	sub	r8,r6,-111
80023970:	f0 05 01 05 	sub	r5,r8,r5
80023974:	e0 15 ff 80 	andl	r5,0xff80
80023978:	ea c5 00 80 	sub	r5,r5,128
8002397c:	e0 45 00 7f 	cp.w	r5,127
80023980:	e0 8a 00 22 	brle	800239c4 <_malloc_trim_r+0x6c>
80023984:	30 0b       	mov	r11,0
80023986:	0e 9c       	mov	r12,r7
80023988:	c4 af       	rcall	8002381c <_sbrk_r>
8002398a:	68 28       	ld.w	r8,r4[0x8]
8002398c:	0c 08       	add	r8,r6
8002398e:	10 3c       	cp.w	r12,r8
80023990:	c1 a1       	brne	800239c4 <_malloc_trim_r+0x6c>
80023992:	ea 0b 11 00 	rsub	r11,r5,0
80023996:	0e 9c       	mov	r12,r7
80023998:	c4 2f       	rcall	8002381c <_sbrk_r>
8002399a:	5b fc       	cp.w	r12,-1
8002399c:	c1 71       	brne	800239ca <_malloc_trim_r+0x72>
8002399e:	30 0b       	mov	r11,0
800239a0:	0e 9c       	mov	r12,r7
800239a2:	c3 df       	rcall	8002381c <_sbrk_r>
800239a4:	68 28       	ld.w	r8,r4[0x8]
800239a6:	f8 08 01 09 	sub	r9,r12,r8
800239aa:	58 f9       	cp.w	r9,15
800239ac:	e0 8a 00 0c 	brle	800239c4 <_malloc_trim_r+0x6c>
800239b0:	a1 a9       	sbr	r9,0x0
800239b2:	91 19       	st.w	r8[0x4],r9
800239b4:	e0 68 05 90 	mov	r8,1424
800239b8:	70 09       	ld.w	r9,r8[0x0]
800239ba:	e0 68 2a ac 	mov	r8,10924
800239be:	f8 09 01 09 	sub	r9,r12,r9
800239c2:	91 09       	st.w	r8[0x0],r9
800239c4:	0e 9c       	mov	r12,r7
800239c6:	c2 9f       	rcall	80023818 <__malloc_unlock>
800239c8:	d8 2a       	popm	r4-r7,pc,r12=0
800239ca:	68 28       	ld.w	r8,r4[0x8]
800239cc:	0a 16       	sub	r6,r5
800239ce:	a1 a6       	sbr	r6,0x0
800239d0:	91 16       	st.w	r8[0x4],r6
800239d2:	e0 68 2a ac 	mov	r8,10924
800239d6:	70 09       	ld.w	r9,r8[0x0]
800239d8:	0a 19       	sub	r9,r5
800239da:	0e 9c       	mov	r12,r7
800239dc:	91 09       	st.w	r8[0x0],r9
800239de:	c1 df       	rcall	80023818 <__malloc_unlock>
800239e0:	da 2a       	popm	r4-r7,pc,r12=1
800239e2:	d7 03       	nop

800239e4 <_free_r>:
800239e4:	d4 21       	pushm	r4-r7,lr
800239e6:	16 96       	mov	r6,r11
800239e8:	18 97       	mov	r7,r12
800239ea:	58 0b       	cp.w	r11,0
800239ec:	e0 80 00 bd 	breq	80023b66 <_free_r+0x182>
800239f0:	c1 3f       	rcall	80023816 <__malloc_lock>
800239f2:	20 86       	sub	r6,8
800239f4:	e0 6a 01 84 	mov	r10,388
800239f8:	6c 18       	ld.w	r8,r6[0x4]
800239fa:	74 2e       	ld.w	lr,r10[0x8]
800239fc:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80023a00:	a1 c8       	cbr	r8,0x0
80023a02:	ec 08 00 09 	add	r9,r6,r8
80023a06:	72 1b       	ld.w	r11,r9[0x4]
80023a08:	e0 1b ff fc 	andl	r11,0xfffc
80023a0c:	1c 39       	cp.w	r9,lr
80023a0e:	c1 d1       	brne	80023a48 <_free_r+0x64>
80023a10:	f6 08 00 08 	add	r8,r11,r8
80023a14:	58 0c       	cp.w	r12,0
80023a16:	c0 81       	brne	80023a26 <_free_r+0x42>
80023a18:	6c 09       	ld.w	r9,r6[0x0]
80023a1a:	12 16       	sub	r6,r9
80023a1c:	12 08       	add	r8,r9
80023a1e:	6c 3b       	ld.w	r11,r6[0xc]
80023a20:	6c 29       	ld.w	r9,r6[0x8]
80023a22:	97 29       	st.w	r11[0x8],r9
80023a24:	93 3b       	st.w	r9[0xc],r11
80023a26:	10 99       	mov	r9,r8
80023a28:	95 26       	st.w	r10[0x8],r6
80023a2a:	a1 a9       	sbr	r9,0x0
80023a2c:	8d 19       	st.w	r6[0x4],r9
80023a2e:	e0 69 05 8c 	mov	r9,1420
80023a32:	72 09       	ld.w	r9,r9[0x0]
80023a34:	12 38       	cp.w	r8,r9
80023a36:	c0 63       	brcs	80023a42 <_free_r+0x5e>
80023a38:	e0 68 2a a8 	mov	r8,10920
80023a3c:	0e 9c       	mov	r12,r7
80023a3e:	70 0b       	ld.w	r11,r8[0x0]
80023a40:	c8 cf       	rcall	80023958 <_malloc_trim_r>
80023a42:	0e 9c       	mov	r12,r7
80023a44:	ce ae       	rcall	80023818 <__malloc_unlock>
80023a46:	d8 22       	popm	r4-r7,pc
80023a48:	93 1b       	st.w	r9[0x4],r11
80023a4a:	58 0c       	cp.w	r12,0
80023a4c:	c0 30       	breq	80023a52 <_free_r+0x6e>
80023a4e:	30 0c       	mov	r12,0
80023a50:	c1 08       	rjmp	80023a70 <_free_r+0x8c>
80023a52:	6c 0e       	ld.w	lr,r6[0x0]
80023a54:	f4 c5 ff f8 	sub	r5,r10,-8
80023a58:	1c 16       	sub	r6,lr
80023a5a:	1c 08       	add	r8,lr
80023a5c:	6c 2e       	ld.w	lr,r6[0x8]
80023a5e:	0a 3e       	cp.w	lr,r5
80023a60:	f9 bc 00 01 	moveq	r12,1
80023a64:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80023a68:	eb fe 1a 02 	st.wne	r5[0x8],lr
80023a6c:	fd f5 1a 03 	st.wne	lr[0xc],r5
80023a70:	f2 0b 00 0e 	add	lr,r9,r11
80023a74:	7c 1e       	ld.w	lr,lr[0x4]
80023a76:	ed be 00 00 	bld	lr,0x0
80023a7a:	c1 40       	breq	80023aa2 <_free_r+0xbe>
80023a7c:	16 08       	add	r8,r11
80023a7e:	58 0c       	cp.w	r12,0
80023a80:	c0 d1       	brne	80023a9a <_free_r+0xb6>
80023a82:	e0 6e 01 84 	mov	lr,388
80023a86:	72 2b       	ld.w	r11,r9[0x8]
80023a88:	2f 8e       	sub	lr,-8
80023a8a:	1c 3b       	cp.w	r11,lr
80023a8c:	c0 71       	brne	80023a9a <_free_r+0xb6>
80023a8e:	97 36       	st.w	r11[0xc],r6
80023a90:	97 26       	st.w	r11[0x8],r6
80023a92:	8d 2b       	st.w	r6[0x8],r11
80023a94:	8d 3b       	st.w	r6[0xc],r11
80023a96:	30 1c       	mov	r12,1
80023a98:	c0 58       	rjmp	80023aa2 <_free_r+0xbe>
80023a9a:	72 2b       	ld.w	r11,r9[0x8]
80023a9c:	72 39       	ld.w	r9,r9[0xc]
80023a9e:	93 2b       	st.w	r9[0x8],r11
80023aa0:	97 39       	st.w	r11[0xc],r9
80023aa2:	10 99       	mov	r9,r8
80023aa4:	ec 08 09 08 	st.w	r6[r8],r8
80023aa8:	a1 a9       	sbr	r9,0x0
80023aaa:	8d 19       	st.w	r6[0x4],r9
80023aac:	58 0c       	cp.w	r12,0
80023aae:	c5 a1       	brne	80023b62 <_free_r+0x17e>
80023ab0:	e0 48 01 ff 	cp.w	r8,511
80023ab4:	e0 8b 00 13 	brhi	80023ada <_free_r+0xf6>
80023ab8:	a3 98       	lsr	r8,0x3
80023aba:	f4 08 00 39 	add	r9,r10,r8<<0x3
80023abe:	72 2b       	ld.w	r11,r9[0x8]
80023ac0:	8d 39       	st.w	r6[0xc],r9
80023ac2:	8d 2b       	st.w	r6[0x8],r11
80023ac4:	97 36       	st.w	r11[0xc],r6
80023ac6:	93 26       	st.w	r9[0x8],r6
80023ac8:	a3 48       	asr	r8,0x2
80023aca:	74 19       	ld.w	r9,r10[0x4]
80023acc:	30 1b       	mov	r11,1
80023ace:	f6 08 09 48 	lsl	r8,r11,r8
80023ad2:	f3 e8 10 08 	or	r8,r9,r8
80023ad6:	95 18       	st.w	r10[0x4],r8
80023ad8:	c4 58       	rjmp	80023b62 <_free_r+0x17e>
80023ada:	f0 09 16 09 	lsr	r9,r8,0x9
80023ade:	58 49       	cp.w	r9,4
80023ae0:	e0 8b 00 06 	brhi	80023aec <_free_r+0x108>
80023ae4:	f0 0b 16 06 	lsr	r11,r8,0x6
80023ae8:	2c 8b       	sub	r11,-56
80023aea:	c2 08       	rjmp	80023b2a <_free_r+0x146>
80023aec:	59 49       	cp.w	r9,20
80023aee:	e0 8b 00 05 	brhi	80023af8 <_free_r+0x114>
80023af2:	f2 cb ff a5 	sub	r11,r9,-91
80023af6:	c1 a8       	rjmp	80023b2a <_free_r+0x146>
80023af8:	e0 49 00 54 	cp.w	r9,84
80023afc:	e0 8b 00 06 	brhi	80023b08 <_free_r+0x124>
80023b00:	f0 0b 16 0c 	lsr	r11,r8,0xc
80023b04:	29 2b       	sub	r11,-110
80023b06:	c1 28       	rjmp	80023b2a <_free_r+0x146>
80023b08:	e0 49 01 54 	cp.w	r9,340
80023b0c:	e0 8b 00 06 	brhi	80023b18 <_free_r+0x134>
80023b10:	f0 0b 16 0f 	lsr	r11,r8,0xf
80023b14:	28 9b       	sub	r11,-119
80023b16:	c0 a8       	rjmp	80023b2a <_free_r+0x146>
80023b18:	f0 0b 16 12 	lsr	r11,r8,0x12
80023b1c:	e0 49 05 54 	cp.w	r9,1364
80023b20:	e0 88 00 04 	brls	80023b28 <_free_r+0x144>
80023b24:	37 eb       	mov	r11,126
80023b26:	c0 28       	rjmp	80023b2a <_free_r+0x146>
80023b28:	28 4b       	sub	r11,-124
80023b2a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80023b2e:	78 29       	ld.w	r9,r12[0x8]
80023b30:	18 39       	cp.w	r9,r12
80023b32:	c0 e1       	brne	80023b4e <_free_r+0x16a>
80023b34:	74 18       	ld.w	r8,r10[0x4]
80023b36:	a3 4b       	asr	r11,0x2
80023b38:	30 1c       	mov	r12,1
80023b3a:	f8 0b 09 4b 	lsl	r11,r12,r11
80023b3e:	f1 eb 10 0b 	or	r11,r8,r11
80023b42:	12 98       	mov	r8,r9
80023b44:	95 1b       	st.w	r10[0x4],r11
80023b46:	c0 a8       	rjmp	80023b5a <_free_r+0x176>
80023b48:	72 29       	ld.w	r9,r9[0x8]
80023b4a:	18 39       	cp.w	r9,r12
80023b4c:	c0 60       	breq	80023b58 <_free_r+0x174>
80023b4e:	72 1a       	ld.w	r10,r9[0x4]
80023b50:	e0 1a ff fc 	andl	r10,0xfffc
80023b54:	14 38       	cp.w	r8,r10
80023b56:	cf 93       	brcs	80023b48 <_free_r+0x164>
80023b58:	72 38       	ld.w	r8,r9[0xc]
80023b5a:	8d 38       	st.w	r6[0xc],r8
80023b5c:	8d 29       	st.w	r6[0x8],r9
80023b5e:	93 36       	st.w	r9[0xc],r6
80023b60:	91 26       	st.w	r8[0x8],r6
80023b62:	0e 9c       	mov	r12,r7
80023b64:	c5 ae       	rcall	80023818 <__malloc_unlock>
80023b66:	d8 22       	popm	r4-r7,pc

Disassembly of section .exception:

80023c00 <_evba>:
80023c00:	c0 08       	rjmp	80023c00 <_evba>
	...

80023c04 <_handle_TLB_Multiple_Hit>:
80023c04:	c0 08       	rjmp	80023c04 <_handle_TLB_Multiple_Hit>
	...

80023c08 <_handle_Bus_Error_Data_Fetch>:
80023c08:	c0 08       	rjmp	80023c08 <_handle_Bus_Error_Data_Fetch>
	...

80023c0c <_handle_Bus_Error_Instruction_Fetch>:
80023c0c:	c0 08       	rjmp	80023c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80023c10 <_handle_NMI>:
80023c10:	c0 08       	rjmp	80023c10 <_handle_NMI>
	...

80023c14 <_handle_Instruction_Address>:
80023c14:	c0 08       	rjmp	80023c14 <_handle_Instruction_Address>
	...

80023c18 <_handle_ITLB_Protection>:
80023c18:	c0 08       	rjmp	80023c18 <_handle_ITLB_Protection>
	...

80023c1c <_handle_Breakpoint>:
80023c1c:	c0 08       	rjmp	80023c1c <_handle_Breakpoint>
	...

80023c20 <_handle_Illegal_Opcode>:
80023c20:	c0 08       	rjmp	80023c20 <_handle_Illegal_Opcode>
	...

80023c24 <_handle_Unimplemented_Instruction>:
80023c24:	c0 08       	rjmp	80023c24 <_handle_Unimplemented_Instruction>
	...

80023c28 <_handle_Privilege_Violation>:
80023c28:	c0 08       	rjmp	80023c28 <_handle_Privilege_Violation>
	...

80023c2c <_handle_Floating_Point>:
80023c2c:	c0 08       	rjmp	80023c2c <_handle_Floating_Point>
	...

80023c30 <_handle_Coprocessor_Absent>:
80023c30:	c0 08       	rjmp	80023c30 <_handle_Coprocessor_Absent>
	...

80023c34 <_handle_Data_Address_Read>:
80023c34:	c0 08       	rjmp	80023c34 <_handle_Data_Address_Read>
	...

80023c38 <_handle_Data_Address_Write>:
80023c38:	c0 08       	rjmp	80023c38 <_handle_Data_Address_Write>
	...

80023c3c <_handle_DTLB_Protection_Read>:
80023c3c:	c0 08       	rjmp	80023c3c <_handle_DTLB_Protection_Read>
	...

80023c40 <_handle_DTLB_Protection_Write>:
80023c40:	c0 08       	rjmp	80023c40 <_handle_DTLB_Protection_Write>
	...

80023c44 <_handle_DTLB_Modified>:
80023c44:	c0 08       	rjmp	80023c44 <_handle_DTLB_Modified>
	...

80023c50 <_handle_ITLB_Miss>:
80023c50:	c0 08       	rjmp	80023c50 <_handle_ITLB_Miss>
	...

80023c60 <_handle_DTLB_Miss_Read>:
80023c60:	c0 08       	rjmp	80023c60 <_handle_DTLB_Miss_Read>
	...

80023c70 <_handle_DTLB_Miss_Write>:
80023c70:	c0 08       	rjmp	80023c70 <_handle_DTLB_Miss_Write>
	...

80023d00 <_handle_Supervisor_Call>:
80023d00:	c0 08       	rjmp	80023d00 <_handle_Supervisor_Call>
80023d02:	d7 03       	nop

80023d04 <_int0>:
80023d04:	30 0c       	mov	r12,0
80023d06:	fe b0 76 03 	rcall	8001290c <_get_interrupt_handler>
80023d0a:	58 0c       	cp.w	r12,0
80023d0c:	f8 0f 17 10 	movne	pc,r12
80023d10:	d6 03       	rete

80023d12 <_int1>:
80023d12:	30 1c       	mov	r12,1
80023d14:	fe b0 75 fc 	rcall	8001290c <_get_interrupt_handler>
80023d18:	58 0c       	cp.w	r12,0
80023d1a:	f8 0f 17 10 	movne	pc,r12
80023d1e:	d6 03       	rete

80023d20 <_int2>:
80023d20:	30 2c       	mov	r12,2
80023d22:	fe b0 75 f5 	rcall	8001290c <_get_interrupt_handler>
80023d26:	58 0c       	cp.w	r12,0
80023d28:	f8 0f 17 10 	movne	pc,r12
80023d2c:	d6 03       	rete

80023d2e <_int3>:
80023d2e:	30 3c       	mov	r12,3
80023d30:	fe b0 75 ee 	rcall	8001290c <_get_interrupt_handler>
80023d34:	58 0c       	cp.w	r12,0
80023d36:	f8 0f 17 10 	movne	pc,r12
80023d3a:	d6 03       	rete
80023d3c:	d7 03       	nop
80023d3e:	d7 03       	nop
80023d40:	d7 03       	nop
80023d42:	d7 03       	nop
80023d44:	d7 03       	nop
80023d46:	d7 03       	nop
80023d48:	d7 03       	nop
80023d4a:	d7 03       	nop
80023d4c:	d7 03       	nop
80023d4e:	d7 03       	nop
80023d50:	d7 03       	nop
80023d52:	d7 03       	nop
80023d54:	d7 03       	nop
80023d56:	d7 03       	nop
80023d58:	d7 03       	nop
80023d5a:	d7 03       	nop
80023d5c:	d7 03       	nop
80023d5e:	d7 03       	nop
80023d60:	d7 03       	nop
80023d62:	d7 03       	nop
80023d64:	d7 03       	nop
80023d66:	d7 03       	nop
80023d68:	d7 03       	nop
80023d6a:	d7 03       	nop
80023d6c:	d7 03       	nop
80023d6e:	d7 03       	nop
80023d70:	d7 03       	nop
80023d72:	d7 03       	nop
80023d74:	d7 03       	nop
80023d76:	d7 03       	nop
80023d78:	d7 03       	nop
80023d7a:	d7 03       	nop
80023d7c:	d7 03       	nop
80023d7e:	d7 03       	nop
80023d80:	d7 03       	nop
80023d82:	d7 03       	nop
80023d84:	d7 03       	nop
80023d86:	d7 03       	nop
80023d88:	d7 03       	nop
80023d8a:	d7 03       	nop
80023d8c:	d7 03       	nop
80023d8e:	d7 03       	nop
80023d90:	d7 03       	nop
80023d92:	d7 03       	nop
80023d94:	d7 03       	nop
80023d96:	d7 03       	nop
80023d98:	d7 03       	nop
80023d9a:	d7 03       	nop
80023d9c:	d7 03       	nop
80023d9e:	d7 03       	nop
80023da0:	d7 03       	nop
80023da2:	d7 03       	nop
80023da4:	d7 03       	nop
80023da6:	d7 03       	nop
80023da8:	d7 03       	nop
80023daa:	d7 03       	nop
80023dac:	d7 03       	nop
80023dae:	d7 03       	nop
80023db0:	d7 03       	nop
80023db2:	d7 03       	nop
80023db4:	d7 03       	nop
80023db6:	d7 03       	nop
80023db8:	d7 03       	nop
80023dba:	d7 03       	nop
80023dbc:	d7 03       	nop
80023dbe:	d7 03       	nop
80023dc0:	d7 03       	nop
80023dc2:	d7 03       	nop
80023dc4:	d7 03       	nop
80023dc6:	d7 03       	nop
80023dc8:	d7 03       	nop
80023dca:	d7 03       	nop
80023dcc:	d7 03       	nop
80023dce:	d7 03       	nop
80023dd0:	d7 03       	nop
80023dd2:	d7 03       	nop
80023dd4:	d7 03       	nop
80023dd6:	d7 03       	nop
80023dd8:	d7 03       	nop
80023dda:	d7 03       	nop
80023ddc:	d7 03       	nop
80023dde:	d7 03       	nop
80023de0:	d7 03       	nop
80023de2:	d7 03       	nop
80023de4:	d7 03       	nop
80023de6:	d7 03       	nop
80023de8:	d7 03       	nop
80023dea:	d7 03       	nop
80023dec:	d7 03       	nop
80023dee:	d7 03       	nop
80023df0:	d7 03       	nop
80023df2:	d7 03       	nop
80023df4:	d7 03       	nop
80023df6:	d7 03       	nop
80023df8:	d7 03       	nop
80023dfa:	d7 03       	nop
80023dfc:	d7 03       	nop
80023dfe:	d7 03       	nop
